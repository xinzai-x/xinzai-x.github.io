[{"title":"串口","url":"/post/f736596e.html","content":"\n","tags":["51单片机"],"categories":["51单片机"]},{"title":"定时器/计数器","url":"/post/2e5216dd.html","content":"\n# <center>原理</center>\n\n1. 时钟源    定时器是内部时钟源，计数器是外部\n2. 计时长度  对应TH  TL计数器初值寄存器\n3. 对应的中断触发函数（在中断中提及）\n\n两个定时器/计数器：`T0(TL0\\TH0)`、`T1(TL1\\TH1)`\n\n工作模式：\n\n- 模式0（13位定时器/计数器）\n- 模式1（16位定时器/计数器）\n- 模式2（8位自动重装初值）\n- 模式3（两个8位定时器/计数器）\n\n# <center>相关寄存器</center>\n\n代码用到：TR0、TR1，中断触发标志位：TF0、TF1\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202404131443931.png\" alt=\"定时器/计数器\" style=\"zoom:67%;\" />\n\nTCON：中的TF0、TF1、TR0、TR1\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202404121532268.png\" alt=\"定时器中断分析\" style=\"zoom:60%;\" />\n\nTMOD：工作模式\n\n![工作模式](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202404131536016.png)\n\n中断允许寄存器\n\n&ensp;&ensp;&ensp;&ensp;开启中断总开关：EA：1\n\n&ensp;&ensp;&ensp;&ensp;定时器：ET0、ET1、ET2，串口：ES\n\n&ensp;&ensp;&ensp;&ensp;外部中断：EX0、EX1。需要外部、定时器、串口那个则赋值那个为1\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202404121351544.png\" alt=\"允许寄存器分析\" style=\"zoom:67%;\" />\n\n# <center>代码编写</center>\n\n\n\n```c\n\n```\n\n\n\n","tags":["51单片机"],"categories":["51单片机"]},{"title":"中断","url":"/post/81b224e1.html","content":"\n# <center>中断原理</center>\n\n你在打游戏，水开了，水壶发出响声，你停止打游戏，去倒水，倒完水接着打游戏\n\n打游戏：就相当于While(1){}里面执行的代码\n\n水壶响：就是中断源\n\n倒水：触发中断后要去做的事情，中断处理函数\n\n# <center>代码实现过程</center>\n\n## <center>中断源</center>\n\nINT0(外部中断源)、Timer0(定时器中断源)、INT1、Timer1、UART(串口中断源)、Timer2、INT2、INT3\n\n中断触发方式：\n\n&ensp;&ensp;&ensp;&ensp;外部中断：下降沿或者低电平\n\n&ensp;&ensp;&ensp;&ensp;定时器中断：定时器计数溢出\n\n&ensp;&ensp;&ensp;&ensp;串口中断：串口发送或者接收完成\n\n## <center>中断处理函数</center>\n\n与中断源对应的中断处理函数，直接使用对应的函数\n\n|                中断处理函数                 |\n| :-----------------------------------------: |\n| Int0_Routine(void)              interrupt 0 |\n|    Timer0_Routine(void)      interrupt 1    |\n| Int1_Routine(void)              interrupt 2 |\n|   Timer1_Routine(void)       interrupt 3    |\n|   UART_Routine(void)         interrupt 4    |\n|    Timer2_Routine(void)      interrupt 5    |\n| Int2_Routine(void)             interrupt 6  |\n| Int3_Routine(void)              interrupt 7 |\n\n## <center>中断寄存器</center>\n\n保存中断源的中断请求信息的专用寄存器\n\n### 中断控制寄存器\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202404121515869.png\" alt=\"中断寄存器功能\" style=\"zoom: 50%;\" />\n\n外部中断：\n\n&ensp;&ensp;&ensp;&ensp;代码用到：IT0、IT1，中断触发标志位(内部)：IE0、IE1\n\n&ensp;&ensp;&ensp;&ensp;下降沿触发：IT0 = 1，低电平触发：IT0 = 0\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202404121721299.png\" alt=\"外部中断分析\" style=\"zoom:60%;\" />\n\n定时器、串口(后续讲)\n\n### 中断优先级寄存器\n\n### 中断允许寄存器\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202404121351544.png\" alt=\"允许寄存器分析\" style=\"zoom:67%;\" />\n\n开启中断总开关：EA：1，需要外部、定时器、串口那个则赋值那个为1\n\n# <center>中断代码</center>\n\n```c\n#include<reg52.h>\n#include <intrins.h>\n\nsbit LED1 = P1^0;\n\nvoid Delay120ms()\t\t//@11.0592MHz\n{\n\tunsigned char data i, j;\n\n\ti = 216;\n\tj = 37;\n\tdo\n\t{\n\t\twhile (--j);\n\t} while (--i);\n}\n\nvoid main()\n{\n    //电路图知：中断源INT0、INT1引脚与按键P3^2、P3^3同一个，则按键为中断源，无需定义按键\n\tEA = 1;\t\t//中断总开关\n\tIT0 = 1;\t//触发方式：1为下降沿触发\n\tEX0 = 1;\t//设置中断方式：外部中断\n\tDelay120ms();\n\tDelay120ms();\n}\n\nInt0_Routine(void)        interrupt 0\t//中断处理函数\n{\n\tDelay120ms();\n\tLED1 = ~LED1;\n}\n```\n\n","tags":["51单片机"],"categories":["51单片机"]},{"title":"I/O","url":"/post/74750b31.html","content":"\n# <center>I/O输出(点灯)</center>\n\n## <center>分析电路</center>\n\n看电路图，元器件形成电压差，即可点亮LED灯\n\n## <center>代码编写</center>\n\n```c\n#include \"reg52.h\"\t//51单片机头文件\n#include <intrins.h>\nsbit LED1 = P1^0;\t//P1^0：对应引脚的LED灯，定义LED1代表P1^0这个引脚的LED灯\nsbit LED2 = P1^1;\nsbit LED3 = P1^2;\nsbit LED4 = P1^3;\n\nint i;\n//延时1000ms的延时函数\nvoid Delay1000ms()    //@11.0592MHz\n{\n  unsigned char data i, j, k;\n  _nop_();\n  i = 8;\n  j = 1;\n  k = 243;\n  do\n  {\n     do\n     {\n       while (--k);\n     } while (--j);\n  } while (--i);\n}\n \nvoid main()\n{\n\twhile(1)\n\t{\n\t\t//方法一：对位操作，P1^0为0，接通\n\t\tLED1 = 0;\t//电路图得知，LED为0时，接通LED灯\n\t\tLED2 = 1;\n\t\tLED3 = 1;\n\t\tLED4 = 1;\n\t\t//方法二：P1寄存器直接赋值，两种效果相同\n\t\t//P1 = 0xfe;   //11111110，LED灯为P1^0~P1^3，则为最低位3位\n\t\tDelay1000ms();\n      \n\t\t//方法一：对位操作，P1^1为0，接通\n\t\tLED1 = 1;\n\t\tLED2 = 0;\n\t\tLED3 = 1;\n\t\tLED4 = 1;\n\t\t//P1 = 0xfd; //11111101\n\t\tDelay1000ms(); \n      \n\t\t//方法一：对位操作，P1^2为0，接通\n\t\tLED1 = 1;\n\t\tLED2 = 1;\n\t\tLED3 = 0;\n\t\tLED4 = 1; \n\t\t//P1 = 0xfb; //11111011\n\t\tDelay1000ms(); \n\n\t\t//方法一：对位操作，P1^3为0，接通\n\t\tLED1 = 1;\n\t\tLED2 = 1;\n\t\tLED3 = 1;\n\t\tLED4 = 0;\n\t\t//P1 = 0xf7; //11110111\n\t\tDelay1000ms();\n\n\t\t//对方法三分析\n\t\t//P1 = 0xff; //11111111\n\t\t//Delay1000ms();\n\t\t//P1 = P1<<1;  //11111110\n\t\t//Delay1000ms();\n\t\t//P1 = P1<<1; //11111100\n\t\t//Delay1000ms();\t\n      \n\t\t//方法三：位移实现对LED灯控制\n\t\tP1 = 0xff; //11111111，将LED灯初始为灭\n\t\tDelay1000ms();\n\t\t//通过4次循环左移，实现对LED灯的控制\n\t\tfor(i=0;i<4;i++)\n\t\t{\n\t\t\tP1 = P1<<1;\n\t\t\tDelay1000ms();\n\t\t}\n\t}\n}\n```\n\n# <center>I/O输入(电平检测)</center>\n\n输入是检测输入的电平的高低，与输出不同\n\n电路图知，按键按下为低电平，则判断按键引脚为低电平则按键按下\n\n注意：按键会有抖动。消除方法：按键并联一个电容 或 代码延时\n\n## <center>代码编写</center>\n\n```c\n#include<reg52.h>\t//51单片机头文件\n#include <intrins.h>\nsbit LED1 = P1^0;\nsbit KEY1 = P3^2;\t//第一个按键位引脚\nsbit KEY2 = P3^3;\t//第二个按键位引脚\nsbit BEEP = P1^6;\t//蜂鸣器位引脚\n//延时函数\nvoid Delay120ms()\t\t//@11.0592MHz\n{\n\tunsigned char data i, j;\n\n\ti = 216;\n\tj = 37;\n\tdo\n\t{\n\t\twhile (--j);\n\t} while (--i);\n}\n\nvoid main()\n{\n\twhile(1)\n\t{\n\t\tif(KEY1 == 0)\n\t\t{\n\t\t\tDelay120ms();\n\t\t\t//双重判断且加延时函数，消除按键抖动\n\t\t\tif(KEY1 == 0)\n\t\t\t{\n\t\t\t\tLED1 = ~LED1;\t//对LED取反，则实现LED开关\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(KEY2 == 0)\n\t\t{\n\t\t\tDelay120ms();\n\t\t\tif(KEY2 == 0)\n\t\t\t{\n\t\t\t\tBEEP = ~BEEP;\t//对蜂鸣器取反，则实现蜂鸣器开关\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n# <center>I/O内部电路分析</center>\n\n## <center>51单片机</center>\n\n准双向口/弱上拉：可用作输出和输入功能而不需要配置口线输出状态\n\n开漏输出(P0)：当P0管脚做I/O时，需要外加上拉电阻，若作为地址/数据总线时，不需要加上拉电阻\n\n## <center>STM32单片机</center>\n\n### 输入\n\n浮空输入：从IO引脚入，VDD(上拉电阻)打开和Vss(下拉电阻)打开，经过输入数据寄存器，读出\n\n上垃输入：从IO引脚入，VDD(上拉电阻)闭合和Vss(下拉电阻)打开，经过输入数据寄存器，读出\n\n下拉输入：从IO引脚入，VDD(上拉电阻)打开和Vss(下拉电阻)闭合，经过输入数据寄存器，读出\n\n模拟输入：从IO引脚入，VDD(上拉电阻)打开和Vss(下拉电阻)打开，经过模拟输入\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202404121123673.png\" alt=\"分析图\" style=\"zoom: 67%;\" />\n\n### 输出\n\n开漏输出：在开漏输出模式下，P-MOS(上拉)管不工作，只有N-MOS(下拉)管起作用。若输出数据寄存器的值为0，则N-MOS导通，IO口输出低电平；若输出数据寄存器的值为1，则N-MOS截止；由于P-MOS不工作，此时IO口既不是高电平，也不是低电平，这种状态被称为高阻态\n\n推挽输出：在推挽输出模式下，若输出数据寄存器的值为0，则N-MOS(下拉)导通，P-MOS(上拉)截止，IO口输出低电平；若输出数据寄存器的值为1，则N-MOS截止，P-MOS导通，IO口输出高电平\n\n复用：使别引脚也具备原本引脚功能\n\n推挽复用输出、开漏复用输出\n","tags":["51单片机"],"categories":["51单片机"]},{"title":"寄存器","url":"/post/f8f1fb54.html","content":"\n# <center>什么是寄存器</center>\n\n对寄存器赋不同特定值，起到配置和控制各种功能的作用\n\n# <center>寄存器分类</center>\n\n## <center>特殊功能寄存器</center>\n\n8位单片机则一个寄存器有8位：P1：P1_0 ~ P1_7，单片机可能还有P0、P1等等\n\nTCON、TMOD、IE.......\n\n## <center>通用寄存器</center>\n\n51单片机包括：R0、R1、R3、R4......\n\n作用：存储临时数据、提高数据访问速度、传递函数参数、存储程序状态\n\n# <center>寄存器操作方式</center>\n\n一个位对应单片机一个引脚，这个引脚连接对应的器件，如：P1_0连接LED灯，若P1_0为1，则LED灯亮\n\n如果没有位寻址，则整个寄存器赋值(十六进制0x00 ~ 0xff)\n\n如何知道寄存器对应的位以及芯片对应引脚功能，查看数据手册\n\n","tags":["51单片机"],"categories":["51单片机"]},{"title":"单片机工作原理","url":"/post/c6b2a2fd.html","content":"\n# <center>最小系统</center>\n\n## <center>单片机芯片</center>\n\n本次51单片机的芯片为：STC89C52\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202404101723175.png\" alt=\"芯片类型\" style=\"zoom:50%;\" />\n\nFlash(闪存)程序存储器：存储程序的空间\n\nSRAM：数据存储器，可用于存放程序执行的中间结果和过程数据\n\nDPTR：16位的寄存器（两个8位寄存器组成），用于间接寻址，DPH存储地址的高8位，而DPL存储地址的低8位\n\nEEPROM：带电可擦可编程只读存储器。是一种掉电后数据不丢失的存储芯片\n\n看门狗：用于监控单片机程序运行状态的机制。它通过一个定时器电路实现，能够在程序运行失控或遇到硬件错误时对单片机进行复位操作，以确保程序能够重新开始执行\n\nA/D：模拟信号到数字信号的转换（模拟/数字）\n\nI/O：输入和输出，输入（Input）是指数据或信号从外部设备或用户传输到计算机系统内部的过程，而输出（Output）则是指数据或信号从计算机系统传输到外部设备或用户的过程\n\n## <center>时钟电路</center>\n\n产生固定频率的交流信号，晶振是产生信号的元器件（由晶振频率计算产生）\n\n12Mhz：\n\n时钟周期：1/12Mhz，单位是秒，12Mhz要转为秒为12000000hz\n\n1/12000000≈0.00000008s\n\n机器周期：12×时钟周期 = 0.00000008s×12 = 0.000001s，转为us就是1us\n\n## <center>复位电路</center>\n\n按键复位和上电复位\n\n## <center>电源</center>\n\n供电，51单片机一般5v，smt32单片机一般3.3v\n\n\n\n\n\n\n\n\n\n\n\n","tags":["51单片机"],"categories":["51单片机"]},{"title":"浏览器插件","url":"/post/def84ee6.html","content":"\n如果我们经常使用的浏览器不是edge或者是chrome浏览器时，需要在浏览器安装插件时，无法获取插件以及不知道如何安装插件，本文章教你如何获取以及安装使用。\n\n# <center>获取方法</center>\n\n## <center>第一种方法（推荐）</center>\n\n无需魔法，即可访问获取插件的网站：[链接](https://www.crxsoso.com/)\n\n还有一个浏览器一些黑科技小网站（正规绿色）：[链接](https://www.youxiaohou.com/)\n\n## <center>网上搜集下载地址</center>\n\n由于这些都是搬运的插件，若怕插件不安全，请使用第一种方法（本人正在使用），也可自行必应搜`浏览器插件下载`关键词\n\nExtfans：[链接](https://extfans.com/)\n\n画夹插件：[链接](https://huajiakeji.com/)\n\n收藏猫插件：[链接](https://chrome.pictureknow.com/)\n\n# <center>使用方法</center>\n\n一般下载之后，插件文件的后缀名为：crx的单文件\n\n这里以华为浏览器为例，首先打开华为浏览器，在右上角点击三点图标，选择设置，进入设置\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202404071329022.png\" alt=\"打开浏览器设置\" style=\"zoom:50%;\" />\n\n打开在左边的下面，有一个扩展程序，点击进去\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202404071331220.png\" alt=\"打开扩展程序\" style=\"zoom:50%;\" />\n\n打开开发者模式\n\n![开发者模式](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202404071332308.png)\n\n打开之后，如果下载后的插件文件后缀为：`crx` 的单文件，则直接将文件拖进扩展程序这个页面，即可添加插件\n\n如果是压缩包，解压之后是多文件，则点击左上角的加载已解压的扩展程序，然后选择解压出来的插件文件夹，打开即可。\n\n如果是其他浏览器也是类似操作，也可以进行模仿尝试是否可以导入插件\n","tags":["插件"],"categories":["技术教程"]},{"title":"资源搜索网址","url":"/post/1f293ccb.html","content":"\n### 猫狸盘搜\n\n[地址](https://www.alipansou.com/)\n\n### 千帆搜索\n\n[地址](https://pan.qianfan.app/)\n\n### 懒盘搜索\n\n[地址](https://www.lzpanx.com/)\n\n### 盘友圈\n\n[地址](https://panyq.com/)\n\n### UP云搜\n\n[地址](https://www.upyunso.com/)\n\n### 学霸盘\n\n[地址](https://www.xuebapan.com/)\n\n### 盘他一下\n\n[地址](https://www.panothers.com/)\n\n### 云盘分享网\n\n[网址](https://alypw.cn/)\n\n### 好当家\n\n[网址](https://www.hjdang.com/)\n\n### 爱盘搜\n\n[网址](https://aipanso.com/)\n\n### 易搜\n\n[网址](https://yiso.fun/)\n","tags":["资源搜索"],"categories":["技术教程"]},{"title":"图片压缩在线工具","url":"/post/79959306.html","content":"\n### TinyPng\n\n[地址](https://tinypng.com/)\n\n### 图好快\n\n[地址](https://www.tuhaokuai.com/)\n\n### Jpeg.io\n\n[地址](https://www.jpeg.io/)\n\n### 色彩笔\n\n[地址](https://www.secaibi.com/tools/)\n\n### 压缩图\n\n[地址](https://www.yasuotu.com/)\n\n### Recompressor\n\n[地址](https://zh.recompressor.com/)\n\n### Picdiet\n\n[地址](https://www.picdiet.com/zh-cn?ref=dartools.com#google_vignette)\n\n### Squoosh\n\n[地址](https://squoosh.app/)\n\n### Imagify\n\n[地址](http://webresizer.com/resizer/)\n\n### Optimizilla\n\n[地址](https://imagecompressor.com/zh/)\n","tags":["图片压缩在线工具"],"categories":["技术教程"]},{"title":"小狼毫配置","url":"/post/5f6e69ef.html","content":"\n# <center>下载小狼毫软件</center>\n\n小狼毫下载：[地址](https://rime.im/download/#)\n\n# <center>安装步骤</center>\n\n下载好安装包后，打开安装包，安装，步骤如下\n\n点击我接受\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403142202912.png\" alt=\"步骤一\" style=\"zoom:50%;\" />\n\n这里是软件安装路径，选择自己要安装的位置，后直接点击安装\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403142203014.png\" alt=\"步骤二\" style=\"zoom:50%;\" />\n\n后续还有个`用户配置文件`的安装目录，这个目录保存好，在别的电脑可以直接恢复配置。\n\n方案选定，选择图片单个即可，选择 中 下一步\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403142204796.png\" alt=\"步骤三\" style=\"zoom:50%;\" />\n\n然后，选择自己喜欢的风格，点击中，即可安装完成。\n\n# 配置\n\n在任务栏中，在 中 字右键，选择用户文件夹\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403142207761.png\" alt=\"配置一\" style=\"zoom:67%;\" />\n\n在大佬整理的文件下载词库配置，大佬的：GitHub[地址](https://github.com/iDvel/rime-ice)，直接整个打包下载\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403142209429.png\" alt=\"打包下载\" style=\"zoom: 33%;\" />\n\n# 重点配置\n\n解压下载好的词库配置包，右键退出算法服务（若点击退出没有反应，直接重启即可），然后删除用户文件夹内的所有文件（最好备份一下原本的文件），复制大佬仓库中的所有文件到你的用户文件夹中，重启电脑，刚重启之后，等待一会儿，如果还不行，再右键重新部署，这期间会出现 输入法调出来但是无法打字的问题，等重新部署完成，可以打字即部署完成\n\n------\n\ntip：个人感觉不是很好用，可能不会配置，或者说没有精力去配置，如果想要好用需要花费精力去配置。本人已切换到百度输入法。\n","tags":["小狼毫输入法"],"categories":["技术教程"]},{"title":"GitHub+Picgo图片上传","url":"/post/d20e58f5.html","content":"\n Picgo下载，修改安装路径，其他一路下一步！\n\n> [地址](https://github.com/Molunerfinn/picgo/releases)\n\n 注册GitHub，注册过程不详细展开，不会的百度一下\n\n> [地址](https://github.com/)\n\n# 新建GitHub仓库存放图片\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011715417.png\" alt=\"新建\" style=\"zoom: 33%;\" />\n\n![填写信息](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011718105.png)\n\n# 生成Token令牌\n\n点击头像，点击Settings\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011720770.png\" alt=\"img\" style=\"zoom: 50%;\" />\n\n滑到最后\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011720876.png\" alt=\"进入生成令牌\" style=\"zoom: 33%;\" />\n\n![选择对应选项](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011721976.png)\n\n过期时间：`No expiration`(永久不过期)\n\n![设置令牌信息](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011722080.png)\n\n> **务必将令牌保存起来**，放在一个安全的地方，页面关掉后就看不到了。\n\n![生产令牌](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011726560.png)\n\n# 创建img文件夹\n\n回到刚才新建存放图片的仓库，新建文件夹\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011726060.png\" alt=\"创建文件夹\" style=\"zoom:50%;\" />\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011727746.png\" alt=\"命名文件夹\" style=\"zoom: 33%;\" />\n\n# 设置GitHub图床\n\n```\n自定义域名需要配置为：https://cdn.jsdelivr.net/gh/用户名/仓库名，这样就才可以通过cdn访问图片\n仓库名：GitHub用户名/GitHub仓库地址\n分支名：main\nToken：GitHub中设定的AccessToken\n自定义域名：https://cdn.jsdelivr.net/gh/用户名/仓库名\n```\n\n![Picgo设置](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011728215.png)\n\n点击上传区上传图片\n\n上传成功之后\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011729915.png\" alt=\"例图\" style=\"zoom: 50%;\" />\n\n如果提示网络不好等错误，可能不稳定，稍后再试试看。或者可以重启试试看!！\n\n在Typora中，文件-》偏好设置中，设置成下图，将语法偏好所有选项关闭，可以避免直接复制图片进Typora报错\n\n![img](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011729398.png)\n\n仓库可能最多只能存放1g，网上说的，所以最好快到的时候重新建一个仓库\n","tags":["GitHub+Picgo图片上传"],"categories":["技术教程"]},{"title":"GitHub同步gitee并部署","url":"/post/6c3f8114.html","content":"\n# <center>创建并同步GitHub仓库</center>\n\n点击加号，选择从GitHub仓库导入\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402282300375.jpg\" alt=\"导入仓库\" style=\"zoom:67%;\" />\n\n选择导入GitHub仓库\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402282301124.jpg\" alt=\"选择仓库\" style=\"zoom: 50%;\" />\n\n导入对应GitHub仓库，此时需要注意仓库名字需要和你创建gitee时的名字相同，如果不知道名字可先往下看，中间可修改仓库名字\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402282303081.jpg\" alt=\"导入仓库\" style=\"zoom: 50%;\" />\n\n查看名字为哪个，可看浏览器网址，中间名字就是\n\n![查看用户名](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402282318977.jpg)\n\n设置仓库为公有，为了可以开启pages，进入仓库，点击管理\n\n![进入设置](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402282306887.jpg)\n\n基本信息最下方找到，是否开源，点击开源\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402282307142.jpg\" alt=\"开源\" style=\"zoom: 50%;\" />\n\n# 部署gitee pages\n\n进入对应仓库，点击服务，点击gitee pages，此处需要实名认证，实名认证完之后才可以开启\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402282320319.jpg\" alt=\"部署\" style=\"zoom: 50%;\" />\n\n进入之后，直接选中对应仓库中的分支，点击部署即可\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402282322599.jpg\" alt=\"部署中\" style=\"zoom: 50%;\" />\n\nGitHub上传部署之后不会自动更新gitee，需要手动部署，只需要在对应的仓库中，点击仓库名字旁边的旋转图标，强制更新即可，更新就直接部署了，不需要自己再进入pages重新部署。\n\n","tags":["GitHub同步gitee并部署"],"categories":["技术教程"]},{"title":"云图床","url":"/post/2ec6e870.html","content":"\n# 图床导航\n\n[网址](http://imgdh.com/)\n\n# 路过图床\n\n[网址](https://imgse.com/)\n\n# Picgo图床\n\n[网址](https://www.picgo.net/)\n\n# sm.ms图床\n\n[网址](https://sm.ms/)\n\n# 薄荷图床\n\n[网址](https://zixiaoyun.com/)\n\n# 风筝图床\n\n[网址](https://www.imgbed.link/)\n\n# ImgURL图床\n\n[网址](https://www.imgurl.org/vip/manage/upload)\n\n# Z4A图床\n\n[网址](https://z4a.net/)\n\n# Hello图床\n\n[网址](https://www.helloimg.com/)\n","tags":["云图床"],"categories":["技术教程"]},{"title":"魔法","url":"/post/812d49a5.html","content":"\n免费白嫖机场\n\n更新网址：[小帅同学的博客](https://xiaoshuai.link/2021/05/06/3.%20%E9%AD%94%E6%B3%95%E6%8E%A8%E8%8D%90&amp;%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/)\n\n# ikuuu（白嫖，老站）\n\n[网址](https://ikuuu.pw/)\n\n每月50g，每日签到再送2g左右\n\n付费价格：可以购买一天1元（不限流量）具体看网址\n\n\n\n\n\n\n\n","tags":["魔法"],"categories":["技术教程"]},{"title":"计算机备考","url":"/post/df95841.html","content":"\n# <center>C语言程序和程序设计概述</center>\n\n程序：可以连续执行的一条条指令的集合\n\n开发过程：C源程序(.c文件) --> 目标程序(.obj二进制文件，目标文件) --> 可执行文件(.exe文件) -->结果\n\n在任何机器上可以运行C源程序生成的` .exe 文件`\n\n没有安装C语言集成开发环境，不能编译C语言程序，`函数`是C程序的`基本单位`\n\n程序设计有以下几个部分：\n\n1. 确定数据结构\n2. 确定算法\n3. 编码（编写代码）\n4. 计算机上调试程序\n5. 整理并写出文档资料\n\nC语言运行方法：编译执行，python：解释执行\n\n头文件：#include<stdio.h>\n\nC语言的结构特点：\n\n- 函数是C程序的主要组成部分\n\n&ensp;&ensp;&ensp;&ensp;一个C程序是由一个或多个函数组成\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;必须包含一个main函数（只能有一个）\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;每个函数都用来实现一个或多个特定功能\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;被调用的函数可以是库函数，也可以是自己编制设计的函数\n\n- 程序总是从main函数开始执行\n- C程序书写可以一行内写几个语句，也可以一个语句分写在多行上（以<mark>分号</mark>为标准，判断是否是一个语句）\n- 数据声明和语句最后必须有分号\n- C语言本事不提供输入输出语句，由库函数提供\n\n算法表示方法：\n\n1. 自然语言\n2. 用伪代码表示\n3. 用流程图表示\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402220850908.png\" alt=\"流程图常用符号\" style=\"zoom:50%;\" />\n\n4. N-S流程图表示\n\n## <center>标识符、常量和变量</center>\n\n常量\n\n整型常量：12、0、-3\n\n实型常量：\n\n&ensp;&ensp;&ensp;&ensp;十进制小数：0.34、-56.79\n\n&ensp;&ensp;&ensp;&ensp;指数形式：12.34e3（12.34×10³）\n\n符号常量：'a'、'b'\n\n字符串常量：\"Beijing\"\n\n```c\n常量在程序运行期间，值不可以改变的\n#define PI 3.14159\t\t//定义符号常量不需要分号\n```\n\n变量\n\n&ensp;&ensp;&ensp;&ensp;在程序运行期间，值是可以改变的\n\n&ensp;&ensp;&ensp;&ensp;定义变量时指定该变量的名字和类型\n\n&ensp;&ensp;&ensp;&ensp;变量名实际上是以一个名字代表一个存储地址\n\n&ensp;&ensp;&ensp;&ensp;从变量取值，实际上是通过变量名找到相应的内存地址，从该存储单元中读取数据\n\n标识符\n\n&ensp;&ensp;&ensp;&ensp;只能由字母、数字和下划线组成，且第一个字符必须为字符或下划线，不能使用C语言关键字作为标识符\n\nC语言是严格区分字母大小写\n\n关键字必须用小写字母\n\n![关键字](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402220849778.png)\n\n## <center>数据类型</center>\n\n### 整型数据\n\n&ensp;&ensp;&ensp;&ensp;整型常量3种表示形式\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;十进制整数，如2，-983\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;八进制整数。以0开头，由0~7构成，通常为无符号数，如012，八进制12\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;十六进制整数。以0x开头，由 0 ~ 9 和 A ~ F 或 a ~ f 构成，如0x12A，十六进制12A\n\n&ensp;&ensp;&ensp;&ensp;整型变量：<font color=\"red\">类型说明符 变量名标识符;</font>\t如 int a,b,c;\n\n&ensp;&ensp;&ensp;&ensp;在定义变量的同时给变量赋初值，称变量初始化，若没有初始化，则内容不确定\n\n计算机最小存储单位：位(bit)\n\n&ensp;&ensp;&ensp;&ensp;一个<mark>字节</mark>(byte) = 8bit\n\n| 关键字 |     类型     |                        所占的空间                        |\n| :----: | :----------: | :------------------------------------------------------: |\n|  char  |  字符串类型  |                占1字节空间（8位二进制位）                |\n| short  |    短整型    |               占2字节空间（16位二进制位）                |\n|  int   |     整型     |               占4个字节空间（32位二进制）                |\n|  long  |    长整型    |   占4个字节空间（32位二进制）（在64为平台下占8个字节）   |\n| float  | 单精度浮点数 |  占4个字节空间（32为二进制）（7位有效位，指数-37到38）   |\n| double | 双精度浮点数 | 占8个字节空间（64为二进制）（16位有效位，指数-307到308） |\n\n在存储有符号数时，存储单元最高为代表符号位，0为正，1为负\n\n设计程序时，注意变量类型的取值范围，当赋值超过取值范围时，会出现溢出错误\n\n一个整 型常量后加 U或u 后缀则被认为时unsigned类型，内存中按unsigned规定方式存放\n\n一个整型常量后加 L或l 后缀则被认为时long类型，内存中按long规定位数存放\n\n无符号长整数：用后缀 UL/ul表示，如：15ul\n\n### 浮点型(实型)数据\n\n实型常量\n\n&ensp;&ensp;&ensp;&ensp;又称实属或浮点数\n\n&ensp;&ensp;&ensp;&ensp;十进制小数形式，如123.456\n\n&ensp;&ensp;&ensp;&ensp;指数形式：以 “e” 或 “E” 后跟一个整数来表示以10为底的幂数，如 2.3026e2\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;规定：字母 e 或 E 之前必须有数字，且e或E后面指数必须为整数\n\n&ensp;&ensp;&ensp;&ensp;10⁸不能写成e8，必须写成：1e8 或 1.0E8\n\n实型变量\n\n&ensp;&ensp;&ensp;&ensp;实型(3.14159)数据在内存中存放的形式：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;+：数符\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;.314159：小数部分\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1：指数\n\n&ensp;&ensp;&ensp;&ensp;小数部分占的为数越多，数的有效数字越多，精度越高\n\n&ensp;&ensp;&ensp;&ensp;指数部分占的位数越多，则能表示的数值范围越大\n\n### 字符型数据\n\n字符常量\n\n&ensp;&ensp;&ensp;&ensp;用单引号括起来的一个字符，如’a‘、’E‘，不能 ’ab‘\n\n&ensp;&ensp;&ensp;&ensp;字符常量以ASCII码存储，一个字符占一个字节，<mark>大写</mark>字母与<mark>小写</mark>字母ASCII码值相差 32\n\n字符变量\n\n&ensp;&ensp;&ensp;&ensp;如：char c1,c2,c3; c1 = 'A'; c2 = '\\n';\n\n&ensp;&ensp;&ensp;&ensp;每个字符变量分配一个字节用于存放一个字符（存放的是字符的ASCII码值）\n\n字符数据与整型数据可相互赋值，直接运算\n\n用%d输出，则输出整型数，用%c输出，则输出字符\n\n字符串常量\n\n&ensp;&ensp;&ensp;&ensp;一对双引号(\" \")括起来的字符序列，字符个数称为其长度，如：\"hellow\"\n\n&ensp;&ensp;&ensp;&ensp;长度为n的字符串，在计算机存储中占n+1个字节，原因：会自动在结尾添加 ’\\0‘\n\nASCII码表\n\n![ASCII码表](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402220849502.png)\n\n### 转义字符\n\n| 字符形式 |               功能               | 字符形式 |             功能              |\n| :------: | :------------------------------: | :------: | :---------------------------: |\n|    \\n    |             回车换行             |   \\\\\\    |      一个反斜杠字符(\\\\)       |\n|    \\t    |   将当前位置移到下一个tab位置    |   \\\\'    |         一个单引号(')         |\n|    \\v    | 当前位置移到下一个垂直制表对齐点 |   \\\\\"    |         一个双引号(\")         |\n|    \\r    |              回车符              |   \\ddd   | 三位八进制数代表一个ASCII字符 |\n|    \\f    |              换页符              |   \\xhh   | 二位十六进制代表一个ASCII字符 |\n|    \\b    |      将当前位置后退一个字符      |    \\0    |     空值，其ASCII码值为0      |\n\n### 符号常量\n\n用标识符表示的常量，一般符号常量名用大写字母表示，命令通常放在文件头，在程序中不允许重新赋值，注意：不需要分号结尾\n\n格式：#define 标识符 常量\t如：#define PI 3\n\n### 数学函数\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402220849431.png\" alt=\"数学函数\" style=\"zoom: 50%;\" />\n\n## <center>运算符和表达式</center>\n\n### 算术运算符\n\n优先级越小，越优先，优先级相同时，运算次序由<mark>结合性</mark>决定\n\n| 运算符 | 运算规则 | 操作数数目 | 优先级 | 结合方向 |\n| :----: | :------: | :--------: | :----: | :------: |\n|   -    |   负号   |    单目    |   2    |  左结合  |\n|   +    |   加法   |    双目    |   4    |  左结合  |\n|   -    |   减法   |    双目    |   4    |  左结合  |\n|   *    |   乘法   |    双目    |   3    |  左结合  |\n|   /    |   除法   |    双目    |   3    |  左结合  |\n|   %    | 取余或模 |    双目    |   3    |  左结合  |\n\n1./3 + 1./3 + 1./3 = 1\n\n取余运算符，所得结果的符号与运算符左侧操作数符号相同，如：-5 % 2 = -1，5 % -2 = 1，`运算对象只能是整型`，结果也是整型，如：5 % 2 =1\n\n### 自增、自减运算符\n\n自增和自减运算符只能用于变量，不能用于常量和表达式\n\n| 含义 | 运算符 | 优先级 | 结合性 |     功能      |\n| :--: | :----: | :----: | :----: | :-----------: |\n| 自增 |   ++   |   2    | 右结合 | 使变量的值增1 |\n| 自减 |   --   |   2    | 右结合 | 使变量的值减1 |\n\n使用形式：\n\n&ensp;&ensp;&ensp;&ensp;++i 或 --i 变量 i 先自增或自减 1，再引用 i\n\n&ensp;&ensp;&ensp;&ensp;i++ 或 i-- 先使用变量 i，再自增或自减1\n\n### 不同数据类型间的转换\n\n自动转换类型：数据类型自动由低级向高级转换\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402220849472.png\" alt=\"自动转换类型图\" style=\"zoom:33%;\" />\n\n强制转换：将表达式的运算结果强制转换成指定的数据类型\n\n格式：(数据类型说明符)(表达式)\n\n```c\nint x,y;\nfloat z;\n(float)(x+y);\t//浮点型\n(int)z+x;\t\t//整型\n```\n\n### 关系运算符（比较运算）\n\n关系表达式：\n\n&ensp;&ensp;&ensp;&ensp;格式：表达式1 关系运算符 表达式2;\t如：m+n <= 20; 成立表达式值为 1，不成立值为0\n\n|   含义   | 运算符 | 优先级 | 结合性 |\n| :------: | :----: | :----: | :----: |\n|   小于   |   <    |   6    | 左结合 |\n| 小于等于 |   <=   |   6    | 左结合 |\n|   大于   |   >    |   6    | 左结合 |\n| 大于等于 |   >=   |   6    | 左结合 |\n|   等于   |   ==   |   7    | 左结合 |\n|  不等于  |   !=   |   7    | 左结合 |\n\n### 逻辑运算符\n\n| 含义   | 运算符 | 优先级 | 结合性 | 运算逻辑           |\n| ------ | ------ | ------ | ------ | ------------------ |\n| 逻辑非 | !      | 2      | 右结合 | 取反               |\n| 逻辑与 | &&     | 11     | 左结合 | 全真为真，其余为假 |\n| 逻辑或 | \\|\\|   | 12     | 左结合 | 全假为假，其余为真 |\n\n#### 逻辑表达式\n\n&ensp;&ensp;&ensp;&ensp;形式：表达式1 逻辑运算符 表达式2\t如：5 > 3 && 2 || 4 - !'a'\n\n判断时，0 代表 假，非0 代表真\n\n逻辑与 和 逻辑或 短路能力\n\n&ensp;&ensp;&ensp;&ensp;逻辑与：只有表达式1值为真，才求表达式2 的值\n\n&ensp;&ensp;&ensp;&ensp;逻辑或：只有表达式1值为假，才判断表达式2的值\n\n### 三目表达式\n\n形式：表达式1 ? 表达式2 : 表达式3\t如：max = (a>b)?a:b;\n\n如果表达式1为真，执行表达式2，为假，执行表达式3\n\n最终判断出的值类型，为表达式2和表达式3 中较高的类型\n\n可以嵌套的，这种嵌套是右结合，如：a > b ? c : c > d ? b : d;\n\n### 赋值运算符\n\n复合赋值运算符：+=、-=、*=、/=、%=\t优先级14，右结合性\n\n### 赋值表达式\n\n简单赋值表达式\n\n&ensp;&ensp;&ensp;&ensp;格式：变量 = 表达式\t如：k = i+++--j\n\n&ensp;&ensp;&ensp;&ensp;执行顺序：先计算，再赋值\n\n复合表达式\n\n&ensp;&ensp;&ensp;&ensp;x += y += z*z\t--> x= x+(y=y+z\\*z)\n\n### 逗号运算符\n\n符号：,\n\n优先级15，左结合\n\n### 逗号表达式\n\n格式：表达式1,表达式2,表达式3\t如：a = 3*5,a\\*10,a+8\n\n求解过程中：先求表达式1的值，再表达式2的值，再表达式n的值，<mark>表达式n</mark>的值作为<font color=\"red\">整个逗号表达式的值</font>\n\n## <center>选择结构（分支结构）</center>\n\n### if语句\n\n格式：\n\n```c\nif(表达式) 语句1;\t//语句1，只能是一条语句\n\nif(表达式)\n{\n\t语句块1;\n}\n\nif()\n{\n    \n}\nelse if()\n{}\nelse\n{}\n\nif()\n{\n    if()\n    {}\n}\n```\n\n注意：else 与 if 必须成对出现，且else总是与<mark>最近</mark>的一个未配对的 if 配对\n\n### switch语句\n\n格式：\n\n```c\nswitch(表达式)\t\t//表达式类型要与case后面常量值类型匹配，只能是整型、字符型或枚举型\n{\n\tcase 常量表达式:\t\t//每个case后的常量表达式不允许相同\n\t\t语句1;\n\t\tbreak;\n\tcase 常量表达式:\n\t\t语句2;\n\t\tbreak;\n\t......\n\tdefault:\n\t\t语句n+1;\n}\nbreak语句终止switch语句的执行\n```\n\n## <center>循环结构</center>\n\n### while语句\n\n格式：\n\n```c\nwhile(表达式)\n{\n    语句块;\t//循环体\n}\n//先判断，再执行，有可能一次也不执行\n```\n\n注意：\n&ensp;&ensp;&ensp;&ensp;1）while没有初始化语句，用户提前初始化好\n\n&ensp;&ensp;&ensp;&ensp;2）while没有步进语句，用户必须在循环语句中写好步进语句\n\n&ensp;&ensp;&ensp;&ensp;3）循环变量的值可以被引用、修改，但不能赋新值\n\n```c\n#include <stdio.h>\nvoid test04()\n{\n    int i = 0;\n    int sum = 0;\n    while(i<=100)\n    {\n        sum += i;\n        i++;   //步进条件 \n    }\n    printf(\"sum = %d\\n\",sum);\t//sum = 5050\n} \nint main(int argc,char *argv[])\n{\n    test04();\n}\n//当循环体是空语句或单个语句\nwhile(x++ < 1000);\t//分号不能省略\n\nx = 10;\nwhile(x-- > 0)printf(\"%d\",x);\n```\n\n### do-while语句\n\n格式：\n\n```c\ndo\n{\n\t//循环体语句\n}while(表达式);\n//特点：先执行，再判断，至少执行一次循环体\n```\n\n### for语句\n\n格式：\n\n```c\nfor(初始语句;循环条件;步进条件)\n{\n    //循环语句\n}\n//初始语句：只在循环开始时执行一次\n//循环条件: 每次循环都要执行，如果循环条件为 真 进入循环体，如果为 假 退出循环\n//步进条件：每次循环结束的时候要执行的语句\n\n//初始语句可以省略，但要在for语句之前给循环变量赋初值\n//循环条件为空时，则会陷入死循环\n//进步条件省略时，需要在循环体内写进步条件\n\n//初始语句和进步条件可以有多项，若有多项则使用逗号表达式\nfor(s = 0,i = 1;i <= 100;s += i,i++);\n\n//单个语句时\nfor(初始语句;循环条件;步进条件)\n    语句;\n//特点：先判断，再执行，有可能一次也不执行\n```\n\n嵌套for循环：总结外层循环的次数*内层循环的次数==总循环次数\n\n```c\n//并列的循环变量可以同名，但嵌套的循环变量不能同名\nfor(初始语句;循环条件;步进条件)\n{\n     for(初始语句;循环条件;步进条件)\n    {\n         //循环语句\n    }\n}\n```\n\n## break语句\n\n格式：break;\n\n作用：提前退出某个循环或跳出switch结构\n\n只能在switch语句和循环体中使用\n\n## continue语句\n\n格式：continue;\n\n作用：结束本次循环，接着下次循环，通常与if语句连用\n\n## <center>数组与结构</center>\n\n### 一维数组\n\n格式：<font color=\"red\">类型说明符 数组名[常量表达式];</font>\n\n常量表达式可以是 <mark>正</mark>整数常量、符号常量或常量表达式，不能包含变量\n\n```c\n#define N 10\nint a[11],b[N],c['0'];\nfloat d[2*N];\n\n//sizeof(类型) * 数组长度 = 总字节数\nint(4字节) * 11 = 44\n//引用方式\n数组名 [下标]\n//数组初始化\n类型符 数组名[表达式] = {初值表};\n//全部元素赋初值\nint a[8] = {0,1,2,3,4,5,6,7};\t//初始数据个数>数组长度，编译出错\n//部分元素赋初值\nint a[8] = {0,1,2,3,4};\t\t//剩下元素的初值为0\n//给全部元素赋初值时可以不指定数组长度\nint a[] = {1,2,3,4,5,6,7};\t//数组长度是初值表中数值的个数\n//当对全部数组元素初始化为0时，可以写成\nint x[5] = {0,0,0,0,0};\n或 int x[5] = {0};\n//初值表不能为空 如：int a[5] = {};\t但是可以int a[5]; 但元素值不确定\n//如果没有初始化的数组，元素的值不确定\n```\n\n数组是数目固定，类型相同的若干变量的有序集合\n\n数组中每一个变量称为数组元素，属于同一个数据类型\n\n数组在内存占有一段连续的存储空间\n\n### 二维数组\n\n格式：类型说明符 数组名[常量表达式1] [常量表达式2];\t如：int a\\[3][4];\n\n注意：下标从0开始\n\n二维数组总字节数：行数 * 列数 * 类型字节数\n\n### 字符数组\n\n# <center>标准库</center>\n\n```c\n//如使用输入输出函数\n#include<stdio.h>\n//使用字符串处理函数\n#include<string.h>\n//使用数学库中的函数\n#include<math.h>\t//所有数学函数返回都是double型\n```\n\nC语言中将 null 定义为 0，则null表示则为0\n\nEOF：为-1\n\n# <center>数据结构</center>\n\n> 课件：https://maifile.cn/est/a65c2e423881c5/pdf\n\n## <center>第二章 线性表</center>\n\n线性表定义：n(>= 0)个数据特性相同的元素的有限序列，记作(a1,a2,.....,an)\n\n线性表逻辑结构：一对一\n\nai是表中数据元素，n是表长度\n\n遍历：逐项访问，从前向后，从后向前\n\n线性表特点：\n\n&ensp;&ensp;&ensp;&ensp;除了第一个元素外，其他每一个元素有且只有一个<font color=\"red\">直接前驱</font>\n\n&ensp;&ensp;&ensp;&ensp;除了最后一个元素外，其他每一个元素有且只有一个<font color=\"red\">直接后驱</font>\n\n&ensp;&ensp;&ensp;&ensp;例：a1<-->a2<---->a3<---->a4\n\n&ensp;&ensp;&ensp;&ensp;线性表的存储结构：顺序存储结构、链式存储结构（单链表、双链表、循环链表）\n\n顺序表（顺序存储）：\n\n&ensp;&ensp;&ensp;&ensp;每个节点只存放数据元素\n\n&ensp;&ensp;&ensp;&ensp;定义：将线性表中的元素相继存放在一个连续的存储空间中\n\n&ensp;&ensp;&ensp;&ensp;特点：线性表的顺序存储方式，可以随机存取\n\n&ensp;&ensp;&ensp;&ensp;优点：可随机存取，存储密度高\n\n&ensp;&ensp;&ensp;&ensp;缺点：要求大片连续空间，改变容量不方便\n\n&ensp;&ensp;&ensp;&ensp;插入/删除 要将后续元素后移/前移动，可通过下表确定目标元素位置，时间开销主要移动元素(O(n))\n\n&ensp;&ensp;&ensp;&ensp;按位查找 O(1) ，按值查找(需要对元素值一一比较) O(n)\n\n链表（链式存储）\n\n&ensp;&ensp;&ensp;&ensp;每个节点除了存放数据元素外，还存储向下一个节点的指针\n\n&ensp;&ensp;&ensp;&ensp;优点：不要求大片连续空间，改变容量方便\n\n&ensp;&ensp;&ensp;&ensp;缺点：不可随机存取，要耗费一定空间存放指针\n\n&ensp;&ensp;&ensp;&ensp;单链表：无法逆向检索，增加头节点目的：方便运算的实现(使得对第一个元素的操作与其他元素操作相同)\n\n&ensp;&ensp;&ensp;&ensp;双链表：可进退检索\n\n&ensp;&ensp;&ensp;&ensp;空表：头节点指针域都指向头节点\n\n&ensp;&ensp;&ensp;&ensp;循环单链表：表尾节点的指针指向头节点，形成循环\n\n&ensp;&ensp;&ensp;&ensp;循环双链表：双向指针域，尾节点指向头节点，头节点指向下一个节点和尾节点，形成循环且可进退\n\n&ensp;&ensp;&ensp;&ensp;复杂度：若从头节点找到尾部，时间复杂度为O(n)，n：n个元素\n\n&ensp;&ensp;&ensp;&ensp;插入/删除 元素只需修改指针即可，但需要遍历找到对应修改元素的位置，时间开销主要查找目标元素(O(n))\n\n&ensp;&ensp;&ensp;&ensp;按位查找 O(n) ，按值查找 O(n)\n\n总结：\n\n&ensp;&ensp;&ensp;&ensp;链表：用于经常需要增加/删除元素(弹性)\n\n&ensp;&ensp;&ensp;&ensp;顺序表：用于查询(搜索)操作\n\n栈：`先进后出`（全部元素不用全部进栈才可以出栈，进栈和出栈的顺序可组成不同的序列）\n\n&ensp;&ensp;&ensp;&ensp;压栈(push)，出栈(pop)\n\n队列：`先进先出`\n\n栈和队列的共同点：只允许端点处插入和删除元素，都是线性表\n\n括号配对算法结构：栈 最佳\n\n## <center>串和广义表</center>\n\n### 串\n\n串或字符串：由零个或多个字符组成的有限序列\n\n串也称为字符串，在 C 语言中是由数字、字母、下划线以及特殊字符组成的串字符，字符串需要用一对双引号括起来。在一个字符串中取一部分作为一个新字符串，这个新字符串叫子串，另一个叫做它的母串\n\ns = “a₁ a₂ a₃ ... an” （n >= 0） n为串的长度\n\n子串：串中任意个连续字符组成的子序列，包含字串的串称为主串\n\n空串：零个字符的串\n\n例：a = \"BEI\"\tb = \"JING\"\tc = \"BEIJING\"\td = \"BEI JING\"\n\n&ensp;&ensp;&ensp;&ensp;a和b都是c和d的字串，a在c和d中的位置都是1，b在c中的位置是4，在d中的位置是5\n\n只有两个串的长度相等，并各个对应位置的字符都相等时，则这两个串都是相等的\n\n### 广义表\n\n定义：广义表是线性表的推广，也称为列表\n\n广义表的深度，可以通过观察该表中所包含括号的层数间接得到\n\n```tex\n如：{{1,2},{3,{4,5}}} 中，子表 {1,2} 和 {3,{4,5}} 位于同层，此广义表中包含 3 层括号，因此深度为 3\n```\n\n广义表的长度(广度)：广义表中所包含的数据元素的个数\n\n```tex\n如：广义表 {{a,b,c}} 中只有一个子表 {a,b,c}，因此它的长度为 1\n```\n\n\n\n## <center>树</center>\n\n树的逻辑结构：一对多\n\n空树：节点数为0的树\n\n有且只有一个根节点\n\n没有后继的节点：叶子节点\n\n有后继的节点：分支节点\n\n除了根节点外，任何一个节点有且只有一个前驱\n\n每个节点可以有 0 个或 多个后继\n\n路径：由一节点到另一节点间的分支构成（只能从上往下）\n\n路径长度：路径上的分支数目（经过几条边）\n\n树的路径长度：树中所有叶子节点到根的路径长度之和\n\n节点的层次(深度)：从上往下数\n\n节点的高度：从下往上数\n\n树的高度(深度)：总共有多少层\n\n节点的度：有几个孩子(分支)\n\n树的度：各节点的度的最大值\n\n树的性质：\n\n&ensp;&ensp;&ensp;&ensp;`总点数 = 总度数 + 1`\n\n&ensp;&ensp;&ensp;&ensp;m叉树：每个节点最多只能有m个孩子的树，可以是空树\n\n&ensp;&ensp;&ensp;&ensp;度为 m 的树第 i 层最多有 m的 i-1 次方 个节点\n\n&ensp;&ensp;&ensp;&ensp;m叉树第 i 层最多有 `m的 i-1次方` 个节点\n\n&ensp;&ensp;&ensp;&ensp;高度为 h 的m叉树至多有几个节点（每一层都最多，则使用每层计算最多节点的方法再相加）\n\n&ensp;&ensp;&ensp;&ensp;高度为 h 的m叉树至少有 h 个节点\n\n&ensp;&ensp;&ensp;&ensp;高度为 h，度为m的树至少有 `h+m-1` 个节点\n\n&ensp;&ensp;&ensp;&ensp;具有n个节点的m叉树的最小高度？ 每一层节点打满\n\n### 二叉树\n\n特点：每个节点至多只有两颗子树，左右子树不能颠倒(二叉树是有序树)\n\n任意二叉树满足：`n0 = n2 + 1`\n\n二叉树转森林：二叉树从根(包含)开始路过几个节点就有几个根，也就是有森林有几棵树\n\n#### 满二叉\n\n&ensp;&ensp;&ensp;&ensp;一颗高度为h，含有 `2的h次方-1` 个节点的二叉树\n\n&ensp;&ensp;&ensp;&ensp;特点：\n\n&ensp;&ensp;&ensp;&ensp;只有最后一层有叶子节点\n\n&ensp;&ensp;&ensp;&ensp;不存在度为1 的节点\n\n&ensp;&ensp;&ensp;&ensp;按层序从1开始编号，节点 i 的左孩子为 2i，右孩子为 2i + 1，节点i的父亲节点为 i/2(向下取整)\n\n#### 完全二叉树\n\n&ensp;&ensp;&ensp;&ensp;在满二叉树的基础上可去掉若干个编号更大的节点(最后几个缺失)，某节点只有一个孩子，一定是左孩子\n\n&ensp;&ensp;&ensp;&ensp;高度：H = ㏒₂N + 1\n\n&ensp;&ensp;&ensp;&ensp;特点：\n\n&ensp;&ensp;&ensp;&ensp;只有最后两层可能有叶子节点\n\n&ensp;&ensp;&ensp;&ensp;最多只有一个度为 1 的节点\n\n&ensp;&ensp;&ensp;&ensp;按层序从1开始编号，节点 i 的左孩子为 2i，右孩子为 2i + 1，节点i的父亲节点为 i/2(向下取整)\n\n&ensp;&ensp;&ensp;&ensp;i <= n/2 为分支节点，i > n/2 为叶子节点  n：节点数\n\n#### 二叉排序树\n\n&ensp;&ensp;&ensp;&ensp;左子树上所有节点的关键字均小于根节点的关键字\n\n&ensp;&ensp;&ensp;&ensp;右子树上所有节点的关键字均大于根节点的关键字\n\n&ensp;&ensp;&ensp;&ensp;左子树和右子树又各是一颗二叉排序树\n\n&ensp;&ensp;&ensp;&ensp;判断二叉排序树的元素大小\n\n&ensp;&ensp;&ensp;&ensp;在树图下方画个向右的坐标轴，从图中对应元素垂直到坐标轴，则可得到元素从小到大排序\n\n&ensp;&ensp;&ensp;&ensp;查找(考察比较次数 == 查找长度)\n\n&ensp;&ensp;&ensp;&ensp;从上往下寻找，左树比根小，右数比根大，查找成功，返回结点指针，查找失败，返回null\n\n&ensp;&ensp;&ensp;&ensp;查找成功时  平均查找长度(ASL)：\t每层的 查找长度 * 节点数 相加 / 节点数\n\n&ensp;&ensp;&ensp;&ensp;查找失败时  平均查找长度(ASL)：\t有叶子节点每一层的 同一层叶子节点数 * 查找长度 相加 / 总叶子节点数\n\n#### 平衡二叉树\n\n&ensp;&ensp;&ensp;&ensp;平衡二叉树是排序二叉树的特殊情况\n\n &ensp;&ensp;&ensp;&ensp;树上，任一节点的左子树和右子树的深度之差不超过1\n\n&ensp;&ensp;&ensp;&ensp;节点平衡因子 = 左子树高 - 右子树高，只能是 `-1  0 或 1`\n\n#### 二叉树遍历\n\n&ensp;&ensp;&ensp;&ensp;都是先左树后右树\n\n&ensp;&ensp;&ensp;&ensp;先序遍历：根左右（从上到下，从左到右）\n\n&ensp;&ensp;&ensp;&ensp;中序遍历：左根右（小嵌套再大嵌套）\n\n&ensp;&ensp;&ensp;&ensp;后续遍历：左右根（小嵌套再大嵌套）\n\n![二叉树遍历](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402220848250.jpg)\n\n&ensp;&ensp;&ensp;&ensp;层序遍历：从上到下，从左到右\n\n只给出前、中、后、层序遍历序列中的一种，可能对应多种二叉树形态，所以不能确定唯一一颗二叉树\n\n需要两种来确定唯一（给出两个序列画图）\n\n&ensp;&ensp;&ensp;&ensp;前序(确根) + 中序遍历(确左右)\n\n&ensp;&ensp;&ensp;&ensp;后序(确根) + 中序遍历(确左右)\n\n&ensp;&ensp;&ensp;&ensp;层序 + 中序遍历\n\n### 哈夫曼树\n\n结点的权(节点上面的数值)：有某种显示含义的数值（如：表示结点的重要性等）\n\n`结点`的带权路径长度：从树的根到该结点的路径长度(经过边数) 与 该`结点上权值`的乘积\n\n`树`的带权路径长度(WPL)：树中所有`叶子结点`的带权路径长度之和\n\n定义：含有n个带权叶子结点的二叉树中，其中树的`带权路径长度最小`的二叉树，哈夫曼树(最优二叉树)\n\n构造\n\n&ensp;&ensp;&ensp;&ensp;选取`权值最小`的结点构成新结点，新结点的权值为左 右子树上根结点权值之和，直到全部结点拼接完\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403172258571.png\" alt=\"哈夫曼树构造\" style=\"zoom:50%;\" />\n\n&ensp;&ensp;&ensp;&ensp;特点：\n\n&ensp;&ensp;&ensp;&ensp;每个初始结点(给出)最终都成为叶子结点，且权值越小的结点到根结点的路径长度越大\n\n&ensp;&ensp;&ensp;&ensp;哈夫曼树的结点总数为：2n-1\tn：初始结点数\n\n&ensp;&ensp;&ensp;&ensp;哈夫曼树中`不存在度为 1 的结点`\n\n&ensp;&ensp;&ensp;&ensp;哈夫曼树并不唯一，但WPL(树的带权路径长度)必然相同且最优\n\n哈夫曼编码\n\n&ensp;&ensp;&ensp;&ensp;固定长度编码：每个字符用相等长度的二进制表示\n\n&ensp;&ensp;&ensp;&ensp;可变长编码：允许对不同字符用不等长的二进制位表示（使用哈夫曼树编辑二进制位）\n\n&ensp;&ensp;&ensp;&ensp;前缀编码：没有一个编码是另一个编码的前缀，无歧义。非前缀编码有歧义\n\n&ensp;&ensp;&ensp;&ensp;哈夫曼编码可以用于数据压缩\n\n## 图\n\n图(G)由顶点集(V)和边集(E)组成，|V|：图中顶点的个数\t|E|：图中边的条数\n\n元素存在`多对多`的关系\n\n图不可以是空，即 V 一定是非空集，但E可为0\n\n有向图：边是有方向的(有向边)\n\nG = (V,E)\n\nV = {A,B,C,D,E}\n\nE = {<A,B>,<A,C>,<A,D>,<A,E>,<B,A>,<B,C>,<B,E>,<C,D>}\n\n无向图：边是没有方向的(无向边)\n\nG = (V,E)\n\nV = {A,B,C,D,E}\n\nE = {(A,B),(B,D),(B,E),(C,D),(C,E),(D,E)}\n\n简单图：不存在重复边，不存在顶点到自身的边（有向图中两个方向不同的边不属于重复边）\n\n多重图：两个结点之间边数多余一条，允许顶点通过同一条边和自己联系\n\n对于无向图\n\n&ensp;&ensp;&ensp;&ensp;顶点的度：依附于该顶点的边的条数\n\n&ensp;&ensp;&ensp;&ensp;无向图的全部顶点的度的和 等于 边数的2倍\n\n对于有向图\n\n&ensp;&ensp;&ensp;&ensp;入度(进来)：顶点 v 为终点的有向边的数目\n\n&ensp;&ensp;&ensp;&ensp;出度(出去)：顶点 v 为起点的有向边的数目\n\n&ensp;&ensp;&ensp;&ensp;顶点v的度：入度和出度之和\t入度之和 = 出度之和 = 边数\n\n路径：顶点到顶点之间的路径\n\n回路或环：第一个顶点和最后一个顶点相同的路径(构成闭环)\n\n简单路径：顶点不重复出现的路径\n\n简单回路：除了第一个顶点和最后一个顶点外，其余顶点不重复出现的回路\n\n路径长度：路径上 边的数目\n\n点到点的距离：顶点u到顶点v的最短路径若存在，则此路径的长度为u到v的距离，若不存在，则该距离为无穷(∞)\n\n无向图中，顶点v 到 顶点w 有路径存在，则称 v 和 w 是<mark>连通</mark>的\n\n有向图中，顶点v 到 顶点w 和 顶点w 到 顶点v 之间都有路径，则这两个顶点为<mark>强连通</mark>的\n\n若图(无向)中，任意两个顶点都是连通的，则成为连通图，否则为非连通图\n\n&ensp;&ensp;&ensp;&ensp;对于n个顶点的无向图G\n\n&ensp;&ensp;&ensp;&ensp;若G是连通图，则最少有 `n-1` 条边\n\n&ensp;&ensp;&ensp;&ensp;若G是非连通图，则最多可能有n(n-1)/2\n\n若图(有向)中，任何一堆顶点都是强连通，则此图为强连通图\n\n&ensp;&ensp;&ensp;&ensp;n个顶点的强连通图，最少有`n`条边(形成回路)\n\n生成子图：无向图中包含全部点(父图)\n\n连通分量：无向图中有几个分开的整体，几个整体就是连通分量\n\n强连通分量：有向图中有几个分开的整体，几个整体就是连通分量\n\n连通图生成树：包含图中全部顶点，边尽可能少，但要保持连通\n\n无向全连通图边数：`n(n-1)/2`\tn：顶点数\n\nn个顶点有向图，每个顶点的度最大可达 `2(n-1)`\n\n### 图的存储\n\n#### 邻接矩阵法\n\n&ensp;&ensp;&ensp;&ensp;注意：有向图的方向，<font color=\"red\">`无向图`</font>`斜角45度对称`\n\n&ensp;&ensp;&ensp;&ensp;在无向图中，第i个结点的度 = 第i行(或者第i列)的非零元素个数\n\n&ensp;&ensp;&ensp;&ensp;在有向图中，第i个结点的<mark>出度</mark> = 第i行的非零元素个数\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第i个结点的<mark>入度</mark> = 第i列的非零元素个数\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第i个结点的度 = 第i行、第i列的非零元素的个数之和\n\n&ensp;&ensp;&ensp;&ensp;邻接矩阵法求顶点的度 出度 入度 的时间复杂度为 O(|v|)\tv：顶点个数\n\n&ensp;&ensp;&ensp;&ensp;邻接矩阵法：所占存储空间与顶点个数相关\n\n&ensp;&ensp;&ensp;&ensp;结点数为n，邻接矩阵A是 n*n 的\n\n![邻接矩阵法](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402220848000.jpg)\n\n&ensp;&ensp;&ensp;&ensp;邻接矩阵法存储带权图\n\n![邻接矩阵图_带权](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402220847724.jpg)\n\n&ensp;&ensp;&ensp;&ensp;邻接矩阵图性能分析\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;空间复杂度：O(|v|²)\tv：顶点数\t只和顶点数有关，和实际边数无关\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;适合用于存储稠密图\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;`无向图`的的邻接矩阵是`对称矩阵`，`可以压缩存储`\n\n#### 邻接表(顺序+链式存储)\n\n&ensp;&ensp;&ensp;&ensp;边结点的数量是2|E|\t（每条边被记录了两次）\n\n&ensp;&ensp;&ensp;&ensp;无向图空间复杂度为：O(|v| + 2|E|)\t\n\n&ensp;&ensp;&ensp;&ensp;有向图空间复杂度为：O(v+e)\n\n&ensp;&ensp;&ensp;&ensp;排列方式：`不唯一`。存储稀疏图(边较少)\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402220847734.jpg\" alt=\"邻接表法\" style=\"zoom:50%;\" />\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291650507.png\" style=\"zoom:50%;\" />\n\n### 图的遍历\n\n可能序列排序不唯一，按节点编号的`升序`一次访问\n\n#### 广度优先遍历(BFS)\n\n树：类似`层序遍历`，一层一层遍历，先孩子再孙子，按编号升序访问\n\n时间复杂度：O(n+e)\tn：顶点数  e：边数\n\n使用`队列`数据结构\n\n#### 深度优先遍历(DFS)\n\n树：类似`先序遍历`，一条直线走到底，走完再换另一个，按编号升序访问方向\n\n时间复杂度：O(n+e)\tn：顶点数  e：边数\n\n使用`栈`数据结构，是一个递归过程\n\n图：\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402220846594.jpg\" alt=\"图1\" style=\"zoom:33%;\" />\n\n广度优先：以2为先，21653748\n\n深度优先：以3为先，34762158\t以2为先，21563478\n\n## 最小生成树\n\n连通图生成树：包含图中全部点，最少边，保持连通\n\n最小生成树：带权值，边权值最小，`图形不唯一`，但最小代价唯一\n\n### Prim算法(普里姆)\n\n贪心算法\n\n先选最小权值的边，再从以选中的顶点所附带的边中选择最小权值的边，以此类推，推出树图\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402220829529.jpg\" alt=\"图2\" style=\"zoom:33%;\" />\n\n### Kruskal算法(克鲁斯卡尔)\n\n贪心算法\n\n每次选择一条权值最小的边，这条边两头连通（原本连通的就不选）\n\n## 排序(需要代码)\n\n### 交换排序\n\n冒泡：把最大的或最小的冒到一边\n\n每两个数字相互比较，按对应顺序排序，比较完一次，再和后面的一个数比较，以此类推\n\n### 选择排序\n\n类似打扑克牌时整理牌的顺序一样，从左往右整理\n\n### 插入排序\n\n### 折半查找\n\n只能在顺序存储，不能在链表，元素有序\n\n# <center>简答题备考</center>\n\n## C语言\n\n机器语言：紧密依赖于计算机的硬件\n\n高级语言：比较接近人们习惯使用的自然语言和数学语言\n\n程序：一组计算机能识别和执行的指令\n\n源程序：用高级语言编写的程序\n\n常量：程序运行过程中不能改变的量\n\n变量：程序运行过程中其值可以改变的量\n\n变量名：以一个容易记忆的名字代表存储单元的地址\n\n转义字符：将反斜杠 \"\\\\\" 后面的字符转换成另外的意义，输出信息时的控制符号 如 '\\n'代表换行\n\n字符串常量：一对双撇号括起来的字符序列\n\n算术表达式：用算术运算符和括号将运算对象连接起来的、符合C语法规则的式子\n\n数据结构：在程序中指定数据类型和数据的组织形式\n\n算法：即操作步骤\n\n修饰符：用来丰富格式字符功能的附加字符\n\n关系表达式：用关系运算符将两个表达式连接起来的式子\n\n逻辑表达式：用逻辑运算符将两个表达式连接起来的式子\n\n用选择机构来检查所指定的条件是否满足，并根据判断的结果决定执行哪种操作\n\n循环结构就是用来处理需要重复处理的问题\n\n数组：具有相同类型的变量，用连续空间存储起来\n\n字符数组：用来存放字符数据的数组\n\n函数就是用来完成一定的功能的\n\n函数的声明称为函数原型\n\n递归调用：在调用一个函数的过程中又出现直接或间接地调用函数本身\n\n局部变量：在函数或复合语句中定义的变量，只在本函数或复合语句内范围内有效\n\n全局变量：在函数之外定义的变量，从定义变量到本源程序文件结束有效，在范围内可以为本程序文件中所有函数共用\n\n静态存储：在程序运行期间由系统在静态存储区分配存储空间的方式，在程序运行期间不释放\n\n动态存储：在函数调用期间根据需要在动态存储分配存储空间的方式\n\n寄存器变量(register)：一些变量频繁使用，将局部变量的值放在CPU中的寄存器，寄存器对于存取速度远高于内存的存取速度，这样可以提高执行效率\n\n内部函数(静态函数)：用static声明的，函数作用只局限于所在文件，其他文件不能引用\n\n外部函数：函数首部最左端添加extern，可供其他文件调用\n\n函数的定义：对函数功能的确立，包括指定函数名、函数值类型、形参及其类型以及函数体等，它是一个完整的、独立的函数单位\n\n函数的声明：好吧函数的名字、函数类型以及形参的类型、个数和顺序通知编译系统，以便在调用该函数时系统按此进行对照检查\n\n变量的定义：定义变量时，要指明数据类型，编译系统要据此给变量分配存储空间，称为定义行声明\n\n变量的声明：不必指定数据类型，数据类型在定义时指定了，只是为了引用的需要，称为引用性声明\n\n将地址形象化地称为“指针”\n\n指针变量：一个变量专门用来存放另一个变量的地址\n\n结构体：用户自己建立由不同类型的数据组成的组合型的数据结构\n\n结构体数组：一个结构体变量中可以存放一组有关联的数据\n\n结构体指针：指向结构\n\n枚举：将变量的值一一列举出来，变量的值只限于列举出来的值的范围内\n\n程序文件：包括源程序(后缀为.c)、目标文件(后缀.obj)、可执行文件(后缀为.exe)文件等。这种文件是用来存放程序的，以便实现程序的功能\n\n数据文件：文件内容不是程序，而是供程序运行时读写的数据，或共程序运行时读入内存的数据\n\n文件分类：按数据的组织形式，数据文件可分为`ASCII文件`和`二进制文件`\n\n## 数据结构\n\n数据：客观事物的符号表示，是所有能输入计算机中并被计算机程序处理的符号的总称\n\n数据元素：是数据的基本单位，在计算机中通常作为一个整体进行考虑\n\n数据项：组成数据元素的、有独立含义的、不可分割的最小单位\n\n数据对象：是性质相同的数据元素的集合，是数据的一个子集\n\n数据结构：相互之间存在一种或多种特定关系的数据元素的集合\n\n算法：为了解决某类问题而规定的一个有限长的操作序列\n\n算法特性：有穷性、确定性、可行性、输入、输出\n\n算法基本标准：正确性、可读性、健壮性、高效性\n\n线性表：由n个数据特性相同的元素构成的有限序列\n\n&ensp;&ensp;&ensp;&ensp;如学生基本信息表，每个学生为一个数据元素，包括学号、姓名、性别、籍贯等数据项\n\n节点：存储七本身的信息之外，还需存储一个指示七直接后继的信息，这两部分信息组成数据元素的存储映像\n\n数据域：存储数据元素信息的域\n\n指针域：存储直接后继存储位置的域\n\n链表：n个节点链接成的表\n\n栈：限定仅在表尾进行插入或删除操作的线性表\n\n栈底：表头端\n\n栈顶：表尾端\n\n队列：一种先进先出的线性表\n\n队尾：允许插入的一端\n\n对头：允许删除的一端\n\n栈和队列都有：顺序和链式存储\n\n串也称为字符串，在 C 语言中是由数字、字母、下划线以及特殊字符组成的串字符，字符串需要用一对双引号括起来。在一个字符串中取一部分作为一个新字符串，这个新字符串叫子串，另一个叫做它的母串\n\n树：n个节点的有限集\n\n森林：n棵互不相交的树的集合\n\n图(G)：由两个集合V和E组成，记为G = (V,E)，V是顶点的有穷非空集合，E是V中顶点偶对的有穷集合，这些顶点偶对 称为 边\n\n查找表：由同一个类型的数据元素构成的集合\n\n关键字：数据元素中某个数据项的值，用它可以标识一个数据元素\n\n&ensp;&ensp;&ensp;&ensp;主关键字：此关键字可以唯一地标识一个记录\n\n&ensp;&ensp;&ensp;&ensp;次关键字：用以识别若干记录的关键字\n\n查找：指根据给定的某个值，在查找表中确定一个关键字等于给定值的记录或数据元素，如果存在查找成功，不存在查找失败\n\n查找分类：顺序查找、折半查找、分块查找\n\n排序：按关键字的非递减或非递增顺序对一组记录重新进行排列的操作\n\n\n\n","tags":["计算机程序与基础"],"categories":["升学"]},{"title":"25.网络编程","url":"/post/f1dbdc9f.html","content":"\n# <center>知识点一：什么是网络编程</center>\n\nJava是Internet上语言，它从语言级别上提供了对网络编程支持，程序猿可以利用Java语言进行网络应用程序编写，Java提供大量网络库，可以实现不同网络连接【TCP/UDP】，联网的底层实现已经被Java进行封装了，只需调用网络包中提供实现类方法就可以完成网络编程\n\n网络编程就是提供互联网应用程序，互联网是什么？把分布在不同区域的计算机与专门外部设备进行通信相互链接在一起，提供一个强大网络关系，从而通过链接网络就可以方便计算机与计算机之间的信息传递，共享硬件，数据和软件信息\n\n之所以计算机之间可以进行网络通信是因为提供网络连接【网线和wifi】\n\n# <center>知识点二：网络通信协议</center>\n\n网络通信协议就是联网设备之间可以进行更好交互，需要遵守一套通信规则\n\n通讯协议有两套【一套是理论协议和一套是实际操作协议】\n\n## <center>1、OSI通信模型【网络7层协议】</center>\n\n![OSI通信模型](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012250386.png)\n\n在7协议的基础至少之上进行网络协议修改，修改之后的协议更加适合现实生活中网络的实现【TCP/IP通信模型】\n\n![层次](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012250533.png)\n\n在这个模型中 传输层和网络层是需要使用的，提供TCP/IP编程可以完成网络通信操作\n\n# <center>知识点三：网络编程三要素</center>\n\n**协议、IP地址、端口号**，在这三个要素的前提下得到到两种网络编程模式【软件结构】-> **C/S架构和B/S架构**\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012251097.png\" alt=\"三要素\" style=\"zoom:50%;\" />\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012252229.png\" alt=\"B/S结构\" style=\"zoom:50%;\" />\n\n其实这两种框架开发时各有有点，但是无论是那种框架，都要离不开【“网络”】，需要提供网络编程，就可以架构通信操作了\n\n## <center>1、协议</center>\n\n通信协议是计算必须遵守规则， 只有遵守规则才可以进行计算机与计算机之间通信，这就好比道路中行驶的汽车必须遵守交通规则，通讯协议也是一样的，通信协议中提供对数据的【传输格式、传输速率、传输步骤】等等都提供统一的规范，通讯双方必须遵守这个规范，最终完成数据的交换\n\n## <center>2、TCP协议</center>\n\n在 java.net 这个包中就提供了这种常见协议：\n\nTCP：传输控制协议，TCP协议是**面向连接**的通信协议，即传输数据之前，在发送端和接收端需要建立起逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输\n\nTCP协议的特点: **面向连接、传输数据安全、传输速度低**\n\n例如： 大宝发现了李四家里牛丢了\n\n&ensp;&ensp;&ensp;&ensp;TCP协议： 大宝一定要找到李四，面对面的告诉他你们家牛丢了\n\nTCP如何保证面向连接安全？\n\n&ensp;&ensp;&ensp;&ensp;TCP在连接时会进行【**三次握手**】，TCP协议中，在发送数据的准备阶段，客户端与服务器之间进行三次交互，以保证可靠连接\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012253925.png\" alt=\"TCP协议\" style=\"zoom:50%;\" />\n\n第一次握手： 客户端向服务器发送连接请求，等待服务器确认\n\n第二次握手：服务器端接收客户端请求并向客户端回送一个响应，通知客户端收到了连接请求\n\n第三次握手：客户端接收到服务器响应，再次向服务器端发送确认信息，确认连接\n\n客户端与服务器之间就可以开始进行通信操作了\n\n完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了，由于这种连接时面思连接的特性，所以TCP协议可以保证传输数据的安全，所以TCP通信协议被广泛的应用【HTTP协议（网页浏览）、文件上传、文件下载】等等\n\n三次握手可以理解为打电话\n\n&ensp;&ensp;&ensp;&ensp;第一次握手就相当于 ---》 你拿起电话开始拨号\n\n&ensp;&ensp;&ensp;&ensp;第二次握手就相当于 ---》 对方拿起电话说“喂”\n\n&ensp;&ensp;&ensp;&ensp;第三次握手就相当于 ---》 听到“喂”就说明两端连同，开始通话\n\n## <center>3、UDP协议</center>\n\n在 java.net 这个包中就提供了这种常见协议：\n\nUDP被称之为 【数据报（文）协议】，UDP协议是一个面向无连接的协议，传输数据时候，不需要建立连接，不管对方服务器是否启动，【直接将数据，数据源和目的地都封装到数据包，直接发送】，每个数据包的大小被限制在64KB，因为连接不可靠而且是面向无连接，所以它传输速度快，但是容易丢包【数据】，日日常应用中：视频、游戏等等\n\n例如： 大宝发现了李四家里牛丢了\n\nUDP协议： 大宝在村里的广播站广播以下李四你家牛丢了，效率快\n\n## <center>4、IP地址</center>\n\nIP地址：是互联网中协议地址，俗称IP，**IP地址用来给一个网络中的计算机设备做唯一的编号**\n\nIP地址分类\n\n&ensp;&ensp;&ensp;&ensp;IPv4：是一个32位的二进制数，通常被划分4个字节，表示形式D.D.D.D 形式表示\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;例如： 192.168.10.27 这就是IP地址，其中的每一位即 D 范围是一个从0~255结束范围 ，最多表示42亿个IP地址，就算这样全世界的IPv4地址已经没有了\n\n&ensp;&ensp;&ensp;&ensp;IPv6：中国主导的，随着全世界互联网网络发展IPv4已经不能满足所有需求，但是网络资源地址还是需要的，使用IPv6来缓解IPv4的缺失，IPv6是一个128位的二进制数，每16个字节划分一组，8组16进制，表示形成 F.F.F.F.F.F.F.F\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;例如： fdb2:2c26:f4e4:0:3421:943d:8040:8eef\n\n**windows中CMD中 输入 ipconfig可以查看本机的IP地址**\n\n所有的人电脑其实在出厂时都有自己的一个IP地址，这个IP地址是供给计算机内容进行通信使用，称之为“环形网络”--》这个IP地址是127.0.0.1 --》 称之为 localhost\n\n## <center>5、端口号</center>\n\n网络的通信，本质上是有两个进程（应用程序）的通信，每台计算机都有很多的进程，那么在网络通信时，如何区分是哪个进程呢？\n\n如果说“IP地址”可以唯一标识网络中的设备，那么“端口号”就可以唯一标识设备中进程（应用程序)了\n\n端口号：用两个字节标识的整数，它的取值范围是0~65535。其中，**0~1023之间端口号用于一些知名的网络服务器与系统应用**，普通的应用程序需啊哟使用1024以上的端口号。**如果端口号被另外一个服务器或应用程序所占用，会导致当前程序启动失败**\n\n开中常见端口号 ： MySQL ： 3306 Oracle 1521 或 1520 Tomcat： 8080\n\n利用这个三个组合 **协议 + IP地址 + 端口号**就可以提供网络中进程（应用程序）\n\n# <center>知识点四：InteAddress类</center>\n\n此类表示互联网协议 (IP) 地址，能够通过InetAddress这个类获取到IP地址，InteAddress也可以理解为一个IP地址的在Java代码中抽象\n\n```java\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\npublic class InterAddressDemo 。\n{\n    public static void main(String[] args) throws Exception \n    {\n        System.out.println(\"----------------------------创建局域网IP地址对象-------------------------------\");\n        //1.使用本机的IP地址创建对象\n        //提供一个编译时异常Unhandled exception: java.net.UnknownHostException【无法获取主机（IP地址）】\n        InetAddress localHost = InetAddress.getLocalHost();\n        //获取封装在对象中IP地址\n        System.out.println(\"ip地址：\"+localHost.getHostAddress());\n        //获取封装在对象中主机名\n        System.out.println(\"主机名：\"+localHost.getHostName());\n        //通过赋值IP地址来创建IP地址对象 --》这个参数也可以赋值为 localhost(主机) ---》赋值网络域名\n        InetAddress byName = InetAddress.getByName(\"10.211.55.3\");\n        System.out.println(\"----------------------------创建外网IP地址对象-------------------------------\");\n        InetAddress byName1 = InetAddress.getByName(\"www.baidu.com\");\n        System.out.println(\"百度IP地址：\"+byName1.getHostAddress());\n        System.out.println(\"百度主机名：\"+byName1.getHostName());\n        //判断连接访问 ---》 ping命令\n        System.out.println(\"2秒内是否可以访问到？\"+ byName1.isReachable(2000));    // ping www.baidu.com\n        //获取IP地址对象中所有的信息\n        InetAddress[] allByName = InetAddress.getAllByName(\"www.baidu.com\");\n        for(InetAddress ip : allByName)\n        {\n            System.out.println(ip);\n        }\n    }\n}\n```\n\n# <center>知识点五：TCP协议编程</center>\n\nJava中TCP协议编程并不需要我们从头开始写，Java已经在net包中提供操作，专门提供两个类来完成TCP操作\n\n**Socket**【客户端】：此类实现客户端套接字（也可以就叫“套接字”）。套接字是两台机器间通信的端点\n\n**ServerSocket**【服务器】：此类实现服务器套接字。服务器套接字等待请求通过网络传入。它基于该请求执行某些操作，然后可能向请求者返回结果\n\n因为TCP连接时面向连接的，也就是属于“长连接”，所以需要进行关闭操作，**客户端是可以与服务器进行通信使用的是字节流**\n\n案例1\n\n&ensp;&ensp;&ensp;&ensp;需求：客户端向服务器发送请求，并传递数据发送【服务你好】\n\n```java\npackage com.qfedu.TCP.V1;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.Socket;\n//客户端程序\npublic class Client \n{\n    public static void main(String[] args) throws Exception \n    {\n        //1.创建客户端对象提供IP地址和端口号\n        /*\n            第一个参数：字符串类型IP地址\n            第二个参数：通信端口号\n        */\n        Socket client = new Socket(\"10.211.55.3\",8888);\n        System.out.println(\"客户端信息：\"+client);\n        //2.获取网络字节输出流对象【建立一条客户端通向服务器的通道】\n        OutputStream outputStream = client.getOutputStream();\n        //利用字节输入流的对象向服务器发送数据即可\n        outputStream.write(\"服务器你好，我是客户端，来自远方问候.....嘿嘿(*^▽^*)！！！\".getBytes());\n        //强烈推荐在使用网路流传输数据时必须要写刷新\n        outputStream.flush();\n        //3.关闭客户端\n        client.close();\n    }\n} \npackage com.qfedu.TCP.V1;\nimport java.io.InputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\npublic class Server \n{\n    public static void main(String[] args) throws Exception \n    {\n        //1.创建服务器端对象，参数只有一个需要和客户端一样的端口号\n        ServerSocket server = new ServerSocket(8888);\n        System.out.println(\"服务器在等待客户端的链接.......\");\n        //2.通过服务器端对象调用 accept 方法获取到连接服务器的客户端对象进行操作\n        Socket sClient = server.accept();    //返回的是客户端的信息(端口号等信息)\n        System.out.println(\"恭喜!来自客户端\"+sClient+\"已经链接上了.......\");\n        //3.创建网络字节输入流对象，获取传输的数据【建立客户端与服务器连接通道】\n        InputStream inputStream = sClient.getInputStream();\n        byte[] bs = new byte[1024];\n        int len = inputStream.read(bs);\n        //4.打印客户端的信息\n        System.out.println(\"来自客户端的信息是：\"+new String(bs,0,len));\n        //5.关闭服务器\n        server.close();\n    }\n}\n```\n\n案例2\n\n&ensp;&ensp;&ensp;&ensp;需求：此时客户端与服务器之间是建立了连接发送了信息，客户端服务器发送了信息，服务器要给客户端予以响应\n\n```java\npackage com.qfedu.TCP.V2;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\n//客户端程序\npublic class Client \n{\n    public static void main(String[] args) throws Exception \n    {\n        //1.创建客户端对象提供IP地址和端口号\n        /*\n            第一个参数是字符串类型IP地址\n            第二个参数通信端口号\n        */\n        Socket client = new Socket(\"10.211.55.3\",8888);\n        System.out.println(\"客户端信息：\"+client);\n        //2.获取网络字节输出流对象【建立一条客户端通向服务器的通道】\n        OutputStream outputStream = client.getOutputStream();\n        //利用字节输入流的对象向服务器发送数据即可\n        outputStream.write(\"服务器你好，我是客户端，来自远方问候.....嘿嘿(*^▽^*)！！！\".getBytes());\n        //强烈推荐在使用网路流传输数据时必须要写刷新\n        outputStream.flush();\n        //3.接收服务器的反馈信息[获取网络字节输入流对象]\n        InputStream inputStream = client.getInputStream();\n        byte[] bs = new byte[1024];\n        int len = inputStream.read(bs);\n        System.out.println(\"当前来之服务器的反馈信息：\"+new String(bs,0,len));\n        //4.关闭客户端\n        client.close();\n    }\n} \npackage com.qfedu.TCP.V2;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\npublic class Server \n{\n    public static void main(String[] args) throws Exception \n    {\n        //1.创建服务器端对象，参数只有一个需要和客户端一样的端口号\n        ServerSocket server = new ServerSocket(8888);\n        System.out.println(\"服务器在等待客户端的链接.......\");\n        //2.通过服务器端对象调用 accept 方法获取到连接服务器的客户端对象进行操作\n        Socket sClient = server.accept();\n        System.out.println(\"恭喜!来自客户端\"+sClient+\"已经链接上了.......\");\n        //3.创建网络字节输入流对象，获取传输的数据【建立客户端与服务器连接通道】\n        InputStream inputStream = sClient.getInputStream();\n        byte[] bs = new byte[1024];\n        int len = inputStream.read(bs);\n        //4.打印客户端的信息\n        System.out.println(\"来之客户端的信息是：\"+new String(bs,0,len));\n        //5.服务器向客户予以响应\n        //5.1提供网络字节输出流对象\n        OutputStream outputStream = sClient.getOutputStream();\n        outputStream.write(\"已收到信息，感谢访问(#^.^#)！\".getBytes());\n        outputStream.flush();\n        //6.关闭服务器\n        server.close();\n    }\n}\n```\n\n案例3\n\n&ensp;&ensp;&ensp;&ensp;需求: 提供客户端与服务器之间聊天程序， 当某一个方输入 886 停止聊天\n\n```java\npackage com.qfedu.TCP.V3;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.Scanner;\n//提供一个客户端程序，完成客户端接收与发送信息给服务器\npublic class Client \n{\n    public static void main(String[] args) throws Exception \n    {\n        //1.提供客户端对象\n        Socket socket = new Socket(\"10.211.55.3\",9999);\n        //2.提供网络字节输入输出流对象\n        InputStream inputStream = socket.getInputStream();\n        OutputStream outputStream = socket.getOutputStream();\n        //3.提供Scanner获取控制台信息\n        Scanner input = new Scanner(System.in);\n        while(true)\n        {\n            System.out.println(\"客户端向服务器说：\");\n            String content = input.next();\n            outputStream.write(content.getBytes());\n            outputStream.flush();\n            //做了一个约定，如果哪一方输入886 就关闭聊天\n            if(\"886\".equals(content))\n            {\n                break;\n            } \n            //提供数组存数据操作\n            byte[] bs = new byte[1024];\n            int len = inputStream.read(bs);\n            System.out.println(\"来之服务器的信息：\"+ new String(bs,0,len));\n        } \n        socket.close();\n    }\n} \npackage com.qfedu.TCP.V3;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Scanner;\npublic class Server \n{\n    public static void main(String[] args) throws\nException \n    {\n        //1.创建服务器端对象\n        ServerSocket server = new ServerSocket(9999);\n        //2.利用serverSocket对象中accept方法获取客户端连接\n        Socket accept = server.accept();\n        //3.提供网络字节输入输出流对象完成信息发送\n        InputStream inputStream = accept.getInputStream();\n        OutputStream outputStream = accept.getOutputStream();\n        //4.提供控制台获取数据\n        Scanner input = new Scanner(System.in);\n        while(true)\n        {\n            //4.1接收客户端向服务器发送的数据\n            byte[] bs = new byte[1024];\n            int len = inputStream.read(bs);\n            String content = new String(bs,0,len);\n            System.out.println(\"来之客户端的信息：\"+content);\n            //判断客户单输入的输入的数据是什么\n            if(\"886\".equals(content))\n            {\n                break;\n            } \n            //4.2服务器向客户端发送数据\n            System.out.println(\"服务器端向客户端说：\");\n            String str = input.next();\n            outputStream.write(str.getBytes());\n            outputStream.flush();\n        } \n        server.close();\n    }\n}\n```\n\n## <center>1、使用TCP模拟Tomcat服务器</center>\n\n需求：利用浏览器进行网页访问，访问服务器中HTML页面，展示服务器端HTML页面在浏览器中\n\n需要在项目中提供web目录并在web目录下提供html页面\n\n在浏览器中访问地址时：\n\n&ensp;&ensp;&ensp;&ensp;IP地址:服务器端口号/访问资源路径 --》 相当于 --》127.0.0.1:9999/web/regist.html\n\n```java\nimport java.io.*;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n//利用ServerSocket模拟Tomcat服务器提供网页访问服务器\npublic class TomcatServer \n{\n    public static void main(String[] args) throws Exception \n    {\n        //1.通过读取浏览器页面请求信息，获取浏览器需要访问的路径\n        //提供ServerSocket服务器端对象\n        ServerSocket server = new ServerSocket(9999);\n        //调用accept方法获取连接的客户端\n        Socket socket = server.accept();\n        //通过返回socket对象获取网络字节输入流对象【建立连接通道】\n        InputStream inputStream = socket.getInputStream();\n        //将字节流转换为字符流【缓冲的】--》读取到字符串了\n        BufferedReader br = new BufferedReader(new InputStreamReader(inputStream));\n        //利用字符缓冲输入流读取文件访问路径\n        String path = br.readLine();\n        System.out.println(path);\n        //利用空格将path路径进行分隔，获取到访问资源路径\n        String[] s = path.split(\" \");\n        //通过下标获取出资源路径，将路径最前面的/去掉\n        String realPath = s[1].substring(1);\n        System.out.println(\"浏览器访问服务器的资源路径：\"+realPath);\n        //利用相对路径读取服务器中相对路径中资源反馈给浏览器\n        FileInputStream fis = new FileInputStream(realPath);\n        //在通过accept方法获取Socket对象获取网络字节输出流【将流中数据反馈给浏览器】\n        OutputStream outputStream = socket.getOutputStream();\n        //开始读写\n        byte[] bs = new byte[8192];\n        int len;\n        //响应页面的时候需要将服务器返回给浏览器的必要信息\n        outputStream.write(\"HTTP/1.1 200OK\\r\\n\".getBytes());\n        outputStream.write(\"ContentType:text/html\\r\\n\".getBytes());\n        outputStream.write(\"\\r\\n\".getBytes());\n        while((len = fis.read(bs))!=-1)\n        {\n            outputStream.write(bs,0,len);\n        } \n        outputStream.flush();\n        //关闭流\n        fis.close();\n        socket.close();\n    }\n}\n```\n\n# <center>知识点六：UDP协议编程（了解）</center>\n\nJava中也提供UDP编程操作提供两个必要类：\n\n&ensp;&ensp;&ensp;&ensp;**DatagramSocket【即是客户端也是服务器】 和DatagramPacket【UDP需要的数据包】**\n\nUDP是无责任的发送模式类似于【广播电台】，UDP发送数据是不保证包安全，UDP的客户端与服务器是同一个类，发送数据时候需要使用DatagramPacket进行数据封装，包的限制64K\n\n```java\npackage com.qfedu.UDP;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.SocketException;\n//UDP发送数据类\npublic class Send \n{\n    public static void main(String[] args) throws Exception \n    {\n        //1.创建UDP对象\n        DatagramSocket sender = new DatagramSocket();\n        //2.提供信息\n        String content = \"今天天气好晴朗，下班要下雨了，赶快跑路....\";\n        //3.提供数据包将数据封装到包中\n        DatagramPacket packet = new DatagramPacket(\n            content.getBytes(),            //提供数据字节数组\n            content.getBytes().length,    //字节数组的长度\n            InetAddress.getByName(\"127.0.0.1\"), //设置发送IP地址\n            9999    //发送端口号\n        );\n        //发送信息\n        sender.send(packet);\n    }\n} \nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.SocketException;\n//UDP接收类\npublic class Receiver \n{\n    public static void main(String[] args) throws Exception \n    {\n        //1.创建UDP对象并指定接收数据端口号\n        DatagramSocket receiver = new DatagramSocket(9999);\n        //2.需要提供byte类型数据接收存数据\n        byte[] bs = new byte[1024];\n        //3.创建数据包对象\n        DatagramPacket packet = new DatagramPacket(bs,bs.length);\n        //接收数据存储在包对象中\n        receiver.receive(packet);\n        /*\n        拆包:\n            getData() 获取包中字节数组\n            getLength() 获取包中字节数组的长度\n        */\n        String content = new String(packet.getData(),0,packet.getLength());\n        System.out.println(content);\n        receiver.close();\n    }\n}\n```\n\n","tags":["Java"],"categories":["编程语言","Java"]},{"title":"26.反射","url":"/post/5883a4af.html","content":"\n# <center>知识点一：类的加载</center>\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012304354.png\" alt=\"类的加载过程\" style=\"zoom: 50%;\" />\n\n```java\npackage com.qf.Demo03;\n\n/**\n * 作者：星仔\n * 描述：永无Bug\n */\npublic class ReflectDemo\n{\n    /**\n     * 反射：在程序运行期获取的相关信息（对象、构造、方法、属性..）\n     *\n     * 以前创建对象：通过new关键字去创建\n     *      User user = new User();\n     * 如果学习了反射，那么可以在代码运行期间创建类的对象（String）\n     * 类的对象：通过new关键字创建的对象是类的对象（可以创建多个）\n     * 类对象：在类加载的时候会产生一个类对象（包含类的所有的信息：属性、方法、构造方法、父类、接口、包名）（只会有一个）\n     * 所有类的类对象的类型是Class类型\n     *\n     * 类加载的时机；\n     *      1.创建对象\n     *      2.创建子类对象\n     *      3.调用类中的静态方法和属性\n     *      4.通过Class.forName(\"\");  主动触发类加载\n     */\n}\n```\n\n在JVM中类的加载是有细分操作，当程序启动时候说那个到某个类，如果该类被加载到内存中，则JVM会通过三个步骤进行类的初始化操作【加载、连接和初始化】\n\n![初始化](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012304757.png)\n\n# <center>知识点二：什么是Class对象？</center>\n\nPS：在Java中提供一个类这个类叫做Class，用于存储类的字节码文件对象【存储自定义类中描述信息】\n\n例如：Java中需要创建某个类的对象\n\n做法： Student stu = new Student(); ---》通过Student类来创建stu这个对象，stu对象是Student类的实例，在创建过程中隐藏了一些内部实现的细节【类的加载】，就可以直接在代码中使用stu这个对象触发Student类中的属性和方法了\n\n&ensp;&ensp;&ensp;&ensp;Java是一门面向对象的语言，面向对象核心【世间万物皆对象】，所有东西都以对象角度为出发来进行思考，既然是这样那么就可以看待提供stu这个实例的类也是一个对象，那么Java就提供了一个可以描述自定义类的类Class【即描述类的类】，在整个类的加载过程中，反复提到了一点就是在类的字节文件【.class文件】加载到内存中时候，会生成一个【Class类的对象】，整个对象存中存储的就是类中所描述的信息，所以外界就可以提供Student stu = new Student(); ---》通过Student类来创建stu这个对象\n\n&ensp;&ensp;&ensp;&ensp;但是除了这种创建方式之外，因为JVM中是存在Class类对象的，所以Java就提供了另外一种方式，可以直接通过Class类的对象加载出来对应类的对象操作，这个操作就叫做“【反射reflect】”\n\n正常创建对象 ---》 Student stu = new Student()；\n\n但是在JVM中先得到Student类的.class字节码文件，通过字节码文件创建出Student这类的对象\n\n![解说](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012305610.png)\n\n# <center>知识点三：获取Class对象</center>\n\n如何获取Class对象,一共有三种方式获取类对象\n\n&ensp;&ensp;&ensp;&ensp;1、通过对象的getClass方法\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;应用场景：必须有类的对象\n\n&ensp;&ensp;&ensp;&ensp;2、通过类的class属性\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;应用场景：一般多用于方法传参\n\n&ensp;&ensp;&ensp;&ensp;3、通过Class类的forName方法\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;应用场景：一般在运行期获取类对象(使用较多)\n\n```java\npackage com.qfeud.JDBC2.reflect;\npublic class ClassTest \n{\n    public static void main(String[] args) throws Exception \n    {\n        //通过Class类的对象获取Student类的对象\n        //1.正常创建Student类的对象操作\n        Student stu = new Student();\n        System.out.println(\"stu就是Student类的对象\");\n        //通过反射获取到Student类的class对象并创建Student类的对象\n        //1.通过Class类中静态方法，forName获取Student类的对象【Class对象】\n        //参数需要是一个类的全限定名称【包名+类名】\n        Class aClass = Class.forName(\"com.qfeud.JDBC2.reflect.Student\");\n        //此时aClass对象就代表着Student类的【Class对象】\n        //Class对象存储的就是Student类中提供描述信息，所以可以得到 Student类的对象\n        Object o = aClass.newInstance();\n        System.out.println(\"通过反射得到o对象是Student类的对象吗？\"+(o instanceof Student));\n        //2.Java中每个类都有一个静态方法，Class类是描述类的类，那么所有类都是Class的实例(即Class对象)\n        // Java中每个类都了一调用class这个静态方法获取到Class类的对象\n        Class<Student> studentClass = Student.class;    //Class对象\n        Student student = studentClass.newInstance();\n        /*\n            3.利用了Object类中提供getClass方法获取到Class对象【强烈不推荐】\n            PS：这个操作需要创建类的对象，并通过对象调用从Object类中继承而来的方法进行获取\n        */\n        Student stu1 = new Student();\n        Class aClass1 = stu1.getClass();\n        Object o1 = aClass1.newInstance();\n        /*\n            Class类中提供方法有两个比较常用\n            newInstance() 这个方法是可以通过Class对象创建出与之相关联的类的对象【调用时无参方法】\n            getName()     这个方法可以获取到类的全限定名称 ---> 包名+类名\n        */\n        System.out.println(aClass1.getName());\n        System.out.println(stu);\n        //强烈推荐第一种方式来获取Class对象，它不收到.java源文件的影响\n    }\n}\n```\n\nJava中有九大内置Class对象【他们是JVM预先加载好的Class实例】 --》 【byte、short、int、long、float、double、char、boolean、void】其中八中基本数据类型对应包装类中存在一个静态属性Type，这个Type属性就可以获取到基本数据类型所对应Class对象\n\n当执行 Integer.Type 等价于 int.class\n\n除此之外Class对象还支持数组，得到数组的Class对象只能通过 数据类型[].class 或 数据对象.getClass()\n\n# <center>知识点四：反射操作</center>\n\n反射其实可以帮组我们做很多的操作，通过分装性将属性和方法进行私有化操作，但是私有化的属性和方法之后，外界就无法获取到属性和方法，如果通过反射的形式来获取类属性和方法可以无视权限修饰符，在返回面前是没有权限修饰符可言，**可以利用反射中操作形成【代理模式】，可以通过【代理模式】动态向类中添加方法【在不改变原码的前提下添加类中方法】---》spring框架（IOC/AOP）**，反射可以作为资源文件加载操作方式\n\n## <center>1、Class对象的常用方法</center>\n\n- c.getSimpleName() 获取类名\n- c.getName() 获取类的全限定名\n- c.getSuperclass(); 获取父类的类对象\n- c.getInterfaces(); 获取父接口的类对象，返回的是一个数组\n- newInstance(); 通过类对象创建的类的对象\n\n调用newInstance方法需要注意：\n\n- 1、这个了类必须有一个无参构造方法 InstantiationException\n- 2、这个类的构造方法必须是public修饰 IllegalAccessException\n\n提供演示操作\n\n```java\n//这个是一个类的 ---> 提供Student类中一些方法属性操作\npublic class Student \n{\n    public int age;\n    private String name;\n    public Student(){}\n    public Student(int age,String name)\n    {\n        this.age = age;\n        this.name = name;\n    } \n    private Student(String name)\n    {\n        this.name = name;\n    }\n    public String getName() \n    {\n        return name;\n    } \n    public void show()\n    {\n        System.out.println(\"这是一个没有参数的方法\");\n    } \n    public void show(int a)\n    {\n        System.out.println(\"这是一个参数的方法\");\n    } \n    public void show(int a ,String b)\n    {\n        System.out.println(\"这是多个参数的方法\");\n    }\n} \npackage com.qfeud.JDBC2.reflect;\nimport jdk.nashorn.internal.ir.CallNode;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\npublic class ReflectTest \n{\n    //利用反射来处理这个类的操作\n    public static void main(String[] args) throws Exception \n    {\n        //1. 获取到Student类的class对象\n        Class aClass = Class.forName(\"com.qfeud.JDBC2.reflect.Student\");\n        //2.通过反射获取到类中所提供构造方法【Constructor】\n        /*\n        相当于通过反射操作获取到Constructor构造方法对象，在通过这个对象创建类的对象\n        这个方法可以获取到class对象中对应类的构造方法对象,参数是可变参数\n        【这个参数如果不传递（不赋值得到就是无参构造方法）、这个参数进行传递(赋值操作，根据赋值个数决定获取对应构造方法)】\n        getConstructor(Class<?>... parameterTypes)\n        */\n        //获取到的就是constructor对象【就是Student类中无参构造方法的对象】\n        Constructor constructor = aClass.getConstructor();\n        /*\n            这个方法是使用constructor构造方法对象调用newInstance方法\n            操作就相当于间接的调用对应构造方法得到这个class对象中存储类的对应对象\n            newInstance(Object ... initargs) 方法中使用也是可变参数\n            所以这个方法参数的传递时根据getConstructor这个方法的参数决定的，如果getConstructor方法没有设置参数\n            newInstance这个方法也要没有参数 --》触发的就是无参构造方法\n            如果如果getConstructor方法设置参数调用 newInstance这个方法也要给与参数，就是对构造方法参数的赋值\n            PS：之前演示Class这个操作的时候，提供newInstance方法调用，并没有获取Constructor对象\n            这样操作也是可以的，但是只能调用类中提供无参构造方法，无法选择有参构造方法\n            这个方式调用构造方法必须是公有的\n        */\n        Object o = constructor.newInstance();\n        System.out.println(\"此时o这个对象得到是Student类的对象吗?\"+(o instanceof Student));\n        //通过上面方式获取有参构造方法的操作 ---》 方法参数传递就是传递方法参数的 class对象\n        /*\n            获取有参构造方法的对象必须传递方法参数class对象到getConstructor这个方法中\n        */\n        Constructor constructor1 = aClass.getConstructor(int.class,String.class);\n        //对构造方法中参数进行赋值操作了\n        Object o1 = constructor1.newInstance(18, \"张三\");\n        //得到这个返回值类型时Object类型，所以得到操作是不能直接使用子类数据的\n        Student stu = (Student)o1;\n        System.out.println(\"stu对象中age属性的值是：\"+stu.age);\n        //反射操作---》在反射面前是没有任何权限修饰符可言 ---》 利用反射操作获取到私有构造方法对象\n        /*\n            获取到非public修饰的构造方法、属性或方法怎么办？\n            在Class这个类中提供带有 Declared 单词的方法就是 ---》 翻译为暴力反射[无视权限修饰符]\n            getDeclaredConstructor 这个方法的使用和getConstructor方法是一样的\n        */\n        Constructor constructor2 = aClass.getDeclaredConstructor(String.class);\n        //private权限是一个特殊权限，因为在权限修饰符中代表最低权限，为了防止外界恶意进行暴力反射\n        //反射获取到操作对象之后，需要再次做一个操作，开启访问权限\n        //setAccessible这个是开启权限的方法，参数是boolean类型，如果为true就开启权限，false就是不开启\n        constructor2.setAccessible(true);\n        Object o2 = constructor2.newInstance(\"李四\");\n        Student stu2 = (Student)o2;\n        System.out.println(\"stu对象中name属性的值是：\"+stu2.getName());\n        //类中通过反射访问类中属性\n        /*\n            通过两个反射方法获取 getField() --> 针对的public修饰的属性\n                               DeclaredField() ---> 针对非public(private)修饰的属性\n            通过属性对象调用setAccessible(true)开启权限配合使用 ---》 针对private使用\n            通过反射方法可以得到一个 Field对象 ---》这个对象可以操作类中属性\n        */\n        Field age = aClass.getField(\"age\");\n        //获取这个属性值如何操作？\n        /*\n            只需要使用Field类中提供 get方法即可以获取到 属性值，但是get方法是有参数\n            这个参数就是通过反射创建的对象即通过newInstance创建出来的对象\n            PS:获取的是静态变量 get方法参数就是null值\n        */\n        Object o3 = age.get(stu);\n        System.out.println(\"stu这个对象中age属性的值是：\"+o3);\n        //对类中提供属性进行赋值操作？\n        /*\n        只需要使用Field类中提供 set方法即可以对属性进行赋值\n        这个方法有两个参数\n            第一个参数:一共有两种赋值方式，原则是根据获取的数据类型决定【成员变量还是静态变量】\n            如果是成员变量 ---》 这个参数就是通过反射创建的对象即通过newInstance创建出来的对象\n            如果是静态变量 ---》 null ---》 对应的是Static修饰符\n            第二个参数对属性赋值的具体数据\n        */\n        age.set(stu,20);\n        System.out.println(\"stu对象中age属性修改之后的数据是：\"+age.get(stu));\n        //【重点记忆】 ---》 获取类中方法操作【通过反射】\n        /*\n            通过两个反射方法获取\n                getMethod() --> 针对的public修饰的方法\n                DeclaredMethod() ---> 针对非public修饰的方法\n            通过属性对象调用\n                setAccessible(true)开启权限配合使用 --> 针对private\n            通过反射获取方法的操作是需要两个参数的\n                第一个参数 : 方法的名字\n                第二个参数： 是一个可变参数，需要传递方法中参数的数据类型---》是class对象\n                不传递参数赋值就是无参方法 传递参数赋值就是有参方法\n                getMethod(String name, Class<?>...parameterTypes)\n        */\n        Method show = aClass.getMethod(\"show\");\n        //得到是一个方法对象要执行方法\n        /*\n            需要调用 invoke这个方法，这个方法也是有两个参数\n            第一个参数:\n                一共有两种赋值方式，原则是根据获取的方法类型决定【成员方法还是静态方法】\n                    如果是成员变量 ---》 这个参数就是通过反射创建的对象即通过newInstance创建出来的对象\n                    如果是静态变量 ---》 null ---》 对应的是Static修饰符\n            第二个参数:\n                需要和getMethod方法相配合 ，如果调用无参方法，这个可变参数就不传递数据\n                如果调用有参反方，这个可变参数就需要进行赋值操作\n                invoke(Object obj, Object... args)\n        */\n        show.invoke(stu);\n        //获取一个show方法对象，如果方法有参数，需要将方法参数类型Class对象传递到参数中\n        Method show1 = aClass.getMethod(\"show\", int.class,\nint.class);\n        show1.invoke(stu,1,1);    //对应数据类型赋值即可\n    }\n}\n```\n\n**总结：**\n\n可以利用反射操作在没有【.java】文件的前提之下可以操作类【构造方法、属性和方法】\n\n针对与使用public修饰构造方法、成员或静态属性和成员或静态方法 ---》提供方法是\n\n&ensp;&ensp;&ensp;&ensp;getConstructor() ----》 获取构造方法  ---》配套使用方法 ---》 newInstance()\n\n&ensp;&ensp;&ensp;&ensp;getField() ---》 获取属性的 ---》配套使用方法---》 get获取 、 set赋值【这个方法中如果是成员属性需要传递反射创建对象，如果是静态属性传递null】\n\n&ensp;&ensp;&ensp;&ensp;getMethod ---》 获取方法的 【重点记忆】---》 配套使用方法 --》 invoke() 【这个方法中如果是成员方\t法需要传递反射创建对象，如果是静态方法传递null】\n\n如果遇到非public修饰的，可以使用带有Declared单词的方法记性获取，并且如果修饰符是private修饰那么就需要配合使用setAccessible(true)开启权限\n\n## <center>2、利用反射可以直接加载properties文件</center>\n\n这个操作是在开发中比较常见的一种方式，多用于对资源文件加载\n\n在工程中创建文件夹就不能是普通文件夹，这里需要创建是一个资源文件夹【Source Folder】\n\n这个文件在工程内部的特点：自动编译文件夹中所有文件并且添加到classPath路径【也就是说将文件添加到工程内部存储字节码文件的文件夹中】，就可以利用反射进行文件的加载\n\nPS:资源文件夹在项目中是以【“蓝色标色”】，在工程中src这个文件夹就是资源文件夹\n\n```java\npackage com.qfeud.JDBC2.reflect;\nimport jdk.nashorn.internal.ir.CallNode;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Properties;\npublic class ReflectReadPropertiesFile \n{\n    public static void main(String[] args) throws IOException \n    {\n        //使用这种方式加载文件，这个文件必须在资源文件夹中\n        /*\n            利用的原理就是 使用类加载器对classPath路径中文件进行加载，会返回一个流资源对象\n            类的加载器在加载这个文件时会去classPath(在IDEA中就是out目录)下寻找这个同名文件\n            建立流资源进行读取操作\n        */\n        //提供一个Properties资源文件对象\n        Properties p = new Properties();\n        //提供一个类的加载器【每一个类都有类的加载器】\n        //利用线程对象获取类的加载器\n        ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();\n        //利用本类的class对象获取类的加载器\n        //ClassLoader classLoader = ReflectReadPropertiesFile.class.getClassLoader();\n        //使用类的加载器对象加载资源文件夹--》这个方法的参数不需要路径，只要文件名字就可以了\n        InputStream resourceAsStream = contextClassLoader.getResourceAsStream(\"db.properties\");\n        //通过字节输入流对象加载资源\n        p.load(resourceAsStream);\n        System.out.println(p);\n        InputStream resourceAsStream1 =ReflectReadPropertiesFile.class.getClassLoader()\n                                                            .getResourceAsStream(\"db.properties\");\n        //这个方法只能在JavaSE中调用在，在后续学习中EE中是不可以调用\n        InputStream systemResourceAsStream = contextClassLoader.getSystemResourceAsStream(\"db.properties\");\n    }\n}\n```\n\n## <center>3、扩展：静态方法和数组参数如何传递</center>\n\n```java\npackage com.qfeud.JDBC2.reflect;\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\nclass Employee    //这是一个员工类\n{ \n    public static void doWork(int... arr)\n    {\n        System.out.println(\"doWork1被调用了:\"+ Arrays.toString(arr));\n    } \n    public static void doWork(String... arr)\n    {\n        System.out.println(\"doWork1被调用了:\"+ Arrays.toString(arr));\n    }\n}\n\npublic class ReflectInvokeStaticMethod \n{\n    public static void main(String[] args) throws Exception \n    {\n        //这里简化获取操作\n        Class employeeClass = Employee.class;\n        Method doWork = employeeClass.getMethod(\"doWork\",int[].class);\n        //调用静态方法执行并对可变参数进行赋值操作\n        //执行方法时，如果是静态方法第一个参数传递null值,第二个参数需要传递一个数组对象进来\n        doWork.invoke(null,new Object[]{new int[]{1,2,3,4,5,6}});\n        Method doWork1 = employeeClass.getMethod(\"doWork\", String[].class);\n        /*\n            如果此时方法的参数类型是存储引用类型数组，此时通过反射方式调用，编译器对方法参数的认知不是String\n            认知为当前参数是一个Object类型的数组，这个数组中存储这个String类型数组\n            即将String类型的数组作为Object类型数组的一个元素存储\n        */\n        doWork1.invoke(null,new Object[]{new String[]{\"1\",\"2\",\"3\",\"4\",\"5\"}});\n        //提示：只要是数组作为方法的参数类型，无论是基本数据类型数据还是引用数据类型的数组\n        // 统一作为反射调用方法参数传递时，都使用 new\n        Object[]{具体数据值}；\n    }\n}\n```\n\n# <center>知识点五：Stream流</center>\n\n## <center>1、概念</center>\n\n流（Stream）与集合类似，但集合中保存的是数据，而Stream中保存对集合或数组数据的操作\n\n## <center>2、Stream特点</center>\n\nStream 自己不会存储元素\n\nStream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。\n\nStream 操作是延迟执行的，会等到需要结果的时候才执行\n\n## <center>3、Stream使用步骤</center>\n\n创建：\n\n&ensp;&ensp;&ensp;&ensp;新建一个流\n\n中间操作：\n\n&ensp;&ensp;&ensp;&ensp;在一个或多个步骤中，将初始Stream转化到另一个Stream的中间操作。\n\n终止操作：\n\n&ensp;&ensp;&ensp;&ensp;使用一个终止操作来产生一个结果。该操作会强制之前的延迟操作立即执行，在此之后，该Stream就不能使用了\n\n## <center>4、创建Stream的方法</center>\n\n1. 通过Collection对象的stream()或parallelStream()方法\n2. 通过Arrays类的stream()方法\n3. 通过Stream接口的of()、iterate()、generate()方法\n4. 通过IntStream、LongStream、DoubleStream接口中的of、range、rangeClosed方法\n\n```java\n//获取Stream对象\npublic static void m1()\n{\n    List<String> list = new ArrayList<>();\n    list.add(\"111\");\n    list.add(\"22\");\n    list.add(\"456557\");\n    list.add(\"123\");\n    list.add(\"56789\");\n    list.add(\"123321\");\n    list.add(\"111\");\n    //list.forEach(System.out::println);    //集合中有forEach遍历方法\n    //通过集合对象获取Stream对象\n    Stream<String> stream = list.stream();\n    stream.forEach(s -> System.out.println(s));\n}\n//获取Stream对象\npublic static void m2()\n{\n    int[] arr = {1,2,3,4};\n    IntStream stream = Arrays.stream(arr);    //返回一种流\n    stream.forEach(System.out::println);    //快捷方式：soutc\n} \n//获取Stream对象\npublic static void m3()\n{\n    Stream<String> stream = Stream.of(\"张三\", \"李四\", \"王五\");\n    stream.forEach(System.out::println);\n}\n```\n\n## <center>5、中间操作的方法</center>\n\n常见中间操作方法：\n\n- filter、limit、skip、distinct、sorted\n- map\n- parallel\n\n```java\n//Stream对象中常用的方法 中间操作\npublic static void m4()\n{\n    List<String> list = new ArrayList<>();\n    list.add(\"111\");\n    list.add(\"22\");\n    list.add(\"456557\");\n    list.add(\"123\");\n    list.add(\"56789\");\n    list.add(\"123321\");\n    list.add(\"111\");\n    //获取集合中长度大于3的元素\n    //list.stream().filter(li -> li.length()>3).forEach(System.out::println);\n    //获取集合的第一页数据（前三条）\n    //list.stream().limit(3).forEach(System.out::println);\n    //获取集合的第二页数据（4~6条）\n    //list.stream().skip(3).limit(3).forEach(System.out::println);\n\t//第一个三是跳过几个元素,第二个是获取几个\n    //获取集合中不重复的元素\n    //list.stream().distinct().forEach(System.out::println);\n    //将集合中的元素进行排序(注意：集合中的元素必须实现了Comparable接口)\n    //list.stream().sorted().forEach(System.out::println);\n    //将集合中的元素进行排序(按照元素的长度降序)\n    //list.stream().sorted((o1, o2) -> o2.length() - o1.length()).forEach(System.out::println);\n    //将集合中的元素转换成int类型\n    //list.stream().map(li -> Integer.parseInt(li)+1).forEach(System.out::println);\n    //list.stream().map(Integer::parseInt).forEach(System.out::println);\n    //使用多线程操作集合中的元素\n    // list.stream().forEach(li->    //单线程操作\n    //{\n    //     System.out.println(Thread.currentThread().getName()+\"=====>\"+li);\n    //});\n    list.stream().parallel().forEach(li->    //多线程操作\n    {\n        System.out.println(Thread.currentThread().getName()+\"=====>\"+li);\n    });\n}\n```\n\n## <center>6、终止操作</center>\n\n常见终止操作：\n\n- forEach、min、max、count\n- reduce、collect\n\n```java\n//Stream对象中常用的方法 终止操作\npublic static void m5()\n{\n    List<String> list = new ArrayList<>();\n    list.add(\"111\");\n    list.add(\"22\");\n    list.add(\"456557\");\n    list.add(\"123\");\n    list.add(\"562789\");\n    list.add(\"123321\");\n    list.add(\"111\");\n    //遍历集合中的元素\n    //list.forEach(System.out::println);\n    //list.stream().forEach(System.out::println);\n    //获取集合中元素长度最小的元素\n    //Optional<String> min = list.stream().min((o1, o2) -> o1.length() - o2.length());\n    //System.out.println(min.get());\n    //Optional<String> max = list.stream().max((o1, o2) -> o1.length() - o2.length());\n    //System.out.println(max.get());\n    //获取集合中长度为3的元素个数\n    //long count = list.stream().filter(li -> li.length() == 3).count();\n    //System.out.println(count);\n    //将集合中的元素转成int类型并计算总和(计算)\n    //Integer result = list.stream().map(Integer::parseInt).reduce(0, (o1, o2) -> o1 + o2);\n    //System.out.println(result);\n    //将Stream流对象转换成List、set、Map集合\n    List<String> collect = list.stream().filter(li -> li.contains(\"2\")).collect(Collectors.toList());\n    collect.forEach(System.out::println);\n}\n```\n\n","tags":["Java"],"categories":["编程语言","Java"]},{"title":"24.多线程","url":"/post/fbc0ae86.html","content":"\n# <center>知识点一：Thread线程基础</center>\n\n有一个场景：在一个程序中即可以玩游戏又可以播放音乐？\n\n以现在编程手段而言 ---》 提供编程结构【顺序、分支、循环】\n\n代码是要遵守顺序执行，代码需要遵守从上至下逐行执行，利用分支和循环修改循环执行一些操作，选择性执行某代码或者是让某些代码重复执行，无论如何操作代码依旧要顺序执行，没有办法让两段代交替执行\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012202919.png\" alt=\"线程流程\" style=\"zoom: 50%;\" />\n\n此时Java为了解决这样的问题，提供一个操作，这个操作就叫做**线程**，可以在代码中使用多线程形式来完成这个操作\n\nPS:现在电脑基本上都是多核CPU，所以每个人电脑上运行线程程序结果可能都不一样，这是一个非常正常现象，多线程运行时是一个不可预知状态，程序猿可以通过代码干预线程运行，以达到我们运行效果\n\n# <center>知识点二：并行和并发</center>\n\n这两个概念在宏观的角度而言他们是一样(相似)的，但是在微观的角度而言他们是有区别\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012203194.png\" alt=\"并行和并发\" style=\"zoom:50%;\" />\n\n**并行就是同时执行，并发就是在交替执行**\n\n&ensp;&ensp;&ensp;&ensp;在操作系统中，安装了很多程序，并发指的是在一段时间内宏观上多个程序同时执行，这个在单个CPU系统中，每一个时刻只有一个程序执行，即微观上这些程序是分时交替的执行，只不过给人感觉是在同时运行，因为分时交替运行时间非常短暂\n\n&ensp;&ensp;&ensp;&ensp;现在而言都是多核CPU，则这些并发执行程序可以分配到不同的处理器上（CPU），实现多个任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序就可以同时执行了，你的电脑CPU核心越多你电脑的性能就相对更加强悍\n\nPS:单核处理的计算机肯定是不能并行处理多个任务，只能是多个任务在单个CPU上并发需要运行，同理线程也是一样的从宏观的角度而言线程并行运行从微观角度看就是串行运行，即线程是一个一个去执行的，当系统只有一个CPU是，线程会以某种顺序执行多个线程，这个情况称之线程调度【线程提供CPU时间争抢】\n\n# <center>知识点三：线程和进程</center>\n\n**进程**\n\n&ensp;&ensp;&ensp;&ensp;进程是程序的一次执行过程，是系统运行程序的基本单元，系统运行一个程序即在运行一个进程【从创建、运行、消亡的一个过程】，每一个进程都有自己一个独立的空间【内存空间】，一个应用程序(进程)可以同时运行多个线程\n\n特点：\n\n1. 进程是一个独立程序单元并且拥有自己独立空间\n2. 一个进程中可以同时运行多个线程\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012204035.png\" alt=\"进程\" style=\"zoom:50%;\" />\n\n进程是可以完成多个任务交替执行的，可以开发一个音乐软件（QQ音乐、网易云音乐、酷狗音乐），也可以开发一个打游戏软件（L0L、吃鸡战场、Dota2），只要运行这两个进程程序就可以完成一边听音乐，一边打游戏，这样做开发成本高，进行是独立的进程与进程之间是无法进行“**通信**”的\n\n**线程**\n\n&ensp;&ensp;&ensp;&ensp;线程是进程中一个内部执行单元，负责当前进程中的程序执行，一个进程中至少有一个线程，一个进程可以有多个线程，这些线程在进程中被称之为“多线程”，进程就可以利用这些多线程，去完成不同操作\n\n特点:\n\n1. 线程是在进程的内部执行，并且可以存在多个，彼此之间共享进程的内存区域\n2. 线程与线程之间彼此独立，但是可以进行“通信”\n\n可以利用这个轻量级的开发完成一个进程内部程序交替执行效果（线程并发执行）\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012205517.png\" alt=\"线程\" style=\"zoom:50%;\" />\n\n总结进程与线程的区别：\n\n&ensp;&ensp;&ensp;&ensp;进程： 有独立的内存空间，进程中数据存放的空间是独立的并且至少有一个线程\n\n&ensp;&ensp;&ensp;&ensp;线程：堆空间是共享的，栈空间是独立的，线程消耗的资源要比进程小，并且可以多个线程存在同一个进程中\n\nPS:需要知道了解的知识点：\n\n1. 因为一个程序中有多个线程并发运行，那么从微观的角度而言是有先后顺序的，那么线程执行的顺序是取决于CPU的调度【线程争抢CPU时间片】，程序猿只能进行干涉，在不加干涉前提下线程执行就会出现很多随机性\n2. Java程序进程中最少包含两个线程，一个是主线程就是main()方法【它在执行方法是或者执行程序时它的优先级永远最高】，另外一个垃圾回收机制线程(GC)【守护线程】，每当Java执行一个类的时候，实际上都会启动一个JVM，每一个JVM实际上就是在操作系统中启动了一个线程，Java本身就被垃圾回收机制所守护，所Java运行时至少启动了两个线程\n3. 由于创建一个线程开销远比创建一个进程开销要小很多，那么我们在开发多任务运行时，通常会优先考虑创建多线程，而不是多进程\n4. 所有的线程轮流使用CPU，每一个线程都会得到CPU分配的时间片，这个分配“尽量”平均分配CPU资源，但是这个效果不一定能达到，所以同优先级的线程对CPU时间的争抢是存在随机性的，可以对线程进行优先级设置来概念获取CPU时间片的几率，优先级越高几率越大，优先级越低几率越小\n\n# <center>知识点四：Java程序中实现线程的方式</center>\n\n在Java中主要创建线程方式有四种：\n\n1. 继承Thread类，此时子类就是线程类\n2. 实现Runnable接口，此时实现类不是线程类，使用Thread类才可成为线程\n\n**无论是上述两种方式中那种方式都需必须重写run方法实现线程逻辑**\n\n3. 实现Callable接口， 此实现方方式并不是线程类，主要针对的是线程池提供\n4. 线程池可以帮组我们创建线程并进行管理操作\n\n如果实现线程需要继承Thread或实现Runnable接口，但是无论是那种都需要实现一个必要核心方法\n\n**这个run方法是提供线程实现的核心逻辑，需要线程什么样需求代码，就将将代码写入到这个线程中**\n\n| void | run() 使用实现接口 Runnable 的对象创建一个线程时，启动该线程将导致在独立执行的线程中调用对象的 run方法 |\n| :--: | :----------------------------------------------------------: |\n|      | **PS：通过观察可以发现这个run方法是没有参数和返回值类型，所以这个run不能通过方法接收参数和返回数据值** |\n\n## <center>1、线程创建方式之继承Thread类</center>\n\n步骤：\n\n```java\n1. 定义一个普通类继承与`java.lang.Thread`类\n2. 在子类中重新给父类Thread中run方法并提供线程实现逻辑\n3. 在测试类中main方法中，通过线程子类或Thread这个父类创建线程对象并执行线程启动完成调用run方法中逻辑执行\n```\n\nPS：因为Thread本身就是线程类，所以继承Thread类子类也是线程类，具备父类中Thread所提供的所有操作者线程方法\n\n需求：使用继承Thread类方法是完成边打游戏和边听音乐\n\n```java\n//为了演示效果方便观察写在同一个文件中\n//此时GameThread继承与Thread类所以GameThread就是线程类\npublic class GameThread extends Thread\n{\n    //必须重写Thread父类中的run方法，提供这个线程需要的执行逻辑\n    @Override\n    public void run() \n    {\n        for(int i =1 ; i<=50;i++)\n        {\n            System.out.println(\"打游戏：\"+i);\n        }\n    }\n} \n//此时MusicThread继承与Thread类所以GameThread就是线程类\nclass MusicThread extends Thread\n{\n    //必须重写Thread父类中的run方法，提供这个线程需要的执行逻辑\n    @Override\n    public void run() \n    {\n        for(int i =1 ; i<=50;i++)\n        {\n            System.out.println(\"听音乐：\"+i);\n        }\n    }\n} \n//提供一个测试类完成线程创建与调用\nclass Test\n{\n    //main方法本身一个线程，主线线程优先级最高\n    public static void main(String[] args) \n    {\n        //如何创建线程对象\n        //下面两种创建线程方式并没有指定线程优先级，所以都是默认优先级athread和bthread的优先级相同\n        /*\n            1. 使用多态的效果【Thread是子线程类父类，所以可以使用Thread方式创建】\n                Thread 线程对象的名字 = new 子线程类();\n        */\n        Thread athread = new GameThread();\n        /*\n            2. 直接使用继承线程子类创建对象\n                子线程类 线程对象的名字 = new 子线程类();\n        */\n        MusicThread bthread = new MusicThread();\n        //启动线程执行 ---》调用 Thread类中提供 start方法 ，而不是调用run方法\n        athread.start();\n        bthread.start();\n    }\n}\n```\n\n## <center>2、线程创建方式之实现Runnable接口</center>\n\nPS：**实现Runnable接口的类并不是线程类，只是实现Runnable接口并提供run方法的重写，需要配合使用Thread类创建线程对象，此时线程才可以操作**。因为Runnable接口中提供run方法的实现【实现Runnable接口的类】，传入到Thread类中时，就会覆盖Thread类中run方法，所以Thread提供创建线程对象就会执行重写Runnable接口中run方法，就会得到线程的效果\n\n步骤:\n\n```java\n1. 定义一个普通类实现Runnable接口\n2. 实现Runnable接口的类必须重写run方法提供线程需要执行的逻辑\n3. 在测试类中main方法中，使用Thread创建线程对象完成线程操作\n```\n\n需求：使用继承Thread类方法是完成边打游戏和边听音乐\n\n```java\npackage com.qfedu.Runnable;\n//为了演示效果方便观察写在同一个文件中\n//此类就是实现Runnable接口并提供run方法实现类\npublic class GameRunnableImpl implements Runnable \n{\n    @Override\n    public void run() \n    {\n        for(int i= 1; i<=50;i++)\n        {\n            System.out.println(\"打游戏：\"+i);\n        }\n    }\n}\nclass MusicRunnableImpl implements Runnable\n{\n    @Override\n    public void run() \n    {\n        for(int i= 1; i<=50;i++)\n        {\n            System.out.println(\"听音乐：\"+i);\n        }\n    }\n} \nclass Test2\n{\n    public static void main(String[] args) \n    {\n        //创建Runnable接口实现类作为Thread线程对象操作\n        //需要将Runnable接口的对象传递到Thread这个类中\n        /*\n            1. 先创建Runnable接口实现类的对象，然后再传递到Thread类中进行线程对象创建\n        */\n        GameRunnableImpl gri = new GameRunnableImpl();\n        Thread thread1 = new Thread(gri);\n        /*\n            2.使用匿名对象的方式进行Thread构造方法Runnable参数传递\n        */\n        Thread thread2 = new Thread(new MusicRunnableImpl());\n        //启动线程\n        thread1.start();\n        thread2.start();\n    }\n}\n```\n\n## <center>3、Thread类创建线程和Runnable接口创建线程</center>\n\n&ensp;&ensp;&ensp;&ensp;两种方式皆可，因为都要实现run方法，但是从类的扩展角度而言，建议使用实现Runnable接口方式来完成作，因为Java中类是单一继承，所以如果继承Thread类就无法在继承其他类，所以就会影响类的扩展，但是如果实现接口方式完成，不仅可以继承一个类还可以实现多个接口所以就比较推荐实现Runnable接口\n\n继承效果：\n\n&ensp;&ensp;&ensp;&ensp;class A extends Thread{} //没有办法让A在继承\n\n&ensp;&ensp;&ensp;&ensp;class B extends XXXX implements Runnable{} // 不仅可以作为线程类操作而且还可以进行继承其他类\n\n## <center>4、start方法和run方法</center>\n\nPS：**创建完毕线程对象之后，线程执行需要调用的是start方法而不是run方法**\n\nstart方法： 用start方法来启动线程，真正的实现了线程运行，通过Thread类中给提供start来启动一个线程，此时线程会进入到“**准备就绪**”状态，但是真正运行，一旦线程获取到CPU时间片，此时线程才会真正的执行，执行调用提供run方法完成线程逻辑\n\nrun方法：run方法只是一个普通方法，只是在run方法中实现线程执行逻辑，如果外界直接调用run方法，线程是没有启动，只不过是在main方法调用了run方法执行，执行出run方法提供操作，和线程一点关系都没有\n\n## <center>5、使用匿名内部类或Lambda表达式便捷的创建线程对象并执行（了解）</center>\n\n```java\npublic class AnonymousAndLambdaThread \n{\n    public static void main(String[] args) \n    {\n        //这种方式，线程是现创建现使用，只会使用一次即可\n        //1.针对Thread类提供匿名内部类创建【只支持匿名内部类】\n        new Thread()\n        {\n            @Override\n            public void run() \n            {\n                for(int i = 0 ;i<50;i++)\n                {\n                    System.out.println(\"听音乐：\"+i);\n                }\n            }\n        }.start();     // 在最外侧的大括号中调用start方法\n        //2.针对Runnable接口提供匿名内部类和Lambda表达式实现\n        new Thread(new Runnable() \n        {\n            @Override\n            public void run() \n            {\n                for(int i = 0 ;i<50;i++)\n                {\n                    System.out.println(\"打游戏：\"+i);\n                }\n            }\n        }).start(); // 在最外侧的大括号中调用start方法\n        \n        new Thread(()->\n        {\n            for(int i = 0 ;i<50;i++)\n            {\n                System.out.println(\"吃饭：\"+i);\n            }\n        }).start(); // 在最外侧的大括号中调用start方法\n    }\n}\n```\n\n# <center>知识点五：线程常用方法</center>\n\n## <center>1、线程状态getState</center>\n\n这个方法可以返回线程运行状态\n\nPS：API有一个静态属性 State【API中给返回类型时错误的，它不是静态类，他是一个枚举】\n\n```java\npublic class GetStateDemo extends Thread\n{\n    @Override\n    public void run() \n    {\n        //使用run方法进行求和操作【GetStateDemo 是 Thread子类\n        所以会得到所有方法】\n        System.out.println(\"进入run方法是当前线程状态：\" + this.getState());\n        int sum = 0 ;\n        for (int i = 0 ; i<=100 ; i++)\n        {\n            sum += i;\n        } \n        System.out.println(\"sum = \"+sum);\n    }\n    public static void main(String[] args) \n    {\n        Thread thread = new GetStateDemo();\n        //在启动线程之前\n        System.out.println(\"start方法之前线程状态：\"+thread.getState());\n        thread.start();\n        System.out.println(\"start方法之后线程状态：\"+thread.getState());\n    }\n}\n```\n\n可以表示线程状态说明\n\n```java\n/**\n* 出生、新生\n* 至今尚未启动的线程就是这种状态\n*/\nNEW,\n/**\n* 准备就绪和执行\n*PS：Java中提供Thread类并没有提供准备就绪的状态描述，所以RUNNABLE就有两个概念\n* 调用start方法时是 ---> 准备就绪\n* 执行run方法时是 ---> 执行\n*/\nRUNNABLE,\n/**\n* 阻塞或睡眠 ---》 sleep方法\n* 当线程出现【阻塞状态】，当前线程就会出现让出CPU时间片的操作等待后续执行\n*/\nBLOCKED,\n/**\n* 等待 ---》 wait\n* 等待是无限期等待只有进行唤醒之后等待效果才会消失【等待不是阻塞状态】\n*/\nWAITING,\n/**\n* 时间等待\n* 在设置等待状态时设置一个时间，只要在时间范围内都是等待状\n态，如果到了并且在等待时期并没有进行唤 \n* 醒从操作，等待线程会自动唤醒\n*/\nTIMED_WAITING,\n/**\n* 消亡，死亡\n* 线程都执行完毕不会在执行就出现这个状态【线程结束】\n*/\nTERMINATED;\n```\n\n## <center>2、线程优先级setPriority</center>\n\n理论上线程优先级越高，获取CPU时间片的几率越大，反之获取几率越小\n\nPS：但是优先级只是相当于给CPU一个暗示【先由我开始】，但是CPU是否会决定将时间片给当前线程，是CPU决定\n\n所有在没有修改优先级之前的线程默认优先级都是相同，在Java中使用1~10之间数字表示线程优先级，数值越大优先级越高，所有在没有\n\n修改优先级之前默认优先级是【5】API中提供三个静态常量方便对优先级的定义\n\n| static int | MAX_PRIORITY 线程可以具有的最高优先级【等级10】 |\n| :--------: | :---------------------------------------------: |\n| static int | MIN_PRIORITY 线程可以具有的最低优先级【等级1】  |\n| static int |  NORM_PRIORITY 分配给线程的默认优先级【等级5】  |\n\n```java\npublic class SetPriorityDemo extends Thread \n{\n    @Override\n    public void run() \n    {\n        for(int i =0 ;i<100;i++)\n        {\n            //getName()获取线程名字\n            System.out.println(getName()+\"：i的数值：\"+i);\n        }\n    } \n    public static void main(String[] args) \n    {\n        //利用线程创建两个线程对象使用默认优先级\n        Thread athread = new SetPriorityDemo();\n        Thread bthread = new SetPriorityDemo();\n        //可能会出现Thread-0先执行 或 Thread-1先执行\n        // athread.start(); // Thread-0\n        // bthread.start(); // Thread-1\n        //修改优先级\n        // 【只要优先级的差别较大就可以的得到先执行和后执行效果】\n        // 【只要优先级等级差别不是很大(比较接近)，执行效果就不是很明显了】\n        athread.setPriority(Thread.MAX_PRIORITY);\n        bthread.setPriority(6);\n        athread.start();     // Thread-0\n        bthread.start();     // Thread-1\n    }\n}\n```\n\n## <center>3、更改和获取线程的名字</center>\n\n线程是有默认名字组成方式 ---》 使用到一个关键字“Thread” + “-” +“数字”，数字的从0开始，随着线程创建而逐渐增多，随着线程的减少而逐渐减少 ---》 默认名字 【Thread-数字】\n\n在编写线程程序时可以通过**getName方法获取线程名字**，但是如果创建线程过多使用默认名字看到效果就不是很明显\n\nJava中提供线程名字修改方式有三种：\n\n1. 在创建出线程对象之后调用setName(“线程新的名字\")\n2. 使用类实现Runnable接口并使用Thread类创建线程对象，调用两个参数版本构造方法进行名字设置\n\n&ensp;&ensp;&ensp;&ensp;Thread(Runnable接口实现类的对象，\"线程名字\");\n\n3. 使用类继承与Thread类，子类中提供一个仿照父类生成构造方法，这个方法参数是String name，子类只\t需要实现这个构造方法即可，在创建线程对象时只需要调用有参构造方法就可以指定线程名字\n\n```java\npublic class SetNameDemo \n{\n    public static void main(String[] args) \n    {\n        //方式一\n        Thread athread = new AThread();\n        athread.setName(\"线程1\");\n        System.out.println(athread.getName());\n        //方式二\n        Thread bthread = new Thread(new BThread(),\"线程B\");\n        System.out.println(bthread.getName());\n        //方式三\n        Thread cthread = new CThread(\"线程C\");    //多态\n        System.out.println(cthread.getName());\n    }\n} \nclass AThread extends Thread\n{\n    @Override\n    public void run() \n    {\n        System.out.println(\"你好\");\n    }\n} \nclass BThread implements Runnable\n{\n    //实现Runnable接口不是线程类，所以不能在实现Runnable接口类中调用Thread类中方法\n    @Override\n    public void run() \n    {\n        // System.out.println(\"线程的名字：\"+getName());\n        /**\n        * 如何在实现Runnable接口的类中获取当前线程\n        * Thread类中提供一个静态方法currentThread() 可以获取当前线程对象\n        */\n        System.out.println(\"通过静态访获取到线程对象：\"+Thread.currentThread().getName());\n        System.out.println(\"你好\");\n    }\n} \nclass CThread extends Thread\n{\n    //子类只要仿照生成一个带有String类型参数方法即可\n    public CThread(String name) \n    {\n        super(name);\n    }\n}\n```\n\n## <center>4、线程休眠sleep【使用几率极高】</center>\n\nsleep这个方法是静态方法，它可以让线程进入到【阻塞状态】即让线程进行到休眠时间，**进入休眠之后线程会让出CPU时间片，给其他的线程进行争抢，当休眠时间到了之后恢复之后线程会继续和其线程进行CPU时间片的争抢**\n\nsleep方法的参数是毫秒值 ---》 1000毫秒 等于 1秒\n\n线程如果触发sleep方法会有两种方式可以醒来：\n\n1. 自然醒来【睡眠时间到了，自动醒来】\n2. 中断醒来【会通过Thread类中添加中断标记，强行让sleep醒来】\n\n所以sleep方法在调用时候会有一个编译时异常【InterruptedException(中断异常)】\n\n**特别注意：如果sleep方法被调用在【同步锁、对象锁、同步监听器、同步代码块】中，sleep方法休眠之后是不会让出当前系统时间片【虽然会睡眠时间片也会释放，但是外界线程是无法获取】**\n\n需求：通过sleep方法来实现以下交替执行效果\n\n```java\npublic class SleepDemo extends Thread \n{\n    @Override\n    public void run() \n    {\n        for(int i = 1; i<=100 ; i++)\n        {\n            if(i%5 == 0)    //只要i值可以对5整除\n            { \n                System.out.println(\"当前线程:\"+getName()+\"~~~~~~~~~\"+i);\n                //在run方法中调用sleep方法是不可以throws异常，只能try-catch抓取\n                try \n                {\n                    Thread.sleep(1000);\n                } \n                catch (InterruptedException e) \n                {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n\nclass Test3\n{\n    public static void main(String[] args) \n    {\n        //创建线程对象\n        Thread athread = new SleepDemo();\n        athread.setName(\"子线程\");\n        athread.start();\n        /*\n            Java程序会默认提供两个线程一个是GC 和 一个是main方法【主线程作为线程操作】\n        */\n        //在主线程中提供和SleepDemo类中一样的操作\n        for(int i = 1 ; i<=100 ;i++)\n        {\n            if (i%5 ==0)\n            {\n                System.out.println(\"当前线程：\"+Thread.currentThread().getName()+\"~~~~~~~~~\"+i);\n                try \n                {\n                    Thread.sleep(1000);\n                } \n                catch (InterruptedException e) \n                {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\nsleep方法确实可以让线程进入到休眠状态，并且释放出CPU时间片，但是时间无法正确把控就会造成无法使用sleep方法进行代码的交替执行\n\n## <center>5、线程礼让yield（了解）</center>\n\n礼让线程的作用就是在调用yield方法的线程中，让出CPU时间片【相当于通知CPU不急着执行】，让出之后CPU会不会回收CPU时间片取决于CPU，礼让原则是：线程优先级越高礼让效果就是会明显一些\n\nyield和sleep方法是有一定区别的，sleep是立即让出CPU时间片，在睡眠时间内是不会争抢CPU时间片，yield方法执行之后，礼让线程会进入“准备就绪”，礼让线程可能会再次持有CPU时间片\n\n```java\npublic class YieldDemo extends Thread\n{\n    @Override\n    public void run() \n    {\n        for (int i=0 ; i<=50;i++)\n        {\n            System.out.println(\"线程的名字：\"+getName()+\"~~~~~~~~\"+i);\n            if(i%2 == 0)\n            {\n                Thread.yield(); //让线程礼让\n            }\n        }\n    } \n    public static void main(String[] args) \n    {\n        //1.创建两个线程对象\n        Thread athread = new YieldDemo();\n        Thread bthread = new YieldDemo();\n        athread.setName(\"a线程\");\n        bthread.setName(\"b线程\");\n        athread.start();\n        bthread.setPriority(Thread.MAX_PRIORITY);\n        bthread.start();\n    }\n}\n```\n\n## <center>6、线程合并join</center>\n\n合并线程是一个效果非常明显操作，合并线程是一个线程正处于运行阶段，此时这个线程达到某个条件时，可以让其他线程合并到这个执行线程中，只要使用join合并，合并线程**必然**会得到CPU时间片，被合并的线程需要等待合并线程执行完毕之后才会继续运行\n\n需求：妹子在看葫芦娃【50级】，当看到【10级】汉子要看喜洋洋\n\n```java\npublic class JoinDemo \n{\n    public static void main(String[] args) \n    {\n        new Meizi().start();\n    }\n} \n\nclass Meizi extends Thread\n{\n    @Override\n    public void run() \n    {\n        for (int i = 1; i<=50;i++)\n        {\n            System.out.println(\"妹子正在看精钢葫芦娃大战蛇精：\"+i);\n            if(i == 10)\n            {\n                //启动另外一个线程进行合并操作\n                Hanzi thread = new Hanzi();\n                //合并之前必要前提：要合并线程必须进入准备就绪状态，即调用start方法\n                thread.start();\n                try \n                {\n                    thread.join();\n                } \n                catch (InterruptedException e) \n                {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n} \n\nclass Hanzi extends Thread\n{\n    @Override\n    public void run() \n    {\n        for (int i = 1; i<=10;i++)\n        {\n            System.out.println(\"汉子正在看喜羊羊与灰太狼：\"+i);\n        }\n    }\n}\n```\n\n线程合并必然是让出CPU时间片，CPU时间片会join的线程，线程必须是启动状态【调用start】\n\n## <center>7、线程中断(标记)</center>\n\n在Thread这个类中提供让线程停止方法 stop方法，但是这个方法被Java进行过时处理，所以就不建议在线程中进行使用了，所以Java就提供一个替代 stop方法的方法 ---》interrupt方法\n\n```java\npublic class InterruptThreadDemo extends Thread \n{\n    @Override\n    public void run() \n    {\n        for(int i = 1; i<=20;i++)\n        {\n            System.out.println(getName()+\"线程中执行i值是:\"+i);\n            if(i == 10)\n            {\n                //停止线程 -->过时的stop方法\n                // stop();\n                //中断线程\n                interrupt();\n            }\n        }\n    } \n    public static void main(String[] args) \n    {\n        new InterruptThreadDemo().start();\n    }\n}\n```\n\n使用这个线程中断标记方法向线程中添加【中断标记】，只有被含有中断异常方法检测到这个标记就会终止方法的执行效果【sleep明显 和join不明显】，**直接在线程调用这个方法是无用的**，只是添加标记不会停止线程，配合API中所提供的一个方法来使用【**interrupted**】，作用检查线程中是否存在中断标记，如果存在着返回true，不存在则返回false\n\n**正确使用方式**\n\n```java\npublic class InterruptThreadDemo extends Thread \n{\n    @Override\n    public void run() \n    {\n        for(int i = 1; i<=20;i++)\n        {\n            System.out.println(getName()+\"线程中执行i值是:\"+i);\n            if(i == 10)\n            {\n                //使用替代stop方法中断线程时，当遇到某个条件要终止线程时，检查中断标记\n                if(Thread.interrupted())\n                {\n                    //停止线程\n                    return;\n                }\n            }\n        }\n    } \n    public static void main(String[] args) \n    {\n        InterruptThreadDemo interruptThreadDemo = new InterruptThreadDemo();\n        interruptThreadDemo.start();\n        //向线程中添加中断标记\n        interruptThreadDemo.interrupt();\n    }\n}\n```\n\n强行终止睡眠\n\n```java\npackage com.qfedu.ThreadMethod;\npublic class InterruptThreadDemo2 extends Thread \n{\n    @Override\n    public void run() \n    {\n        System.out.println(\"进入线程\");\n        try \n        {\n            Thread.sleep(5000);\n            System.out.println(\"没有被中断正常睡眠苏醒\");\n        } \n        catch (InterruptedException e) \n        {\n            System.out.println(\"中断睡眠苏醒\");\n        } \n        System.out.println(\"线程结束\");\n    } \n    public static void main(String[] args) \n    {\n        InterruptThreadDemo2 interruptThreadDemo2 = new InterruptThreadDemo2();\n        interruptThreadDemo2.start();\n        //为了效果让主线程休眠2秒之后在触发中断标记\n        try \n        {\n            Thread.sleep(2000);\n        } \n        catch (InterruptedException e) \n        {\n            e.printStackTrace();\n        } \n        interruptThreadDemo2.interrupt();  //如果检查到中断标记就会强行终止睡眠\n    }\n}\n```\n\n# <center>知识点六：火车售票问题</center>\n\n需求：火车站买票，一共有且仅有【100】张票，4个窗口同时贩卖临界资源就是这个票，多个线程访问保证票有且仅有100张，开4个线程同时买100张票\n\n&ensp;&ensp;&ensp;&ensp;其实这个卖票案例就是多线程下同时操作一个资源(临界资源),如何保证线程操作资源安全不出现以下情况\n\n&ensp;&ensp;&ensp;&ensp;买票不会出现重票 --> 线程1 卖出第99张票 线程2 卖出99张票\n\n&ensp;&ensp;&ensp;&ensp;错误票 ---> 线程1 卖出第75张票. 线程2 卖出76张票 ---> 这个是对\n\n&ensp;&ensp;&ensp;&ensp;但是 线程2 卖出49张票\n\n&ensp;&ensp;&ensp;&ensp;负数票 ---> 某个线程买完最后一张票的时候 剩余线程就不能在卖票0 -1 -2...票\n\n&ensp;&ensp;&ensp;&ensp;1秒卖一张 ---> 有且仅有100张 --->不要卖出400张票数\n\n**问题1：如何将票固定在100张，而不是每个线程都卖出100张票**\n\n&ensp;&ensp;&ensp;&ensp;如何做到所有的线程都共享这一个资源？\n\n1. 将票作为成员变量，作为成员变量之后，需要保证这个提供票的类在外界创建对象必须是唯一的，如果不唯一的，就会出现你创建票的对象每个对象都会唯一，一个成员变量，4个对象就是4个成员变量，此时相当于400张票【单例设计模式】\n\nPS：单例设计模式的原则：保证外界无论如何获取对象都是唯一的\n\n```java\n//v1基础版本\npackage com.qfedu.Thread.SellTicket1;\n//v1版本\n/*\n    不要让类继承与Thread，继承Thread必然要提供四个线程对象\n    这样就会出现无法控制票100张\n    建议实现Runnable，以Runnable实现类方式创建线程处理\n*/\npublic class SellTicket1 implements Runnable\n{\n    //提供成成员变量存储票的信息\n    private int tickets = 100;\n    @Override\n    public void run() \n    {\n        //执行买票操作\n        //提供一个for循环，这个循环执行100次\n        for(int i = 0; i<100;i++)\n        {\n            //提供买票的逻辑\n            if(tickets > 0)    //证明还票可以出售\n            {\n                try \n                {\n                    //休眠1秒在买票\n                    Thread.sleep(1000);\n                } \n                catch (InterruptedException e) \n                {\n                    e.printStackTrace();\n                } \n                //买票\n                System.out.println(\"当前售票员[\"+Thread.currentThread().getName()+\"]第\"+\"[\"+(tickets--)+\"]票\");\n            }\n        }\n    } \n    public static void main(String[] args) \n    {\n        //如果提供的是成员变量【保证存储成员变量的这个类所得到对象是必须唯一】\n        //出现400张票问题[在构建线程对象时，提供四个Runnable接口实现类对象创建]\n        /* \n            Thread thread1 = new Thread(new SellTicket1(),\"刘德华\");\n            Thread thread2 = new Thread(new SellTicket1(),\"张学友\");\n            Thread thread3 = new Thread(new SellTicket1(),\"郭富城\");\n            Thread thread4 = new Thread(new SellTicket1(),\"吴奇隆\");\n            thread1.start();\n            thread2.start();\n            thread3.start();\n            thread4.start();\n        */\n        //在外界只创建一个Runnable接口实现类对象，保证对象是唯一的\n        SellTicket1 sellTicket1 = new SellTicket1(); //只会维护一份的票对象【100】张\n        //利用这个对象初始化创建4个线程对象\n        Thread thread1 = new Thread(sellTicket1,\"刘德华\");\n        Thread thread2 = new Thread(sellTicket1,\"张学友\");\n        Thread thread3 = new Thread(sellTicket1,\"郭富城\");\n        Thread thread4 = new Thread(sellTicket1,\"吴奇隆\");\n        thread1.start();\n        thread2.start();\n        thread3.start();\n        thread4.start();\n    }\n}\n```\n\n## <center>GetInstance</center>\n\n在主函数开始时调用，返回一个实例化对象，此对象是static的，在内存中保留着它的引用，即内存中有一块区域专门用来存放静态方法和变量，可以直接使用，调用多次返回同一个对象\n\nGetInstance与new区别\n\n&ensp;&ensp;&ensp;&ensp;如Object object = new Object()，这时候，就必须要知道有第二个Object的存在，而第二个Object也常常是在当前的应用程序域中的，可以被直接调用的\n\n```java\npackage com.qf.Demo03.test;\n//提供了成员变量\nclass SellTicket2 implements Runnable\n{\n    //提供成员变量，变量是存储票信息\n    private int tickets = 100;\n    /*\n    单设计模式的原则--》保证在外界获取对象时都是同一个对象【地址也是相同的】\n    1.私有化构造方法\n    2.提供一个私有化静态变量并对静态变量进行赋值【类型是本类类型提供对象创建】\n    3.提供一个静态共有方法可以获取本类对象的唯一途径\n     */\n    private SellTicket2()\n    {}\n    //使用本类类型创建对象\n    private static SellTicket2 sellTicket2 = new SellTicket2();\n    public static SellTicket2 getInstance()\n    {\n        return sellTicket2;\n    }\n\n    @Override\n    public void run()\n    {\n        //执行买票操作\n        //提供一个for循环，这个循环执行100次\n        for(int i = 0; i<100;i++)\n        {\n            //提供买票的逻辑\n            if(tickets > 0)    //证明还票可以出售\n            {\n                try\n                {\n                    //休眠1秒在买票\n                    Thread.sleep(1000);\n                }\n                catch (InterruptedException e)\n                {\n                    e.printStackTrace();\n                }\n                //买票\n                System.out.println(\"当前售票员[\"+Thread.currentThread().getName()+\"]第\"+\"[\"+(tickets--)+\"]票\");\n            }\n        }\n    }\n    public static void main(String[] args)\n    {\n        // 提供了静态变量，这个类的创建对象方式就无所谓\n        SellTicket2 sellTicket2 = SellTicket2.getInstance();\n        Thread thread1 = new Thread(sellTicket2,\"刘德华\");\n        Thread thread2 = new Thread(sellTicket2,\"张学友\");\n        Thread thread3 = new Thread(sellTicket2,\"郭富城\");\n        Thread thread4 = new Thread(sellTicket2,\"吴奇隆\");\n        thread1.start();\n        thread2.start();\n        thread3.start();\n        thread4.start();\n    }\n}\n```\n\n2. 定义一个变量保证所有对象共享，无论外界如何创建线程对象【实现Runnable还是继承Thread类】，这里都可以保证所有兑现共享这个变量，可以提供一个static修饰变量即静态变量\n\n```java\npackage com.qfedu.Thread.SellTicket1;\n//v1.1版本 ---> 提供了静态变量\npublic class SellTicket2 implements Runnable\n{\n    //提供静态成员变量存储票的信息\n    private static int tickets = 100;\n    @Override\n    public void run() \n    {\n        //执行买票操作\n        //提供一个for循环，这个循环执行100次\n        for(int i = 0; i<100;i++)\n        {\n            //提供买票的逻辑\n            if(tickets > 0)    //证明还票可以出售\n            {\n                try \n                {\n                    //休眠1秒在买票\n                    Thread.sleep(1000);\n                } \n                catch (InterruptedException e) \n                {\n                    e.printStackTrace();\n                } \n                //买票\n                System.out.println(\"当前售票员[\"+Thread.currentThread().getName()+\"]第\"+\"[\"+(tickets--)+\"]票\");\n            }\n        }\n    } \n    public static void main(String[] args) \n    {\n        // 提供了静态变量，这个类的创建对象方式就无所谓\n        Thread thread1 = new Thread(new SellTicket2(),\"刘德华\");\n        Thread thread2 = new Thread(new SellTicket2(),\"张学友\");\n        Thread thread3 = new Thread(new SellTicket2(),\"郭富城\");\n        Thread thread4 = new Thread(new SellTicket2(),\"吴奇隆\");\n        thread1.start();\n        thread2.start();\n        thread3.start();\n        thread4.start();\n    }\n}\n```\n\n问题2：在买票的时候会出现、重票、错票、排序顺序的混乱的问题\n\n&ensp;&ensp;&ensp;&ensp;这个问题产生就是多线程并发争抢\"临界资源\"出现里临界资源不安全问题\n\n## <center>1、如何解决多线程并发访问临界资源，保证资源安全问题</center>\n\n此时Java为了保证多线程并发访问临界资源线程安全问题，提供了一个处理机制，可以在处理临界资源代码中添加（同步锁/对象锁/同步代码块/同步监听器），这里四个名称都是指的是同一个操作，可以添加“锁机制”，保证在同一个时刻的只有一个线程操作临界资源，保证临界资源安全\n\n## <center>2、synchronized关键字</center>\n\nsynchronized翻译意思：同步\n\n使用synchronized关键字进行同步操作，使用synchronized组成同步操作叫做【同步锁/对象锁/同步代码块】\n\n语法 ：\n\n```java\nsynchronized(资源锁对象)\n{\n    提供操作临界资源的代码\n}\n```\n\n执行原理： 利用了同一时间内【只能有一个线程对象持有当前资源锁对象】，只要线程不释放这个所资源对象，外界线程是无法执行线程逻辑资源代码，在同步代码块中执行线程进行休眠是不会释放CPU时间片到外界给其他线程，因为sleep方法是不会释放锁资源\n\n需要注意还需要保证【**资源锁对象必须是唯一的**】，不唯一锁对象数无法进行同步操作\n\n如果保证资源锁对象是唯一的？\n\n个人建议：十分不推荐使用 this 作为锁资源对象，this可能锁不了，this代表的是当前对象，那么就意味着这个提供临界支援类必须是创建唯一的对象才可以，这样才可以保证this是唯一的\n\n替代方案一：\n\n&ensp;&ensp;&ensp;&ensp;在静态资源处理线程类中提供一个全局静态常量“锁资源”\n\n```java\nprivate static final Object obj = new Object();\nsynchronized(obj)\n{\n    提供操作临界资源的代码\n}\n```\n\n替代方案二【推荐】\n\n&ensp;&ensp;&ensp;&ensp;天生对象就是唯一的，Java中这个对象无论你如何操作，就可以保证他是唯一的地址都是同一个，String字符串类，直接使用字符串对象即可---->【使用 \"\" (双引号)创建】\n\n提供字符串空串处理 ---> 即 提供字符串空串对象\n\n```java\nsynchronized(\"\")\n{\n    提供操作临界资源的代码\n}\n```\n\n**使用同步代码块修改买票的案例的**\n\n```java\npackage com.qfedu.Thread.SynchronizedSellTicket1;\n//v2版本 ---> 提供了静态变量 和 同步代码块执行买票操作\npublic class SellTicket implements Runnable\n{\n    //提供静态成员变量存储票的信息\n    private static int tickets = 100;\n    @Override\n    public void run() \n    {\n        //执行买票操作\n        //提供一个for循环，这个循环执行100次\n        for(int i = 0; i<100;i++)\n        {\n            //提供买票的逻辑\n            synchronized (\"\") //同步代码块\n            {\n                if (tickets > 0) //证明还票可以出售\n                {\n                    try \n                    {\n                        //休眠1秒在买票\n                        Thread.sleep(1000);\n                    } \n                    catch (InterruptedException e) \n                    {\n                        e.printStackTrace();\n                    } \n                    //买票\n                    System.out.println(\"当前售票员[\" + Thread.currentThread().getName() + \"]第\"\n                                                    + \"[\" + (tickets--) + \"]票\");\n                }\n            }\n        }\n    } \n    public static void main(String[] args) \n    {\n        // 提供了静态变量，这个类的创建对象方式就无所谓\n        Thread thread1 = new Thread(new SellTicket(),\"刘德华\");\n        Thread thread2 = new Thread(new SellTicket(),\"张学友\");\n        Thread thread3 = new Thread(new SellTicket(),\"郭富城\");\n        Thread thread4 = new Thread(new SellTicket(),\"吴奇隆\");\n        thread1.start();\n        thread2.start();\n        thread3.start();\n        thread4.start();\n    }\n}\n```\n\n## <center>3、同步方法/对象同步方法/成员同步方法</center>\n\n使用synchronized关键字进行成员方法的修饰，这个方法就会成为**同步方法**将操作资源代码写入到这个方法中就可以进行同步操作了\n\n语法：\n\n```java\n访问权限修饰符 synchronized 返回值类型 方法名(参数列表)\n{\n    方法体；\n    return；\n}\n```\n\n**特别注意：使用是同步方法，所以这个方法使用锁资源对象是【this】，提供同步方法的这个类所创建对象必须是唯一的才可以锁住资源**\n\nPS：到目前位置 方法定义中其他修饰符就已经全部介绍完毕\n\n&ensp;&ensp;&ensp;&ensp;类中方法可以使用：【static、final、abstract、synchronized】\n\n&ensp;&ensp;&ensp;&ensp;接口中方法可以使用：【abstract、static、default】\n\n**修饰同步方法是该买票案例**\n\n```java\npackage com.qfedu.Thread.SynchronizedSellTicket1;\n//v2.1版本 ---> 提供了静态变量 和 同步方法进行买票\npublic class SellTicket2 implements Runnable\n{\n    //提供静态成员变量存储票的信息\n    private static int tickets = 100;\n    @Override\n    public void run() \n    {\n        //执行买票操作\n        //提供一个for循环，这个循环执行100次\n        for(int i = 0; i<100;i++)\n        {\n            //提供买票的逻辑 ---》调用同步方法即可\n            seller();\n        }\n    }\n    //同步方法 --> 这个锁资源对象是this\n    public synchronized void seller()\n    {\n        //提供就是线程处理临界资源操作\n        if (tickets > 0) //证明还票可以出售\n        {\n            try \n            {\n                //休眠1秒在买票\n                Thread.sleep(1000);\n            } \n            catch (InterruptedException e) \n            {\n                e.printStackTrace();\n            } \n            //买票\n            System.out.println(\"当前售票员[\" +\n            Thread.currentThread().getName() + \"]第\"\n            + \"[\" + (tickets--) + \"]票\");\n        }\n    } \n    public static void main(String[] args) \n    {\n        // 提供了静态变量，这个类的创建对象方式就无所谓\n        //同步方法提供类如果是线程类，需要保证线程类对象是唯一的\n        SellTicket2 sellTicket2 = new SellTicket2();   //这是保证线程类对象唯一\n        Thread thread1 = new Thread(sellTicket2,\"刘德华\");\n        Thread thread2 = new Thread(sellTicket2,\"张学友\");\n        Thread thread3 = new Thread(sellTicket2,\"郭富城\");\n        Thread thread4 = new Thread(sellTicket2,\"吴奇隆\");\n        thread1.start();\n        thread2.start();\n        thread3.start();\n        thread4.start();\n    }\n}\n```\n\n## <center>4、类锁/类同步代码块/类同步方法/静态同步方法</center>\n\n如果使用是同步代码块的语法，就是将资源锁对象，从当前对象替换成类对象，通过类的方式获取对象【通反射获取】，静态同步方法就是使用static和synchronized同时修饰方法\n\n**类锁/类同步代码块**\n\n```java\nsynchronized(类名.class)    // 类锁对象\n{\n    操作临界资源代码即可\n}\n```\n\n**类同步方法/静态同步方法**\n\n```java\n访问权限修饰符 static synchronized 返回值类型 方法名(参数列表)\n{\n    方法代码\n    return；\n}\n```\n\n```java\n//v2.2版本 ---> 提供了静态变量 和 静态同步操作\npublic class SellTicket3 implements Runnable\n{\n    //提供静态成员变量存储票的信息\n    private static int tickets = 100;\n    @Override\n    public void run() \n    {\n        //执行买票操作\n        //提供一个for循环，这个循环执行100次\n        for(int i = 0; i<100;i++)\n        {\n            //提供买票的逻辑 ---》调用同步方法即可\n            //seller();\n            synchronized (String.class)    // 类锁\n            { \n                if (tickets > 0) //证明还票可以出售\n                {\n                    try \n                    {\n                        //休眠1秒在买票\n                        Thread.sleep(1000);\n                    } \n                    catch (InterruptedException e) \n                    {\n                        e.printStackTrace();\n                    } \n                    //买票\n                    System.out.println(\"当前售票员[\" +\n                    Thread.currentThread().getName() + \"]第\"\n                    + \"[\" + (tickets--) + \"]票\");\n                }\n            }\n        }\n    }\n    //静态同步方法 --> 这个锁资源就是当前类的对象【是唯一的】，通过类获取即 类.class\n    public static synchronized void seller()\n    {\n        //提供就是线程处理临界资源操操作\n        if (tickets > 0) //证明还票可以出售\n        {\n            try \n            {\n                //休眠1秒再买票\n                Thread.sleep(1000);\n            } \n            catch (InterruptedException e) \n            {\n                e.printStackTrace();\n            } \n            //卖票\n            System.out.println(\"当前售票员[\" +Thread.currentThread().getName() + \"]第\" \n                                                        + \"[\" + (tickets--) + \"]票\");\n        }\n    }\n    public static void main(String[] args) \n    {\n        // 提供了静态变量，这个类的创建对象方式就无所谓\n        //同步方法提供类如果是线程类，需要保证线程类对象是唯一的\n        SellTicket3 sellTicket2 = new SellTicket3();\n        Thread thread1 = new Thread(sellTicket2,\"刘德华\");\n        Thread thread2 = new Thread(sellTicket2,\"张学友\");\n        Thread thread3 = new Thread(sellTicket2,\"郭富城\");\n        Thread thread4 = new Thread(sellTicket2,\"吴奇隆\");\n        thread1.start();\n        thread2.start();\n        thread3.start();\n        thread4.start();\n    }\n}\n```\n\nsynchronized总结：\n\n1. 在开发中常用肯定是对象锁【同步代码块】但是这个代码块的范围不要太大，不然的话会影响执行效率\n\n&ensp;&ensp;&ensp;&ensp;PS: 在什么位置对资源操作就在什么位置添加 同步代码块\n\n2. 使用synchronized关键字之后线程就会变成安全，间接就将并行线程修改为串行线程，使用锁机制将线程变\t成 【一个一个站排执行效果】\n\n# <center>知识点七：线程通信</center>\n\n到现目前位置线程与线程之间依旧是彼此独立，就算使用同步代码块，也是让线程执行有一定顺序，但是还是没有进行通信操作，如果需要遇到某个线程执行完毕之后需要通知另外一个线程继续执行，此时就需要使用到线程通信，可以在一个进程中开发多个线程，每个线程之间可以进行通信操作，从而协调性的完成某个进程中需要执行逻辑\n\n**线程通信有一个标准的通信模型【生产者与消费者模式】**\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012227153.png\" alt=\"线程通信\" style=\"zoom:50%;\" />\n\n## <center>1、完成生产者和消费者通信模型v1版本</center>\n\nBank(银行类) ---》 提供数据维护与使用\n\n```java\n//基础的第一个版本 ---》 提供临界资源并提供操作\npublic class Bank \n{\n    /*\n        临界资源一共有两种提供方式【提供成员变量和提供静态变量】\n    */\n    private double money;    //存储前的临界变量\n    /*\n        外界无论如何创建Bank类对象，都需要是唯一的，不然的话成员变量会跟着对象多少而进行创建\n        提供对象唯一创建方式【单例设计模式】\n        单例设计模式可以保证外界无论如何操作得到对象都是唯一单例设计模式的实现：\n        1. 一定要私有化构造方法 --> 防止外界调用构造方法创建对象\n        2. 提供一个私有静态常量对象，这个对象就是单例类唯一创建对象\n        3. 提供一个静态方法，获取这个创建好的对象，得到实例【外界只能通过这个方法获取对象】\n    */\n    private Bank()\n    {}\n    private static final Bank bank = new Bank();\n    public static Bank getInstance()\n    {\n        return bank;\n    }\n    /**\n    *生产者向共享资源中存储数据的方法【生产】\n    * @param m 存储钱\n    */\n    public void pushMoney(double m)\n    {\n        money = m+money;\n        System.out.println(Thread.currentThread().getName() + \"存了\"+m+\"余额是：\" + money);\n    }\n    /**\n    *消费者向共享资源中存储数据的方法【消费】\n    * @param m 消费钱\n    */\n    public void popMoney(double m)\n    {\n        money = money-m;\n        System.out.println(Thread.currentThread().getName()+\"取了\"+m+\"余额是：\"+money);\n    }\n}\n```\n\n生产者【是一个线程提供数据存储操作】\n\n```java\n//生产者\npublic class Producer implements Runnable\n{\n    //提供银行属性\n    private Bank bank;\n    public Producer(Bank bank)\n    {\n        this.bank = bank;\n    } \n    @Override\n    public void run() \n    {\n        //提供线程存储钱的操作 存储十次 每次1000元\n        for(int i = 0 ;i<10;i++)\n        {\n            bank.pushMoney(1000);\n        }\n    }\n}\n```\n\n消费者【是一个线程提供数据获取操作】\n\n```java\n//消费者\npublic class Consumer implements Runnable\n{\n    //提供银行属性\n    private Bank bank;\n    public Consumer(Bank bank)\n    {\n        this.bank = bank;\n    } \n    @Override\n    public void run() \n    {\n        //提供线程存获取的操作 获取十次 每次1000元\n        for(int i = 0 ;i<10;i++)\n        {\n            bank.popMoney(1000);\n        }\n    }\n}\n```\n\n提供一个测试类Test进行测试操作\n\n```java\npackage com.qfedu.Thread.waitAndnotfiny;\npublic class Test \n{\n    public static void main(String[] args) \n    {\n        //通过单例获取银行对象\n        Bank bank1 = Bank.getInstance();\n        //2.创建线程对象并启动操作\n        new Thread(new Producer(bank1),\"花花\").start();\n        new Thread(new Consumer(bank1),\"菲菲\").start();\n    }\n}\n```\n\n问题1：现在执行速度太快了，看不到交替执行效果，让线程休眠1秒操作\n\n问题2：虽然让线程休眠之后，出现了一个执行错乱的问题，因为多线程并发访问临界资源money，出现线程挣抢的问题，所以出现临界资源部不安全问题，添加同步代码块\n\nBank银行类需要修改为\n\n```java\npackage com.qfedu.Thread.waitAndnotfiny;\n//基础的第一个版本 ---》 提供临界资源并提供操作\npublic class Bank \n{\n    /*\n        临界资源一共有两种提供方式【提供成员变量和提供静态变量】\n    */\n    private double money;//存储前的临界变量\n    /*\n        外界无论如何创建Bank类对象，都需要是唯一的，不然的话成员变量会跟着对象多少而进行创建\n        提供对象唯一创建方式【单例设计模式】\n        单例设计模式可以保证外界无论如何操作得到对象都是唯一\n        单例设计模式的实现：\n        1. 一定要私有化构造方法 --> 防止外界调用构造方法创建对象\n        2. 提供一个私有静态常量对象，这个对象就是单例类唯一创建对象\n        3. 提供一个静态方法，获取这个创建好的对象，得到实例【外界只能通过这个方法获取对象】\n    */\n    private Bank()\n    {}\n    private static final Bank bank = new Bank();\n    public static Bank getInstance()\n    {\n        return bank;\n    }\n    /**\n    *生产者向共享资源中存储数据的方法【生产】\n    * @param m 存储钱\n    */\n    public void pushMoney(double m)\n    {\n        synchronized (\"\") \n        {\n            try \n            {\n                Thread.sleep(1000);\n                money = m + money;\n                System.out.println(Thread.currentThread().getName() + \"存了\" + m + \"余额是：\" + money);\n            } \n            catch (InterruptedException e) \n            {\n                e.printStackTrace();\n            }\n        }\n    }\n    /**\n    *消费者向共享资源中存储数据的方法【消费】\n    * @param m 消费钱\n    */\n    public void popMoney(double m)\n    {\n        synchronized (\"\") \n        {\n            try \n            {\n                Thread.sleep(1000);\n                money = money - m;\n                System.out.println(Thread.currentThread().getName() + \"取了\" + m + \"余额是：\" + money);\n            } \n            catch (InterruptedException e) \n            {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n## <center>2、完成生产者和消费者通信模型v2版本</center>\n\n使用了同步代码块+sleep方法，虽然让程序执行有序了也保证线程中操作临界资源过程也安全了，但是还是无法保证线程可以做到交替执行的效果【**即生产者生产完数据之后通知消费者可以进行消费，消费者消费完数据之后通知生产者可以生产**】，所以如何完成这个通信操作呢？\n\n此时就需要使用Java中Object类中提供三个方法了\n\n| 线程通信方法 |                           方法说明                           |\n| :----------: | :----------------------------------------------------------: |\n|    wait()    | 执行该方法的线程对象会释放【同步锁资源】，JVM会把当前线程放到等待池中，等待其他线程唤醒操作 |\n|   notify()   | 执行该方法的线程对象会在等待池【随机唤醒】一个等待的线程，把线程转移到锁池中等待，再次获取资源 |\n| notifyAll()  | 执行该方法的线程对象会在等地池中【唤醒所有的线程】，把线程转移到锁池中等待，再次获取资源 |\n\n&ensp;&ensp;&ensp;&ensp;就可以利用这三个方法进行线程通信操作了，**特别注意调用通信方法必须是锁资源对象，否则会出现异常提示信息【在哪里调用等待方法就在位置被唤醒】**\n\n线程通信执行流程：\n\n&ensp;&ensp;&ensp;&ensp;假设**A线程**和**B线程**共同操作一个**X锁对象**，A、B线程可以通过X锁对象调用wait和notify方法进行如下线程通信操作\n\n```java\n当A线程执行到X锁对象时，A线程持有X锁对象，B线程是没有执行机会的，B线程在X对象的等待锁池中\nA线程在同步代码块种执行到X.wait方法时，A线程会释放X对象所资源，A线程会进入到X对象的等待锁池中\nB线程就会在等待锁池中得到A线程释放的X资源锁对象，B线程就开始执行操作\nB线程在同步代码块中执行到X.notify方法时，JVM把A线程从X对象等待池中，移动到等待X对象锁资源中得到锁资源\nB线程执行完毕之后释放锁资源，A线程就有机会获取到锁，继续执行同步方法\n```\n\n修改Bank类提供线程通信操作者\n\n```java\npackage com.qfedu.Thread.waitAndnotfiny.V2;\n//通信的版本 ---》 提供临界资源并提供操作[添加线程通信和同步代码块+sleep方法]\npublic class Bank \n{\n    /*\n        临界资源一共有两种提供方式【提供成员变量和提供静态变量】\n    */\n    private double money;    //存储前的临界变量\n    /*\n        外界无论如何创建Bank类对象，都需要是唯一的，不然的话成员变量会跟着对象多少而进行创建\n        提供对象唯一创建方式【单例设计模式】\n        单例设计模式可以保证外界无论如何操作得到对象都是唯一\n        单例设计模式的实现：\n            1. 一定要私有化构造方法 --> 防止外界调用构造方法创建对象\n            2. 提供一个私有静态常量对象，这个对象就是单例类唯一创建对象\n            3. 提供一个静态方法，获取这个创建好的对象，得到实例【外界只能通过这个方法获取对象】\n    */\n    private Bank()\n    {}\n    private static final Bank bank = new Bank();\n    public static Bank getInstance()\n    {\n        return bank;\n    }\n    /*\n        在外界创建生产者与消费者线程对象中都是可以获取到CPU资源\n        但是问题在于，如果消费者先获取到资源，但是没有数据不能消费\n        所以就提供一个变量来存储状态的，通过对这个状态的判断决定执行哪个线程\n    */\n    private static boolean isEmpty = false;\n    /**\n    *生产者向共享资源中存储数据的方法【生产】\n    * @param m 存储钱\n    */\n    public void pushMoney(double m)\n    {\n        synchronized (\"\") \n        {\n            try \n            {\n                //添加线程通信操作\n                if(isEmpty)\n                {\n                    //如果条件为true值，就证明现在有数据，无需生产\n                    //生产这个就进入到等待状态\n                    \"\".wait();\n                } \n                //因为if没有执行就证明，没有数据可以生产\n                Thread.sleep(1000);\n                money = m + money;\n                System.out.println(Thread.currentThread().getName() + \"存了\" + m + \"余额是：\" + money);\n                //生产数据完毕之后需要修改状态信息\n                isEmpty = true;\n                //执行唤醒操作\n                \"\".notify();\n            } \n            catch (InterruptedException e) \n            {\n                e.printStackTrace();\n            }\n        }\n    }\n    /**\n    *消费者向共享资源中存储数据的方法【消费】\n    * @param m 消费钱\n    */\n    public void popMoney(double m)\n    {\n        synchronized (\"\") \n        {\n            try \n            {\n                // 增加线程通信操作\n                //isEmpty状态值 false代表没有数据 true代表有属性\n                if(!isEmpty)    //没有数据的时候不能执行消费，等待生产\n                { \n                    /*\n                        没有数据isEmpty值是false，取非操作 !false --》 true if就执行等待\n                        有数据isEmpty值是true ，取非操作 !true --》false if就不执行等待，进行消费\n                    */\n                    \"\".wait();\n                } \n                //if分支语句不执行就证明有数据，进行消费操作\n                Thread.sleep(1000);\n                money = money - m;\n                System.out.println(Thread.currentThread().getName() + \"取了\" + m + \"余额是：\" + money);\n                //修改状态数据\n                isEmpty = false;\n                //进行唤醒操作\n                \"\".notify();\n            } \n            catch (InterruptedException e) \n            {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n## <center>3、分析执行流程</center>\n\n1. 现有的两个线程生产者【花花】和消费者【菲菲】默认初始isEmpty状态都是false\n2. 消费者【菲菲】先获取到CPU时间片，持有所资源，判断if分支条件为!false,消费者【菲菲】就会释放锁资源并且进入到等待池中\n\n```java\n//等待池\n/*\n    生产者【花花】\n*/\n```\n\n3. 等待池中生产者【花花】就会或得到执行CPU时间片，并且获取到锁资源，判断if分支条件false，证明没有数据，生产数据并且唤醒等待池中【菲菲】修改isEmpty值true，生产者线程就执行完毕了\n\n```java\n//等待池\n/*\n    消费者【菲菲】\n*/\n```\n\n4. 此时生产者【花花】和消费者【菲菲】就会再次同时争抢CPU时间片和锁资源对象，假如生产者【花花】再次获取哦到CPU时间片和锁资源对象，执行线程逻辑，判断if分支条件为true，此时花花就会释放资源进入到等待池中\n\n```java\n//等待池\n/*\n    生产者【花花】\n*/\n```\n\n5. 消费者【菲菲】必然获取到CPU时间片，执行操作逻辑判断条件!true 得到是false，就执行消费，并且修改状态为false，唤醒等待池中生产者，这样就完成交替执行效果\n\n**PS：以上这些操作就是典型的一对一生产者与消费者模型**\n\n# <center>知识点八：多对多通信模型</center>\n\n提供线程对象创建操作， 这里从原有一对一的模式，变成多对多的模式，原来的一个生产者对应一个消费者，修改为了多个生产者对应多个消费者\n\n```java\npublic class Test \n{\n    public static void main(String[] args) \n    {\n        //通过单例获取银行对象\n        Bank bank1 = Bank.getInstance();\n        //2.创建线程对象并启动操作\n        new Thread(new Producer(bank1),\"花花1\").start();\n        new Thread(new Consumer(bank1),\"菲菲2\").start();\n        new Thread(new Producer(bank1),\"花花3\").start();\n        new Thread(new Consumer(bank1),\"菲菲4\").start();\n    }\n}\n```\n\n当将线程对象增多之后，执行多线程同时操作就出现两个问题“**负数问题和死等待问题**”\n\n## <center>1、负数问题</center>\n\n现有线程【花花1（存)、菲菲2（取）、花花3（存）、菲菲4（取）】，模拟一个执行流程\n\n1. 菲菲2先抢到线程，不能取，所以进入到等待队列中，释放CPU时间片和释放锁资源\n2. 菲菲4抢到线程资源，不能取，所以进入到等待列中，释放CPU时间片和释放锁资源\n\n```java\n//等待队列 菲菲2、菲菲4\n```\n\n3. 花花1抢到线程，存储了数据，修改标记为true值，并唤醒等待队列中的线程的线程对象，现在使用唤醒机制notify方法【随机唤醒一个等待队列汇总线程对象】，假设唤醒了菲菲4\n\n```java\n//等待队列中 菲菲2\n//外部争抢CPU操作的时间片 花花1、花花3、菲菲4\n//临界资源中存储数据是 ---》 1000\n```\n\n4. 菲菲4抢到了线程，在哪里等待就在哪里被唤醒，而且if分支语句特点，只会执行一次判断即if分支条件判断完成之后【不添加循环前提】，只会执行一次判断，菲菲4正好是在if分支语句中进行等待操作，醒来之后机会继续向后执行【它是不会在判断if分支语句】，菲菲4进行正常消费，修改标记为false，需要执行notify，唤醒等待队列菲菲2【菲菲2这个线程是通过wait进入到等待状态，它已经执行了if判断】\n\n```java\n//等待队列中 空\n// 外部增强CPU操作者时间片 花花1、菲菲2【从等待状态恢复而来】、花花3、菲菲4\n// 临界资源中存储的数据是 ----》 0 【因为菲菲4消费了】\n```\n\n5. 菲菲2抢到了执行权，会在if分支语句继续执行操作，此时虽然标记已经修改为false，正常而言不应该消费的，但是if分支语句已经被执行过，所以不会进行判断继续执行，进行消费，修改标记，执行唤醒\n\n但是现在的数据是 0 在执行消费出现数据就是 -1000\n\n**为了保证线程通信可以正常执行，建议在开发的时候，不要书写if作为状态判断操作，建议使用while循环语句替代if分支，while循环语句只有条件为false，才不执行，否者就继续执行，这样就可以让等待位置线程在次被唤醒之后可以再次判断状态操作，以防出现错误数据**\n\n```java\npackage com.qfedu.Thread.waitAndnotfiny.V3;\n//通信的版本【多对多】 ---》 提供临界资源并提供操作[添加线程通信和同步代码块+sleep方法]\npublic class Bank \n{\n    /*\n    临界资源一共有两种提供方式【提供成员变量和提供静态变量】\n    */\n    private double money;//存储前的临界变量\n    /*\n        外界无论如何创建Bank类对象，都需要是唯一的，不然的话成员变量会跟着对象多少而进行创建\n        提供对象唯一创建方式【单例设计模式】\n        单例设计模式可以保证外界无论如何操作得到对象都是唯一\n        单例设计模式的实现：\n        1. 一定要私有化构造方法 --> 防止外界调用构造方法创建对象\n        2. 提供一个私有静态常量对象，这个对象就是单例类唯一创建对象\n        3. 提供一个静态方法，获取这个创建好的对象，得到实例【外界只能通过这个方法获取对象】\n    */\n    private Bank()\n    {}\n    private static final Bank bank = new Bank();\n    public static Bank getInstance()\n    {\n        return bank;\n    }\n    /*\n        在外界创建生产者与消费者线程对象中都是可以获取到CPU资源\n        但是问题在于，如果消费者先获取到资源，但是没有数据不能消费\n        所以就提供一个变量来存储状态的，通过对这个状态的判断决定执行哪个线程\n    */\n    private static boolean isEmpty = false;\n    /**\n    *生产者向共享资源中存储数据的方法【生产】\n    * @param m 存储钱\n    */\n    public void pushMoney(double m)\n    {\n        synchronized (\"\") \n        {\n            try \n            {\n                //添加线程通信操作\n                //只需要将if修改为while即可\n                while(isEmpty)\n                {\n                    //如果条件为true值，就证明现在有数据，无需生产\n                    //生产这个就进入到等待状态\n                    \"\".wait();\n                } \n                //因为if没有执行就证明，没有数据可以生产\n                Thread.sleep(1000);\n                money = m + money;\n                System.out.println(Thread.currentThread().getName() + \"存了\" + m + \"余额是：\" + money);\n                //生产数据完毕之后需要修改状态信息\n                isEmpty = true;\n                //执行唤醒操作\n                \"\".notify();\n            } \n            catch (InterruptedException e) \n            {\n                e.printStackTrace();\n            }\n        }\n    }\n    /**\n    *消费者向共享资源中存储数据的方法【消费】\n    * @param m 消费钱\n    */\n    public void popMoney(double m)\n    {\n        synchronized (\"\") \n        {\n            try \n            {\n                // 增加线程通信操作\n                //isEmpty状态值 false代表没有数据 true代表有属性\n                //只需要将if修改为while即可\n                while(!isEmpty)    //没有数据的时候不能执行消费，等待生产\n                { \n\n                    /*\n                        没有数据isEmpty值是false，取非操作 !false --》 true if就执行等待\n                        有数据isEmpty值是true ，取非操作 !true --》false if就不执行等待，进行消费\n                    */\n                    \"\".wait();\n                }\n                //if分支语句不执行就证明有数据，进行消费操作\n                Thread.sleep(1000);\n                money = money - m;\n                System.out.println(Thread.currentThread().getName() + \"取了\" + m + \"余额是：\" + money);\n                //修改状态数据\n                isEmpty = false;\n                //进行唤醒操作\n                \"\".notify();\n            } \n            catch (InterruptedException e) \n            {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n## <center>2、死等待问题</center>\n\n所有线程都进入到等待池中无人唤醒\n\n**PS：这个效果是需要特殊情况下才会出现【它属于一个极端情况】**\n\n**这个原因的产生就是使用notfiy随机唤醒机制**\n\n现有线程【花花1（存)、菲菲2（取）、花花3（存）、菲菲4（取）】模拟一个执行流程\n\n1. 菲菲2先抢到线程，不能取，所以进入到等待池中，释放锁和CPU时间片\n2. 菲菲4抢到线程，不能取，所以进入到等待池中，释放锁和CPU时间片\n\n```java\n//等待队列中 菲菲2、菲菲4\n```\n\n3. 花花1抢到线程，存储数据，修改标记为true并进行唤醒操作【随机唤醒】\n\n```java\n//等待队列中 菲菲2\n//争抢CPU资源 花花1、花花3、菲菲4\n```\n\n4. 花花1在次获取线程，不能存储，所以要进入到等待队列中，释放锁和CPU时间片\n\n```java\n//等待队列中 菲菲2、花花1 //争抢CPU资源 花花3、菲菲4\n```\n\n5. 花花3抢到线程，不能存储，所以要进入到等待队列中，释放锁和CPU时间片\n\n```java\n//等待队列中 菲菲2、花花1、花花3 //争抢CPU资源 菲菲4\n```\n\n6. 菲菲4抢到线程，取钱消费，修改标记为false，并进入唤醒操作【随机唤醒】 --》 菲菲2唤醒\n\n```java\n//等待队列汇总 花花1、花花3 //争抢CPU资源 菲菲4、菲菲2 ，现在状态时false\n```\n\n7. 生产者都在等待队列中，外部都是消费这个，现在状态时false\n\n```java\n//等待队列中 花花1、花花3、菲菲4、菲菲2\n```\n\n所有线程都进入到等待队列中，无人唤醒就出现死的等待问题\n\n&ensp;&ensp;&ensp;&ensp;之所以会出现死等待原因就因为使用了notify的操作，它是随机唤醒，等待池中两个消费，外界两个生产【生产完毕，状态修改，无法唤醒】，或等待池中两个生产，外界两个消费【消费完毕，状态修改，无法唤醒】，**建议使用notifyAll 替换 notfiy**，进行全部唤醒，然后再进行条件判断执行操作，决定好是否存储与消费\n\n```java\n//通信的版本 ---》 提供临界资源并提供操作[添加线程通信和同步代码块+sleep方法]\npublic class Bank \n{\n    /*\n        临界资源一共有两种提供方式【提供成员变量和提供静态变量】\n    */\n    private double money;//存储前的临界变量\n    /*\n        外界无论如何创建Bank类对象，都需要是唯一的，不然的话成员变量会跟着对象多少而进行创建\n        提供对象唯一创建方式【单例设计模式】\n        单例设计模式可以保证外界无论如何操作得到对象都是唯一\n        单例设计模式的实现：\n        1. 一定要私有化构造方法 --> 防止外界调用构造方法创建对象\n        2. 提供一个私有静态常量对象，这个对象就是单例类唯一创建对象\n        3. 提供一个静态方法，获取这个创建好的对象，得到实例【外界只能通过这个方法获取对象】\n    */\n    private Bank()\n    {}\n    private static final Bank bank = new Bank();\n    public static Bank getInstance()\n    {\n        return bank;\n    }\n    /*\n        在外界创建生产者与消费者线程对象中都是可以获取到CPU资源\n        但是问题在于，如果消费者先获取到资源，但是没有数据不能消费\n        所以就提供一个变量来存储状态的，通过对这个状态的判断决定执行哪个线程\n    */\n    private static boolean isEmpty = false;\n    /**\n    *生产者向共享资源中存储数据的方法【生产】\n    * @param m 存储钱\n    */\n    public void pushMoney(double m)\n    {\n        synchronized (\"\") \n        {\n            try \n            {\n                //添加线程通信操作\n                while(isEmpty)\n                {\n                    //如果条件为true值，就证明现在有数据，无需生产\n                    //生产这个就进入到等待状态\n                    \"\".wait();\n                } \n                //因为if没有执行就证明，没有数据可以生产\n                Thread.sleep(1000);\n                money = m + money;\n                System.out.println(Thread.currentThread().getName() + \"存了\" + m + \"余额是：\" + money);\n                //生产数据完毕之后需要修改状态信息\n                isEmpty = true;\n                //执行唤醒操作进行全部唤醒操作\n                \"\".notifyAll();\n            } \n            catch (InterruptedException e) \n            {\n                e.printStackTrace();\n            }\n        }\n    }\n    /**\n    *消费者向共享资源中存储数据的方法【消费】\n    * @param m 消费钱\n    */\n    public void popMoney(double m)\n    {\n        synchronized (\"\") \n        {\n            try \n            {\n                // 增加线程通信操作\n                //isEmpty状态值 false代表没有数据 true代表有属性\n                while(!isEmpty)    //没有数据的时候不能执行消费，等待生产\n                { \n                    /*\n                    没有数据isEmpty值是false，取非操作 !false --》 true if就执行等待\n                    有数据isEmpty值是true ，取非操作 !true --》false if就不执行等待，进行消费\n                    */\n                    \"\".wait();\n                } \n                //if分支语句不执行就证明有数据，进行消费操作\n                Thread.sleep(1000);\n                money = money - m;\n                System.out.println(Thread.currentThread().getName() + \"取了\" + m + \"余额是：\" + money);\n                //修改状态数据\n                isEmpty = false;\n                //进行唤醒操作修改为全部唤醒\n                \"\".notifyAll();\n            } \n            catch (InterruptedException e) \n            {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n**总结：如果在日后的开发中出现线程通信操作，建议判断状态标签的位置使用while关键字而不是if，进行唤醒操作建议使用notfiyAll而不是notify**\n\n## <center>3、扩展：Lock接口【显示锁】</center>\n\nLock接口是Java5中新加入与Synchronized比较操作，它属于显示定义，结构更加灵活，提供了一个更加便捷的操作，相对比synchronized更加简洁易用\n\nPS：这个锁资源Lock虽然语法更加简洁易用，但是它不能定义锁对象，Lock使用锁对象是【this】，**使用Lock时就需要保证this的唯一性了**\n\n**Lock锁如何操作？**\n\n&ensp;&ensp;&ensp;&ensp;Lock是一个接口所以需要使用到他实现类进行锁的操作\n\n**ReentrantLock**提供两常用操作\n\n| Lock锁方法 |        说明        |\n| :--------: | :----------------: |\n|   lock()   |  添加锁(对象上锁)  |\n|  unlock()  | 释放锁(对象所释放) |\n\n&ensp;&ensp;&ensp;&ensp;以为Lock是一个显示锁对象，所有不能调用Object类中提供wait、notify、notifyAll方法进行线程通信，所以系统就提供了**一个和Lock锁一起使用线程通信接口Condititon**\n\n|  通信方法   |                  说明                  |\n| :---------: | :------------------------------------: |\n|   await()   |     线程等待释放锁资源和CPU时间片      |\n|  signal()   | 唤醒等待池中某一个线程对象【随机唤醒】 |\n| signalAll() |        唤醒等待池中所有线程对象        |\n\n使用Lock锁替代Synchronized同步代码块进行数据操作\n\n```java\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n//通信的版本【多对多】 ---》 提供临界资源并提供操作[添加线程Lock锁+sleep方法+线程通信]\npublic class BankLock \n{\n    /*\n        临界资源一共有两种提供方式【提供成员变量和提供静态变量】\n    */\n    private double money;//存储前的临界变量\n    /*\n        外界无论如何创建Bank类对象，都需要是唯一的，不然的话成员变量会跟着对象多少而进行创建\n        提供对象唯一创建方式【单例设计模式】\n        单例设计模式可以保证外界无论如何操作得到对象都是唯一\n        单例设计模式的实现：\n        1. 一定要私有化构造方法 --> 防止外界调用构造方法创建对象\n        2. 提供一个私有静态常量对象，这个对象就是单例类唯一创建对象\n        3. 提供一个静态方法，获取这个创建好的对象，得到实例【外界只能通过这个方法获取对象】\n    */\n    private BankLock()\n    {}\n    private static final BankLock bank = new BankLock();\n    public static BankLock getInstance()\n    {\n        return bank;\n    } \n    //提供锁资源对象\n    private final Lock lock = new ReentrantLock();\n    //提供线程通信资源对象【它是接口不能new，使用lock对象调用newCondition创建】\n    private Condition condition = lock.newCondition();\n    /*\n        在外界创建生产者与消费者线程对象中都是可以获取到CPU资源\n        但是问题在于，如果消费者先获取到资源，但是没有数据不能消费\n        所以就提供一个变量来存储状态的，通过对这个状态的判断决定执行哪个线程\n    */\n    private static boolean isEmpty = false;\n    /**\n    *生产者向共享资源中存储数据的方法【生产】\n    * @param m 存储钱\n    */\n    public void pushMoney(double m)\n    {\n        //synchronized (\"\") //替换成lock锁资源对象\n        //{\n            lock.lock();\n            try \n            {\n                //添加线程通信操作\n                //只需要将if修改为while即可\n                while(isEmpty)\n                {\n                    //如果条件为true值，就证明现在有数据，无需生产\n                    //生产这个就进入到等待状态\n                    // \"\".wait();\n                    condition.await();    //使用通信资源创建对象\n                } \n                //因为if没有执行就证明，没有数据可以生产\n                Thread.sleep(1000);\n                money = m + money;\n                System.out.println(Thread.currentThread().getName() + \"存了\" + m + \"余额是：\" + money);\n                //生产数据完毕之后需要修改状态信息\n                isEmpty = true;\n                //执行唤醒操作\n                //\"\".notifyAll();\n                condition.signalAll();    //使用通信资源创建对象\n            } \n            catch (InterruptedException e) \n            {\n                e.printStackTrace();\n            }\n            finally \n            {\n                lock.unlock(); //锁资源释放\n            }\n        //}\n    }\n    /**\n    *消费者向共享资源中存储数据的方法【消费】\n    * @param m 消费钱\n    */\n    public void popMoney(double m)\n    {\n        //synchronized (\"\") \n        //{\n                lock.lock();\n                try \n                {\n                    // 增加线程通信操作\n                    //isEmpty状态值 false代表没有数据 true代表有属性\n                    //只需要将if修改为while即可\n                    while(!isEmpty)    //没有数据的时候不能执行消费，等待生产\n                    { \n                    \n                        /*\n                            没有数据isEmpty值是false，取非操作 !false --》 true if就执行等待\n                            有数据isEmpty值是true ，取非操作 !true --》false if就不执行等待，进行消费\n                        */\n                        //\"\".wait();\n                        condition.await();\n                    } \n                    //if分支语句不执行就证明有数据，进行消费操作\n                    Thread.sleep(1000);\n                    money = money - m;\n                    System.out.println(Thread.currentThread().getName() + \"取了\" + m + \"余额是：\" + money);\n                    //修改状态数据\n                    isEmpty = false;\n                    //进行唤醒操作\n                    // \"\".notifyAll();\n                    condition.signalAll();\n                } \n                catch (InterruptedException e) \n                {\n                    e.printStackTrace();\n                }\n                finally \n                {\n                    lock.unlock();\n                }\n        // }\n    }\n}\n```\n\n# <center>知识点九：线程声明周期</center>\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012240972.png\" alt=\"声明周期\" style=\"zoom:50%;\" />\n\n线程声明周期分为两条线:\n\n1. 基础线程声明周期： 新建 ---》 准备就绪 ---》 运行状态 ---》 死亡状态\n2. 对线程添加了一些操作造成线程阻塞现象的产生【sleep、join、wait、synchronized等等】\n\n新建 ---》 准备就绪 ---》 运行状态 ---》【 阻塞状态 ---》 准备就绪 ---》 运行状态】 ---》 死亡状态\n\nPS：在阻塞状态没有消失之前\n\n准备就绪 ---》 运行状态 ---》阻塞状态 ---》 准备就绪 ---》 运行状态 ..... 【会一直重复执行】\n\n1、新建状态(new):使用new创建一个线程对象,仅仅在堆中分配内存空间,在调用start方法之前.\n\n&ensp;&ensp;&ensp;&ensp;新建状态下,线程压根就没有启动,仅仅只是存在一个线程对象而已.\n\n&ensp;&ensp;&ensp;&ensp;Thread t = new Thread();//此时t就属于新建状态\n\n&ensp;&ensp;&ensp;&ensp;当新建状态下的线程对象调用了start方法,此时从新建状态进入可运行状态\n\n&ensp;&ensp;&ensp;&ensp;线程对象的start方法只能调用一次,否则报错:IllegalThreadStateException\n\n2、可运行状态(runnable):分成两种状态，ready和running。分别表示就绪状态和运行状态\n\n&ensp;&ensp;&ensp;&ensp;就绪状态:线程对象调用start方法之后,等待JVM的调度(此时该线程并没有运行).\n\n&ensp;&ensp;&ensp;&ensp;运行状态:线程对象获得JVM调度,如果存在多个CPU,那么允许多个线程并行运行\n\n3、阻塞状态(blocked):正在运行的线程因为某些原因放弃CPU,暂时停止运行,就会进入阻塞状态.\n\n&ensp;&ensp;&ensp;&ensp;此时JVM不会给线程分配CPU,直到线程重新进入就绪状态,才有机会转到运行状态.\n\n&ensp;&ensp;&ensp;&ensp;阻塞状态只能先进入就绪状态,不能直接进入运行状态\n\n&ensp;&ensp;&ensp;&ensp;阻塞状态的两种情况:\n\n&ensp;&ensp;&ensp;&ensp;（1）当A线程处于运行过程时,试图获取同步锁时,却被B线程获取.此时JVM把当前A线程存到对象的锁池中,A线程进入阻塞状态.\n\n&ensp;&ensp;&ensp;&ensp;（2）当线程处于运行过程时,发出了IO请求时,此时进入阻塞状态\n\n4、等待状态(waiting)(等待状态只能被其他线程唤醒):此时使用的无参数的wait方法,\n\n&ensp;&ensp;&ensp;&ensp;（1）当线程处于运行过程时,调用了wait()方法,此时JVM把当前线程存在对象等待池中\n\n5、计时等待状态(timed waiting)(使用了带参数的wait方法或者sleep方法)\n\n&ensp;&ensp;&ensp;&ensp;(1)当线程处于运行过程时,调用了wait(long time)方法,此时JVM把当前线程存在对象等待池中.\n\n&ensp;&ensp;&ensp;&ensp;(2)当前线程执行了sleep(long time)方法.\n\n6、终止状态(terminated):通常称为死亡状态，表示线程终止.\n\n&ensp;&ensp;&ensp;&ensp;(1)正常执行完run方法而退出(正常死亡).\n\n&ensp;&ensp;&ensp;&ensp;(2)遇到异常而退出(出现异常之后,程序就会中断)(意外死亡)\n\n线程一旦终止,就不能再重启启动,否则报错(IllegalThreadStateException).\n\n在Thread类中过时的方法(因为存在线程安全问题,所以弃用了【真心好用，绝对不能用】)\n\n&ensp;&ensp;&ensp;&ensp;void suspend() :暂停当前线程\n\n&ensp;&ensp;&ensp;&ensp;void resume() :恢复当前线程\n\n&ensp;&ensp;&ensp;&ensp;void stop() :结束当前线程\n\n# <center>知识点十：拓展</center>\n\n## <center>1、线程池【重点】</center>\n\n### （1）线程池概念\n\n如果有非常的多的任务需要多线程来完成，且每个线程执行时间不会太长，这样频繁的创建和销毁线程。\n\n频繁创建和销毁线程会比较耗性能。有了线程池就不要创建更多的线程来完成任务，因为线程可以重用\n\n线程池用维护者一个队列，队列中保存着处于等待（空闲）状态的线程。不用每次都创建新的线程\n\n### （2）线程池实现原理\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012242641.png\" alt=\"实现原理\" style=\"zoom:50%;\" />\n\n### （3）线程池中常见的类\n\n常用的线程池接口和类(所在包java.util.concurrent)\n\nExecutor：线程池的顶级接口。\n\nExecutorService：线程池接口，可过submit(Runnable task) 提交任务代码\n\nExecutors工厂类：通过此类可以获得一个线程池\n\n|              方法名              |                        描述                        |\n| :------------------------------: | :------------------------------------------------: |\n| newFixedThreadPool(int nThreads) | 获取固定数量的线程池。参数：指定线程池中线程的数量 |\n|      newCachedThreadPool()       |   获得动态数量的线程池，如不够则创建新的，无上限   |\n\n**创建方法一：**\n\n```java\npackage com.qf.demo.thread1;\n\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\n/**\n * 作者：星仔\n * 描述：永无Bug\n */\npublic class ThreadPoolDemo1\n{\n    public static void main(String[] args)\n    {\n        //1.创建一个线程池对象   创建了一个固定数量3个的线程池\n        ExecutorService es = Executors.newFixedThreadPool(3);   //返回ExecutorService对象\n        //2.通过线程池对象调用sumit方法来提交线程任务\n        es.submit(new MyRunnable1());   //传入实现runnable接口的类\n        es.submit(new MyRunnable2());\n        es.submit(new MyRunnable3());\n        es.submit(new MyRunnable4());\n        //3.结束线程池\n        es.shutdown();\n    }\n}\n\nclass MyRunnable1 implements Runnable\n{\n    @Override\n    public void run()\n    {\n        for (int i = 0; i < 10; i++)\n        {\n            try\n            {\n                Thread.sleep(10);\n            }\n            catch (InterruptedException e)\n            {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName() + \"--->\" + i);\n        }\n    }\n}\nclass MyRunnable2 implements Runnable\n{\n    @Override\n    public void run()\n    {\n        for (int i = 10; i < 20; i++)\n        {\n            try\n            {\n                Thread.sleep(10);\n            }\n            catch (InterruptedException e)\n            {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName() + \"--->\" + i);\n        }\n    }\n}\nclass MyRunnable3 implements Runnable\n{\n    @Override\n    public void run()\n    {\n        for (int i = 20; i < 30; i++)\n        {\n            try\n            {\n                Thread.sleep(10);\n            }\n            catch (InterruptedException e)\n            {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName() + \"--->\" + i);\n        }\n    }\n}\nclass MyRunnable4 implements Runnable\n{\n    @Override\n    public void run()\n    {\n        for (int i = 30; i < 40; i++)\n        {\n            try\n            {\n                Thread.sleep(10);\n            }\n            catch (InterruptedException e)\n            {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName() + \"--->\" + i);\n        }\n    }\n}\n```\n\n创建方式二：\n\n```java\npackage com.qf.demo.thread1;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\n/**\n * 作者：星仔\n * 描述：永无Bug\n */\npublic class ThreadPoolDemo02\n{\n    public static void main(String[] args)\n    {\n        //1.创建一个线程池对象   创建一个带缓存的连接池对象\n        ExecutorService es = Executors.newCachedThreadPool();\n        //2.通过线程池对象，提交线程任务，并启动线程执行任务\n        es.submit(new Runnable()\n        {\n            @Override\n            public void run()\n            {\n                for (int i = 0; i < 10; i++)\n                {\n                    try\n                    {\n                        Thread.sleep(10);\n                    }\n                    catch (InterruptedException e)\n                    {\n                        e.printStackTrace();\n                    }\n                    System.out.println(Thread.currentThread().getName() + \"-->\" + i);\n                }\n            }\n        });\n        es.submit(new Runnable()\n        {\n            @Override\n            public void run()\n            {\n                for (int i = 0; i < 10; i++)\n                {\n                    try\n                    {\n                        Thread.sleep(10);\n                    }\n                    catch (InterruptedException e)\n                    {\n                        e.printStackTrace();\n                    }\n                    System.out.println(Thread.currentThread().getName() + \"-->\" + i);\n                }\n            }\n        });\n        es.submit(new Runnable()\n        {\n            @Override\n            public void run()\n            {\n                for (int i = 0; i < 10; i++)\n                {\n                    try\n                    {\n                        Thread.sleep(10);\n                    }\n                    catch (InterruptedException e)\n                    {\n                        e.printStackTrace();\n                    }\n                    System.out.println(Thread.currentThread().getName() + \"-->\" + i);\n                }\n            }\n        });\n        //3.关闭连接池\n        es.shutdown();\n    }\n}\n```\n\n### （4）Callable接口\n\nJDK5加入，与Runnable接口类似，实现之后代表一个线程任务。\n\nCallable具有泛型返回值、可以声明异常\n\n```java\npublic interface Callable< V >\n{\n    public V call() throws Exception;\n}\n```\n\n如果不使用返回值和Runnable的作用一样\n\n```java\npackage com.qf.demo.thread1;\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\n/**\n * 作者：星仔\n * 描述：永无Bug\n */\npublic class CallableDemo\n{\n    public static void main(String[] args)\n    {\n        //1.创建一个线程对象\n        ExecutorService es = Executors.newCachedThreadPool();\n        //2.通过线程池对象提交线程任务，并启动线程执行任务\n        es.submit(new MyCallable());\n\n        //3.关闭线程对象\n        es.shutdown();\n\n    }\n}\n\nclass MyCallable implements Callable   //Callable接口的泛型表示call方法返回值的类型\n{\n\n    @Override\n    public Object call() throws Exception\n    {\n        for (int i = 0; i < 10; i++)\n        {\n            System.out.println(Thread.currentThread().getName() + \"--->\" + i);\n        }\n        return  null;\n    }\n}\n```\n\n使用返回值\n\n```java\npackage com.qf.demo.thread1;\nimport java.util.concurrent.*;\n\n/**\n * 作者：星仔\n * 描述：永无Bug\n */\npublic class CallableDemo02\n{\n    public static void main(String[] args) throws ExecutionException, InterruptedException\n    {\n        //1.创建一个线程对象\n        ExecutorService es = Executors.newCachedThreadPool();\n        //2.通过线程池对象提交线程任务，并启动线程执行任务\n        Future<String> future = es.submit(new MyCallable2());   //保存线程的返回结果\n        System.out.println(future.get());\n\n        //3.关闭线程对象\n        es.shutdown();\n    }\n}\n\nclass MyCallable2 implements Callable<String>\n{\n\n    @Override\n    public String call() throws Exception\n    {\n        return \"这是call方法返回值\";\n    }\n}\n```\n\n案例\n\n```java\npackage com.qf.demo.thread1;\n\nimport java.util.concurrent.*;\n\n/**\n * 作者：星仔\n * 描述：永无Bug\n */\npublic class CallableDemo03\n{\n    public static void main(String[] args) throws ExecutionException, InterruptedException\n    {\n        //需求：线程A 计算1~50 线程B 51~100  最终得到结果\n        ExecutorService es = Executors.newCachedThreadPool();\n        Future<Integer> f1 = es.submit(new Callable<Integer>()\n        {\n            @Override\n            public Integer call() throws Exception\n            {\n                int sum = 0;\n                for (int i = 1; i < 51; i++)\n                {\n                    sum += i;\n                }\n                return sum;\n            }\n        });\n        Future<Integer> f2 = es.submit(new Callable<Integer>()\n        {\n            @Override\n            public Integer call() throws Exception\n            {\n                int sum = 0;\n                for (int i = 51; i < 101; i++)\n                {\n                    sum += i;\n                }\n                return sum;\n            }\n        });\n        System.out.println(\"结果为:\" + (f1.get() + f2.get()));\n        es.shutdown();\n    }\n}\n```\n\n### （5）Future接口\n\nFuture接口表示将要执行完任务的结果。\n\nget()以阻塞形式等待Future中的异步处理结果（call()的返回值）\n\n```java\npublic class TestCallable2 \n{\n    /**\n    * Runnable接口和Callable接口的区别？\n    * 1、这两个接口都可以当做线程任务提交并执行\n    * 2、Callable接口执行完线程任务之后有返回值，而Runnable接口没有返回值\n    * 3、Callable接口中的call方法已经抛出了异常，而Runnable接口不能抛出编译异常\n    * Future接口：\n    * 用于接口Callable线程任务的返回值。\n    * get()方法当线程任务执行完成之后才能获取返回值，这个方法是一个阻塞式的方法\n    *随堂案例：\n    * 使用两个线程，并发计算1-100的和， 一个线程计算1~50,另一个线程计算51~100， 最终汇总结果\n    */\n    public static void main(String[] args) throws InterruptedException,\nExecutionException \n    {\n        //1、创建线程池对象\n        ExecutorService es = Executors.newFixedThreadPool(2);\n        //2、通过线程池提交线程并执行任务\n        Future<String> future = es.submit(new MyCallable1());\n        //获取线程任务的返回值\n        System.out.println(future.get());\n        System.out.println(\"哈哈哈哈哈哈\");\n        //3、关闭线程池\n        es.shutdown();\n    }\n} \nclass MyCallable1 implements Callable<String>\n{\n    @Override\n    public String call() throws Exception \n    {\n        for (int i = 0; i < 10; i++) \n        {\n            Thread.sleep(1000);\n            System.out.println(Thread.currentThread().getName()+\"--->\"+i);\n        } \n        return \"这是Callable线程任务的返回值\";\n    }\n}\n```\n\n### （6）读写锁\n\nReentrantReadWriteLock：\n\n&ensp;&ensp;&ensp;&ensp;一种支持一写多读的同步锁，读写分离，可分别分配读锁、写锁。\n\n&ensp;&ensp;&ensp;&ensp;支持多次分配读锁，使多个读操作可以并发执行。\n\n互斥规则：\n\n&ensp;&ensp;&ensp;&ensp;写-写：互斥，阻塞\n\n&ensp;&ensp;&ensp;&ensp;读-写：互斥，读阻塞写、写阻塞读。\n\n&ensp;&ensp;&ensp;&ensp;读-读：不互斥、不阻塞。\n\n&ensp;&ensp;&ensp;&ensp;在读操作远远高于写操作的环境中，可在保障线程安全的情况下，提高运行效率\n\n```java\npackage com.qf.demo.thread2;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\n/**\n * 作者：星仔\n * 描述：永无Bug\n */\npublic class ReadWriterLockDemo\n{\n    public static void main(String[] args)\n    {\n        //记录开始时间\n        long start = System.currentTimeMillis();\n        //1.创建线程池对象\n        ExecutorService es = Executors.newFixedThreadPool(10);\n        //2.提交8个读操作任务，提交2个写操作任务\n        User user = new User();\n        ReadThread readThread = new ReadThread(user);\n        for (int i = 0; i < 8; i++)\n        {\n            es.submit(readThread);\n        }\n       WriteThread writeThread = new WriteThread(user);\n        for (int i = 0; i < 2; i++)\n        {\n            es.submit(writeThread);\n        }\n        //3.结束线程池\n        es.shutdown();\n        //es.isTerminated();    获取当前线程池的状态，如果线程池钟的任务执行结束，那么返回true，否则返回false\n        //System.out.println(es.isTerminated());\n        //我们希望以下的代码在线程任务执行结束之后再执行.利用代码空转来判断\n        while (!es.isTerminated())\n        {}\n        //记录结束时间\n        long end = System.currentTimeMillis();\n        System.out.println(\"耗时\" + (end-start) + \"毫秒\");\n    }\n}\n\n//写线程\nclass  WriteThread implements Runnable\n{\n    User user;\n    public WriteThread(User user)\n    {\n        this.user = user;\n    }\n    @Override\n    public void run()\n    {\n        user.setName(\"jack\");\n    }\n}\n//读线程\nclass ReadThread implements Runnable\n{\n    User user;\n    public ReadThread(User user)\n    {\n        this.user = user;\n    }\n    @Override\n    public void run()\n    {\n        user.getName();\n    }\n}\n\nclass User\n{\n    private String name;\n    //读写锁\n    ReentrantReadWriteLock rrwl = new ReentrantReadWriteLock();\n    //读锁\n    ReentrantReadWriteLock.ReadLock readLock = rrwl.readLock();\n    //写锁\n    ReentrantReadWriteLock.WriteLock writeLock = rrwl.writeLock();\n\n    //写操作\n    public void setName(String name)\n    {\n        writeLock.lock();\n        try\n        {\n            Thread.sleep(1000);\n            this.name = name;\n        }\n        catch (InterruptedException e)\n        {\n            e.printStackTrace();\n        }\n        finally\n        {\n            writeLock.unlock();\n        }\n    }\n\n    //读操作\n    public String getName()\n    {\n        readLock.lock();\n        try\n        {\n            Thread.sleep(1000);\n            return name;\n        }\n        catch (InterruptedException e)\n        {\n            e.printStackTrace();\n        }\n        finally\n        {\n            readLock.unlock();\n        }\n        return null;\n    }\n}\n//读和写都需要花一秒，而读和读是不影响的，读和写的互斥的，写和写是互斥的\n//class User\n//{\n//    private String name;\n//    Lock lock = new ReentrantLock();\n//\n//    //写操作\n//    public void setName(String name)\n//    {\n//        lock.lock();\n//        try\n//        {\n//            Thread.sleep(1000);\n//            this.name = name;\n//        }\n//        catch (InterruptedException e)\n//        {\n//            e.printStackTrace();\n//        }\n//        finally\n//        {\n//            lock.unlock();\n//        }\n//\n//    }\n//\n//    //读操作\n//    public String getName()\n//    {\n//        lock.lock();\n//        try\n//        {\n//            Thread.sleep(1000);\n//            return name;\n//        }\n//        catch (InterruptedException e)\n//        {\n//            e.printStackTrace();\n//        }\n//        finally\n//        {\n//            lock.unlock();\n//        }\n//        return null;\n//    }\n//}\n```\n\n### （7）重入锁\n\n重入锁:在同步锁中可以继续加入同步锁(锁对象是同一个)\n\n&ensp;&ensp;&ensp;&ensp;synchronized和Lock锁都可以实现锁的重入\n\n```java\npublic class TestReentrantLock \n{\n    /**\n    * 重入锁:在同步锁中可以继续加入同步锁(锁对象是同一个)\n    * synchronized和Lock锁都可以实现锁的重入\n    */\n    public static void main(String[] args) \n    {\n        //启动线程\n        new Thread(new MyRunnable()).start();\n    }\n} \nclass MyRunnable implements Runnable\n{\n    @Override\n    public void run() \n    {\n        a();\n    } \n    //当前锁对象为this\n    public synchronized void a() \n    {\n        System.out.println(\"a\");\n        b();\n    } \n    //当前锁对象为this\n    public synchronized void b() \n    {\n        System.out.println(\"b\");\n        c();\n    } \n    public synchronized void c() \n    {\n        System.out.println(\"c\");\n    }\n}\n```\n\n### （8）公平锁\n\n公平锁和非公平锁\n\n&ensp;&ensp;&ensp;&ensp;非公平锁：优先使用上一个线程接着执行下面的线程任务\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;synchronized是非公平锁的实现，无法实现公平锁\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;lock锁默认是非公平锁，如果想要实现公平锁，那么需要在构造方法设置为true\n\n&ensp;&ensp;&ensp;&ensp;公平锁：让每个线程都公平去执行线程任务\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;lock锁可以实现公平锁\n\n```java\n//Lock锁实现公平锁 参数为true表示是公平锁，默认是false表示非公平锁\nLock lock = new ReentrantLock(true);\n```\n\n","tags":["Java"],"categories":["编程语言","Java"]},{"title":"23.IO流","url":"/post/3e1167ea.html","content":"\n# <center>知识点一：概念</center>\n\n**PS：IO很简单主要记忆的就是IO中进行文件读写操作**\n\nJava中IO流的作用：IO流在Java中作用就是将内存中数据写入到磁盘进行保存，程序运行时将磁盘中的数据读取到内存中进行处理\n\n在Java中在没有学习到IO流之前，在程序中所有处理数据都是在内存中进行存储的【栈和堆】，在内存中存储的好处在于【执行效率高】坏处【数据无法持久存储】\n\n内存中存储体现在于【DVD操作系统】：所有数据使用集合存储之后依旧是在内存中进行存储，每次执行程序时，都会在内存从新初始化集合中数据，这样就造成无论你如何修改集合中数据，只要程序重新运行数据使用保持原始状态\n\n所以需要将内存中数据保存到磁盘中进行持久保存【将内存中数据写成文件中内容进行保存操作】，如果将内存中数据写到磁盘中，就需要使用到IO流【使用输出流】，数据存存储在磁盘文件之后，程序运行时需要加载磁盘中文件数据【将磁盘文件中内容读取到内存中进行处理】，如果需要将磁盘中文件内读取到内存中，就需要使用到IO流【使用输入流】\n\n什么是IO流？\n\nI ---》 顾名思义 ---》IN(读取、输入、读入) --》将磁盘中文件内容读取到内存中\n\nO---》 顾名思义 --》OUT(输出、写出、写入) ---》将内存中数据写入到磁盘文件中\n\n**IO流就是内存与磁盘【存储设备】之间数据传输通道**\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011942738.png\" alt=\"传输过程\" style=\"zoom:33%;\" />\n\n在程序中所有的数据都是以流的方式进行传输与保存，程序需要数据时使用输入流读取数据，当程序需要保存数据时使用输出流保存数据\n\n除了对数据保存之外，实际在网页中的文件上传与下载操作就是IO流完成\n\n**PS：IO操作属于“长连接”，需要管理这个连接操作，如果不管理这个连接操作，会造成IO流操作会持续在内存中存在，会造成内存浪费，所以在不使用IO操作下，一定要关闭IO流**\n\n# <center>知识点二：Java中提供常用IO流</center>\n\nIO流其实就是建立起内存与硬盘【存设备】之间数据传输通道，通过这个通道可以将数据进行读取与写入操作，这个就是IO流本质\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011943586.png\" alt=\"输入输出关系\" style=\"zoom:50%;\" />\n\n可以根据IO流进行简单的分类\n\n根据流的流向：\n\n&ensp;&ensp;&ensp;&ensp;输入流： 把存储在磁盘中数据读取到内存中\n\n&ensp;&ensp;&ensp;&ensp;输出流 : 把内存中数据写入到磁盘中\n\n根据流中数据：\n\n&ensp;&ensp;&ensp;&ensp;字节流： 无论是输入还是输出流中数据都是byte类型\n\n&ensp;&ensp;&ensp;&ensp;字符流： 无论是输入还是输出流中数据都是char类型\n\n# <center>知识点三：字节输入输出流</center>\n\n这个流中数据类型就是byte，这个流既可以进行输入操作【读取】，也可以进行输出操作【写出】\n\n## <center>1、InputStream【字节输入流】</center>\n\nInputStream流是所有字节输入流的父类，所有字节输入流都要直接或间接继承InputStream\n\n这个流是一个抽象类不能直接创建对象，所以需要使用到这个流的子类来完成对字节输入流操作\n\n在API文档中提供创建语句\n\n```java\npublic abstract class InputStream extends Object implements Closeable\n```\n\n在API文档中已知实现之类\n\n```java\nAudioInputStream, ByteArrayInputStream,\"FileInputStream\", FilterInputStream, InputStream,\nObjectInputStream, PipedInputStream,SequenceInputStream, StringBufferInputStream\n```\n\n这里多子类中，使用那个之类来操作呢？学习流目的在于什么？--》将内存数据写出到磁盘中【持久保存】，程序需要使用时将磁盘中文件存储内容读取到内存中，整个操作过程中都需要使用磁盘文件，所以就需要操作一个处理文件的流来进行操作 --》需要使用其之类FileInputStream\n\n## <center>2、FileInputSteam【文件字节输入流】</center>\n\nFileInputStream是InputStream字节入的子类，这个流主要提供是对文件读取操作，这个文件是泛指【指代的是：所有文档二进制文件（文本文件、音频、视频、压缩包、图片等等）】，都可以通过\n\nFileInputStream进行读取操作，FileInputSteam是字节输入流所以流中数据是【**byte类型**】\n\n在API文档中提供创建定义\n\n```java\npublic class FileInputStream extends InputStream\n```\n\nPS：Java中提供原生流【系统API中定义好流】只能对文本文件中内容进行操作即【txt】文件，无法对Office文件记性操作，如果需要对这些文件进行操作需要导入【第三方jar包（别人封装好实现）】\n\n### （1）核心构造方法\n\n|                           构造方法                           |\n| :----------------------------------------------------------: |\n| FileInputStream(File file) 通过一个File对象创建FileInputStream字节输入流对象 |\n| FileInputStream(String name) 通过一个String对象(文件的路径)创建FileInputStream字节输入流对象 |\n\nPS：这两个构造方法创建出对象方式是一样的，只是参数不一样，个人选取\n\n### （2）核心API方法\n\n| 返回值类型 |                           方法说明                           |\n| :--------: | :----------------------------------------------------------: |\n|    int     |                read() 一次读取一个字节的数据                 |\n|    int     | read(byte[] bs) 一次读取参数字节数组长度的数据并存储在字节数组中[常用] |\n|    int     | read(byte[] bs, int off, int len) 一次读取字节数组长度的数据,根据len读取实际内容长度,并从off位置开始入写到字节数组中 |\n|    void    |   close() IO流式一个长连接,所以需要需要关闭流对象【常用】    |\n\n```java\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Objects;\npublic class FileInputStreamAPIDemo \n{\n    public static void main(String[] args) \n    {\n        //文件字节输入流操作\n        //1.提供文件字节输入流对象创建\n        /*\n            这个构造方法中一共提供两种参数\n            第一种传入File -->FileInputStream fis = new FileInputStream(new File(\"绝对或相对文件路径\"));\n            第二种传入String类型参数 --》 String类型赋值时一个路径\n            \tFileInputStream fis = new FileInputStream(\"绝对或相对文件路径\");\n            在创建文件字节输入流对象同时需要处理创建对象时提供 编译时异常\n                         \tUnhandled exception:java.io.FileNotFoundException\n            今天---》使用try-catch进行处理 ---》 特殊用途\n            明天---》 throws处理 --》 开发通用\n            后续流开发如果出现异常行，自行选择处理方式\n        */\n        FileInputStream fis = null; //先声明流资源对象赋值为null值\n        try \n        {\n            //IO流的链接是长链接，所以在不使用IO流前提下要进行关闭操作\n            //在try代码块进行流对象具体赋值操作\n            fis = new FileInputStream(new File(\"dir/file1.txt\"));\n            //读取文件中数据的read方法都有编译时异常Unhandled exception: java.io.IOException\n            //1. 一次读取一个字节的内容--》几乎与不使用\n            int read = fis.read();    //返回文件内容中对应的ASCII，所以要看到读取内容效果需要强制类型转换\n            System.out.println(\"一次读取一个字节的内容是:\"+ ((char)read));\n            \n            //2. 一次读取参数中字节数组长度内容，并且将内容存存储到字节数组中 --》【常用】\n            //2.1 需要提供一个字节数组\n            byte[] bs = new byte[5];\n            //2.2通过字节输入流对象调用read方法参数是字节数组\n            /*\n                千万不要理解为:通过fis流对象读取字节数组bs中内容【错误理解】\n                真正含义:通过fis流对象读取文件中内容，读取文件中内容是参数bs数组长度，并且将读取到内容存储到bs数组中\n            */\n            fis.read(bs);\n            //因为byte类型数组，存储都是整数，所以存储都是文件内容中字符对应十进制形式\n            System.out.println(Arrays.toString(bs)); //相当于查看字节数内容，但是不是具体文件中内容\n            //利用String这个类构造方法将字节数组转换成字符串查看内容\n            System.out.println(\"读取文件中内容是：\" + new String(bs));\n            \n            //3.一次读取参数中字节数组长度内容并且存储在字节数组中，根据off参数指定下标为开始写入数据，\n            // 再根据len参数为基础进行实际读取内容长度作为写入数组中内容长度\n            //3.1提供一个byte类型数组\n            byte[] bs2 = new byte[8];\n            //3.2在通过文件字节输入流对象调用read方法进行读取\n            fis.read(bs2,1,5);\n            System.out.println(Arrays.toString(bs2));\n            System.out.println(\"读取文件中内容是:\" + new String(bs2));\n        } \n        catch (Exception e) \n        {\n            e.printStackTrace();\n        }\n        finally\n        {\n            //无论try代码块是否出现异常，finally语句代码块都会执行，多用于资源释放 ---》 管理流就是资源释放\n            //因为是在try外界创建对象赋值为null，如果赋值成功会存在堆中地址，这样才有关闭价值\n            if(Objects.nonNull(fis))    //判断数据是否为null\n            {\n                \n                try \n                {\n                    //释放流资源--》关闭流 -->close方法也有一个编译时异常Unhandled exception: java.io.IOException\n                    fis.close();\n                } \n                catch (IOException e) \n                {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n问题：如果使用FileInputStream文件字节输入流读取一个文件，这个文件大小未知（文件存储内容不确定），使用刚刚讲解API中 read(byte[]bs) 进行文件内容读取，此时提供byte数组应该多大？，如何获取到文件中所有内容？\n\n```java\nimport java.io.*;\nimport java.util.Objects;\npublic class FileInputStreamLoopReadFile \n{\n    public static void main(String[] args) \n    {\n        //1.提供文件字节输入流对象【因为InputStream是\n        FileInputStream父类，所以可以利用多态创建】\n        InputStream is = null;\n        try \n        {\n            is = new FileInputStream(new File(\"dir/FileInputStreamAPIDemo.java\"));\n            //提供字节数组 ---》 1024 -->给读取文件数组中大小即 1024\n            //在开发中如果使用流进行操作，提供byte类型数组或char类型数组使用初始化大小默认给1024\n            //如果1024并不能满足你读取文件内容需求，建议倍数递增\n            byte[] bs = new byte[1024];\n            //因为给定初始容量1024，但是不能完全读取文件中所有内容\n            //is.read(bs);\n            /*\n                只需要让读取文件中内容操作重复执行就行--》提供循环让is.read可以去重复去读文件内容\n                提供死循环确实可以让读取操作重复执行，但是需要提供读取文件停止方式，不然话程序执行是不合理\n                只需要知道是否读取到文件的末尾，就可以停止循环操作了，如何得到读取到文件末尾的操作？\n                read 方法在读取文件数据时，如果读取到文件的末尾返回-1作为提示\n            */\n            \n            /* \n                //提供一个变量len 存储read读取到长度\n                int len = 0;\n                while(true)\n                {\n                    len = is.read(bs);\n                    if(len == -1)\n                    {\n                        break;\n                    } \n                    System.out.println(new String(bs));\n                }\n            */\n            /*\n                通过文件字节读取到数据之后进行打印，发现输出内容末尾的位置多出了一些内容，但是在源文件中是不存在\n                当调用read方法读取文件中内容时，是按照bs数组的长度进行读取，然后写入到bs数组中，这是一次读取\n                下一次循环读取时，也会按照bs数组的长度进行读取，然后是覆盖写入到bs数组中，即不会清除原有数组中存的内容\n                而是直接覆盖进新读取到文件内容到数组\n                例如：现在读取文件大小是 4063字节 存储数据数组的大小1024字节\n                第一次读取时 4063-1024 --》剩余字节 3039 但是读取到 1024字节内容\n                第二次读取时 3039-1024 --》剩余字节 2015 但是读取到 1024字节内容\n                第二次读取时 2015-1024 --》剩余字节 991 但是读取到 1024字节内容\n                第四次读取时 读取字节是991 并没有填充满1024 --》 实际读取991个字节\n                991个字节覆盖到byte数组中之后 会剩余33个字节没有进行覆盖内容\n                所以通过new String方式打印数组内容时，就会将33个没有覆盖内容数据打印出来\n                read(byte[] bs)这个方法的返回值不仅可以返回读取到文件末尾-1值\n                                而且这个方法还可以返回读取到实际文件内容长度的实际值\n            */\n            //提供流循环读取文件内容的while循环书写方式\n            //需要提供一个存储实际读取文件内容长度变量【包括文件末尾值】\n            int len = 0;\n            while((len = is.read(bs))!=-1)\n            {\n                //循环内部对数组中存储内容进行操作\n                /*\n                    第一个参数是存储数据数组\n                    第二个参数是从数组中什么位置开始获取数据【默认值是0(使用是下标值)】\n                    第三个参数 实际读取文件内容长度，因为可以避免输出书中没有被覆盖掉内容\n                */\n                System.out.println(new String(bs,0,len));\n            }\n        } \n        catch (Exception e) \n        {\n           e.printStackTrace();\n        }\n        finally \n        {\n            if(Objects.nonNull(is))\n            {\n                try \n                {\n                    is.close();\n                } \n                catch (IOException e) \n                {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n## <center>3、OutputStream字节输出流</center>\n\nOutputStream字节输出流是所有字节输出的父类，所有字节输入出流都是直接或间接继承OutputStream类\n\n根据API文档中提供类创建方式\n\n```java\npublic abstract class OutputStream extends Object implements Closeable, Flushable\n```\n\nOutputStream是抽象类无法直接创建对象使用，所以需要提供子类来完成对流操作\n\n根据API文档中提供子类有\n\n```java\nByteArrayOutputStream, *FileOutputStream*,\nFilterOutputStream, ObjectOutputStream, OutputStream, PipedOutputStream\n```\n\n根据现在操作数据原则，将数据从磁盘文件读取到内容，将内存中数据写出到磁盘文件中，始终要处理是File文件，所以使用**子类是FileOutputStream文件字节输出流**\n\n## <center>4、FileOutputStream文件字节输出流</center>\n\nFileOutputStream文件字节输出流类是OutputStream的子类，这个类主要用用于将内存中存储数据写入到磁盘文件中进行保存操作，这里的文件是泛指【**指代是二进制文件（文本文件、音频、视频、图片、压缩包等等）**】都可以使用FileOutputStream这个流对象将数据写入到磁盘中\n\n根据API文档中说明\n\n```java\npublic class FileOutputStream extends OutputStream\n```\n\n**核心构造方法**\n\n|                           构造方法                           |\n| :----------------------------------------------------------: |\n| FileOutputStream(File file) 通过一个File对象(封装的文件路径)创建文件字节输出流对象 |\n| FileOutputStream(File file, boolean append)通过一个File对象(封装的文件路径)创建文件字节输出流对象,并根据第二个参数的值决定是否是对文件进行追加写入数据 true是追加 false 不追加 |\n| FileOutputStream(String name) 通过一个String对象(封装的文件路径)创建文件字节输出流对象 |\n| FileOutputStream(String name, boolean append)通过一个String对象(封装的文件路径)创建文件字节输出流对象,并根据第二个参数的值决定是否是对文件进行追加写入数据 true是追加 false不追加 |\n\n### （1）核心API方法\n\n| void | **close() 关闭此文件输出流并释放与此流有关的所有系统资源 【常用】** |\n| :--: | :----------------------------------------------------------: |\n| void |    write(byte[] b) 将以字节数组长度的内容写入到磁盘文件中    |\n| void | **write(byte[] b, int off, int len) 将实际len长度的内容****从数组b中off位置开始写入到磁盘文件中【常用】** |\n| void |      write(int b) 一次写一个字节的内容写入到磁盘文件中       |\n| void | **flush() 加快流的流速,强制清空缓冲区中数据**【加快输出效果（在使用网络流的时候一定要添加）】 |\n\n```java\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Objects;\npublic class FileOutputStreamAPIDemo \n{\n    public static void main(String[] args) \n    {\n        //1.创建文件字节输出流对象【一个参数的版本】\n        /*\n            一个参数的版本参数可以传递两种方式\n            第一种：传入File对象 --》fos = new FileOutputStream(new File(\"绝对或相对路径文件\"));\n            第二种：传入String类型对象(代表的是文件的路径)\n                                fos = new FileOutputStream(\"绝对或相对路径文件\");\n            在创建文件字节输出流对象时，需要处理编译时异常 Unhandled exception: java.io.FileNotFoundException\n            处理方式 要么 try-catch 要么 throws\n        */\n        FileOutputStream fos = null;\n        try \n        {\n            /*\n                创建文件字节输出流对象【两个参数的版本】\n                第一个参数可以是File对象或String类型对象，只要提供文件绝对或相对路径\n                第二个参数需要注意是一个boolean类型参数，传入true时会开启追加写入操作\n                    new FileOutputStream(\"绝对或相对路径文件\",true);\n                或者\n                    new FileOutputStream(new File(\"绝对或相对路径文件\"),true);\n            */\n            //写出数据到磁盘中时，磁盘中可以不存在这个文件，在写数据时会自动创建这个文件\n            fos = new FileOutputStream(\"dir/file2.txt\",true);\n            //常用写出方法中都存在一个编译时异常Unhandledexception: java.io.IOException\n            //1.一次向文件中写入一个字节的数据\n            //fos.write(65);     //参数是int类型对应ASCII值的字符\n            //不是“连续”向文件中写入内容，而是再次向file2.txt内容时，覆盖写入\n            //2.向文件中一次性写过字节数组中的所有内容\n            //getBytes()-->将字符串转换为字节数组\n            /*\n                如果是分批写入数据，为了防止文件中内容被后一次书写数据进行覆盖，\n                可以使用FileOutputStream中构造方法【两个参数版本】，开启追加写入\n                一般追加写入的作用都是生成日志文件，记录用户写入一些数据到文件中，一般不追加的比较常用\n            */\n            fos.write(\"BCDEFGHIJKLMN\".getBytes());    //getBytes()将字符串转换成字节数组\n            //3.从字节数组中将内容写入到文件中，从off参数提供的位置读取数据开始写，写len提供长度内容\n            /*\n                第一个参数是存储数据字节数组\n                第二个参数是从字节数组什么位置开始读取和写出数据【默认0（下标）】\n                第三个参数实际写出内容长度（一般会配合输入流中read方法获取实际长度进行写出）\n            */\n            fos.write(\"BCDEFGHIJKLMN\".getBytes(),6,\"HIJKMLN\".length());\n            //执行刷新操作\n            fos.flush();\n            System.out.println(\"老子写完了！！！\");\n        } \n        catch (FileNotFoundException e) \n        {\n            e.printStackTrace();\n        } \n        catch (IOException e) \n        {\n            e.printStackTrace();\n        } \n        finally \n        {\n            if(Objects.nonNull(fos))    //也可以是 fos != null\n            {\n                try \n                {\n                    //存在一个编译时异常要处理\n                    fos.close();\n                } \n                catch (IOException e) \n                {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n## <center>5、图片拷贝案例</center>\n\n利用文件字节输入输出流完成图片拷贝操作\n\n```java\npackage com.qfedu.InputStreamAndOutputStream;\nimport java.io.*;\nimport java.util.Objects;\npublic class FileCopy \n{\n    public static void main(String[] args) \n    {\n        //1.提供文件字节输入输出流对象\n        InputStream is = null;\n        OutputStream os = null;\n        try \n        {\n            is = new FileInputStream(new File(\"dir/1_io.jpg\"));\n            os = new FileOutputStream(new File(\"desc/1_io.jpg\"));\n            //2.一定明确在使用是什么流【字节或字符】-》提供对应数组进行数据存储与接收\n            byte[] bs = new byte[1024];    //提供存储读取数据的字节数组\n            //3. 提供一个变量存储读取文件实际内容长度【存储读取到文件末尾-1的值】\n            int len = 0;\n            //4.提供流的循环读写操作【读和写都是有编译时异常的要处理】\n            while((len = is.read(bs))!=-1)    //循环读取数据并存储在bs数组中\n            { \n                //将存储在bs数组中数据写出到磁盘文件中\n                os.write(bs,0,len);\n            } \n            os.flush();    //刷新\n            System.out.println(\"老子写完了！！！\");\n        } \n        catch (FileNotFoundException e) \n        {\n            e.printStackTrace();\n        } \n        catch (IOException e) \n        {\n            e.printStackTrace();\n        } \n        finally \n        {\n            //谁先创建谁最后关闭\n            if(Objects.nonNull(os))\n            {\n                try \n                {\n                    os.close();\n                } \n                catch (IOException e) \n                {\n                    e.printStackTrace();\n                }\n            } \n            if (Objects.nonNull(is))\n            {\n                try \n                {\n                    is.close();\n                } \n                catch (IOException e) \n                {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n## <center>6、利用字节流将文件中的内容进行拷贝赋值操作</center>\n\n```java\npackage com.qfedu.InputStreamAndOutputStream;\nimport java.io.*;\nimport java.util.Objects;\npublic class FileCopy2 \n{\n    public static void main(String[] args) \n    {\n        //1.提供字节输入输出流对象\n        FileInputStream fis = null;\n        FileOutputStream ois = null;\n        try \n        {\n            fis = new FileInputStream(new File(\"dir/1.txt\"));\n            ois = new FileOutputStream(new File(\"desc/1.txt\"));\n            //2.明确使用是字节流还是字符流\n            byte[] bs = new byte[1024];\n            //3.提供循环读写操作【处理编译时异常】\n            int len;\n            while((len = fis.read(bs))!=-1)\n            {\n                // ois.write(bs,0,len);\n                System.out.println(new String(bs,0,len));\n            } \n            ois.flush();\n            System.out.println(\"老子写完了！！！\");\n        } \n        catch (FileNotFoundException e) \n        {\n            e.printStackTrace();\n        } \n        catch (IOException e) \n        {\n        e.printStackTrace();\n        } \n        finally \n        {\n            if(Objects.nonNull(ois))\n            {\n                try \n                {\n                    ois.close();\n                } \n                catch (IOException e) \n                {\n                    e.printStackTrace();\n                }\n            } \n            if(Objects.nonNull(fis))\n            {\n                try \n                {\n                    fis.close();\n                } \n                catch (IOException e) \n                {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n总结:字节输入输出流在文件进行操作，因为字节流中使用数据类型byte类型主要针对是二进制的文件，所以**字节流主要对的是【图片、音频、视频、压缩包】这类的二进制文件**，在读取和写出文本文件时，会在处理文件时出现一些乱码问题�，所以字节流主要是处理二进制文件而使用，如果处理文件文件的数据就不太建议使用字节流来完成操作，就是因为容易出现乱码问题�\n\n# <center>知识点四：字符输入输出流</center>\n\n字符输入输出流是专门用于对文本文件进行操作流，用于弥补字节流对文本文件操作时容易出现乱码的为题，所以用字符输入输出流对文本文件进行处理操作\n\n## <center>1、Reader字符输入流</center>\n\nReader是字符输入的父类，所有字符输入流都要直接或间接继承与Reader类，因为这个流是字符流，所以流中数据是char，要提供数组也是char类型数组\n\n根据API文档中描述可以发现\n\n```java\npublic abstract class Reader extends Object implements Readable, Closeable\n```\n\n提供已知的之类\n\n```java\nBufferedReader, CharArrayReader, FilterReader, InputStreamReader, PipedReader, StringReader\n```\n\n操作文件FileReader这个类并不是Reader的直接子类，而是间接子类，操作文件FileReader类是继承与InputStreamReader这个类，InputStreamReader这个类是Reader直接子类，可以利用FileReader进行文件操作\n\n## <center>2、FileReader文件字符输入流</center>\n\nFileReader是Reader的间接子类，FileReader的直接父类是InputStreamReader，InputStreamReader这个类提供文件编码集和缓冲区操作，API文档中也说明【此类的构造方法假定默认字符编码和默认字节缓冲区大小都是适当的】\n\n通过流操作文本文件时，文本文件是存在编码集的，在使用FileReader类操作是使用就是默认编码集，这个默认编码集是根据系统进行获取，编码集的目的【提供文件的编码让文件可以达到统一性Unicode(UTF-8)】\n\n在使用字节流时，API文档中是没有描述字节流具备缓冲区，但是在使用字符流的时，API文档提供缓冲区的概念，当使用流写出数据时，有一个方法**flush方法**，这个方法就是专门针对缓冲区进行设计，提供缓冲这个概念可以大大提高，流的使用效率\n\n在API文档中提供FileReader中定义描述\n\n```java\npublic class FileReader extends InputStreamReader\n```\n\n**常用构造方法**\n\n|                         构造方法摘要                         |\n| :----------------------------------------------------------: |\n| FileReader(File file) 通过一个File对象(封装着文件路径)创建一个FileReader对象进行数据读取 |\n| FileReader(String fileName) 通过一个String对象(封装着文件路径)创建一个FileReader对象进行数据读取 |\n\n### （1）常用API方法\n\n| 方法摘要 |                                                              |\n| :------: | :----------------------------------------------------------: |\n|   void   |         **close() 关闭该流并释放与之关联的所有资源**         |\n|   int    |                     read() 读取单个字符                      |\n|   int    |      **read(char[] cbuf) 读取字符数组长度的内容(常用)**      |\n|   int    | read(char[] cbuf, int off, int len) 将读取len的长度内容写入到cbuf数组中并且从off的位置开始在数组中写入 |\n\nPS:直接参考FileInputStream即可，只要将byte数组换char数组就可以了\n\n## <center>3、Writer字符输出流</center>\n\nWriter字符输入流是所有字符输入流父类，所有字符输入流都要直接或间接继承与Writer，因为这个流是字符流，所以流中数据是char类型，需要提供char类型数组\n\n根据API文档中描述\n\n```java\npublic abstract class Writer extends Object implements Appendable, Closeable, Flushable\n```\n\n它是一个抽象类不能直接创建流对象进行操作，所以需要使用到其子类\n\n```java\nBufferedWriter, CharArrayWriter, FilterWriter, OutputStreamWriter, PipedWriter, PrintWriter, StringWriter\n```\n\n操作文件的FileWriter这个类不是Writer的直接子类，而是间接子类，但是FileWriter可以完成对文件写出操作\n\n## <center>4、FileWriter文件字符输出流</center>\n\nFileWriter是Writer的间接子类，FileWriter的直接父类是OutputStreamWriter，OutputStreamWriter个类提供文件编码集和缓冲区操作，API文档中也说明【此类的构造方法假定默认字符编码和默认字节缓冲区大小都是适当的】\n\n通过流操作文本文件时，文本文件时存在编码集的，在使用FileWriter类操作时使用就是默认编码集，这个默认编码集是根据系统进行获取，编码集的目的【提供文件的编码让文件可以达到统一性Unicode(UTF-8)】\n\n在使用字节流时，API文档中是没有描述字节流具备缓冲区，但是在使用字符流的时，API文档提供缓冲区的概念，当使用流写出数据时，有一个方法flush方法，这个方法就是专门针对缓冲区进行设计，提供缓冲这个概念可以大大提高，流的使用效率\n\n### （1）常用构造方法\n\n|                         常用构造方法                         |\n| :----------------------------------------------------------: |\n|    FileWriter(File file) 构建了一个文件对象FileWriter对象    |\n| FileWriter(File file, boolean append) 构建了一个文件对象FileWriter对象 |\n|  FileWriter(String fileName) 构造给定文件名的FileWriter对象  |\n| FileWriter(String fileName, boolean append) 构造FileWriter对象给出一个文件名与一个布尔值，指示是否附加写入的数据 |\n\nPS:构建方法中多了一个第二参数，是boolean参数值作用就是提供文件追加写入操作，当设置参数为true时，当前写入文件中数据操作就是追加写入【主要适合：记录日志的工作】，如果是连续写出数据，可以不开启这个操作\n\n### （2）常用API方法\n\n| void |                close() 关闭此流，但要先刷新它                |\n| :--: | :----------------------------------------------------------: |\n| void |                    flush() 刷新该流的缓冲                    |\n| void |               write(char[] cbuf) 写入字符数组                |\n| void | write(char[] cbuf, int off, int len) 从cbuf数组读取数据并写入到文件中,len是实际写出数据长度,off是从cbuf数组中什么位置开始写出 (使用字符数组时核心方法) |\n| void |                  write(int c) 写入单个字符                   |\n| void |       write(String str) 写入字符串(非常有用的核心方法)       |\n\nPS: 在写出数据到文件中时，只有字符流中会提供一个参数为String类型write方法，这个方法可以帮我们便捷将数据写出到文件中，这个方法极其重要\n\nFileWriter操作可以完全参考FileOutputStream这个类，基本上是一模一样，只不过将byte类型转换char类型即可\n\n## <center>5、使用字符输入输出流进行文本文件的拷贝操作</center>\n\n```java\npackage com.qfedu.ReaderAndWriter;\nimport java.io.*;\nimport java.util.Objects;\npublic class FileReaderAndFileWriterCopyFile \n{\n    public static void main(String[] args) \n    {\n        //1.提供字符输入输出流对象创建\n        Reader reader = null;\n        Writer writer = null;\n        //在创建对象时要处理编译时异常Unhandled exception: java.io.FileNotFoundException 处理方法和字节流一样\n        try \n        {\n            reader = new FileReader(new File(\"dir/1.txt\"));\n            writer = new FileWriter(new File(\"desc/2.txt\"));\n            //2.一定要明确使用是什么流--》字符流\n            char[] buf = new char[1024];\n            //3. 提供循环读写操作\n            int len;\n            while((len = reader.read(buf))!=-1)\n            {\n                System.out.println(new String(buf,0,len));\n                //writer.write(buf,0,len);\n            } \n            writer.flush();\n            System.out.println(\"老子写完了！！！！\");\n        } \n        catch (IOException e) \n        {\n            e.printStackTrace();\n        } \n        finally \n        {\n            if(Objects.nonNull(writer))\n            {\n                try \n                {\n                    writer.close();\n                } \n                catch (IOException e) \n                {\n                    e.printStackTrace();\n                }\n            } \n            if (Objects.nonNull(reader))\n            {\n                try \n                {\n                    reader.close();\n                } \n                catch (IOException e) \n                {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n## <center>6、使用字符输入输出流进行图片的拷贝操作</center>\n\n打开拷贝之后图片，观察拷贝之后图片与原来图片的大小\n\n使用字符流进行图片复制拷贝操作是不可以完成，图片出现问题\n\n```java\npackage com.qfedu.ReaderAndWriter;\nimport java.io.*;\nimport java.util.Objects;\npublic class FileReaderAndFileWriterCopyFile2 \n{\n    public static void main(String[] args) \n    {\n        //1.提供字符输入输出流对象创建\n        Reader reader = null;\n        Writer writer = null;\n        //在创建对象时要处理编译时异常Unhandled exception: java.io.FileNotFoundException\n        try \n        {\n            reader = new FileReader(new File(\"dir/1_io.jpg\"));\n            writer = new FileWriter(new File(\"desc/2_io.jpg\"));\n            //2.一定要明确使用是什么流--》字符流\n            char[] buf = new char[1024];\n            //3. 提供循环读写操作\n            int len;\n            while((len = reader.read(buf))!=-1)\n            {\n                writer.write(buf,0,len);\n            } \n            writer.flush();\n            System.out.println(\"老子写完了！！！！\");\n        } \n        catch (IOException e) \n        {\n            e.printStackTrace();\n        } \n        finally \n        {\n            if(Objects.nonNull(writer))\n            {\n                try \n                {\n                    writer.close();\n                } \n                catch (IOException e) \n                {\n                    e.printStackTrace();\n                }\n            } \n            if (Objects.nonNull(reader))\n            {\n                try \n                {\n                    reader.close();\n                } \n                catch (IOException e)\n                {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n# <center>知识点五：字节流和字符流之间区别</center>\n\n字节流和字符流是有本质上区别：\n\n1. 流中数据是不同，字节流流中的数据是byte而字符流流中数据是char\n2. 根据流中不同数据类型所以字节流主要处理是二进制文件【图片、音频、视频、压缩包的等等】也可以处理【文本文件】但是容易出现乱码，而字符流主要是处理文本文件提供流，它是无处理二进制文件的\n3. 字节流和字符流之间还有一个很大区别\n\n&ensp;&ensp;&ensp;&ensp;字节流在操作流的过程中是【没有使用缓冲区】，直接对文件本身进行操作\n\n&ensp;&ensp;&ensp;&ensp;字符流在操作流的过程中是【使用了缓冲区】，通过缓冲区进行进行对文件操作\n\n**什么是缓冲区？**\n\n&ensp;&ensp;&ensp;&ensp;缓冲区可以理解为一段特殊区域，某些情况下，如果一个程序频繁的操作一个资源（如文件或数据库），则会出现性能下降的问题，此时为了提升性能，就可以将内存中部分数据读取到一个内存区域中，以后直接从这个区域进行数据去读，这样化就可以提升系统的性能，那么这个提供区域就是“缓冲区”\n\n```java\nimport java.io.*;\npublic class BufferedDemo \n{\n    public static void main(String[] args) throws\nException \n    {\n        /*\n            在同等条件下进行操作\n            创建文件字节输出流和文件字符输出流对象，将数据通过流写入到文件中\n            创建了字节和字符文件输出流对象，进行数据书写到文件中并关闭了流资源，此时外界文件中是可以存在数据\n        */\n        /* \n            OutputStream os = new FileOutputStream(new File(\"desc/字节流文件.txt\"));\n            os.write(\"Hello World\".getBytes());\n            os.close();\n            Writer writer = new FileWriter(new File(\"desc/字符流文件.txt\"));\n            //自有字符流中提供可以将字符串写入到文件中方法\n            writer.write(\"Hello world\");\n            writer.close();\n        */\n        //-------------------------------------------------------------------------------------\n        /*\n            在同等条件下进行操作            创建文件字节输出流和文件字符输出流对象，将数据通过流写入到文件中，但是不添加close方法\n            字节流可以将数据直接写出到磁盘文件中，在没有使用close方法前提下程序正常结束也可以将流中数据写入到文件中\n            字符流在没有使用close方法的前提下，程序正常结束是没有办法将数据写入到文件中的\n            就是因为 字符流使用 缓冲区技术即使用“缓冲区”\n            在字符流操作过程中，所有字符都是在“内存中形成”的，在输出前会将“所有的暂时保存在内存中内容”输出到文件中\n            使用close这个方法在在关闭流资源自后会将缓冲区中数据输出文件中(有flush功能)，所以字符流就要更加要关闭流资源\n            但是为了防止忘记书写close方法，并且共缓冲区的利用率，Java对所有输出流都提供了一个方法flush\n            flush这个方法可以强制的刷新出缓冲区中数据，所以就算没有关闭流资源可以将字符流中数据写出到文件中\n            所以建议在所有写出数据操作中添加flush这个方法\n        */\n        OutputStream os = new FileOutputStream(new File(\"desc/字节流文件.txt\"));\n        os.write(\"Hello World\".getBytes());\n        Writer writer = new FileWriter(new File(\"desc/字符流文件.txt\"));\n        //自有字符流中提供可以将字符串写入到文件中方法\n        writer.write(\"Hello world\");\n        writer.flush();\n    }\n}\n```\n\n使用字符流还是使用字节流？\n\n&ensp;&ensp;&ensp;&ensp;区分场景而言文本文件使用字符流，二进制文件使用字节流，但是字节流处理场景明显要比字符流多，所以建议优先使用字节流处理数据，如果数据是文本文件在考虑转换流操作\n\n# <center>知识点六：字符编码</center>\n\n阶段1:\n\n&ensp;&ensp;&ensp;&ensp;所以规定使用的字节的最高位是0.每一个字节都是以【0~127之间的数字来表示】,比如A对应65,a对应97.这就是美国标准信息交换码【ASCII】.\n\n'A'~‘Z’ ‘a’~‘z’ ‘0’~‘9’\n\n**阶段2:**\n\n&ensp;&ensp;&ensp;&ensp;随着计算机在全球的普及,很多国家和地区都把自己的字符引入了计算机,比如汉字.\n\n&ensp;&ensp;&ensp;&ensp;此时发现一个字节能表示数字范围太小,不能包含所有的中文汉字那么就规定使用两个字节来表示一个汉字.\n\n&ensp;&ensp;&ensp;&ensp;规定:原有的ASCII字符的编码保持不变,仍然使用一个字节表示,为了区别一个中文字符和ASCII码字符中文字符的每个字节最高位规定为1(中文的二进制是负数).这个规范就是【GB2312】编码,后来在GB2312的基础上增加了更多的中文字符,比如汉字,也就出现了【GBK】.\n\n阶段3:\n\n&ensp;&ensp;&ensp;&ensp;新的问题,在中国是认识汉字的,但是如果把汉字传递给其他国家,该国家的码表中没有收录汉字,其实就显示另一个符号或者乱码为了解决各个国家因为本地化字符编码带来的影响,咱们就把全世界所有的符号统一进行编码-【Unicode万国码】编码.此时某一个字符在全世界任何地方都是固定的,比如【哥】,在任何地方都是以十六进制的【54E5】来表示.Unicode的编码字符都占有【2个字节大小】\n\n常用字符编码集\n\n&ensp;&ensp;&ensp;&ensp;ASCII码： 占一个字节，只能包含128个符号，不能表示汉字\n\n&ensp;&ensp;&ensp;&ensp;ISO-8859-1【latin-1】占一个字节，收录的是西欧语言，不能表示汉字 ---》properties\n\n&ensp;&ensp;&ensp;&ensp;ANSI【GB2312】占两个字节，在简体中文操作系统中ANSI就是值的GB2312(淘汰了)\n\n&ensp;&ensp;&ensp;&ensp;GB18030/GBK 占两个字节，支持中文\n\n&ensp;&ensp;&ensp;&ensp;UTF-8：是一种针对Unicode的可变长字符编码，又称万国码，UTF-8是Unicode的实现方式之一，这个编码兼容ASCII码 UTF-8表示汉字'\\u0000'~'\\uffff'\n\nps：在UTF家族中提供了其他编码 UTF-8E ，UTF-16 ,UTF-32， 这里有一个特殊编码集千万不要使用，这个编码集是MS公司搞出来UTF-8 BOM，默认3个字节一个汉字【不要使用】\n\n# <center>知识点七：InputStreamReader 字节字符转换输入流</center>\n\n字节字符转换输入流的作用：**将字节流转换为字符流，并且可以设置文件编码集**\n\n“特别说明：**InputStreamReader的父类是Reader类，所以这个流中数据是char类型**”\n\n&ensp;&ensp;&ensp;&ensp;“**InputStreamReader是FileReader的直接父类**”\n\n## <center>1、核心构造方法</center>\n\n|                         常用构造方法                         |\n| :----------------------------------------------------------: |\n| InputStreamReader(InputStream in) 通过参数InputStream流的对象构建InputStreamReader流对象并使用的是默认编码集 |\n|    InputStreamReader(InputStream in, Charset cs) 通过参数    |\n| InputStream流的对象构建InputStreamReader流对象并用过Charset设置读取文件编码集 |\n| InputStreamReader(InputStream in, String charsetName)通过参数InputStream流的对象构建InputStreamReader流并用过字符串设置读取文件编码集 |\n\nPS： 转换输入流，所以构建InputStreamReader对象时，需要提供一个字节输入流作为转换对象\n\n通过InputStreamReader可以设置编码集，设置编码集方式是通过InputStreamReader构造方法中第二参数进行设置，这里设置有两种方式\n\n&ensp;&ensp;&ensp;&ensp;第一种方式：使用Charset类型进行设置 ---》 Charset.forName(\"编码集名字\")\n\n&ensp;&ensp;&ensp;&ensp;第二种方式：使用String类型进行设置 ---》 \"编码集名字\"\n\n## <center>2、核心API方法</center>\n\n|        |                           常用方法                           |\n| :----: | :----------------------------------------------------------: |\n|  void  |         close() 关闭流并释放与它相关联的任何系统资源         |\n| String | getEncoding() 返回此流使用的字符编码的名称。(在读取文件的同时读取文件编码集) |\n|  int   |                     read() 读取单个字符                      |\n|  int   | read(char[] cbuf, int offset, int length) 将字符读入一个数组的一部分 |\n|  int   |        read(char[] cbuf) 将读取的数据存储到字符数组中        |\n\n# <center>知识点八：OutputStreamWriter 字节字符转换输出流</center>\n\n字节字符转换输出流作用:将字符流转换为字节流输出，并可以设置编码集\n\n特别注意:\"**OutputStreamWriter的父类是Writer,所以这个流中数据是char类型**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;\"**OutputStreamWriter是FileWriter的父类**\"\n\n## <center>1、核心构造方法</center>\n\n|                         常用构造方法                         |\n| :----------------------------------------------------------: |\n| OutputStreamWriter(OutputStream out) 通过OutputStream对象创建OutputStreamWriter对象并使用默认编码集写出数据 |\n| OutputStreamWriter(OutputStream out, Charset cs) 通过OutputStream对象创建OutputStreamWriter对象并使用Charset设置写出文件编码集 |\n| OutputStreamWriter(OutputStream out, StringcharsetName) 通过OutputStream对象创建OutputStreamWriter对象并使用String类型设置写出文件编码集 |\n\nPS： 转换输出流，所以构建OutputStreamWriter对象时，需要提供一个字节输出流作为转换对象\n\n通过OutputStreamWriter可以设置编码集，设置编码集方式是通过OutputStreamWriter构造方法中第二参数进行设置，这里设置有两种方式\n\n&ensp;&ensp;&ensp;&ensp;第一种方式：使用Charset类型进行设置 ---》 Charset.forName(\"编码集名字\")\n\n&ensp;&ensp;&ensp;&ensp;第二种方式：使用String类型进行设置 ---》 \"编码集名字\"\n\n## <center>2、核心的API方法</center>\n\n|        |                           常用方法                           |\n| :----: | :----------------------------------------------------------: |\n|  void  |                    close() 关闭流，冲洗它                    |\n|  void  |                         flush() 冲流                         |\n| String |          getEncoding() 返回此流使用的字符编码的名称          |\n|  void  | write(char[] cbuf, int off, int len) 写入一个字符数组的一部分 |\n|  void  |                   write(int c) 写一个字符                    |\n|  void  |    write(String str, int off, int len) 写入字符串的一部分    |\n\nPS： 因为OutputStreamWriter是父类Writer方法，所以也会继承到Writer方法中参数为String类方法，所以提供直接输出字符串的方法\n\n**这两流的操作可以完全操作FileRader和FileWriter进行操作**\n\n需求：使用转换流在设置编码集的前提下进行文件的赋值与粘贴\n\n1. 读取文件使用UTF-8编码集进行，输出文件时将文件编码集修改为GBK\n\n```java\npackage com.qfedu.BufferedInputStreamAndBufferedOutputStream;\nimport java.io.*;\nimport java.nio.charset.Charset;\npublic class FileEncodingCopyDemo \n{\n    public static void main(String[] args) throws Exception \n    {\n        //使用转换流进行文件的编码集设置操作\n        //1.提供创建字节字符转换输入输出流对象\n        //在创建转换流对象时，是存在一个编译时异常 UnsupportedEncodingException【不支持设置编码集】\n        InputStreamReader isr = new InputStreamReader(new FileInputStream(new File(\"dir/1.txt\")),\"UTF-8\");\n        //只有读对了才可以写对\n        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(new File(\"desc/1.txt\")),\n        Charset.forName(\"GBK\"));\n        //2.这两个转换流是父类都是字符类型，所以流中的数据都是char类型\n        char[] buf = new char[1024];\n        //提供一个变量存储实际读取到文件长度【包括文件末尾-1的返回值】\n        int len = 0;\n        //3.循环读取数据并将当前数据输出\n        while((len = isr.read(buf))!=-1)\n        {\n            osw.write(buf,0,len);\n        } \n        osw.flush();\n        osw.close();\n        isr.close();\n        System.out.println(\"老子写完了！！！\");\n    }\n}\n```\n\n需求：仿照上面代码提供一个通用方法可以设置文件编码集并且使用转换流进行拷贝与粘贴操作\n\n1. 读取文件使用UTF-8编码集进行，输出文件时将文件编码集修改为GBK\n2. 读取文件使用GBK编码集进行，输出文件时将文件编码集修改为UTF-8\n3. 使用GBK编码集读取一个UTF-8文件，输出文件时使用UTF-8编码集输出\n\n```java\npackage com.qfedu.BufferedInputStreamAndBufferedOutputStream;\nimport java.io.*;\nimport java.nio.charset.Charset;\npublic class FileEncodingCopyDemo2 \n{\n    public static void main(String[] args) throws Exception \n    {\n        // 1. 读取文件是UTF-8，写出文件GBK\n        /* \n            copyFile(new File(\"dir/1.txt\"),\"UTF-8\",new File(\"desc/1.txt\"),\"GBK\");\n        */\n        //2. 读取文件是GBK ，写出文件是UTF-8编码\n        /* \n            copyFile(new File(\"desc/1.txt\"),\"GBK\", new File(\"dir/UFT-8文件.txt\"),\"UTF-8\");\n        */\n        // 3. 读取一个UTF-8的编码文件使用GBK编码，写出文件是使用UTF-8写出\n        copyFile(new File(\"dir/UFT-8文件.txt\"),\"GBK\", new File(\"desc/将UFT-8文件设置为GBK之后修\n                                                                                改为UTF-8.txt\"),\"UTF-8\");\n    } \n        /**\n        * 设置文件编码集进行赋值粘贴的方法\n        * @param srcFile 源文件\n        * @param srcCharset 源文件编码集\n        * @param descFile 目标文件\n        * @param descCharset 目标文件编码集\n        * @throws Exception 代表方法所有要抛出的编译时异常\n        */\n    public static void copyFile(File srcFile,String srcCharset,File descFile,String descCharset)throws Exception\n    {\n        //1.提供字节字符转换输入输出流对象\n        InputStreamReader isr = new InputStreamReader(new FileInputStream(srcFile),srcCharset);\n        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(descFile),descCharset);\n        //2.使用的是什么流，流中数据是什么 --》 他们都是字符流\n        char[] buf = new char[1024];\n        int len = 0;\n        while((len = isr.read(buf))!=-1)\n        {\n            osw.write(buf,0,len);\n        } \n        osw.flush();\n        osw.close();\n        isr.close();\n    }\n}\n```\n\n**转换流的总结：**\n\n&ensp;&ensp;&ensp;&ensp;**转换流的目的在于提供了字节与字符流之间的一种转换效果，我们可以通过转换流将字符流和字节流进行转化，除此之外还可以设置文件的编码集进行文件的读取和写出操作**，这样可以完成文件的编码集转换操作【文件编码集的转换操作原则是：只有读取文件时编码集设置正确，才可在写出文件时将编码集设置正确】\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012007515.png\" alt=\"字符流转字节流\" style=\"zoom: 67%;\" />\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012008623.png\" alt=\"字节流转字符流\" style=\"zoom:67%;\" />\n\n# <center>知识点九：缓冲流</center>\n\n有了缓冲流之后，不建议使用原始流进行操作，缓冲流效率是远远高于原始流，缓冲流提供缓冲区让流可以进行操作\n\n原始流指的是：InputStream和OutputStream 或者 Reader和Writer不使用缓冲区的流\n\nPS：需要注意的是 字符流 默认使用了缓冲区，所以和缓冲流的效果差不多\n\n## <center>1、字节缓冲流</center>\n\n字节缓冲流是针对原始字节流而提供一种流，这个中流可以更加高效处理流中操作\n\n**BufferedInputStream字节缓冲输入流 和 BufferedOutputStrem 字节缓冲输出流**\n\nBufferedInputStream字节缓冲输入流是InputStream字节输入流的子类，这个流提供一个缓冲区，这个缓冲区可以帮组流进行数据缓冲与操作，**这个缓冲区的大小默认是8192K**,提供BufferedInputStream这个流可以包装一个普通字节输入流进行缓冲操作，这个缓冲区大小是可以用过BufferedInputStream构造方法进行设置，但是**这个缓冲区的设置不要低于8192，设置时按照1024倍数设置即可**\n\n### （1）BufferedInputStream常用构造方法\n\n|                         常用构造方法                         |\n| :----------------------------------------------------------: |\n| BufferedInputStream(InputStream in) 创建一个BufferedInputStream 和保存它的参数，输入流 in ，供以后使用 |\n| BufferedInputStream(InputStream in, int size) 创建一个具有指定的缓冲区大小 BufferedInputStream ，并保存它的参数，输入流 in ，供以后使用 |\n\nPS：缓冲流的使用其实就是对原始流进行二次“包装”，让原始就具备一个缓冲区可以快速进行流操作，所以构建字节缓冲输入流对象时，**需要提供一个“InputStream字节输入流对象”**，不仅如此还可以设置缓冲区的默认大小，**不要低于8192这个数据，设置时按照1024倍数设置即可**，缓冲流输入流是唯一支持字节输入流父类中提供mark和reset方法【但是没有任何效果】\n\n### （2）BufferedInputStream常用API方法\n\n|         |                           常用方法                           |\n| :-----: | :----------------------------------------------------------: |\n|  void   |     close() **关闭此输入流并释放与流关联的任何系统资源**     |\n|   int   |        read() 看到的 InputStream 的 read 方法一般合同        |\n|   int   |       read(byte[] b) **读取文件存储到数组中**【常用】        |\n|   int   | read(byte[] b, int off, int len) 从这个字节的输入流读取到指定的字节数组中的字节，从给定的偏移量开始 |\n| boolean |  markSupported() 如果输入流的支持 mark 和reset 方法【无用】  |\n|  void   | mark(int readlimit) 看到的 InputStream 的mark 方法一般合同【无用】 |\n|  void   |   reset() 看到的 InputStream 的 reset 方法一般合同【无用】   |\n\n&ensp;&ensp;&ensp;&ensp;BufferedOutputStream字节缓冲输出流是OutputStream字节输出流子类，这个流提供一个缓冲区，这个缓冲区可以帮组流进行数据缓冲与操作，**这个缓冲区的大小默认是8192K**,提供BufferedOutputStream这个流可以包装一个普通字节输出流进行缓冲操作，这个缓冲区大小是可以用过BufferedOutputStream构造方法进行设置，**但是这个缓冲区的设置不要低于8192，设置时按照1024倍数设置即可**\n\n### （3）BufferedOutputStream常用构造方法\n\n|                         常用构造方法                         |\n| :----------------------------------------------------------: |\n| BufferedOutputStream(OutputStream out) 创建一个新的缓冲输出流，将数据写入到指定的基本输出流中 |\n| BufferedOutputStream(OutputStream out, int size) 创建一个新的缓冲输出流，用指定的缓冲区大小写数据到指定的基本输出流中 |\n\nPS：缓冲流的使用其实就是对原始流进行二次“包装”，让原始就具备一个缓冲区可以快速进行流操作，所以构建字节缓冲输出流对象时，**需要提供一个“OutputStream字节输出流对象”**，不仅如此还可以设置缓冲区的默认大小，**不要低于8192这个数据，设置时按照1024倍数设置即可**\n\n### （4）BufferedOutputStream常用API方法\n\n|      |                           常用方法                           |\n| :--: | :----------------------------------------------------------: |\n| void |                    flush() 刷新缓冲输出流                    |\n| void | write(byte[] b, int off, int len) 写 len 字节指定字节数组中的起始偏移 off 这个缓冲输出流 |\n| void |         write(int b) 将指定的字节写入该缓冲输出流中          |\n| void |      close() 关闭此输出流并释放与此流关联的任何系统资源      |\n\nPS:字节缓冲输入输出流没有任何特殊方法，这个操作可以完全参考FileInputStream 和FileOutputStream\n\n字节缓冲输入输出流就是提供缓冲区提高操作效率而已\n\n性能对比： 使用缓冲字节流和普通字节流进行 大于2GB文件拷贝操作计算时间\n\n```java\npackage\ncom.qfedu.BufferedInputStreamAndBufferedOutputStream;\nimport java.io.*;\npublic class FileCopyTest \n{\n    public static void main(String[] args) throws\nException \n    {\n        //提供一个开始时间\n        long beginTime = System.currentTimeMillis();\n        //先提供字节输入输出流拷贝操作\n     //copyFileToByte(new File(\"C:\\\\Users\\\\jkmaster\\\\Desktop\\\\23_IO流1.zip\"),new File(\"C:\\\\abc\\\\23_IO流1.zip\"));\n        //在提供缓冲字节输入输出流拷贝操作\n        copyFileToBufferedByte(new File(\"C:\\\\Users\\\\jkmaster\\\\Desktop\\\\23_IO流1.zip\"),\n                                                                        new File(\"C:\\\\abc\\\\23_IO流1.zip\"));\n        long endTime = System.currentTimeMillis();\n        //System.out.println(\"缓冲字节输入输出流拷贝文件的时间\n                                                    //是：\"+(endTime-beginTime)+\"毫秒\");5869毫秒 --》约等于 6秒\n        //System.out.println(\"普通字节输入输出流拷贝文件的时间\n                                                   //是：\"+(endTime-beginTime)+\"毫秒\");21387毫秒 --》约等于 21秒\n    } \n    /**\n    * 普通字节输入输出流拷贝文件操作\n    * @param srcFile 源文件\n    * @param descFile 目标文件\n    * @throws Exception 抛出所有编译时异常信息    \n    */\n    public static void copyFileToByte(File srcFile, File descFile)throws Exception\n    {\n        //1.提供字节输入输出对象\n        InputStream is = new FileInputStream(srcFile);\n        OutputStream os = new FileOutputStream(descFile);\n        //2.提供byte类型数组\n        byte[] bs = new byte[1024];\n        //3.提供一个变量存储读取实际文件长度【读取文件末尾-1值】\n        int len;\n        while((len = is.read(bs))!=-1)\n        {\n            os.write(bs,0,len);\n        } \n        os.flush();\n        os.close();\n        is.close();\n        System.out.println(\"字节输入输出流拷贝文件结束！\");\n    } \n    /**\n    * 提供缓冲字节输入输出流拷贝文件操作\n    * @param srcFile 源文件\n    * @param descFile 目标文件\n    * @throws Exception 抛出所有编译时异常信息    \n    */\n    public static void copyFileToBufferedByte(File srcFile, File descFile)throws Exception\n    {\n        //1.提供缓冲字节输入输出对象\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(srcFile));\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(descFile));\n        //2.提供byte类型数组\n        byte[] bs = new byte[1024];\n        //3.提供一个变量存储读取实际文件长度【读取文件末尾-1值】\n        int len = 0;\n        while((len = bis.read(bs))!=-1)\n        {\n            bos.write(bs,0,len);\n        } \n        bos.flush();\n        bos.close();\n        bis.close();\n        System.out.println(\"缓冲字节输入输出流拷贝文件结束！\");\n    }\n} \n//PS：能用缓冲流就用缓冲流，不要使用普通字节流\n```\n\n## <center>2、字符缓冲流</center>\n\nPS：这个流才是我们真记忆，他符合内容数据写入到磁盘，在从磁盘将数据读取到内容使用流\n\n字符缓冲流对于将内存中数据写入到磁盘中和将磁盘中数据读取到内容中有非常好支持，所以只要是这样数据操作就一定使用这个流\n\n字符缓冲流也是缓冲流，所有字符缓冲输入输出流都具备缓冲区，默认大小也是8192K，如果要修改缓冲区大小需要比8192K大，并且是提供1024倍数进行修改\n\nBufferedReader缓冲字符输入流是Reader字节输入的子类，提供8192K缓冲区，可以包装一个普通的字符输入流提高操作效率\n\n### （1）BufferedReader常用构造方法\n\n|                           构造方法                           |\n| :----------------------------------------------------------: |\n| BufferedReader(Reader in) 创建一个使用默认大小输入缓冲区的缓冲字符输入流 |\n| BufferedReader(Reader in, int sz) 创建一个使用指定大小的输入缓冲区的缓冲字符输入流 |\n\nPS：BuffereReader是缓冲字符输入流，所以需要提供一个字符输入流作为对象传入到缓冲字符输入流中进行对象创建，除此之外提供修改默认缓冲区大小\n\n### （2）BufferedReader常用API方法\n\n|        |             常用方法              |\n| :----: | :-------------------------------: |\n| string | readLine() 读一行文本【强烈推荐】 |\n\n说明：\n\n1. BufferedReader是一个流，所以也需要调用close方法\n2. BufferedReader读取数据方式一共有两种：\n\n&ensp;&ensp;&ensp;&ensp;2.1 使用原始字符输入流的方式进行数据读取 --》 提供char数组，使用read方法读取数据【不推荐】\n\n&ensp;&ensp;&ensp;&ensp;2.2 使用BufferedReader中独有的方法进行数据读取 ---》 readLine方法【强烈推荐】\n\n &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;readLine这个方法是返回读取一次文本中内一行内容，这个方法的返回值是String\n\n```java\npackage com.qfedu.BufferedReaderAndBufferedWriter;\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\npublic class BufferedReaderDemo \n{\n    public static void main(String[] args)throws Exception\n    {\n        //1.创建字符缓冲输入流BufferedReader对象\n        BufferedReader br = new BufferedReader(new FileReader(new File(\"dir/UFT-8文件.txt\")));\n        //2.提供两种读取数据的方式\n        //2.1 使用char数组的方式进行读取\n        /* \n            char[] buf = new char[1024];\n            int len;\n            while((len = br.read(buf))!=-1)\n            {\n                System.out.println(new String(buf,0,len));\n            }\n        */\n        //2.1 使用 readLine进行数据读取，一次读取文件中一行内容\n        //2.1.1 提供一个String类型变量接收读取到数据\n        String content = null;\n        /*\n            readLine方法读取文件中每一个行内容时，一共有两种数据返回形态\n            读取到数据就返回String类型字符串读，取到文件末尾就返回null值\n        */\n        while((content = br.readLine()) != null)\n        {\n            //可以在这个循环中对content得到String字符串数据即文件中读取到内容进行操作\n            System.out.println(content);\n        } \n        br.close();\n    }\n}\n```\n\n### （3）BufferedWriter缓冲字符输出流\n\nBufferedWritrer缓冲字符输出流是Writer字符输出流子类，并且提供一个默认缓冲区大小为8192K，提供给包装普通字符输出流对象使用对字符输出流操作\n\n#### 常用构造方法\n\n|                         常用构造方法                         |\n| :----------------------------------------------------------: |\n| BufferedWriter(Writer out) 创建一个使用默认大小输出缓冲区的缓冲字符输出流 |\n| BufferedWriter(Writer out, int sz) 创建一个新的缓冲字符输出流，该流使用给定大小的输出缓冲区 |\n\nPS：BufferedWriter缓冲字符输出流是包装一个字符输出流对象，所以参数需要一个字符出流对象进行传入创建，并且可以设置默认缓冲区的大小，不建议低于8192K大小，提供设置默认值时要是1024的倍数\n\n#### 常用API方法\n\n| void | write(String str) 写一个字符串【这个方法是专门应对readLine方法写出的】 |\n| :--: | :----------------------------------------------------------: |\n| void |                     newLine() 写行分隔符                     |\n\n说明：\n\n1. BufferedWriter提供字符缓冲输出流操作，所以支持flush和close方法\n2. BufferedWriter提供数据写出操作，提供两种方式应对BufferedReader的操作\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;2.1 如果BufferedReader使用是char类型数组进行数据读取操作BufferedWriter就提 ·writer(char[] buf,int off,int len)将数据写出\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;2.2 如果BufferedReader使用是readLine这个方法进行数据读取操作者BufferedWriter就提供 write(String str) 将数据写出\n\n**PS: 使用write(String str) 将数据写出时需要配合使用newLine()这个方法以保证写出文件正确格式**\n\n需求： 使用缓冲字符输入输出流对象进行数据拷贝操作\n\n```java\nimport java.io.*;\npublic class CopyFileDemo \n{\n    public static void main(String[] args) throws\nException\n    {\n        //1.提供缓冲字符输入输出流对象\n        BufferedReader br = new BufferedReader(new FileReader(new File(\"dir/UFT-8文件.txt\")));\n        BufferedWriter bw = new BufferedWriter(new FileWriter(\"desc/file文件.txt\"));\n        //1.提供char数组方式进行写入写出操作\n        /* \n            char[] buf = new char[1024];\n            int len;\n            while((len = br.read(buf))!=-1)\n            {\n                bw.write(buf,0,len);\n            }\n        */\n        //2.使用newLine来进行数据写入写出操作\n        String str = null;\n        while((str = br.readLine()) != null)    //readLine这个方式不读取换行操作，不读取回车\"\\n\"\n        {\n        \n            bw.write(str);\n            //所以为了保证写出数据的格式完整性\n            bw.newLine(); //添加换行操作即添加\"\\n\"\n        } \n        bw.flush();\n        bw.close();\n        br.close();\n    }\n}\n```\n\n总结:\n\n&ensp;&ensp;&ensp;&ensp;Java中提供缓冲流的效率是远远高于普通（原始）流，因为缓冲流提供缓冲区操作，**缓冲字节输入输出流针对是二进制文件【视频、音频、图片、压缩包】等等，缓冲字符输入输出流针对的是文本文件，主要完成就是将内存中数据写入到文件中，将文件中数据在读取会内容，提供这个操作**\n\n案例：使用字符输入流从控台读取数据【不用Scanner】，写入到文件中【默认记录聊天数据】，写出数据时使用\n\nSystem.out打印到文件中\n\n```java\npackage com.qfedu.BufferedReaderAndBufferedWriter;\nimport java.io.*;\npublic class ReadScannerToFile \n{\n    public static void main(String[] args) throws Exception \n    {\n        //不使用Scanner进行数据操作\n        //可以提供字符缓冲输入流进行控制台数据读取\n        //之所以可以在控制台获取到数据主要是因为使用标准字节输入流--》System.in\n        //如果使用这种方法获取数据方式很单一只有readLine\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        /*\n            使用System这个类中 setOut方法改变打印数据流向--》标准输出流重定向\n        */\n        //需要提供一个字节打印流对象，提供流输出数据位置\n        PrintStream ps = new PrintStream(new FileOutputStream(\"desc/聊天记录.txt\"));\n        //修改打印流的流向\n        System.setOut(ps);\n        //提供循环进行数据获取\n        String content = null;\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyyMM-dd HH:mm:ss\");\n        while(true)\n        {\n            //提供一个Date对象获取当前时间\n            Date date = new Date();\n            //读取控制台数据\n            content = br.readLine();\n            //约定如果输入886结束程序\n            if(content.equals(\"886\"))\n            {\n                break;\n            } \n            //就将数据写入到文件中\n            String time = sdf.format(date);\n            //System.out.println(time);\n            System.out.println(content);\n        } \n        br.close();\n        ps.close();\n    }\n} \n//ps:已经将System.out的输出指定到文件中，如果需要将输出在指定会控制台打印如何做？\n```\n\n## <center>3、资源文件Properties</center>\n\nProperties文件是继承与Hashtable，Properties文件中存储数据方式就是以【key-value键值对】进行，对这个文件操作是将需要使用数据存储在value中，提供key可以访问外界访问到key获取到需要value值\n\nProperties文件是可以通过代码进行创建，也可以在外界直接创建这个文件但是文件后缀名必须【.properties】这个文件被称之为资源文件，可以向这个文件中提供一些常用的配置信息【JDBC链接信息，Spring的配置信息、SpringBoot配置信息】等等，这个文件默认编码集是ISO-8859-1，所以不支持使用代码的形式创建文件中出现中文，如果出现中文是以Unicode码进行展示的。直接创建文件是支持写入中文但是要以注释形式存在\n\n**案例：使用流方式来创建Properties文件**\n\n```java\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.InputStreamReader;\nimport java.util.Properties;\npublic class PropertiesFileDemo \n{\n    public static void main(String[] args)throws Exception\n    {\n        //在控制台上获取一些数据，存储在properties文件中\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        //文件后缀名字必须是.properties\n        BufferedWriter bw = new BufferedWriter(new FileWriter(\"dir/config.properties\"));\n        //1.提供Properties对象的创建\n        Properties p = new Properties();\n        //循环获取到控制台输入的数据\n        while(true)\n        {\n            System.out.println(\"请输入key值：\");\n            String key = br.readLine();\n            //当key值获取到over的时候停止循环操作\n            if(\"over\".equals(key))\n            {\n                break;\n            } \n            System.out.println(\"请输入value值：\");\n            String value = br.readLine();\n            //调用Properties中方法将key-value键值对存储到 Properties对象中\n            p.setProperty(key,value);\n        } \n        //将存储在Properties对象中数据写入到文件中，properties文件中 #号是注释的意思\n        /*\n            store方法需要传递输出流对象【字符或字节都可以】\n            第二个参数是 注释--》通过代码写出文件中文是无法正确展示的，所以建议使用英文\n        */\n        p.store(bw,\"我是注释!!!\");\n        bw.close();\n        br.close();\n    }\n}\n```\n\n案例：使用流读取Properties文件【常用】\n\n```java\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.Properties;\n//读取资源文件的工具类\npublic class PropertiesUtil \n{\n    //1.提供一个私有静态Properties对象获取文件中数据\n    private static Properties properties;\n    //2.加载文件操作一般都会提前加载，而不是当用户使用到时候在加载\n    static    //使用静态代码块进行资源加载，只会执行一次不会出现重复加载问题\n    { \n        \n        properties = new Properties();\n        /*\n            调用load方法加载资源文件，将资源文件中内容读取到properties对象中\n            这个方法参数既可以是字节流也可以是字符流\n            这个操作会存在编译时异常，static静态代码块中是不能throws，只能try-catch\n        */\n        try \n        {\n            properties.load(new FileInputStream(\"dir/config.properties\"));\n        } \n            catch (IOException e) \n        {\n            System.out.println(\"资源文件加载失败，无法加载：\"+e.getMessage());\n        }\n    }\n    /*\n        提供一个方法可以获取Properties资源文件中值\n    */\n    public static String getValue(String key)\n    {\n        //通过key值获取到vlaue值        \n        return properties.getProperty(key);\n    }\n} \n\nimport java.util.Scanner;\npublic class Test \n{\n    public static void main(String[] args) \n    {\n        Scanner input = new Scanner(System.in);\n        System.out.println(\"获取用户名字请输入username:\");\n        String username = input.next();\n        String value = PropertiesUtil.getValue(username);\n        System.out.println(\"用户名：\"+value);\n    }\n}\n```\n\n总结Properties核心方法：\n\n1. 创建对象---》new Properties();\n2. 存储key和value键值对 ---》setProperty(key,value)\n3. 创建Properties文件 ---》 store(字节或字符输出流对象，\"文件内容注释\")\n4. 读取Properties文件 ---》 load(字节或字符输入流对象)\n5. 获取value值 ---》 getProperty(key)\n\n## <center>4、序列化和反序列化【对象流】</center>\n\n序列化和反序列化？\n\n&ensp;&ensp;&ensp;&ensp;**对象序列化** : **把一个【对象转换二进制数据】这种方式称之为序列化**，序列化之后对象可以方便实现对象【**存储与传输**】\n\n**&ensp;&ensp;&ensp;&ensp;对象反序列化**：**把一个【二进制数据转换成对象】这种方式称之为反序列化**,通过反序列化操作就可以得到存储在文件中对象内的数据了\n\n**Serializable接口**\n\n&ensp;&ensp;&ensp;&ensp;如果需要将某个对象进行序列化操作，那么这个对象描述类就需要实现**Serializable接口**，这样才可以允许对当前对象进行序列化和反序列化\n\n&ensp;&ensp;&ensp;&ensp;API文档中对Serializable接口的说明： 类通过实现java.io.Serializable 接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。可序列化类的所有子类型本身都是可序列化的。序列化接口没有方法或字段，仅用于标识可序列化的语义\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012018417.png\" alt=\"兼容问题\" style=\"zoom:50%;\" />\n\n### （1）对象字节输入输出流\n\n使用对象字节输入流读取文件称之为【反序列化】，从磁盘文件中将对象读取到内存使用是【ObjectInputStream】\n\n使用对象字节输出流写出文件称之为【序列化】，从内存将对象写入到文件中使用是【ObjectOutputStream】\n\n**ObjectOutputStream常用构造方法和常用方法**\n\n|        |                         常用构造方法                         |\n| :----: | :----------------------------------------------------------: |\n| public | ObjectOutputStream(OutputStream out)创建一个对象写入到指定的输出流，参数需要是一个字节输出流对象 |\n\n|      |                           常用方法                           |\n| :--: | :----------------------------------------------------------: |\n| void | writeObject(Object obj) 将对象写入到对象流中【对象的序列化】 |\n\n因为需要将对象序列化到文件中所以构造方法中需要提供字节输出流对象，配套使用是FileOutputStream，核心方法就是序列化对象，所以使用writeObject方法，还支持很多其他的写入方法，但是使用较少，支持关闭和刷新流\n\n**ObjectInputStream常用的构造方法和常用方法**\n\n```java\n常用构造方法\npublic ObjectInputStream(InputStream in)\n创建一个对象输入流读取从指定的输入流，参数需要一个字节输入流对象\n常用方法\nObject readObject() 从对象输入流读取对象【反序列化】 \n读取的是文件中内容，所以参数需要一个字节输入流对象，匹配使用是FileInputStream，核心方法就是反序列化对象，\n所以使用readObject这个方法，特别注意返回值类型时Object，这个流也需要关闭\n```\n\n案例：单个对象序列和反序列化操作\n\n```java\nimport java.io.Serializable;\npublic class Student implements Serializable \n{\n    private String name;\n    private int age;\n    public Student() \n    {\n    } \n    public Student(String name, int age) \n    {\n        this.name = name;\n        this.age = age;\n    } \n    public String getName() \n    {\n        return name;\n    }\n    public void setName(String name) \n    {\n        this.name = name;\n    }\n    public int getAge() \n    {\n        return age;\n    } \n    public void setAge(int age) \n    {\n        this.age = age;\n    } \n    @Override\n    public String toString() \n    {\n        return \"Student{\" +\n        \"name='\" + name + '\\'' +\n        \", age=\" + age +\n        '}';\n    }\n} \n\nimport java.io.*;\npublic class Test \n{\n    public static void main(String[] args) throws Exception \n    {\n        //java.io.NotSerializableException: com.qfedu.serializable.Student\n        //出现这个异常原因是因为没有实现：Serializable接口\n        // Student student = new Student(\"成龙\",68);\n        // serializableObject(student);\n        deSerializableObject();\n    } \n    /* \n        对象序列化操作\n    */\n    public static void serializableObject(Student student) throws Exception \n    {\n        //1.创建序列化对象的流对象\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"dir/序列化单个对象的文件\"));\n        //2.代用writeObject方法进行序列化操作\n        oos.writeObject(student);\n        System.out.println(\"序列化成功！\");\n        oos.close();\n    } \n    /* \n        对象反序列化操作\n    */\n    public static void deSerializableObject() throws Exception \n    {\n        //1.提供反序列化流对象\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"dir/序列化单个对象的文件\"));\n        //2.调用readObject方法反序列化操作\n        Object o = ois.readObject();    //这个方法返回值是Boject类型，如果需要对数据进行具体化操作需要对象向下转型\n        System.out.println(\"验证o对象是否是Student类型：\"+(o instanceof Student));\n        System.out.println(o);\n    }\n}\n```\n\n案例：多个对象序列化和反序列化【创建5个Student对象进行序列化和反序列化操作要求在同一个文件中（一个文件5个对象）】\n\n```java\nimport java.io.*;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n//多个对象序列化与反序列化操作\npublic class Test2 \n{\n    public static void main(String[] args) throws Exception \n    {\n        List<Student> list = new ArrayList<>();\n        Collections.addAll(list, new Student(\"张三1\",19),new Student(\"张三2\",20), new Student(\"张三3\",21),\n                           new Student(\"张三4\",22), new Student(\"张三5\",23),null);//追加null就是结尾证明没有数据了\n        //serializableMoreObject(list);\n        //deSerializableMoreObject();\n        // --------------------------------------------------\n        //serializableMoreObject2(list);\n        deSerializableMoreObject2();\n    } \n    //提供第一个处理方式\n    public static void serializableMoreObject(List<Student> list) throws Exception \n    {\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"dir/多个对象序列化文件\"));\n        //此时要序列化操作，但是现在所有的对象都是存在List集合中，所以直接序列化集合即可\n        //这个操作只是取巧，不是多个对象序列化， 只是序列化了一个List集合对象\n        oos.writeObject(list);\n        oos.flush();\n        oos.close();\n    } \n    //\n    public static void deSerializableMoreObject() throws Exception \n    {\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"dir/多个对象序列化文件\"));\n        //readObject这个方法的返回值是Object类型，所以需要操作数据时需要向下转型\n        List<Student> stus = ((List<Student>)ois.readObject());\n        for (Student student : stus) \n        {\n            System.out.println(student);\n        }\n    }\n    //----------------------------------------------------------------------------------------------\n    //第二种序列化和反序列化方式\n    public static void serializableMoreObject2(List<Student> list) throws Exception \n    {\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"dir/多个对象序列化文件2\"));\n        //此时要序列化操作，但是现在所有的对象都是存在List集合中，需要从集合中获取所有对象\n        for (Student student : list) \n        {\n            oos.writeObject(student); //这样才是5对象序列化\n        } \n        oos.flush();\n        oos.close();\n    }\n\n    public static void deSerializableMoreObject2() throws Exception \n    {\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"dir/多个对象序列化文件2\"));\n        //提供一个集合存储读取对象数据\n        List<Student> stus = new ArrayList<>();\n        /*\n            readObject这个方法的返回值是Object类型，所以需要操作数据时需要向下转型\n            因为文件中存储的5个对象，如果对象么有值使用什么代表--》null值\n            利用这个原则进行数据读取操作\n        */\n        Object obj = null;\n        /*\n            使用这种读取方式readObject提示一个EOFException含义\n            此异常主要被数据输入流用来表明到达流的末尾\n            证明是争取读取到文件中每一个数据并且读取到文件末尾，才会出现这个异常\n            在while循环中提供判断是无法生效，它是无法获取到文件末尾的null，即没有这个null\n            只能以异常形式停止，所以如何处理这个问题，会在集合存储的最后一个位置添加一个null作为结尾\n        */\n        while((obj = ois.readObject())!=null)\n        {\n            stus.add(((Student)obj));\n        }\n        /* \n            while(true)\n            {\n                try \n                {\n                    obj = ois.readObject();\n                    stus.add(((Student)obj));\n                } \n                catch (EOFException e) \n                {\n                    break;\n                }\n            }\n        */\n        ois.close();\n        stus.forEach(System.out::println);\n    }\n}\n```\n\n","tags":["Java"],"categories":["编程语言","Java"]},{"title":"22.File类和递归","url":"/post/8f9052f9.html","content":"\n# <center>知识点一：File类</center>\n\nFile类是Java中专门提供给代码进行对文件系统中【操作系统】文件夹或文件进行操作的类，这个File类中提供【创建、删除、重命名、判断文件状态、检查文件的属性】等等功能，就可以通过File对象将系统中文件或文件夹以，面向对象的方式进行操作，File类只能对文件进行管理操作，对于文件内容存储数据File类是无法进行操作\n\nFile类就是Java中表示系统文件或系统文件夹的一个抽象，可以提供一个【路径】将路径所描述文件或文件夹具体化，并且提供File类中给提供方法对文件或文件进行操作\n\nPS：建议尽量不在C盘判断进行操作，极少部分电脑对C盘操作是需要\n\n权限【管理员权限】\n\n文件和文件夹路径和问题？\n\n操作系统中文件或文件夹的路径分为两种**\"绝对路径\"和”相对路径\"**\n\nPS:这里以windows系统为例：\n\n**绝对路径： 是从系统盘符开始路径是绝对路径**【在开发尽量少用】\n\nwindows系统中对绝对路径的路径分隔符号是【\\】\n\n```java\nC:\\File类\\笔记 --》绝对路径\n```\n\n这里问题在于，在Java代码中【\\】是转义字符，针对\\后的字母进行转义操作，所以为了避免提供绝路径出现歧义在编写代码的时候如果提供绝对路径，路径分隔符要写成【\\\\】\n\n```java\nC:\\\\File类\\\\笔记 --》这样代码才可以读取这个绝对路径\n```\n\nJava为了减少程序猿书写路径麻烦，Java会仿照Unix或Linux系统中提供路径分隔符进行路径分隔操作，提供是【/】 --》 得到路径是 --》/Users/jkmaster，即将绝对路径修改为\n\n```java\nC:/File类/笔记 --》这样代码才可以读取这个绝对路径 此时【/】 等价于 【\\\\】\n```\n\nPS：windows系统是可以兼容使用Unix或Liunx路径分隔符号，但是Unix或Liunx是不兼容windows的路径分隔符号\n\n例如： 提供一个Linux文件系统根路径\n\n```java\n/Users/jkmaster/app/File类/笔记 ---》 Linux路径但是不可以这样写\n\\\\Users\\\\jkmaster\\\\app\\\\File类\\\\笔记 --->错误无法读取\n```\n\n**相对路径：主要针对的服务器或IDEA编译工具的路径作为参考路径，从而形成路径就是相对路径**\n\nPS: 相对路径是不区分操作系统\n\n以工程中类文件作为参考进行文件路径拷贝操作\n\n```java\n绝对路径--》C:\\IdeaProjects\\File\\src\\com\\qfedu\\FileAPI\\FileAPIDemo.java\n```\n\n以工程中类文件作为参数进行文件路径的拷贝操作\n\n```java\n相对路径：src/com/qfedu/FileAPI/FileAPIDemo.java\n```\n\n相对路径的提供必须有一个路径参考存在，不能随意提供相对路径，相对路径参考必须是一个真实存在路径，相对路径是在有绝对路径前提下提供，所以必须提供一个参考，**在IDEA编译器工程中提供相对路径参考就是IDEA工程**\n\n```java\n不可以在代码中这样提供相对路径\n提供一个绝对的路径：\n\tString path = \"C:\\\\abc\\123\\\\456\";    //不是真实的路径\n\tString path2 = \"file.txt\"; //file.txt参考是path路径，这样完全错误\n```\n\n**相对路径在什么位置提供针对的就是谁在进行参考**\n\nPS：项目中是可以读取绝对路径，但是针对网络中读取本地的【视频或音频文件或图片】\n\n&ensp;&ensp;&ensp;&ensp;本地读取文件【操作系统】使用盘符，但是从服务端读取  http://IP地址：端口号/文件路径\n\n## <center>1、File类中常用方法</center>\n\n```java\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Date;\npublic class FileAPIDemo \n{\n    public static void main(String[] args) \n    {\n        //提供文件路径【文件路径分隔符号】\n        separator();\n        //通过封装File对象获取文件或文件夹路径\n        showPath();\n        //检查文件或文件夹的状态\n        checkFileState();\n        //文件操作[记住]\n        operationFile();\n        //文件夹操作[记录]\n        operationDirectory();\n    } \n    \n    private static void operationDirectory() \n    {\n        File file = new File(\"C:\\\\123\\\\456\\\\789\");\n        System.out.println(\"判断file对象中是否存在文件夹：\"+file.exists());\n        System.out.println(\"判断file是否是文件夹：\"+file.isDirectory());\n        //file.mkdir(); //创建文件夹【只能创建一个】\n        file.mkdirs();    //同时创建多个文件夹\n        //获取文件夹下所有文件或文件夹路径【String类型路径】\n        String[] list = file.list();\n        //获取文件夹下所有文件或文件夹路径【File类型对象】\n        File[] files = file.listFiles();\n        //提供系统所有盘符\n        File[] files1 = File.listRoots();\n    }\n    \n    private static void operationFile() \n    {\n        //File对象另外的创建方式\n        /*\n            提供父子路径进行拼接操作\n            第一个参数是 父路径 ---》 一般是一个文件夹路径\n            参数类型可以是一个File对象，也可以是String类型对象\n            第二个参数是 子路径 ---》 一般是文件或文件夹路径\n            参数类型可以是一个File对象，也可以是String类型对象\n            子路径是不需要提供开始路径分隔符号：即 456.txt即可 无需\n            \\\\456.txt\n        */\n        File file = new File(\"C:\\\\abc\\\\xxx\\\\123\",\"456.txt\");\n        //1. 判断file对象是否是文件\n        System.out.println(file.isFile());\n        //2. 判断文件或文件夹是否存在\n        System.out.println(file.exists());\n        //提供一个判断操作，判断文件是否存在\n        if(!file.exists())\n        {\n            try \n            {\n                file.createNewFile();//创建新的文件\n            } \n            catch (IOException e) \n            {\n                System.out.println(\"文件创建失败：\"+e.getMessage());\n            }\n        }\n        else\n        {\n            //删除文件\n            file.delete();\n            //集【移动复制剪切粘贴重命名】与一身的方法\n            // file.renameTo(new File(\"需要将文件或文件夹到什么\n            位置路径【移动路径中可以修改文件名字】\"));\n        }\n    } \n    \n    private static void checkFileState() \n    {\n        //File对象中是一个文件\n        File file = new\n        File(\"C:\\\\abc\\\\xxx\\\\123\\\\456.txt\");\n        System.out.println(\"文件是否可读：\"+file.canRead());\n        System.out.println(\"文件是否可写：\"+file.canWrite());\n        //这个方法主要是针对Linux和Unix系统文件 --》 系统文件是有三个符号表文件状态 r【读】w【写】x【执行】\n        //在windows中效果不是很明显\n        System.out.println(\"文件是否可执行：\"+file.canExecute());\n        System.out.println(\"判断文件是否是隐藏文件：\"+file.isHidden());\n        System.out.println(\"获取文件最后修改时间：\" + new Date(file.lastModified()));\n        //文件大小是根据存储内容大小决定\n        System.out.println(\"文件的大小：\" + file.length() + \"字节\");\n    } \n    \n    private static void showPath() \n    {\n        //1. File类创建对象的方式，以字符串为参数进行路径传入即可\n        【绝对路径或相对路径】\n        //通过文件路径将456.txt这个文件封装到File这个对象中，通过\n        File对象就可以对这个文件进行操作\n        File file = new File(\"C:\\\\abc\\\\xxx\\\\123\\\\456.txt\");\n        System.out.println(file);    //重写toString方法打印的是存储的路径\n        //(了解) ---> 获取文件绝对路径【返回值类型时File】\n        System.out.println(file.getAbsoluteFile());\n        //(了解) ---> 获取文件绝对路径【返回值类型是String】\n        System.out.println(file.getAbsolutePath());\n        //(了解) ---> 获取当前路径的上一级路径【返回值类型是 String】\n        System.out.println(file.getParent());\n        //(了解) ---> 获取当前路径的上一级路径【返回值类型是File】\n        System.out.println(file.getParentFile());\n        //(知道) ---> 获取文件路径\n        System.out.println(file.getPath());\n        // (记住) ---> 获取文件的名字\n        System.out.println(file.getName());\n    }\n    private static void separator()\n    {\n        //除了数据类型一样之外，剩下完全相同根据不同操作系统动态变化分隔符号\n        System.out.println(File.separator);    //String类型分隔符号\n        System.out.println(File.separatorChar);    //char类型分隔符号\n    }\n}\n```\n\n# <center>知识点二：递归</center>\n\n递归是方法一种【自身调用自身的一种方式】\n\n递归调用时是一种特殊的调用形式，是方法自己调用自己即一个方法内部调用方法本身，这种方式被称之为递归，方法递归包含了一个隐式循环，它会重复执行某段代码，但是这个重复执行操作需要加以控制，否则就会出现\"栈溢出错误\n\n\"递归的本身执行效率极高【在同时间内容所有资源都被递归所调用执行操作】，在开发中提供递归操作是需要特别注意\n\n如何理解递归操作？\n\n通俗：从前有座山，山里有座庙，庙里有一个老和尚和小和尚，老和尚在给小和尚讲故事，从前有座山，山里有座庙.....【小和尚睡着（递归的停止条件）】\n\n**递归的必要原则：一定要提供一个递归的停止点，如何让递归正确停止下来**\n\n```java\npublic class MethodDemo \n{\n    public static void main(String[] args) \n    {\n        //StackOverflowError show方法并没有正确停止方式，所以在栈中会堆积大量的show调用\n        //必须注意正确停止递归，不要出现StackOverflowError错误停止递归【JVM虚拟机停止了】\n        show();\n    }\n    public static void show()\n    {\n        show(); //这就是递归【在show方法的内容调用自身show方法\n    }\n}\n```\n\n需求： 使用递归的方式计算1~5之间所有数据之和\n\n```java\npackage com.qfedu.File;\npublic class MethodDmo2 \n{\n    public static void main(String[] args) \n    {\n        //正常解题\n        int sum = 0;\n        for (int i = 1; i <= 5; i++) \n        {\n            sum += i;\n        } \n        System.out.println(sum);\n        //既然可以这样计算，也可以提供循环\n        int sum1 = 0;\n        for (int i = 5; i >= 1; i--) \n        {\n            sum1 += i;\n        } \n        System.out.println(sum1);\n        int i = ToSum(5);\n        System.out.println(i);\n} \n    //当我们需要计算1~某个数字之间所有数据之和的时候1是确定值，也就是计算的最后一个位置也是开始的位置\n    /*\n        提供一个方法，方法可以帮组累加计算 参数num就是需要累加到数据位置\n    */\n    public static int ToSum(int num)\n    {\n        if (num == 1)\n        {\n            return 1;    //当得到1的时候，证明计算到最后一个值\n        }\n        else \n        {\n            return num + ToSum(num - 1);    //形成递归\n            /*\n                第一次调用ToSum方法时 ，参数是 5 执行 num == 1 不等于 执行 num+ToSum(num-1);\n                即 5+ ToSum(5-1) 再次触发 ToSum调用\n                第二次调用ToSum方法时 ，参数是(5-1) 执行 num == 1不等于 执行 num+ToSum(num-1)\n                即 4+ToSum(4-1) 再次触发 ToSum调用\n                第三次调用ToSum方法时 ，参数是(4-1) 执行 num == 1不等于 执行 num+ToSum(num-1)\n                即 3+ToSum(3-1) 再次触发 ToSum调用\n                第四次调用ToSum方法时 ，参数是(3-1) 执行 num == 1不等于 执行 num+ToSum(num-1)\n                即 2+ToSum(2-1) 再次触发 ToSum调用\n                第五次调用ToSum方法时 ，参数是(2-1) 执行 num == 1等于 方法执行return 1\n                就会返回给第四次调用 2+ToSum(2-1) 作为ToSum方法的返回值获取 即 2+1 = 3\n                3这个结果值就会返回第三调用3+ToSum(3-1)作为ToSum方法的返回值获取 即3+3 = 6\n                6这个结果值就会返回第二调用4+ToSum(4-1)作为ToSum方法的返回值获取 即4+6 = 10\n                10这个结果值就会返回第一次调用5+ToSum(5-1)作为ToSum方法的返回值获取 即 5+10 = 15\n            */\n        }\n    }\n}\n```\n\n需求: 有6个人， 第6个人说 比 第5个人大3岁，第5个人说 比 第4个人大3岁，第4个人说 比 第3个人大3岁，第3个人说 比 第2个人大3岁，第2个人说 比 第1个人大3岁，第1个人说自己13岁，问第6个人多大\n\n```java\n//提供一个计算年龄递归方法，参数是int类型，n代表的是人数\npublic static int sumAge(int n)\n{\n    if(n == 1)    //最后一个人的时候年龄是13\n    { \n        return 13;\n    }\n    else\n    {\n        return sumAge(n-1)+3;\n    }\n}\n```\n\n# <center>1、总结</center>\n\n```java\n\"1. 写递归必须要有结束点【递归的停止】，否则会出现\nStackOverflowError栈溢出错误【终止递归】\"\n\"2. 明确这个方法的重复做什么事情，是否有重复做事情的条件，是否可\n以重复做到事情\"\n\"3. 简单递归都是使用【循环解决】，但是深层次的递归是无法使用循环\n替代的\"\n\"4. 一般项目中书写递归一定要慎重，一般递归出现在于无法使用循环解\n决操作或是进行执行效率优化时\"\n```\n\n进阶案例演示：遍历操作系统中某个盘符，获取判断中所有文件夹和文件夹信息，打印层级\n\n```java\nimport java.io.File;\nimport java.util.Objects;\n//使用递归遍历盘符下所有信息\npublic class FileLoopDemo \n{\n    public static void main(String[] args) \n    {\n        //1.提供一个File对象进行路径封装\n        File file = new File(\"C:\\\\\");\n        showLayers(file,0);\n    } \n    /**\n    * 提供遍历盘符方法\n    * @param file 封装盘符的对象\n    * @param level 等级\n    * 0是最高级别，依次递增，主要是为了提供层级拼接效果使用\n    */\n    private static void showLayers(File file, int level) \n    {\n        //1.创建一个字符串构建器进行层级拼接\n        StringBuilder bs = new StringBuilder(\"|--\");\n        for(int i = 0 ; i<level;i++)\n        {\n            bs.insert(0,\"|\");\n        }\n        //2.判断是文件夹还是文件，如果是文件就停止访问\n        File[] files = file.listFiles();\n        if (Objects.isNull(files))\n        {\n            return;\n        } \n        //判断 files数组中存储的是文件还是文件夹\n        for (File tempFile : files)\n        {\n            //先获取名字然后再进行判断操作\n            System.out.println(bs.toString().concat(tempFile.getName()));\n            //如果是目录，继续查找目录中数据\n            if(tempFile.isDirectory())\n            {\n                showLayers(tempFile,level+1);\n            }\n        }\n    }\n}\n```\n\n","tags":["Java"],"categories":["编程语言","Java"]},{"title":"21.异常","url":"/post/a24af109.html","content":"\n# <center>知识点一：概念</center>\n\n程序在运行的过程出现的错误，称之为异常\n\n# <center>知识点二：异常处理的重要性</center>\n\n如果异常不处理，那么就会终止java虚拟机的运行。意味着出现异常后面的代码就不会再执行了\n\n```java\n//程序出现异常，但是没有处理\nSystem.out.println(10/0);\nSystem.out.println(\"处理了么\");     //不会运行\n```\n\n# <center>知识点三：异常的分类</center>\n\n- Throwable (异常的父类)\n  - Error(错误) 内存溢出、硬件等等(程序员无法通过程序解决)\n  - **Exception**(异常)\t\t需要程序处理\n    - **运行期**异常(未检查) \t程序运行期间出现的异常\t\t**RuntimeException**\n    - **不是必须处理**\n      - 举例：空指针异常、类转换异常、数组下标越界异常、输入异常、下标越界异常等\n    - **编译期**异常 (受检)\t\t程序在编译期间出现的异常\t**Exception**\n    - **必须处理**\n      - 举例：ParseException InterruptedException等\n\n# <center>知识点四：异常处理</center>\n\n## <center>1、捕获异常(主动处理)</center>\n\ntry、catch、finally\n\n**语法**\n\n```java\ntry\n{\n    可能会出现异常的代码\n}\ncatch(要捕获的异常类型1 变量名)\n{\n    如果出现对应异常所执行的代码\n}\ncatch(要捕获的异常类型2 变量名 )\n{\n    如果出现对应异常所执行的代码\n}...\n```\n\ncatch需要注意的点\n\n&ensp;&ensp;&ensp;&ensp;（1）catch中捕获的异常类型必须要与出现异常的类型要一致(大于等于)，否则相当于没有处理异常\n\n&ensp;&ensp;&ensp;&ensp;（2）catch中的异常类型可以捕获多个,注意：捕获异常的顺序是从小到大\n\n&ensp;&ensp;&ensp;&ensp;（3）捕获异常的时候，可以捕获最大的异常Exception\n\nfinally的特点\n\n&ensp;&ensp;&ensp;&ensp;（1）无论代码是否出现异常，都会执行finally中的代码\n\n&ensp;&ensp;&ensp;&ensp;（2） 一般在finally写释放资源的代码\n\n&ensp;&ensp;&ensp;&ensp;（3）如果方法中出现return关键字，finally依旧会执行.（但是如果调用System.exit(0);那么finally不会再执行）\n\ntry catch finally使用语法\n\n&ensp;&ensp;&ensp;&ensp;try{...}catch(){..} 一起使用\n\n&ensp;&ensp;&ensp;&ensp;try{...}catch(){..}catch(){..} 一起使用\n\n&ensp;&ensp;&ensp;&ensp;try{...}finally{....} 一起使用\n\n&ensp;&ensp;&ensp;&ensp;try{...}catch(){..}catch(){..}finally{....} 一起使用\n\n&ensp;&ensp;&ensp;&ensp;不能单独使用\n\n捕获异常 代码执行的顺序\n\n先执行try中的代码\n\n&ensp;&ensp;&ensp;&ensp;（1）没有异常，正常执行完整个程序\n\n&ensp;&ensp;&ensp;&ensp;（2）有异常 ,就会执行对应catch语句块。而try后面的代码就不会执行了\n\n```java\npublic class ExceptionDemo\n{\n    public static void main(String[] args)\n    {\n        //如果要对不同异常要做不同处理，则用这种形式\n//        try\n//        {\n//            //try中放可能会出现错误的代码\n//            String[] names = {\"jack\",\"rose\"};\n//            System.out.println(names[3]);\n//            String s = null;\n//            System.out.println(s.length());\n//        }\n//        catch (NullPointerException e)\n//        {\n//            //一定一定记住!!!     无论如何要把错误信息打印出来\n//            e.printStackTrace();    //打印异常信息\n//            System.out.println(\"当出现空指针异常的时候会执行这里代码\");\n//        }\n//        catch (ArrayIndexOutOfBoundsException e)\n//        {\n//            e.printStackTrace();\n//            System.out.println(\"出现数组下标越界异常的时候会执行这里代码\");\n//        }\n//        System.out.println(\"这里代码会执行么？？？\");\n\n        //如果不需要分别处理不同异常，则用这种形式\n//        try\n//        {\n//            //try中放可能会出现错误的代码\n//            String[] names = {\"jack\",\"rose\"};\n//            System.out.println(names[3]);\n//            String s = null;\n//            System.out.println(s.length());\n//        }\n//        //Exception:无论啥异常，都可以捕获那个最大异常\n//        catch (Exception e)  //写异常时要从小异常写到大异常\n//        {\n//            //一定一定记住!!!     无论如何要把错误信息打印出来\n//            e.printStackTrace();    //打印异常信息\n//            System.out.println(\"当出现异常的时候会执行这里代码\");\n//        }\n//        System.out.println(\"这里代码会执行么？？？\");\n\n        try\n        {\n            //try中放可能会出现错误的代码\n            String[] names = {\"jack\",\"rose\"};\n            System.out.println(names[1]);\n            String s = null;\n            System.out.println(s.length());\n        }\n        catch (Exception e)\n        {\n            //一定一定记住!!!     无论如何要把错误信息打印出来\n            e.printStackTrace();    //打印异常信息\n            System.out.println(\"当出现异常的时候会执行这里代码\");\n            //return; //finally执行\n            System.exit(0); //jvm结束，finally不会执行\n        }\n        finally     //无论try、catch结构是否报错都会执行\n        {\n            //一般用于写释放资源的代码\n            System.out.println(\"这是finally中的代码\");\n        }\n        System.out.println(\"这里代码会执行么？？？\");\n    }\n}\n```\n\n## <center>2、抛出异常(被动处理)</center>\n\n### （1）在方法上声明 throws\n\n语法： public void show() throws 异常的类型1,异常的类型2{}\n\n特点:\n\n&ensp;&ensp;&ensp;&ensp;1）如果在方法上声明异常，那么方法的调用者就要进行处理\n\n&ensp;&ensp;&ensp;&ensp;2）如果异常声明在了main方法上，实际上就是给jvm处理(那就是没有处理)\n\n&ensp;&ensp;&ensp;&ensp;3）声明异常可以声明多个\n\n场景：\n\n&ensp;&ensp;&ensp;&ensp;1）当前无法对异常进行处理的时候，就可以把异常抛给方法的调用者。\n\n&ensp;&ensp;&ensp;&ensp;2）现在如果代码出现异常(直接try、catch)\n\n特殊案例：\n\n&ensp;&ensp;&ensp;&ensp;如果在main方法上声明(抛出)异常,那么这个异常就叫给了main 方法的调用者。而main方法的调用者是jvm，所以这个异常并没有处理\n\n### （2）在方法内部抛出 throw\n\n语法： throw 异常对象;\n\n特点:\n\n&ensp;&ensp;&ensp;&ensp;1）如果抛出运行期异常，那么直接抛出即可\n\n&ensp;&ensp;&ensp;&ensp;2）如果抛出编译期异常，那么需要在方法上声明抛出\n\n场景：\n\n&ensp;&ensp;&ensp;&ensp;一般写框架的时候，设计\n\n```java\npublic class ExceptionDemo02\n{\n    public static void main(String[] args) throws ParseException\n    {\n        //调用者需要处理这个异常\n//        m1();   //如果调用者继续抛出，则这个异常没有处理\n//        System.out.println(\"这个代码会执行么？？\");\n\n        //调用者\n        try\n        {\n            m2(\"admin\",\"123456\");\n            System.out.println(\"进入到首页\");\n        }\n        catch (Exception e)\n        {\n            e.printStackTrace();\n            System.out.println(\"返回到登陆页面\");\n        }\n    }\n\n    //不知道怎么处理异常时\n    public static void m1() throws ParseException   //抛出异常\n    {\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyy-MM-dd\");\n        //快捷方式：alt+enter\n        sdf.parse(\"2022/03/29\");\n    }\n\n    //一些大型框架都是抛出，让调用者解决异常\n    public static void m2(String username,String passward) throws Exception\n    {\n        if (!username.equals(\"admin\") || !passward.equals(\"123456\"))\n        {\n            //主动抛出异常\n            //语法：throw 异常对象\n            throw new Exception(\"用户或密码错误\"); //编译期异常\n\n        }\n    }\n}\n```\n\n**总结**\n\n&ensp;&ensp;&ensp;&ensp;1）运行期异常，一般不需要处理，可以利用逻辑判断解决(避免)\n\n&ensp;&ensp;&ensp;&ensp;2）编译期异常，必须要解决 现在如果代码出现异常(现阶段直接try、catch)\n\n## <center>3、自定义异常</center>\n\n（1）自定义运行时异常\n\n&ensp;&ensp;&ensp;&ensp;写一个类继承自RuntimeException\n\n&ensp;&ensp;&ensp;&ensp;编写有参和无参构造方法\n\n（2）自定义编译期异常\n\n&ensp;&ensp;&ensp;&ensp;写一个类继承自Exception\n\n&ensp;&ensp;&ensp;&ensp;编写有参和无参构造方法\n\n应用场景：\n\n&ensp;&ensp;&ensp;&ensp;（1）一般在系统的异常无法满足自己公司需求的时候会自定义异常。\n\n&ensp;&ensp;&ensp;&ensp;（2）自定义异常一般和throw抛出一起配合使用\n\n```java\npublic class UsernameAndPasswardException extends Exception //编译期异常\n{\n    //构造一个无参和一个参数的函数\n    public UsernameAndPasswardException()\n    {\n        super();    //调用父类\n    }\n\n    public UsernameAndPasswardException(String message)\n    {\n        super(message);\n    }\n}\n```\n\n```java\npublic class ExceptionDemo02\n{\n    public static void main(String[] args) throws ParseException\n    {\n        //调用者\n        try\n        {\n            m2(\"adm\",\"123456\");\n            System.out.println(\"进入到首页\");\n        }\n        catch (Exception e)\n        {\n            e.printStackTrace();\n            System.out.println(\"返回到登陆页面\");\n        }\n    }\n    public static void m2(String username,String passward) throws Exception\n    {\n        if (!username.equals(\"admin\") || !passward.equals(\"123456\"))\n        {\n            //主动抛出异常\n            //语法：throw 异常对象\n            throw new UsernameAndPasswardException(\"用户或密码错误\"); //编译期异常\n        }\n    }\n}\n```\n\n继承中方法的重写\n\n&ensp;&ensp;&ensp;&ensp;子类重写父类的方法，不能抛出比父类更大、更多的编译器异常\n\n```java\npublic class Father\n{\n    public void hello() throws ParseException\n    {}\n}\n```\n\n```java\npublic class Son extends Father\n{\n    /**\n     * 子类不能抛出父类更多更大的编译期异常\n     * 子类抛出的异常不能比父类的大，且抛出异常的个数不能超过父类抛出异常的个数\n     */\n    @Override\n    public void hello() throws ParseException\n    {\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyy-MM-dd\");\n        sdf.parse(\"2022-03-23\");\n    }\n}\n```\n\n## <center>4、File类</center>\n\n### 概念\n\n表示操作系统磁盘上的文件或者是文件夹\n\n路径：\n\n&ensp;&ensp;&ensp;&ensp;相对路径 （相对于当前工程的跟路径）\n\n&ensp;&ensp;&ensp;&ensp;绝对路径 (在磁盘上的完整路径)\n\n### 对象的创建\n\n```java\npublic class FileDemo\n{\n    public static void main(String[] args)\n    {\n        //创建File对象\n        //参数：文件或文件夹路径(绝对路径)，第一种构建方式\n        File file1 = new File(\"d:\\\\a.txt\"); //表示的是一个文件\n        File file2 = new File(\"d:\\\\zz\");    //表示的是文件夹\n\n        //第二种构建方式\n        //参数1：父目录的路径(字符串) 参数2：子目录的路径\n        File file3 = new File(\"d:\",\"b.txt\");\n\n        //第三种构建方式\n        //参数1：父目录(file对象) 参数2：子目录路径\n        File file4 = new File(file2,\"c.txt\");\n\n        //参数:文件或者文件夹(相对路径:相对于当前工程)\n        File file5 = new File(\"d.txt\");\n    }\n}\n```\n\n### 常见方法\n\n| 方法名            | 描述                                         |\n| ----------------- | -------------------------------------------- |\n| createNewFile()   | 创建一个新文件                               |\n| mkdir()           | 创建一个新目录。如果父目录不存在，则无法创建 |\n| mkdirs()          | 创建一个新目录。如果父目录不存在，则一起创建 |\n| delete()          | 删除文件或空目录                             |\n| exists()          | 判断File对象所对象所代表的对象是否存在       |\n| length()          | 获取文件(夹)的大小(字节)                     |\n| getAbsolutePath() | 获取文件的绝对路径                           |\n| getAbsoluteFile() | 获取文件(夹)的绝对路径:（返回File）          |\n| getName()         | 获取当前file对象的文件名或者是文件夹名       |\n| getParent()       | 获取当前file对象的父目录（返回String）       |\n| isDirectory()     | 是否是目录                                   |\n| isFile()          | 是否是文件                                   |\n| getPath()         | 获取文件(夹)的相对路径:（返回String）        |\n| listFiles()       | 列出目录中的所有内容                         |\n\n```java\npublic class FileDemo02\n{\n    public static void main(String[] args)\n    {\n        //创建文件\n//        File file = new File(\"a.txt\");\n//        try\n//        {\n//            //创建文件\n//            file.createNewFile();\n//        }\n//        catch (IOException e)\n//        {\n//            e.printStackTrace();\n//        }\n\n        //创建文件夹\n        //mkdirs(); 如果父目录不存在连同父目录一起创建\n        //mkdir();  如果父目录不存在则创建不成功\n//        File file = new File(\"d:\\\\zz\");\n//        file.mkdirs();\n\n        //在创建文件或者文件夹的时候，先判断文件或者文件夹是否存在\n//        File file = new File(\"d:\\\\zz\\\\aa\");\n//        System.out.println(file.exists());\n\n\n//        File file = new File(\"d:\\\\z\\\\aa\");  //文件\n//        //判断是否是文件\n//        System.out.println(file.isFile());\n//        //判断是否是文件夹\n//        System.out.println(file.isDirectory());\n\n        //File file = new File(\"a.txt\");\n        //获取文件的绝对路径\n//        System.out.println(file.getAbsolutePath()); //返回类型：String\n//        System.out.println(file.getAbsoluteFile()); //返回类型：File\n\n        //获取文件的父目录  如果写的是相对路径，则会按照相对路径去找父目录\n//        System.out.println(file.getParent());\n//        System.out.println(file.getParentFile());\n\n        //删除文件\n        //如果file对象是一个文件则可以删除\n        //如果file对象是一个空文件夹则可以删除，但是如果文件夹中有内容则无法删除\n        //System.out.println(file.delete());  //成功返回true，失败返回false\n\n        //获取文件或文件夹的名称\n        //System.out.println(file.getName());\n\n        File file = new File(\"d:\\\\zz\");\n        //获取当前文件夹下所有的文件或者文件夹名称\n        String[] a = file.list();\n        for (String s : a)\n        {\n            System.out.println(s);\n        }\n\n    }\n}\n```\n\n","tags":["Java"],"categories":["编程语言","Java"]},{"title":"20.集合","url":"/post/9e25cba9.html","content":"\n# <center>知识点一：集合框架</center>\n\n## <center>1、概念</center>\n\n&ensp;&ensp;&ensp;&ensp;如果处理一套通用逻辑就提供一个自定义封装处理数组的类，那么开发中可能会需要提供N这样类，问题在于需要自行完成操作，Java也发现这个问题，所有为了让程序猿可以更加的便捷的对数据进行操作，无需向数组一样提供【增删改查】的自定义实现，Java提供一个集合框架，便于程序猿对数据进行存储与管理操作\n\n什么是集合框架？\n\n&ensp;&ensp;&ensp;&ensp;Java中的集合框架其实就是对【数据结构】的封装，这个封装中提供了一些常用方法，可方便操作数据，无需程序猿自定定义操作，只需要调用封装方法就可以完成对存在集合中数据【增删改查】集合其实就是对数据结构一种封装，所以之前sun公司就把集合放置到一个统一包中进行管理【java.util】包\n\n什么是数据结构？\n\n&ensp;&ensp;&ensp;&ensp;数据结构其实就是计算机，组织和存储数据形式\n\n&ensp;&ensp;&ensp;&ensp;数据结构是指相互之间存在一种或多种特定关系的数据集合\n\n&ensp;&ensp;&ensp;&ensp;通常情况下，精心选择数据结构可以带来更加高效运行和存储效率，数据结构往往高效的原因在于【检索算法】和【索引计数】\n\n&ensp;&ensp;&ensp;&ensp;常见数据结构：【数组、栈、链表(单向和双向)、哈希表、队列(单向和双向)、堆、树、图】\n\n&ensp;&ensp;&ensp;&ensp;Java的集合框架其实就是对【数据结构实现】，我们需要掌握就是如何操作这个数据结构（即操作集合中方法），高效存储与处理数据\n\nPS：根据不同数据结构，操作数据性能是不同（有地查询块、有的插入快、有地允许重复、有的不允许重复等等），在开发中只要选择合理数据结构即集合对数据存储与操作即可\n\n推荐： 后期可以看一本书【大话数据结构】 ---》兄弟 ----》【大话设计模式】\n\n## <center>2、集合架构</center>\n\nPS：习惯性说Java中集合有三大框架【List、Set和Map】\n\n如果详细说明的话应该2个框架3个实现：\n\n&ensp;&ensp;&ensp;&ensp;2个框架： Collection 和 Map\n\n&ensp;&ensp;&ensp;&ensp;3个实现 ：Collection这个集合下两个主要实现 List 和 set 所以称为三大集合List、set 和Map\n\n集合和数组最大区别在于：\n\n1. 集合中只能存储引用类型即对象\n2. 集合是一个变长容量，根据集合存储元素个数动态进行删减【扩容和减容】\n3. 数组是一个定长容器，创建大小数固定，无论存储多少数据长度都是唯一\n\n常见三大集合框架：\n\n1. List【列表】：集合中存储对象是按照索引位置进行存储，允许存储重复数据\n2. Set【集】: 集合中存储对象不是按照特定方式进行存储，不允许出现重复数据\n3. Map【映射】：集合中每一个存储元素都是以一种【键值对keyvalue】方式进行存储的，以一种key和value的形式存储的，key这个对象是不允许重复【唯一性】，value是允许重复\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271930400.jpg\" alt=\"列表、集合、映射图\" style=\"zoom: 33%;\" />\n\n无论什么时候都要先创建Collection对象\n\n![集合](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271930293.jpg)\n\n## <center>3、List集合</center>\n\n![List集合](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271930586.jpg)\n\n# <center>知识点二：List集合之ArrayList集合</center>\n\n## <center>1、分析ArrayList的效率</center>\n\n因为ArrayList使用是数组实现所以可以得到如下以下特点：\n\n1. 保存操作：\n\n&ensp;&ensp;&ensp;&ensp;把一个数据保存到ArrayList中，最快的操作只要操作一次即可，最慢的操作可能操作N次\n\n&ensp;&ensp;&ensp;&ensp;平均执行效率(N+1)/2次 ---》扩容问题\n\n2. 删除操作:\n\n删除ArrayList中某个数据，最快的只要操作一次即可， 最慢的操作可能操作N次\n\n平均执行效率(N+1)/2次 ---》减容问题\n\n3. 修改操作: 操作一次即可\n\n4. 查询操作：根据索引一次即可。如果遍历查询使用【检索算法】做优化效率高度，如果遍历从到为【顺序查找】效率是低\n\n因为ArrayList使用是数组的形式进行存储数据操作，所以基于这样数据结构做查询和修改效率是高，但是做增加和删除效率是低【动态扩容和减容】\n\n## <center>2、语法</center>\n\n```java\n ArrayList<泛型> 变量名 = new ArrayList<>();\n```\n\n## <center>3、常用方法</center>\n\n1）向指定下标位置添加一个元素,下标范围：0~list.size\tlist.size：有多少个元素\n\n&ensp;&ensp;&ensp;&ensp;变量名.add(指定下标数,添加的元素);\n\n2）移除指定下标位置的元素,下标范围：0~list.size-1\n\n&ensp;&ensp;&ensp;&ensp;变量名.remove(指定下标数);\n\n3）修改指定下标位置的元素,下标范围：0~list.size-1\n\n&ensp;&ensp;&ensp;&ensp;变量名.set(指定下标数,修改元素内容);\n\n4）获取指定下标位置上的元素，下标范围：0~list.size-1\n\n&ensp;&ensp;&ensp;&ensp;变量名.get(指定下标数)\n\n&ensp;&ensp;&ensp;&ensp;返回值为对应的数据类型\n\n```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.function.Predicate;\nimport java.util.function.UnaryOperator;\npublic class ArrayListAPIDemo \n{\n    public static void main(String[] args) \n    {\n        //提供ArrayList集合对象进行数据的存储操作\n        /*\n            1.ArrayList集合提供一个无参构造方法可以创建一个空的集合对象\n            -->空指定的是集合没有存储任何数据，但是集合引用是在的\n            在Java7，使用new ArrayList无参构造方法创建对象，一个元素都不存储\n            依旧会在堆中开辟一个大小为10的数据空间，并且数组的默认存储数据类型时Object\n            在Java8中，Java开发人员发现，如果在使用ArrayList集合之前，如果使用无参构造方法\n            创建ArrayList集合对象会出现一个10大小的堆中数组空间，这样会造成一定量的空间浪费\n            所以在Java8中提供一个全新优化，使用 new ArrayList无参构造方法创建ArrayList对象时\n            并不会创建一个大小为10数组在堆中进行存储，而是创建创建一个空的数组进行空间的开辟\n            private static final Object[]\n            DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n            当通过集合对象调用集合集合中提供add方法时，此时才会真正的初始化数组空间\n        */\n        ArrayList list = new ArrayList();\n        //2.ArrayList集合使用其他的Collection集合对象中存储数据\n        作为新的集合中存储数据进行初始化\n        //即将参数中Collection集合对象数据存储到新建ArrayList集\n        合中\n        ArrayList list2 = new ArrayList(list);\n        //3.自定义ArrayList集合的底层数组初始化容量 --》【使用较少】\n        ArrayList list3 = new ArrayList(100);\n        //常用API\n        \n        //1.向集合对象中添加元素【存储数据】 ---》 集合只能存储引用\n        类型即对象\n        /*\n            集合中只能存储引用类型 --> 明显调用add时存储的是1,2,3,4,5 int类型数据\n            可以存储的，因为向集合中存储基本数据类型时，完成自动转换操作 --》将基本数据类型 转换为对应 包装类\n        */\n        list.add(1);\n        list.add(2);\n        list.add(3);\n        list.add(4);\n        list.add(5);\n        list.add(\"6\");\n        //集合在没有使用泛型之前是可以存储任何引用类型对象,因为方法参数类型时Object\n        //ArrayList集合重写toString，所以可以直接打印集合对象查看集合内容\n        System.out.println(list);\n        \n        //2.向集合中指定位置添加元素数据【第一个参数是下标位置，第二个参数是存储的元素】\n        list.add(2,100);\n        System.out.println(list);\n        \n        //3.向集合中添加参数集合中数据到集合中进行存储\n        //PS：参数是一个Collection集合，所以只要是List或Set集合实现类都是传递到这个参数中\n        ArrayList list1_1 = new ArrayList();\n        list1_1.add(1);\n        list1_1.add(2);\n        list.addAll(list1_1);    //将list1_1集合里面的数据存储到list集合中\n        System.out.println(list);\n        //addAll有一个重载在指定位置中添加添加参数集合数据 addAll(下标, Collection集合对象);\n        /*\n            特别注意： add 和 addAll的区别\n            add这个方法是向集合中添加引用类型对象，即向集合集合添加地址\n            addAll这个方法是向集合中添加参数中集合数据\n        */\n        ArrayList arrayList1 = new ArrayList();\n        ArrayList arrayList2 = new ArrayList();\n        arrayList1.add(1);\n        arrayList1.add(2);\n        System.out.println(arrayList1);\n        arrayList2.add(3);\n        arrayList2.add(4);\n        arrayList1.add(arrayList2);    //相当于将arrayList2中引用存储到arrayList1这个集合中，存储是对象即地址\n        System.out.println(arrayList1);\n        arrayList1.addAll(arrayList2);    //相当于将arrayList2中存储数据存储到arrayList1这个集合中，存储的是数据内容\n        System.out.println(arrayList1);\n        \n        //4.清空集合中存储的数据，但是集合引用不会消失，消失的是集合数据\n        System.out.println(\"没有清空之前arrayList1中的数据是：\"+arrayList1);\n        arrayList1.clear();\n        System.out.println(\"清空之后arrayList1中的数据是：\"+arrayList1);\n        \n        //5.判断集合否为空，即判断集合是都没有存储任何数据 [true空/false不空]\n        System.out.println(arrayList1.isEmpty());\n        \n        //6.判断集合中是否存在指定元素【判断集合中是否存储在这个对象】 --> true存在 false不存在\n        System.out.println(list.contains(1));\n        \n        //7.判断集合中是否存在参数集合中数据 ---》这方法不是\n        ArrayList独有的而是List接口提供\n        System.out.println(list.containsAll(list1_1));\n        \n        //8.通过集合中存储元素下标获取集合中元素 ---》【下标不要越界范围（0~集合存储元素个数-1）】\n        System.out.println(list.get(0));\n        \n        //9.查询集合中是否存在指定元素并返回下标【只会返回第一次遇到元素的下标】\n        // 找到了就是下标 找不到就是负数\n        System.out.println(list.indexOf(1));\n        //list.lastIndexOf(查找的数据) --》查询集合中是否存在指定元素并返回下标【从后向前寻找】\n        \n        //10.集合是提供真正删除操作 ---> 进行减容操作\n        //10.1 根据数据删除集合中存在数据\n        list.remove(new Integer(1));\n        System.out.println(list);\n        \n        //10.2 根据下标删除集合中数据\n        list.remove(6);\n        System.out.println(list);\n        \n        //10.3 List集合接口提供方法 removeAll\n        ArrayList list1_2 = new ArrayList();\n        list1_2.add(2);\n        list1_2.add(100);\n        list1_2.add(3);\n        //根据参数集合提供数据在当前集合进行删除操作\n        list.removeAll(list1_2);\n        System.out.println(list);\n        \n        //10.4 List集合接口提供方法 retainAll\n        ArrayList list1_3 = new ArrayList();\n        list1_3.add(5);\n        //根据参数集合提供数据保留当前集合中存储的数据，剩余的数据进行删除\n        list.retainAll(list1_3);\n        System.out.println(list);\n        \n        //10.5 在java8中ArrayList提供一个新的处理集合删除方法removeIf\n        //这个方法参数支持 Lambda表达式 和 匿名内部类方式处理\n        ArrayList list1_4 = new ArrayList();\n        list1_4.add(1);\n        list1_4.add(2);\n        list1_4.add(3);\n        list1_4.add(5);\n        list1_4.add(6);\n        //匿名内部类\n        list1_4.removeIf(new Predicate(){\n        //需要在这个方法方法执行删除规则 结果true就会进行删除操作\n        //参数Object 中o会获取到集合每一个元素的值\n        @Override\n        public boolean test(Object o) \n        {\n            return ((Integer)o)%2 == 0;\n        }\n        });\n        //lambda表达式\n        list1_4.removeIf(o-> ((Integer)o)%2 == 0);\n        System.out.println(list1_4);\n        \n        //11.Java8中提供一个全新的方法【支持lambda表达式和匿名内部类】\n        //根据指定规则进行元素的替换操作\n        list1_4.replaceAll(new UnaryOperator()\n        {\n            //指定当前替换规则的方法，方法参数Object中o会获取到所有集合中数据\n            //需要在方法内部提供替换规则，返回的是替换之后需要存在集合中数据\n            @Override\n            public Object apply(Object o) \n            {\n                return o.equals(3) ? 30 : o;\n            }\n        });\n        list1_4.replaceAll(o->o.equals(3) ? 30 : o);\n        System.out.println(list1_4);\n        \n        //12. 修改【替换】集合中指定位置的数据 ---》第一个参数是下标，第二个参数修改数据\n        list1_4.set(0,10000);\n        System.out.println(list1_4);\n        \n        //13.获取集合中存储元素个数【集合长度】\n        System.out.println(list1_4.size());\n        \n        //14.将集合转换为数组\n        Object[] objects = list1_4.toArray();\n        //PS：数组中也提供一个方法【Arrays】，将数组转换为List集合\n        List objects1 = Arrays.asList(objects);\n        \n        //15.【不太推荐】 截取指定范围内容集合数据得到一个新的集合\n        ArrayList arrayList1_5 = new ArrayList();\n        arrayList1_5.add(1);\n        arrayList1_5.add(2);\n        arrayList1_5.add(3);\n        arrayList1_5.add(4);\n        arrayList1_5.add(5);\n        arrayList1_5.add(6);\n        arrayList1_5.add(7);\n        arrayList1_5.add(8);\n        //包括前不包括后 包括开始位置，不包括结束位置，参数都是下标\n        List list1 = arrayList1_5.subList(2, 6);\n        System.out.println(list1);\n    }\n}\n```\n\n# <center>知识点三：List集合三种遍历方式</center>\n\n## <center>普通for循环</center>\n\nPS：因为ArrayList的底层实现是数组，所以支持数组中提供下标进行\n\n对ArrayList进行操作\n\n语法格式：\n\n```java\nfor(int i = 0; i< 集合对象.size();i++)\n{\n    循环变量i值就是ArrayList集合下标变量，int i = 0 定义下标初始值\n    ArrayList它获取集合长度使用 size() 方法\n    通过ArrayList集合提供get方法或set方法对集合数据进行\n取值与赋值操作\n}\n```\n\n特点：因为这里操作的是下标，所以可以利用下标对集合数据进行【增删改查】操作\n\n## <center>增强for循环【foreach循环】</center>\n\nPS：因为ArrayList的底层实现是数组，所以支持数组中提供下标进行对ArrayList进行操作\n\n语法格式:\n\n```java\nfor(集合中存储元素的类型 变量名 : 集合名)\n{\n    通过操作局部变量就可以操作集合中数据了\n}\n```\n\nPS：之前在学习数组的时候说过，数组遍历方式有两种一种普通for循环，一种是增强for循环，增强for循环只能使用在数组或集合中，在数组使用增强for循环它的实现原码是将数组值赋值给局部变量，所以对与增强for循环中局部变量修改是不会影响到数组，增强for循环适合简单数据运算、分支判断和打印数组中数据\n\n特点：集合中增强for循环和数组中增强for循环同样效果，支持数组进行简单数据运算、分支判断和打印集合中数据，【但是不支持对集合中数据进行修改操作，也不允许在增强for循环中调用集合删除方法进行数据删除】，如果一旦删除就会出现一个【并发迭代修改异常 --》ConcurrentModificationException】\n\n```java\npublic class CollectionForeach\n{\n    public static void main(String[] args)\n    {\n        ArrayList<String> list = new ArrayList<>();\n        list.add(\"jack\");    \n        list.add(\"rose\");\n        list.add(\"cxk\");\n        list.add(\"李四\");\n        list.add(\"rose\");\n        list.add(\"尼古拉斯\");\n\n        //List集合遍历方式1：使用迭代器\n        Iterator<String> it = list.iterator();\n        while (it.hasNext())\n        {\n            System.out.println(it.next());\n        }\n        \n        //1.提供一个ArrayList集合对象\n        ArrayList arrayList = new ArrayList();\n        arrayList.add(1);\n        arrayList.add(2);\n        arrayList.add(3);\n        arrayList.add(4);\n        arrayList.add(5);\n        //提供一个普通for循环操作\n        for(int i = 0 ; i<arrayList.size();i++)\n        {\n            //获取存储的数据\n            System.out.println(arrayList.get(i));\n            // 通过下标对集合中数据进行修改\n            if(i == 2) \n            {\n                arrayList.set(i, 100);\n            } \n            //通过下标进行数据删除操作 ---》 支持全套删除\n            if(i == 3)\n            {\n                arrayList.remove(i);\n            }\n        } \n        System.out.println(arrayList);\n        System.out.println(\"-------------------------------------------\");\n        //增强for循环\n        int sum = 0 ;\n        for(Object obj : arrayList)\n        {\n            //obj中就会存储这个集合中所有数据\n            System.out.println(obj);//打印集合数据\n            //判断集合中数据做什么操作\n            if(obj.equals(3))\n            {\n                //操作代码\n                System.out.println(obj);\n            } \n            //数据类型是可以做计算\n            sum += ((Integer)obj);\n            //需要注意set方法无法使用，因为set第一个参数是下标\n            //不能使用集合中删除方法，即在增强for循环中是不允许调用\n            删除方法的\n            if(obj.equals(1))\n            {\n                arrayList.remove(new Integer(1));\n            }\n        } \n        System.out.println(arrayList);\n        System.out.println(sum);\n    }\n}\n```\n\n**提供增强for循环的原码**\n\n```java\nIterator iterator = arrayList.iterator();\ndo\n{\n    if (!iterator.hasNext())\n    break;\n    Object obj = iterator.next();\n    System.out.println(obj);\n    if (obj.equals(Integer.valueOf(3)))\n    System.out.println(obj);\n    sum += ((Integer)obj).intValue();\n    if (obj.equals(Integer.valueOf(1)))\n    arrayList.remove(new Integer(1));\n} while (true);\n\"增强for循环之所以不可以删除,原因就是在于增强for循环即foreach底层实现就是一个迭代器，\n迭代器中是不允许使用集合中删除方法进行数据删除的，如果删除ConcurrentModificationException就出现这个异常\"\n```\n\n## <center>foreach方法遍历</center>\n\nforeach是Java8中提供一个新增的方法，主要是以一个方法形态可以遍历打印集合中数据，因为这个方式Java8中提供，所以这个方法支持lambda表达式和匿名内部类实现\n\nPS: 这个方法主要就是用于打印，其他方式较少\n\n```java\nimport java.util.ArrayList;\nimport java.util.function.Consumer;\npublic class Java8ForArrayList \n{\n    public static void main(String[] args) \n    {\n        //1.提供一个ArrayList集合对象\n        ArrayList arrayList = new ArrayList();\n        arrayList.add(1);\n        arrayList.add(2);\n        arrayList.add(3);\n        arrayList.add(4);\n        arrayList.add(5);\n        //方法内部可以指定打印效果\n        //匿名内部类的形式\n        arrayList.forEach(new Consumer() \n        {\n            //这个方法中就是咱们打印集合中数据的形式\n            @Override\n            public void accept(Object o) {//Object类型o参数\n            可以获取到集合每一个数据\n            System.out.println(o);\n            //提供一些判断打印效果，根据具体需求来，这个方法没\n            有返回值，所以打印效果是不会影响实际存储数据的\n        }\n        });\n        //Lambda表达式实现\n        arrayList.forEach(o -> System.out.println(o));\n        //提供Lambda中方法引用操作\n        arrayList.forEach(System.out::println);\n    }\n}\n```\n\n# <center>知识点四：ArrayList底层实现原理</center>\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271931515.jpg\" alt=\"ArrayList底层实现原理\" style=\"zoom: 50%;\" />\n\n```java\npublic class ArrayListDemo02\n{\n    public static void main(String[] args)\n    {\n        //1、构造方法初始化一个长度为0的Object数组\n        ArrayList<String> list = new ArrayList<>();\n        /**\n         * ArrayList底层的元素是数组\n         * add方法的原理\n         * 1、当第一次添加元素的时候，初始化一个长度为10的数组\n         *  当添加元素超过数组的长度的时候，会对数组进行扩容，扩容到1.5倍\n         * 2、将当前的元素添加到数组指定的下标位置上\n         *    elementData[size++] = e;\n         *\n         *数组数据结构的特点：增删慢，查询快\n         */\n        list.add(\"jack\");\n        list.add(\"rose\");\n    }\n}\n```\n\n# <center>知识点五：迭代器</center>\n\nJava中专门针对Collection集合提供了一种遍历方式，这种遍历方式是根据Iterable接口来决定，只要是Collection的集合接口在子接口基本上都会具备Iterable这个接口，这个接口中主要提供一个方法\n\n| Iterator | iterator() 返回按适当顺序在列表的元素上进行迭代的迭代器      |\n| -------- | ------------------------------------------------------------ |\n|          | 这个方法会返回一个按照集合顺序并存储集合数据的一个迭代器对象 |\n\n## <center>1、迭代器原理</center>\n\n迭代是重复反馈过程的活动,其目的通常是为了逼近所需目标或结果。每一次对过程的重复称为一次“迭代”,而每一次迭代得到的结果会作为下一次迭代的初始值\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291911167.jpg\" alt=\"原理\" style=\"zoom: 50%;\" />\n\n## <center>2、获取迭代器对象</center>\n\nIterator 变量名 = Collection的变量名.iterator();\n\n## <center>3、迭代器的三个方法</center>\n\n（1）判断迭代器是否有下一个元素\n\n&ensp;&ensp;&ensp;&ensp;变量名.hasNext();\n\n&ensp;&ensp;&ensp;&ensp;返回值boolean类型\n\n（2）获取当前游标对应元素并将游标向后移动一位\n\n&ensp;&ensp;&ensp;&ensp;变量名.next()\n\n&ensp;&ensp;&ensp;&ensp;返回迭代的下一个元素\n\n（3）移除当前迭代器上对应的元素\n\n&ensp;&ensp;&ensp;&ensp;变量名.remove();\n\n&ensp;&ensp;&ensp;&ensp;说明：可以利用Iterator中提供三个核心方法操作迭代器影响集合中数据\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402292037504.png\" alt=\"迭代器方法\" style=\"zoom:50%;\" />\n\nPS： 迭代器中在没有使用泛型之前，next方法的返回值类型都是统一Object，所以将方法中返回E看做是Object即可，迭代器提供自身remove方法，所以在迭代器中删除数据时要调用迭代器提供remove，而不是集合\n\n```java\nimport java.util.ArrayList;\nimport java.util.Iterator;\npublic class IteratorArrayList \n{\n    public static void main(String[] args) \n    {\n        //基础迭代器\n        ArrayList arrayList = new ArrayList();\n        arrayList.add(1);\n        arrayList.add(2);\n        arrayList.add(3);\n        arrayList.add(4);\n        arrayList.add(5);\n        //需要使用ArrayList集合对象调用iterator方法获取迭代器对象\n        Iterator iterator = arrayList.iterator();\n        //利用迭代器对象调用hasNext进行操作判断迭代器中是否还存在下一个元素\n        /*\n        while(iterator.hasNext())\n        {\n            //通过next方法获取迭代器中数据\n            System.out.println(iterator.next());\n        }\n        */\n        //迭代器使用问题--》删除数据\n        while(iterator.hasNext())\n        {\n            Integer integer = ((Integer) iterator.next());\n            if (integer.equals(2)) \n            {\n                //删除掉2这个值\n                //iterator.remove();//使用迭代器中提供删除[删除迭代器中存储数据的同时会删除集合中对应数据]\n                //千万不要调用集合中提供删除方法\n                //ConcurrentModificationException --> 就会出现并发迭代修改异常\n                \n                arrayList.remove(integer);\n            }\n        } \n        System.out.println(arrayList);\n    }\n}\n```\n\n## <center>4、强化迭代器</center>\n\n强化迭代器只有List集合具备，专门为List集合提供一个增强迭代器，因为原始迭代器中只有三个方法，不利于对集合数据的操作，增强迭代器就新增多个方法进行迭代器操作\n\nListIterator是List集合在Iterator迭代器接口之上提供一个更多方法操作的迭代器，ListIterator在原始迭代器基础上增加，新增数据，修改数据，从后向前遍历【获取数据】的操作，还可以获取下标\n\n| void    | add(E e) 将指定的元素插入列表（可选操作）                    |\n| ------- | ------------------------------------------------------------ |\n| boolean | hasNext() 以正向遍历列表时，如果列表迭代器有多个元素，则返回 true （换句话说，如果 next 返回一个元素而不是抛出异常，则返回 true ） |\n| boolean | hasPrevious() 如果以逆向遍历列表，列表迭代器有多个元素，则返回 true |\n| void    | add(E e) 将指定的元素插入列表（可选操作）                    |\n| E       | next() 返回列表中的下一个元素                                |\n| int     | nextIndex() 返回对 next 的后续调用所返回元素的索引           |\n| E       | previous() 返回列表中的前一个元素                            |\n| int     | previousIndex() 返回对 previous 的后续调用所返回元素的索引   |\n| void    | remove() 从列表中移除由 next 或 previous 返回的最后一个元素（可选操作） |\n| void    | set(E e) 用指定元素替换 next 或 previous 返回的最后一个元素（可选操作） |\n\nPS：在没有使用泛型之前，方法所有使用E的部分都看做是Object类型即可\n\n```java\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.ListIterator;\npublic class ListIteratorArrayList \n{\n    public static void main(String[] args) \n    {\n        //基础迭代器\n        ArrayList arrayList = new ArrayList();\n        arrayList.add(1);\n        arrayList.add(2);\n        arrayList.add(3);\n        arrayList.add(4);\n        arrayList.add(5);\n        //需要使用ArrayList集合对象调用listiterator方法获取迭代器对象\n        ListIterator iterator = arrayList.listIterator();\n        //如果你想调用逆向遍历操作时，需要现将光标向后移动才可以，光标最先开始是在第一个元素位置上\n        while(iterator.hasNext())\n        {\n            System.out.println(iterator.next());\n        }\n        //此时对迭代器进行逆向遍历【从后向前】\n        while(iterator.hasPrevious())\n        {\n            System.out.println(iterator.previous());\n        }\n    }\n}\n\"listIterator同样是遵守一个原则，不要再迭代器中使用后集合删除方法删除数据，要使用迭代器提供方法进行删除\"\n```\n\n## <center>5、迭代器注意事项</center>\n\n（1）迭代器迭代完成之后，迭代器的位置在最后一位。 所以迭代器只能迭代一次\n\n（2）迭代器在迭代的时候，不要调用多次next方法，可能会出错 NoSuchElementException\n\n（3）在迭代器迭代的时候，不能向集合中添加或者删除元素\n\n```java\npublic class CollectionDemo03\n{\n    public static void main(String[] args)\n    {\n        Collection coll = new ArrayList();\n        coll.add(\"jeck\");\n        coll.add(\"rose\");\n        coll.add(\"马冬梅\");\n        coll.add(\"Lisi\");\n        coll.add(\"wangwu\");\n\n        //1、迭代器不能使用多次，如果要多次使用那么要多次获取\n//        Iterator it = coll.iterator();\n//        while (it.hasNext())\n//        {\n//            System.out.println(it.next());\n//        }\n//        while (it.hasNext())\n//        {\n//            System.out.println(it.next());\n//        }\n\n        //2、在同一次迭代中，不能多次使用next方法\n//        Iterator it = coll.iterator();\n//        while (it.hasNext())\n//        {\n//            //第一种\n//            Object obj = it.next();\n//            System.out.println(obj);\n//            //第二种\n//            System.out.println(it.next());\n//            //不能这么多次使用\n//            Object obj = it.next();\n//            System.out.println(it.next());\n//        }\n\n        //3、迭代器在迭代的过程中不能调用add或者remove方法\n        Iterator it = coll.iterator();\n        while (it.hasNext())\n        {\n            coll.add(\"haha\");\n            System.out.println(it.next());\n        }\n    }\n}\n```\n\n# <center>知识点六：List集合之LinkedList集合</center>\n\n## <center>1、说明</center>\n\nLinkedList集合也是List集合接口中主要实现类，这个LinkedList的主要实现结构有【链表】，除了链表结构之外LinkeList还使用栈、 队\t列、数组，LinkedList是允许存重复数据化并且可以快速插入数据\n\n**LinkedList中实现的数据结构**\n\n**栈**：stack,又称堆栈，它是运算受限的线性表，其限制是仅允许在表的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。\n\n简单的说：采用该结构的集合，对元素的存取有如下的特点\n\n**先进后出**（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。例如，子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先弹出上面的子弹，然后才能弹出下面的子弹\n\n**栈的入口、出口的都是栈的顶端位置**\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291919875.png\" alt=\"栈的位置\" style=\"zoom:67%;\" />\n\n这里两个名词需要注意：\n\n&ensp;&ensp;&ensp;&ensp;**压栈**：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置\n\n&ensp;&ensp;&ensp;&ensp;**弹栈**：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置\n\n**队列**：队列和栈有一些类似，也是一种受到限制的线性表，其限制是仅允许在表的一表进行插入，另外一段进行取出和删除，这样队列叫做单向队列【Queue】\n\n队列是存在一个特点：先进先出\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291920090.png\" alt=\"队列\" style=\"zoom: 33%;\" />\n\n队列：除了单向队列之外，还提供一种非受限制线性表，这表就是双端队列，依旧遵守先进先出原则，**双端队列**【Deque】\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291921569.png\" alt=\"双端队列\" style=\"zoom:33%;\" />\n\n链表：链表属于一个线性表，线性表中包含了存储链接位置和数据的位置，利用链接位置进行相连接，使数据之间呈现一种链接状态，链表可以理解为：老鹰抓小鸡\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291921058.png\" alt=\"链表\" style=\"zoom:50%;\" />\n\n链表和队列差不多，链表也分为单向和双向链表，类似于现实生活中的【火车】通过链接方式就可以获取得到链表中数据\n\n单向链表和双向链表是有本质上区别的，单向链表包含两个区域【存储链接位置和数据存储位置】，通过【存储链接位置】让每一个单独链接节点进行相连，形成一个单向链表，即单向链表只能向一个方法进行遍历操作，双向链表包含是三个区域【2个存储链接位置和1个数据存储位置】 ，利用双向链表中两个存储链接的位置进行前后节点的链接，此时链表就形成了一个双向通道，即可以从头到尾，也可以从到头，允许直接在头尾两端进行操作\n\n## <center>2、分析LinkedList的执行效率</center>\n\n主要实现方式是【双向链表】，所以使用LinkedList效果\n\n1. 保存数据 ：只要执行一次即可【API中也提供 addFirst 和addLast】\n\n2. 删除操作： 只要执行一次即可【API中也提供 removeFirst 和removeLast】，就选中间节点(1+N)/2\n\n3. 查询操作和修改操作：平均值(N+1)/2\n\n结论：LinkedList增删执行效率是高的，但是查询和修改执行效率是低的\n\n## <center>3、常用方法</center>\n\n常用的方法与ArrayList一致。自己独有一些向首尾添加移除等方法(可以模拟对列、堆栈等数据结构)\n\n```java\nimport java.util.Iterator;\nimport java.util.LinkedList;\npublic class LinkedListAPIDemo \n{\n    public static void main(String[] args) \n    {\n        //因为LinkedList实现了List集合接口，所以具备所有List集合\n        操作方法\n        //LinkedList中List方法操作完全参考ArrayList即可\n        //LinkedList集合独有方法\n        //1.创建LinkedList对象\n        //1.1 创建一个空的LinkedList集合对象\n        LinkedList linkedList = new LinkedList();\n        //1.2使用参数中Collection集合对象中存储数据初始化LinkedList集合对象\n        LinkedList linkedList1 = new LinkedList(linkedList);\n        \n        //独有API        \n        //1.向集合开头的位置添加元素\n        linkedList.addFirst(1);\n        System.out.println(linkedList);\n        \n        //2.向集合结尾的位置添加元素\n        linkedList.addLast(2);\n        System.out.println(linkedList);\n        \n        //3.获取集合第一个元素的数据【但是不删除集合数据】\n        Object element = linkedList.element();\n        System.out.println(element);\n        \n        //4.获取集合中第一个数据和最后一个数据【但是不删除集合数据】\n        Object first = linkedList.getFirst();\n        Object last = linkedList.getLast();\n        //PS： LinkedList允许使用下标形式进行数据获取\n        Object o = linkedList.get(0);\n        \n        //5.添加元素到集合的末尾\n        linkedList.offer(3);\n        //添加到第一个位置offerFirst和最后一个位置offerLast\n        \n        //6.获取集合集合第一个元素但是【不删除集合数据】，有元素就返回，没有就是null\n        Object peek = linkedList.peek();\n        Object o1 = linkedList.peekFirst();\n        //获取最后一个元素的值，有元素就返回，没有就是null\n        Object o2 = linkedList.peekLast();\n        \n        //7.poll系列也是也可以获取集合中第一个和最后一个元素的【删除数据】\n        //在获取数据的同时删除集合中数据\n        // Object poll = linkedList.poll();\n        // Object o3 = linkedList.pollFirst();\n        // Object o4 = linkedList.pollLast();\n        \n        //8. 弹出集合中第一个数据\n        Object pop = linkedList.pop();\n        //向集合中添加数据\n        linkedList.push(4);\n        \n        //9.删除集合中第一个或最后一个元素值\n        linkedList.removeFirst();\n        linkedList.removeLast();\n        \n        //10.List集合特点就是允许存储重复数据，下面两个方法的作用就是遍历集合\n        //First的方法从前之后 Last的方法从后向前\n        //遇到第一个相同数据删除\n        linkedList.removeFirstOccurrence(1);\n        linkedList.removeLastOccurrence(1);\n        //LinkedList有一个独有的迭代器，允许逆向的遍历迭代器中数据值\n        //但是它的操作方式和iterator是一样\n        Iterator iterator = linkedList.descendingIterator();\n        //它的方式只有三个 hasNext next 和 remove\n        while(iterator.hasNext())\n        {\n            System.out.println(iterator.next());\n        } \n        //不同点在于：它的光标最先开始是放置在迭代器最后一个元素的位置，你hasNext是向前判断\n    }\n}\n```\n\n## <center>4、LinkedList实现原理</center>\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291923333.png\" alt=\"实现原理\" style=\"zoom:50%;\" />\n\n# <center>知识点七：List集合总结</center>\n\nList集合是Collection集合子集合即List集合是继承与Collection集合，因为List集合是接口所以无法直接操作，Java就提供了两个可以便捷操作List集合实现类ArrayList和LinkedList\n\nList集合的特点：允许存储重复数据并给存储数据是有顺序\n\n在官方API文档中可以查看到：public interface List extends Collection\n\n有序的 collection（也称为序列）。此接口的用户可以对列表中每个元素的插入位置进行精确地控制。用户可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素\n\n**所有已知实现类**： ArrayList 和 LinkedList\n\n**所有超级接口**： Collection 和 Iterable\n\n因为也继承了Iterable所以List集合中是支持的迭代器【Iterator】\n\nList接口中提供常用方法已经在ArrayList集合中完全进行演示，所以使用List集合时只要参考ArrayList提供方法演示就可以操作集合\n\nArrayList和LinkedList实现类是实现List接口，所以List相当于是他们的父类，所以List集合接口支持多态\n\n```java\nList集合接口允许这样这样创建对象\nList list = new ArrayList();\n或者\nList list = new LinkedList();\n\"这样直接使用较少，多用于在方法中如果需要设置List集合参数，优先会\n将List作为参数类型，而不是实现类\"\n\"因为这样做可以接收ArrayList或LinkedList\"\n\"上面这种方式是不使用泛型，所以默认数据类型时Object，操作时就一定\n注意转换问题【对象的向下转型】\"\n\"Java中所有集合都是有泛型语法，所以可以使用泛型方式进行创建对象\"\n    List<数据类型> list = new ArrayList<>();\n\"泛型语法形式：\"\n    集合的数据类型<数据类型> 集合对象名字 = new 集合数据类型<>();\n\"集合都是使用new关键字创建，所以它是引用类型\"\n\"现在学习ArrayList和LinkedList都是线程不安全的集合，在多线程操\n作前提下是不能使用这两个集合进行数据存储操作，这两个集合只适合在单线程下使用\"\n```\n\nList集合接口还有一个**实现类Vector**\n\nVector在JDK1.0的时候就已经存在，这个类其实是ArrayList集合类“前身”，在JDK1.2时候Java开始强调了集合框架概念，所以提供Collection集合框架，在Collection下面提供List和Set，Vector的实现也是数组，所以被归类到了List接口的实现类中，现在开发已经不在使用Vector这个类，主要使用ArrayList这个类\n\nVector和ArrayList之间相似点和区别在于什么？\n\n相似点：都是List集合接口的实现类，都使用数组作为集合数据结构进行实现\n\n不同点：Vector这个集合是线程安全的，但是效率低，提供较早并且使用率低\n\n&ensp;&ensp;&ensp;&ensp;ArrayList这个集合是线程不安全，但是效率高，提供较晚并且使用率高\n\nPS：就算Vector是线程安全的，但实际开发中也不会使用Vector，还是使用ArrayList\n\n从Java5开始提供ArrayList和LinkeList线程安全处理模式:\n\n```java\n\"集合中是存在一个工具类，这个类叫做Collections，这个工具类提供\n了如果将线程不安全集合转换为线程安装集合的方法\"\nCollections.synchronizedList(List集合对象); ---》可以将\n一个线程不安全集合转换为线程安全\n\"除了这种处理方式之外,现在主要处理方式可以使用Java在JDK1.5中提\n供的一个新包java.util.concurrent 并发工具包，\n这个包中提供大量的线程安全处理时可以使用的集合\"\n```\n\nStack(栈集合)和Queue、Deque(队列集合)\n\nStack是List集合的实现类，而Queue、Deque集合接口：有专门实现类来实现主要体现在于LinkedList\n\n# <center>知识点八：泛型基本使用</center>\n\n## <center>1、作用</center>\n\n什么是泛型？\n\n&ensp;&ensp;&ensp;&ensp;泛型是一个特殊类型，泛型是统称指代任何引用数据类型，泛型本身代表【通用类型含义】，在定义泛型时如果没有对泛型进行数据类型赋值之前，泛型本身是不具备任何含义，只有赋值为具体数据类型时，泛型才会真正意义\n\n为什么要使用这个泛型?\n\n&ensp;&ensp;&ensp;&ensp;泛型解决了集合中存储数据类型的问题\n\n```java\nimport java.util.ArrayList;\npublic class CenericityList \n{\n    public static void main(String[] args)\n    {\n        /*\n            在学习集合之前，是没有使用泛型，所以集合中默认类型就是Object\n            我们面临的问题就是取出数据时，需要进行向下转型操作才可以\n        */\n        ArrayList list = new ArrayList();\n        list.add(1);\n        list.add(2);\n        list.add(3);\n        list.add(4);\n        //对集合存储的数据进行计算求和\n        int sum =0 ;\n        for(Object obj : list)\n        {\n            sum += ((Integer) obj);\n        } \n        //因为不使用泛型默认类型时Object类型所以和这个集合中就可以存储任何数据类型只要是Object子类\n        list.add('9');\n        list.add(\"7\");\n        list.add(new Student());\n        list.add(true);\n        //如果你在不清楚集合中存储在什么样数据类型数据时，如果进行转换操作？代码就无形中增加开发成本\n        /*\n            所以在这种情况下，集合建议使用泛型，来约束集合中存储数据\n            一旦集合使用泛型就要可以约束集合只能 存储泛型中提供的数据类型对应数据，从而减少转换操作\n            此时list1这个集合中只能存储Integer类型数据，使用泛型作为约束\n        */\n        ArrayList<Integer> list1 = new ArrayList<>();\n        list1.add(1);\n        //list1.add(\"1\");\n        int sum1 = 0;\n        for(Integer i : list1)\n        {\n            sum1+=i;\n        }\n    }\n}\n```\n\nPS： 如何定义泛型集合？\n\n### 语法\n\n```java\n集合数据类型<存储数据的数据类型> 集合对象名 = new 集合数据类型<>();\n```\n\n此时就可以使用【存储数据的数据类型】约束集合中存储的数据了\n\nPS：集合泛型你就可以理解为 就是创建数组是\n\n数组中存储元素数据类型[] ---》相当于 集合数据类型<存储数据的数据类型>\t只能引用数据类型\n\n泛型解决通用性问题\n\n编程原则：DRY【不要重复你自己（不要写重复性代码）】\n\n需求： 求点中x和y的值\n\n```java\nclass Point\n{\n    private Integer x;\n    private Integer y;\n} \nclass Point2\n{\n    private Double x;\n    private Double y;\n} \nclass Point3\n{\n    private Long x;\n    private Long y;\n} \nclass Point4\n{\n    private String x;\n    private String y;\n} \n为了Point类型可以获得不同参数类型数据，需要提供大量相同逻辑类，此时就触发DRY原则，\n现有解决方案就是将数据类型替换成Object类型，但\n是我们需要面临数据类型转换和传递非计算类型问题，有没有什么方式可以\n动态决定类中x和y属性类型操作，根据外界传递类型来进行x和y的限制操作 ---》 可以使用\"泛型\"\nclass Point<T>\n{\n    private T x;\n    private T y;\n}\n```\n\n## <center>2、定义</center>\n\nPS：泛型中会出现一个【占位符】的概念，这个占位符本身是没有任何意义，就是一个占位，对泛型进行赋值时，占位符才会有具体的意义\n\n泛型的概念是Java5开始引入到Java中，它可以通过对泛型赋值进行对数据赋值约束，通过泛型动态决定数据类型时什么\n\n语法：\n\n```java\n<占位符>\nPS：这种语法在Java中叫做\"菱形语法\"，这样语法与占位符组合就是成\n为\"泛型\"\n这个语法可以使用在 \"类、方法和接口\"上\n占位符\"一般是一个大写字母[A~Z]\",不建议使用其他形式进行占位符定义\n习惯书写占位符是 \"T\" --> \"Type(类型)\" ---> <T> 泛型T\n占位符可以在一个语法存在多个需要使用\",\"分隔，使用占位符的多少就相\n当于你定义多个泛型\n泛型语法:只能存在在编译时期，一旦程序运行泛型就会自动消失\"称之为泛型擦除\"\n        定义的泛型在编译字节码文件中即[.class文件]看不到\n```\n\n## <center>3、泛型的使用之集合</center>\n\n```java\npublic class CenericityList \n{\n    public static void main(String[] args)\n    {\n        // 集合的数据类型<泛型赋值数据类型> 集合对象名字 = new 集合的数据类型<>();\n        // 声明的就是带有泛型集合，泛型可以作为集合类型一部分，可以出现在方法参数位置和返回值类型的位置\n        ArrayList<Integer> list1 = new ArrayList<>();\n        list1.add(1);\n        //一旦集合使用泛型之后，集合只允许使用泛型定义数据类型，非泛型定义数据类型时无法存储到集合中\n        //list1.add(\"1\");\n        int sum1 = 0;\n        //集合使用泛型之后，确定了集合中存储数据的数据类型，在集合中的数据就无需向下转型操作\n        for(Integer i : list1)\n        {\n            sum1+=i;\n        }\n    } \n    public static void showList(ArrayList<Integer> list)\n    {}\n    public static ArrayList<Integer> showList()\n    {}\n}\n```\n\n## <center>4、泛型的使用之泛型类</center>\n\n```java\n/**\n    当前类在没有使用任何其他修饰符之前【final 或 abstract】,没有使用泛\n型语法之前 都是一个普通类\n    public class CenericityClass \n    {}\n    利用泛型语法 <占位符> 可以将当前类变成泛型类\n    语法：\n        public class 类名<占位符>    //这个类就是泛型类\n        { \n            此时这个泛型是定义在类上，所以在类中成员变量和成员方法都可以使用\n            这个泛型\n作为数据类型使用\n        } \n*/\npublic class CenericityClass<T> // 使用泛型是 T 这个T现在是没有意义 只是一个占位符号\n{     \n    //此时这个T是没意义，为了保证语法不错误，占位使用\n    //泛型T只有被赋值之后【数据类型（必须是引用数据类型）】 T才会有意义\n    private T x;\n    public T y;\n    public CenericityClass()\n    {}\n    public CenericityClass(T x, T y) \n    {\n        this.x = x;\n        this.y = y;\n    } \n    public void show(T t)\n    {\n        System.out.println(t);\n    }\n} \n//在类上定义泛型，如何确定泛型数据类型，只要在创建类的对象时对泛型进行赋值，泛型就有具体的数据类型\nclass Test\n{\n    public static void main(String[] args) \n    {\n        // 类名<泛型赋值数据类型> 对象名字 = new 类名<>();\n        CenericityClass<Integer> cc = new\n        CenericityClass<>();\n        cc.y = 1;\n        cc.show(1);\n        //这样创建对象,创建泛型的同时不对泛型进行赋值操作\n        //此时没有对泛型进行赋值，所以泛型类型默认使用Object\n        CenericityClass cc1 = new CenericityClass();\n        cc1.y = 1;\n        cc1.y = \"1\";\n        cc1.show('1');\n    }\n} \n\"\nPS：泛型在动态决定数据类型时什么的时候，不存在继承关系\"\n\"不要这样写，这个语法是错误，对泛型进行赋值什么数据类型时，就决定这个数类型，所不允许赋值为其他类\"\nCenericityClass<Object> cc = new\nCenericityClass<Integer>();\n```\n\n## <center>5、泛型使用之泛型方法</center>\n\n泛型方法的定义主要是为了摆脱使用泛型类上或泛型接口上的泛型约束问题，就相当于方法向使用自己定义泛型作为类型操作，就可以定义为泛型方法\n\n泛型类和泛型接口上定义泛型，不能在静态方法上使用，所以只能定义泛型方法对方法进行泛型使用修饰\n\n```java\npublic class GenericityMethod<T> // 使用泛型是 T 这个T现在是没有意义 只是一个占位符号\n{ \n\n    //提供一个成员方法 泛型类上定义泛型就可以在方法中使用\n    public void show(T t)\n    {\n        System.out.println(t);\n    } \n    //泛型类上定义泛型是不能在静态方法上使用\n    //public static void showInfos(T t){ }\n    //给方法添加泛型\n    /*\n        泛型静态方法：\n            访问权限修饰符 static<占位符> 返回值类型 方法名(参数列表)\n            {\n                此时这个占位符可以使用在返回值类型上 和 参数列表定义中\n            } \n    */\n    public static<E> void showInfos(E e)\n    {\n        //E a;// 方法上泛型主要是为了 返回值类型和参数类型而提供的，在内部就不在使用\n        System.out.println(e);\n    } \n    /* \n        泛型成员方法：\n            访问权限修饰符<占位符> 返回值类型 方法名(参数列表)\n            {\n                此时这个占位符可以使用在返回值类型上 和 参数列表定义中\n            } \n        此时不仅可以使用泛型方法上定义泛型，也可以使用类上或接口上定义泛型\n    */\n    public<F> void showInfoss(F f,T t)\n    {\n        //F a;// 方法上泛型主要是为了 返回值类型和参数类型而提供的，在内部就不在使用\n        System.out.println(f);\n    } \n    //定义泛型方法泛型，不能单独使用在方法返回值类型位置，需要配合使用参数列表定义\n    public static<O> O showInfosss(O o)\n    {\n        //静态方法可以这样操作，成员的不可以\n        //return o;\n        return o;\n    }\n}\nclass Test1\n{\n    public static void main(String[] args) \n    {\n        //如何给方法定义泛型进行赋值操作---》赋值数据类型\n        //在调用方法对泛型定义参数列表赋值时，可以决定方法的泛型是什么，定义泛型方法时\n        //一定要将泛型定义在参数列表中，以确定数据类型是什么\n        GenericityMethod.showInfos(\"1\");\n        GenericityMethod genericityMethod = new\n        GenericityMethod();\n        Integer integer = GenericityMethod.showInfosss(1);\n    }\n}\n```\n\n## <center>6、泛型使用之接口泛型</center>\n\n接口泛型和泛型类差不多，在接口上定义泛型，这个泛型可以在接口内部使用\n\n```java\nimport java.util.ArrayList;\nimport java.util.List;\n/*\n    public interface 接口名<占位符>\n    {}泛型接口\n*/\npublic interface GenericityInterface<T>\n{\n    //在接口上定义泛型可以在接口内部使用\n    void run(T t);\n    //支持抽象方法自定义泛型\n    public abstract<E> void show (E e);\n} \n//1. 在使用类实现接口时可以对泛型接口的泛型进行赋值，决定泛型类型是什么 \nclass Demo implements GenericityInterface<Integer>\n{\n    //在接口中定义方法使用泛型位置都会变成数据类型\n    @Override\n    public void run(Integer integer) \n    {\n    } \n    @Override\n    public <E> void show(E e) \n    {\n    }\n}\n//2. 使用泛型类实现泛型接口，使用泛型类中泛型作为接口中新泛型\nclass Demo2<P> implements GenericityInterface<P>\n{\n    //在创建泛型类对象时可以决定泛型类型\n    @Override\n    public void run(P p) \n    {\n    }\n    @Override\n    public <E> void show(E e) \n    {\n    } \n    public static void main(String[] args) \n    {\n        GenericityInterface<Double> gi = new Demo2<>();\n        gi.run(1.0);\n        Demo2<String> demo2 = new Demo2<>();\n        demo2.run(\"1\");\n        //这种操作其实就是List集合中使用List集合创建对象的方式\n        List<String> list = new ArrayList<>();\n        ArrayList<Long> list2 = new ArrayList<>();\n    }\n} \n//3.直接使用匿名内部类的形似进行泛型接口上泛型的赋值\nclass Demo3\n{\n    public static void main(String[] args) \n    {\n        new GenericityInterface<Integer>()\n        {\n            @Override\n            public void run(Integer integer) \n            {\n            } \n            @Override\n            public <E> void show(E e) \n            {\n            }\n        };\n    }\n}\n```\n\n## <center>7、泛型的限定</center>\n\n泛型限定其实就是定义泛型可以赋值哪些数据类型，只有满足限定要求的数据类型才可以进行定义赋值操作\n\n**泛型通配符【?】**\n\n?代表未知，可以作为通配符使用，但是不能作为参数类型单独使用，通配符多用于在泛型限定上\n\n```java\npublic class GenericityDemo \n{\n    public static void main(String[] args) \n    {\n        // ? 是一个通配符\n        List<?> list = new ArrayList<>();\n        list.add(1); // 这里是无法确定数据类型，无法单独使用\n    }\n}\n```\n\n**< ? extends 类> 这是使用途径 此时 ？ 就代表着可以接收extends关键字后的相同类型或子类**\n\n**< ? super 类> 这是使用途径 此时 ？ 就代表着可以接收super关键字后的相同类型或父类**\n\n```java\nimport java.util.ArrayList;\nimport java.util.List;\npublic class GenericityDemo \n{\n    public static void main(String[] args) \n    {\n        //提供4个List集合对象\n        List<Integer> list1 = new ArrayList<>();\n        List<String> list2 = new ArrayList<>();\n        List<Number> list3 = new ArrayList<>();\n        List<Object> list4 = new ArrayList<>();\n        //调用泛型的上限操作，即参数类型使用的是List<? extends Number>进行限制\n        /*\n            泛型限定必须是 Number类型或Number子类\n            而list1是Integer类型即Number子类 list3是Number类型即\nNumber类型所以可以进行传递\n            而list2和list4分别是String和Object，既不是Number类型也\n不是Number子类，所以无法传递到方法中\n        */\n        doWork1(list1);\n        //doWork1(list2);\n        doWork1(list3);\n        //doWork1(list4);\n        //调用泛型下限操作，即参数类型使用的是List<? super Number>进行限制\n        /*\n            泛型限定必须是Number类型或Number父类\n            而list1和list2分别是Integer和String，既不是Number类型也不是Number父类，所以无法传递到方法中\n            list3和list4 分别是Number和Object 满足了必须是Number类型或Number父类，所以传递到方法中\n        */\n        //doWork2(list1);\n        //doWork2(list2);\n        doWork2(list3);\n        doWork2(list4);\n    } \n    //泛型的上限，此时的泛型中?(通配符) 必须是Number的类型或Number子类\n    public static void doWork1(List<? extends Number> list)\n    {\n    } \n    //泛型的下限，此时的泛型中?(通配符) 必须是Number的类型或Number父类\n    public static void doWork2(List<? super Number> list)\n    {\n    }\n}\n```\n\n## <center>8、特点</center>\n\n（1）泛型集合在存储元素的时候，支持多态(不推荐使用)\n\n（2）泛型定义的时候，不存在多态\n\n&ensp;&ensp;&ensp;&ensp;Collection coll1 = new ArrayList(); err\n\n（3）泛型擦除\n\n&ensp;&ensp;&ensp;&ensp;在JDK1.7之后，右边的<>中不需要定义泛型类型\n\n&ensp;&ensp;&ensp;&ensp;集合的泛型不能是基本数据类型，要使用它们的包装类\n\nCollectionDemo01类\n\n```java\npublic class CollectionDemo01\n{\n    /**\n     * 泛型：参数化类型     JKD1.5之后\n     * 泛型作用：因为在没有使用泛型之前，向集合中存储实际上是Object类型的数据，所以获取的时候也是Object类型\n     *         如果想要使用这个对象，需要发生向下转型，那么在整个集合存储元素的时候，不停的发生向上和向下转型,可能会发生异常\n     * 泛型的好处：类型转换的操作提前到了编译器\n     *泛型特点：\n     *      泛型集合在存储元素的时候，支持多态(不推荐使用)\n     *      泛型定义的时候，不存在多态\n     *         Collection<Person> coll1 = new ArrayList<Student>(); err\n     *      泛型擦除\n     *          在JDK1.7之后，右边的<>中不需要定义泛型类型\n     *      集合的泛型不能是基本数据类型，要使用它们的包装类\n     */\n    public static void main(String[] args)\n    {\n//        Collection coll = new ArrayList();\n//        coll.add(new Student(\"jack\",28));\n//        coll.add(new Student(\"尼古拉斯\",23));\n//        coll.add(new Teacher(\"rose\",32));\n//\n//        //遍历集合  迭代器\n//        Iterator it = coll.iterator();\n//        while (it.hasNext())\n//        {\n//            //没有向下转型时时Object类\n//            //System.out.println(it.next().play());\n//            Object obj = it.next();\n//            Student stu = (Student) obj;\n//            stu.play();\n//        }\n\n        Collection<Student> coll = new ArrayList<>();\n        coll.add(new Student(\"jack\",23));\n        coll.add(new Student(\"niu\",23));\n        Iterator<Student> it = coll.iterator();\n        while (it.hasNext())\n        {\n            Student student = it.next();\n            student.play();\n        }\n\n        //泛型集合在存储元素的时候，支持多态\n        Collection<Person> coll1 = new ArrayList<>();\n        coll1.add(new Student(\"jack\",23));\n        coll1.add(new Teacher(\"sdf\",34));\n\n        //不能用基本数据类型\n        //Collection<int> coll2 = new ArrayList<>();\n        Collection<Integer> coll3 = new ArrayList<>();\n    }\n}\n```\n\nPerson类\n\n```java\npublic class Person\n{\n}\n```\n\nStudent类\n\n```java\npublic class Student extends Person\n{\n    private String name;\n    private int age;\n\n    public Student(String name, int age)\n    {\n        this.name = name;\n        this.age = age;\n    }\n\n    public Student()\n    {\n    }\n\n    public String getName()\n    {\n        return name;\n    }\n\n    public void setName(String name)\n    {\n        this.name = name;\n    }\n\n    public int getAge()\n    {\n        return age;\n    }\n\n    public void setAge(int age)\n    {\n        this.age = age;\n    }\n\n    @Override\n    public String toString()\n    {\n        return \"Student{\" +\n                \"name='\" + name + '\\'' +\n                \", age=\" + age +\n                '}';\n    }\n    //Student类中的方法\n    public void play()\n    {\n        System.out.println(\"Student玩。\");\n    }\n}\n```\n\nTeacher类\n\n```java\npublic class Teacher extends Person\n{\n    private String name;\n    private int age;\n\n    public Teacher(String name, int age)\n    {\n        this.name = name;\n        this.age = age;\n    }\n\n    public Teacher()\n    {\n    }\n\n    public String getName()\n    {\n        return name;\n    }\n\n    public void setName(String name)\n    {\n        this.name = name;\n    }\n\n    public int getAge()\n    {\n        return age;\n    }\n\n    public void setAge(int age)\n    {\n        this.age = age;\n    }\n\n    @Override\n    public String toString()    \n    {\n        return \"Teacher{\" +\n                \"name='\" + name + '\\'' +\n                \", age=\" + age +\n                '}';\n    }\n}\n```\n\n# <center>知识点九：Set集合的介绍</center>\n\n![set集合](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291933362.png)\n\n# <center>知识点十：Set集合实现类HashSet</center>\n\nHashSet集合是Set集合主要实现类，也是日常开发使用最常用Set集合实现类\n\n```java\npublic class HashSet<E> extends AbstractSet implements Set<E>, Cloneable, Serializable\n```\n\nHashSet集合继承了Set集合的特点，向hashSet集合中存储数据时，是不允许出现重复数据，如果有存储重复数据HashSet集合会进行自动排重操作，**HashSet集合的主要实现数据结构“Hash表”**,存储数据顺序是无序，**通过观察API文档发现HashSet集合的所有方法都是Set集合接口提供，本身没有任何特殊方法**\n\n特点:\n\n- 无序 （插入顺序）\n- 无下标\n- 不可重复\n\n## <center>1、Hash表</center>\n\n**什么是hash表？**\n\n&ensp;&ensp;&ensp;&ensp;Hash 一般被翻译为“散列”，也可以直接音译为“哈希”，它是基于【快速存取的角度而设计的一种存储结构】，而且是一个典型【空间换时间】的做法，利用Hash表的原理进行数据存储操作\n\n&ensp;&ensp;&ensp;&ensp;Hash表其实就是【“数组+链表”】的组合形式，在Hash表数组起到作用提供存储位置，在Hash表链表起到作用提供数据存储结构\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291936873.png\" alt=\"Hash表\" style=\"zoom:50%;\" />\n\n上图中是典型Hash表的结构，Hash表也别称之为【散列表(Hashtable)】，Hash表是根据键值对（Key-value）而直接进行访问的数据结构，也就是说【通过把key值映射到表中一个位置来记录访问位置】，以加快查找数据（这个操作就是确定数据在Hash表中存储的位置），这个操作也被称之为【散列函数】，通过散列函数计算出存储位置会后，会将存储数据以链表形似挂载在存储位置中，这种方式成为【桶】如果存储70个元素，但是存储70个元素时申请100个空间，70/100 = 0.7 ，这个0.7这个值就称之为“负载（加载）因子”，通过这个因子对hash表进行扩容操作\n\n因为Hash表是基于【快速存取】的操作，所以Hash表会尽量的平均将数据分配到Hash表中进行存储，但是在存储过程中就会触发，在同一个存储空间中出现重复数据问题，此时Hash就会启动自动排重操作，原则就是equals比较，只要equals比较结果为true，就不在这个空间存储相同数据\n\n假如：向上面Hash表中存储12这个数据如果进行存储计算\n\n第一步：通过散列函数计算12需要存储的位置 --》hash(key)%len【散列函数】\n\nhash(key) ---》 key 是要存储数据 hash(key) ---》**计算key的hash值即Java中hashcode值**\n\nlen ---》其实就是存储Hash表中数组长度，上图中数组长度为16所以散列函数计算效果\n\nhash(12) % 16 ---》 12%16 ----》 余数12 ，利用12这个值去数组中提供存储位置对别查找存\n\n**Hash表的扩容机制？**\n\n&ensp;&ensp;&ensp;&ensp;Hash表示一个自动扩容机制，**当达到【加载因子】参数要求时，Hash表就会进行自动扩容**\n\n&ensp;&ensp;&ensp;&ensp;Java中使用**Hash表默认大小给16，加载因子0.75**当16个存储位置发生了75%位置都存储了数据即16*0.75 = 12，也就说12个下标位置中都存储数据，Hash表就会发生自动扩容，扩容机制就以2的幂次进行扩容【16是2^4】扩容之后2^5即hash表每次扩容之后都是原有容量一倍，就会从原有16扩容到32\n\n&ensp;&ensp;&ensp;&ensp;在介绍HashSet时说过HashSet中存储数据不能保证存储位置永久不变，只要Hash表发生一次扩容，那么Hash表中存储的数据就要重新计算存储位置\n\n原始数据28 存储在大小为16的hash表中 计算位置 28%16 --》 余数12\n\n一旦扩容大小从16变成32 此时原始数据28可就要重新计算存储位置\n\n在hash表 计算位置 28%32 ---》 余数 28\n\n**总结：Hash表数据存储和查找是非常优秀，但是一旦扩容就会降低Hash表的性能**\n\n## <center>2、HashSet基本使用</center>\n\n###  (1）语法\n\n```java\nHashSet<泛型> 变量名 = new HashSet<>();\n```\n\nHashSet是实现Set集合接口，查看API时可以发现HashSet中并没有任何特殊方法，所以知己使用Set接口提供方法就完成HashSet集合操作【**HashSet集合中操作方法方式和ArrayList集合中介绍方式是一样的，只不过HashSet带有排重的效果，可以完全参考ArrayList集合中API使用在HashSet中进行使用**】\n\n```java\nimport java.util.*;\nimport java.util.function.Predicate;\npublic class HashSetAPI \n{\n    public static void main(String[] args) \n    {\n        //1.创建HashSet集合对象\n        /*\n            表面上代码操作是在创建一个HashSet集合，但是实际底层操作过程中是在创建HashMap集合\n            向HashSet集合存储的数据其实就是在想HashMap中key的位置存储\n数据，为什么要这样会做\n            Hash表存储数据值是以【key-value】进行数据存储操作 --》\nJava集合中可以提供Key-value形式存储只有Map集合\n        */\n        //1.提供一个空的HashSet集合对象【默认容量16,加载因子0.75】\n        HashSet<Integer> hashSet = new HashSet<>();\n        //PS：HashSet是Set集合的实现类，也就相当于是Set集合\"子类\"\n        //利用Set集合接口使用多态形式创建Set集合对象\n        Set<String> set = new HashSet<>();\n        //2.可以利用参数Collection集合对象中存储数据初始化HashSet集合对象\n        HashSet<Integer> hashSet1 = new HashSet<>\n(hashSet);\n        //3.指定HashSet集合初始化容量大小【使用默认加载因子0.75】\n        //遵守大小原则是2次幂来定义的，但是不要小于16\n        HashSet<Double> hashSet2 = new HashSet<>\n(((int)Math.pow(2,5)));    //2的5次幂(double类型)强转int\n        //4.指定HashSet集合初始化容量大小和加载因子 第二参数加载因子是float类型\n        HashSet<Character> hashSet3 = new HashSet<> (((int)Math.pow(2,5)),0.85f);\n        //常用API\n        //向集合中添加数据\n        hashSet.add(1);\n        hashSet.add(20);\n        hashSet.add(4);\n        hashSet.add(9);\n        hashSet.add(7);\n        hashSet.add(17);\n        //hashSet是可以对存储在集合数据提供排重操作的\n        System.out.println(hashSet);\n        \n        //将参数集合对象中数据存储到当前HashSet中\n        //addAll(Collection集合对象); \n        \n        //清空HashSet集合中数据\n        //hashSet.clear();\n        \n        //判断HashSet集合是否为空【指没有任何数据，而不是当前hashset地址为null】\n        //isEmpty();\n        \n        //判断HashSet集合中是否存在指定元素\n        if(hashSet.contains(1))\n        {\n            System.out.println(\"返回true证明存在\");\n        }\n        else\n        {\n            System.out.println(\"返回false证明不存在\");\n        } \n        \n        //containsAll(Collection集合对象) 判断Collection集合对象中个存储数据是否存在在Hashset集合对象中\n        //因为HashSet不存在下标的概念所以HashSet是不支持普通for循环的\n        //HashSet支持循环方式有\n        // 增强for循环\n        for(Integer integer : hashSet)\n        {\n            System.out.println(integer);\n            //不要调用集合删除方法\n        } \n        \n        // foreach方法\n        hashSet.forEach(System.out::println);\n        \n        //普通迭代器(HashSet集合只支持普通迭代器，不支持增强迭代器即listIterator)\n        Iterator<Integer> iterator = hashSet.iterator();\n        while(iterator.hasNext())\n        {\n            System.out.println(iterator.next());\n            //删除数据就调用 迭代器中remove\n        } \n        \n        //删除集合中数据 参数是要删除的数据\n        hashSet.remove(1);\n        //删除参数结合提供提供数据所在HashSet集合对象中数据\n        //removeAll(Collection集合对象);\n        //保留参数集合对象中数据在HashSet集合中然后删除剩余HashSet集合中数据\n        //retainAll(Collection集合对象);\n        hashSet.removeIf(new Predicate<Integer>() \n        {\n            @Override\n            public boolean test(Integer integer) \n            {\n                return integer%2 ==0 ;\n            }\n        });\n        hashSet.removeIf(integer -> integer%2 ==0);\n        \n        //获取集合中存储元素的个数\n        System.out.println(hashSet.size());\n        \n        //转换成数组\n        Object[] objects = hashSet.toArray();\n        Integer[] integers = hashSet.toArray(new Integer[hashSet.size()]);\n    }\n}\n```\n\n### (2)HashSet集合的排重操作\n\n需求:创建一个Person对象，提供属性名字和年龄【按照标准JavaBean提供，提供toString重写】在提供PersonTest类型在类中创建两个Person对象，赋值为张三，18，存储在HashSet集合中，然后打印集合中数据，查看是否排重？如果没有排重如何处理？\n\n```java\npublic class Person \n{\n    private String name;\n    private int age;\n    public Person() \n    {\n    } \n    public Person(String name, int age) \n    {\n        this.name = name;\n        this.age = age;\n    } \n    public String getName() \n    {\n        return name;\n    } \n    public void setName(String name) \n    {\n        this.name = name;\n    } \n    public int getAge() \n    {\n       return age;\n    } \n    public void setAge(int age) \n    {\n        this.age = age;\n    } \n    @Override\n    public String toString() \n    {\n        return \"Person{\" +\n        \"name='\" + name + '\\'' +\n        \", age=\" + age +\n        '}';\n    }\n} \npublic class PersonTest \n{\n    public static void main(String[] args) \n    {\n        HashSet<Person> hashSet = new HashSet<>();\n        hashSet.add(new Person(\"张三\",18));\n        hashSet.add(new Person(\"张三\",18));\n        //利用HashSet中存储机制【Hash表】可以存储重复数据进行排重操作\n        System.out.println(hashSet);\n        HashSet<Integer> hashSet1 = new HashSet<>();\n        hashSet1.add(1);\n        hashSet1.add(1);\n        System.out.println(hashSet1);\n    }\n}\n```\n\nHashSet底层实现是什么？---》\n\n使用Hash表实现的，Hash表示如何进行数据存储的？ ---》\n\n使用Hash表提供散列函数，散列函数是什么？ ---》\n\n这是散列函数 hash(key)%len， hash(key)得到结果什么？len得到结果什么？ ---》\n\n**hash(key)计算存储数据所在内存中hashcoded地址值**\n\nlen是Hash表中容量的大小，默认是16 ---》\n\n利用散列函数【 hash(key)%len】 求得存储在Hash表中位置以进行数据的存储\n\nHash表的排重机制是：通过散列函数计算出数据存储的位置进行数据存储，如果出现同一个数据计算出位置相同，此时也会向存储位置进行插入存储，但是要进行equals比较，如果equals 比较结果为false就整存储位置中，没有与之相同数据，以链表存储，如果equals比较结果为true，证明这个存储位置有与之相同数据，此时就会放弃新添加的数据存，从而不会进行存储数据操作，那么些就是HashSet即Hash表排重机制\n\n```java\npublic class PersonTest \n{\n    public static void main(String[] args) \n    {\n        HashSet<Person> hashSet = new HashSet<>();\n        Person p1 = new Person(\"张三\",18);\n        Person p2 = new Person(\"张三\",18);\n        hashSet.add(p1);\n        hashSet.add(p2);\n        System.out.println(\"p1对象的hashcode值：\"+ p1.hashCode());\n        System.out.println(\"p2对象的hashcode值:\"+ p2.hashCode());\n        //利用HashSet中存储机制【Hash表】可以存储重复数据进行排重操作\n        System.out.println(hashSet);\n        HashSet<Integer> hashSet1 = new HashSet<>();\n        hashSet1.add(1);\n        hashSet1.add(1);\n        System.out.println(hashSet1);\n    }\n}\n```\n\n为什么存储自定类的对象到HashSet集合没有进行排重？\n\n就是因为自动以类并没对对象提供同一个hashcode的实现并且在Person类中也没有一共equals方法的实现，所以我们根本没有提供排重操作的原则，所以向HashSet中存储自定义类的对象是无法排重\n\n**如果需要向HashSet集合存储自定义类的对象并提供排重机制，那么自定义类必须提供equals和hashcode方法的重写**\n\n从写hashcode的目的在于：\n\n1. 在Java中认为两个对象相等是通过equals方决定，决定原则在于类中提供属性完全或部分相等，认为两个对象相等，既然两个对象已经相等了，那么他们的地址也要相等，但是Java语言是无法直接操作真实内存地址的，但是我们可以获取到真实内存地址映射hashcode值，所以将equals比较相等对象的hashcode修改为相等就间接的满足【真实内存地址相等】\n2. 当向HashSet集合存储数据时候，HashSet集合底层实现是Hash表，而Hash表有需要通过hashcode计算存数据位置，只有在hash表存储位置相同才可能出现相同数据，这样一来就需要提供相同对象hashcode地址是相同的，通过这个方法将对象计算到同一个存储位置，在通过equals方法计算相等操作触发Hash表排重机制\n\n综上所述：对Person这类提供equals和hashcode的重写操作\n\n```\nimport java.util.Objects;\npublic class Person \n{\n    private String name;\n    private int age;\n    public Person() \n    {\n    } \n    public Person(String name, int age) \n    {\n        this.name = name;\n        this.age = age;\n    } \n    public String getName() \n    {\n        return name;\n    } \n    public void setName(String name) \n    {\n        this.name = name;\n    } \n    public int getAge() \n    {\n        return age;\n    } \n    public void setAge(int age) \n    {\n        this.age = age;\n    } \n    @Override\n    public String toString() \n    {\n        return \"Person{\" +\n        \"name='\" + name + '\\'' +\n        \", age=\" + age +\n        '}';\n    }\n    \n    /*\n        IDEA编译器提供两个版本的equals和hashcode的重写\n        这两个版本都是可以，只能二选一不能共存\n    */    \n    \n    //这个版本IDEA默认版本\n    /*\n        生成equals和hashcode方法是最后选项中有一个non-null\n        这里不建议勾选这个选中给提供属性，因为引用类型还是进行非null判断\n        如果你勾选在那么系统就默认认为引用类型时为null值\n        就会使用这个引用类型方法，如果此时你引用类型属性被赋值null，必\n出空指针异常\n    */\n    //勾选之后 non-null选项之后提供 equals实现\n    /* \n        @Override\n        public boolean equals(Object o) \n        {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass())\n            return false;\n            Person person = (Person) o;\n            if (age != person.age) return false;\n            return name.equals(person.name);\n        }\n    */\n    \n    //没有勾选 non-null选项之后提供 equals实现\n    /* \n    @Override\n    public boolean equals(Object o) \n    {\n        //比较了地址，这个地址是真实地址，如果真实地址都相等 必然是同一个对象\n        if (this == o) return true;\n        */\n        /*\n            如果输入对象引用地址null那么 必然对象不同一个\ngetClass方法的作用是用过字节码文件[.class]文件进行对象获\n取\n            只要是同一个类创建对象，他们字节码文件都是同一个【唯一】\n            两个对象字节码文件都不一样必然不是同一个对象\n        */\n        /*\n            if (o == null || getClass() != o.getClass())\n            return false;\n            //多态向下转型操作\n            Person person = (Person) o;\n        */        \n        //如果当前对象age属性与传入对象的age属性不一致 返回false，\n如果相等就不做任何操作\n        /*\n        if (age != person.age) return false;\n        */\n        /*\n        提供引用类型非null判断\n\t\t只要当前对象的name属性值不为null 就通过name调用String类\n\t\tequals方法\n        与传入对象name进行比较 相等为true，不相等为false\n        如果对象的name属性为null 就判断传入对象的name属性是否为null\n        如果也为null 结果就是true 否则就是false\n        */\n        /*\n        return name != null ? name.equals(person.name) :\n        person.name == null;\n    } \n    @Override\n    public int hashCode() \n    {\n        //获取引用类hashcode值作为新的hashcode值计算\n        int result = name != null ? name.hashCode() : 0;\n        //使用31这个值 乘以 引用类型hashcode值 然后加上 值类型属性值 得到最终hashcode\n        //最大的限度保证hashcode不出现重复\n        result = 31 * result + age;\n        return result;\n    }\n    */\n    \n    //这个版本IDEA使用Java7中提供Objects工具类\n    @Override\n    public boolean equals(Object o) \n    {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass())\n        return false;\n        Person person = (Person) o;\n        /*\n            变化现在使用:值类型比较融入到返回值比较结果中\n            调用了Objects工具类中equals方法进行 引用类型比较 --》原码实现\n            public static boolean equals(Object a, Object b)\n            {\n            地址相等就是同一个对象或者判断 a 参数不为null 然后用a调用equals进行比较\n            return (a == b) || (a != null && a.equals(b));\n            } \n        */\n        return age == person.age &&\n Objects.equals(name, person.name);\n    } \n    @Override\n    public int hashCode() \n    {\n        /*\n        Objects工具类中提供 hash方法 这个方法可以计算新的hashcode值\n        */\n        return Objects.hash(name, age);\n    }\n}\n```\n\n### (3)底层原理\n\nHashSet底层实现原理是HashMap\n\n```java\npublic class HashSetDemo\n{\n    public static void main(String[] args)\n    {\n        HashSet<Integer> hashSet = new HashSet<>();\n        hashSet.add(3);\n        hashSet.add(2);\n        hashSet.add(1);\n        hashSet.add(4);\n        hashSet.add(4);\n        System.out.println(hashSet);\n\n        //HashSet没有特殊方法，它的方法与Collection中学的方法是一致的\n        //Set集合的遍历方式(迭代器)\n        Iterator<Integer> it = hashSet.iterator();\n        while (it.hasNext())\n        {\n            System.out.println(it.next());\n        }\n\n        //foreach遍历\n        for (Integer integer :\n                hashSet)\n        {\n            System.out.println(integer);\n        }\n        //HashSet的底层实现原理：HashSet底层实现原理是HashMap\n    }\n}\n```\n\n# <center>知识点十一：LinkedHashSet类</center>\n\n特点：\n\n- 有序\n- 无下标\n- 不可重复\n\n与父类的方法(HashSet)一致,去重的原理，也与父类一致\n\n```java\npublic class LinkedHashSetDemo\n{\n    /**\n     * 特点：\n     *     1、有序（插入顺序）\n     *     2、不重复\n     *     3、无下标\n     */\n    public static void main(String[] args)\n    {\n        LinkedHashSet<String> linkedHashSet = new LinkedHashSet<>();\n        linkedHashSet.add(\"rose\");\n        linkedHashSet.add(\"wangwu\");\n        linkedHashSet.add(\"jack\");\n        linkedHashSet.add(\"jack\");\n        System.out.println(linkedHashSet);\n        //1、底层实现 (LinkedHashMap)\n        //2、去重原理 (与hashSet一致)\n    }\n}\n```\n\n# <center>知识点十二：Set集合实现类TreeSet</center>\n\nTreeSet是Set集合接口实现类之一，它是一个特殊集合【这个集合不仅可以排重而且可以对存储到集合中的数据提供升序排序】，在以往开发中可以利用TreeSet这个特性对需要排序数据进行操作\n\nPS：从Java8开始List集合专门提供方法sort方法，List集合也可以调用集合提供Sort方法进行对数据排序操作，但是不能排重，所以学习TreeSet的目的为类接触可以排序接口\n\n在API文档中有说明：基于 TreeMap 的 NavigableSet 实现。使用元素的 自然顺序Comparable 对元素进行排序，或者根据创建 set 时提供的 自定义排序Comparator 进行排序，具体取决于使用的构造方法\n\nSet集合系列主要实现都是依赖于Map集合，HashSet底层实现是HashMap，TreeSet底层实现是TreeMap，在Java8之前TreeSet底层实现的结构【二叉树+Hash表】，从Java8开始之后将底层实现的结构【红黑树+Hash表】\n\nTreeSet中的使用API可以完全参考Set集合即可，其余API文档中提供方法自行查看\n\n提供一个基础的TreeSet使用\n\n```java\nimport java.util.TreeSet;\npublic class TreeSetDemo \n{\n    public static void main(String[] args) \n    {\n        //向TreeSet中存储系统提供数据类型\n        TreeSet<Integer> set = new TreeSet<>();\n        set.add(100);\n        set.add(20);\n        set.add(17);\n        set.add(1);\n        set.add(6);\n        set.add(88);\n        set.add(66);\n        set.add(33);\n        set.add(77);\n        set.add(1);\n        //存储数据中提供两个1进行存储 ---》 自动排重和排序操作【默认是升序】\n        System.out.println(set);\n    }\n}\n```\n\n向TreeSet中存储自定义类的对象Student，根据学生年龄进行排序操作\n\n```java\npublic class Student \n{\n    private String name;\n    private int age;\n    private int height;\n    private int weight;\n    public Student() \n    {\n    } \n    public Student(String name, int age, int height, int\n weight) \n    {\n        this.name = name;\n        this.age = age;\n        this.height = height;\n        this.weight = weight;\n    } \n    public String getName() \n    {\n        return name;\n    } \n    public void setName(String name) \n    {\n        this.name = name;\n    } \n    public int getAge() \n    {\n        return age;\n    } \n    public void setAge(int age) \n    {\n        this.age = age;\n    } \n    public int getHeight() \n    {\n        return height;\n    } \n    public void setHeight(int height) \n    {\n        this.height = height;\n    } \n    public int getWeight() \n    {\n        return weight;\n    } \n    public void setWeight(int weight) \n    {\n        this.weight = weight;\n    } \n    @Override\n    public String toString() \n    {\n        return \"Student{\" +\n        \"name='\" + name + '\\'' +\n        \", age=\" + age +\n        \", height=\" + height +\n        \", weight=\" + weight +\n        '}';\n    }\n} \n\nimport java.util.TreeSet;\npublic class StudentTest \n{\n    public static void main(String[] args) \n    {\n        //1.提供TreeSet集合对象用于存储Student类的对象\n        TreeSet<Student> treeSet = new TreeSet<>();\n        treeSet.add(new Student(\"张三\",18,178,100));\n        treeSet.add(new Student(\"李四\",20,181,200));\n        treeSet.add(new Student(\"王五\",16,200,10));\n        treeSet.add(new Student(\"赵六\",19,145,150));\n        treeSet.add(new Student(\"田七\",21,190,160));\n        System.out.println(treeSet);\n    }\n}\n```\n\n问题：使用TreeSet存储系统提供数据类型时，可以对数据进行排重与排序操作，但是向TreeSet中添加自定义类对象时，并没有进行排重排序操作，出现了一个异常\n\n```java\nException in thread \"main\" java.lang.ClassCastException:com.qfedu.TreeSet.\n    Student cannot be cast tojava.lang.Comparable\n```\n\n问题原因所在：当用TreeSet的无参构造方法时创建Set集合对象，【该 set 根据其元素的自然顺序进行排序。插入该 set 的所有元素都必须实现 Comparable 接口】，刚刚插入到TreeSet集合中Student类的对象并没有实现Comparable接口，所以出现ClassCastException\n\n# <center>知识点十三：Comparable接口【自然排序接口】</center>\n\n官方文档说明:此接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的 compareTo 方法被称为它的自然比较方法,【间接的说明Comparable接口是一个自然排序接口，对与实现接口类会提供排序操作，这个排序操作需要完成compareTo这个方法】\n\n当前调用TreeSet集合的无参构造方法时，就要求向TreeSet中存储的数据必须实现Comparbale\n\n实现Comparbale接口就需要实现接口中给提供方法\n\n| int  | compareTo(T o) 比较此对象与指定对象的顺序                    |\n| ---- | ------------------------------------------------------------ |\n|      | compareTo这个方法使用接口上泛型作为方法参数泛型，所以在实现Comparable的时候需要指定接口中泛型是什么类型，这样可以避免不必要向下转型，泛型T如何赋值，Comparbale提供谁进行比较这个类型就是谁Comparable提供compareTo方法对数据进行比较时遵守的原则 比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。compareTo这个方法的返回值类型时int类型，这个方法返回值是一个数字 |\n\nPS：compareTo这个方法不建议理解为比较方法，理解为交换方法即通过这个方法的得到返回值决定如何进行数据交换【存储】\n\n之前有接触过一些排序的操作，例如冒泡、选择这些手写排序，但是这些排序中都会有一个必要的操作\n\n```java\n//提供比较操作，进行数据交换\nif(arr[i] > arr[i+1])\n{\n    int tmp = arr[i];\n    arr[i] = arr[i+1];\n    arr[i+1] = tmp;\n} \n-------------------------------------\nif(arr[i] < arr[i+1])\n{\n    int tmp = arr[i];\n    arr[i] = arr[i+1];\n    arr[i+1] = tmp;\n} \n//通过修改比较操作中 大于号 或 小于号 可以决定 排序顺序\n//那么Comparable接口中compareTo得到的int类型数值就是决定数据如何排序\n```\n\n需要对CompareTo方法进行深入的理解【万能公式】\n\n```java\n\"CompareTo这方法会返回三个值 正整数、 负整数 和 0\"\n/*\n    一般来说自定义类中提供比较属性基本上都是系统类型，就可以通过两个数\n据之间记性“差值计算”从而得到 正整数、 负整数 和 0\n    Student类为例 需要比较是年龄 --》年龄的属性是 int类型\n    用两个int类型进行相减 得到结果就是 正整数、 负整数 和 0 正好满\n足了CompareTo方法需求\n    谁减谁可以得到什么结果，如果不是基本数据类型时引用类型减也不能计\n算？\n    不用担心引用类型问题，基本上能用来比较的引用类型都实现了\nComparable，\n    所以比较引用类型调用这个引用类型中对应CompareTo方\n法就可以\n*/\n\"需要区分当前对象和传入对象\"\n\"调用CompareTo方法的就是当前对象使用【this表示】\"\n\"对CmpareTo方法参数赋值的就是传入对象使用【other表示】\"\n\"由此就可以得到一个万能公式：\n\"当前对象 - 传入对象 【得到排序结果就是升序】\" ---》 正整数\n\"传入对象 - 当前对象 【得到排序结果就是降序】\" ---》 负整数\n\"切记：TreeSet的排重机制并不是equals和HashCode，而是实现排序\n接口中CompareTo或Compare方法的返回值，只要返回值为0，TreeSet\n就会认为是同一个对象，进行排重操作\"\n//当前使用万能公式做计算时，如果遇到得到0时，出现排重效果，建议在得到0时在提供一个排序条件操作，或者使用List中sort方法排序\n使用这个公式进行排序时会面临到问题：\n问题1：此时排序数据类型时自定义类Student\n我们是不能使用 Student - Student 也不可能\nStudent.CompareTo(Student)\n对自定义对象排序时，排序时*自定义对象的属性*，将当前公式变形为\n\"当前对象.属性 - 传入对象.属性 【得到排序结果就是升序】\" ---》正整数\n\"传入对象.属性 - 当前对象.属性 【得到排序结果就是降序】\" ---》负整数\n问题2：此时排序数据类型时系统类型Integer\n\"当前对象 - 传入对象 【得到排序结果就是升序】\" ---》 正整数\n\"传入对象 - 当前对象 【得到排序结果就是降序】\" ---》 负整数\n问题3: 如果遇到是引用类型无法使用减号进行计算时\n\"当前对象.compareTo(传入对象) 【得到排序结果就是升序】\" ---》正整数\n\"传入对象.compareTo(当前对象) 【得到排序结果就是降序】\" ---》负整数\n```\n\n修改Student类进行年龄属性排序操作\n\n```java\npackage com.qfedu.TreeSet;\npublic class Student implements Comparable<Student>\n{\n    private String name;\n    private int age;\n    private int height;\n    private int weight;\n    public Student() \n    {\n    } \n    public Student(String name, int age, int height, int weight) \n    {\n        this.name = name;\n        this.age = age;\n        this.height = height;\n        this.weight = weight;\n    } \n    public String getName() \n    {\n        return name;\n    }\n    public void setName(String name) \n    {\n        this.name = name;\n    } \n    public int getAge() \n    {\n        return age;\n    } \n    public void setAge(int age)\n    {\n        this.age = age;\n    } \n    public int getHeight()\n    {\n        return height;\n    } \n    p\nublic void setHeight(int height) \n    {\n        this.height = height;\n    } \n    p\nublic int getWeight() \n    {\n        return weight;\n    } \n    public void setWeight(int weight) \n    {\n        this.weight = weight;\n    } \n    @Override\n    public String toString() \n    {\n        return \"Student{\" +\n        \"name='\" + name + '\\'' +\n        \", age=\" + age +\n        \", height=\" + height +\n        \", weight=\" + weight +\n        '}';\n    } \n    @Override\n    public int compareTo(Student other) \n    {\n        //比较的是student类中age属性值 [升序排序]\n        //return this.age - other.age;\n        //比较的是student类中age属性值 [降序排序]\n        //return other.age - this.age;\n        //防止出现比较结果为0的时候怎么办？ ---> 在提供一个比较数据即可\n        return this.age - other.age == 0 ? this.height - other.height : this.age - other.age;\n    }\n}\n```\n\n# <center>知识点十四：Comparator接口【自定义排序接口】</center>\n\n除了TreeSet集合中可以使用Comparable接口进行自然排序之外，还有一个更加灵活方便的接口Comparator，在系统API文档中说明：强行对某个对象 collection 进行整体排序 的比较函数。可以将Comparator 传递给 sort 方法（如 Collections.sort 或Arrays.sort ），从而允许在排序顺序上实现精确控制。还可以使用Comparator 来控制某些数据结构（如 有序 set 或 有序映射）的顺序，或者为那些没有 自然顺序的对象 collection 提供排序\n\n**综上所述：Comparator接口不仅可以对TreeSet提供排序操作，而且可以针对Java系统API提供sort方法进行自定义排序操作**\n\nComparator接口中的核心比较方法\n\n| int  | compare(T o1, T o2) 比较用来排序的两个参数                   |\n| ---- | ------------------------------------------------------------ |\n|      | compare这个方法和Comparable接口中compareTo方法是一个道理也是返回 正整数、负整数和0 代表对象 大于 小于和等于 |\n\n刚刚在Comparable中提供万能公式可以直接使用在Comparator\n\n```java\n\"\n这里是需要注意的是：\n\"Comparator接口中compare方法有两个参数,两个参数谁是当前对象，谁是传入对象\"\n\"compare方法中第一个参数 即 o1 就是当前对象即this\"\n\"compare方法中第二个参数 即 o2 就是传入对象即other\"\n\"由此就可以得到一个万能公式：\n\"当前对象 - 传入对象 【得到排序结果就是升序】\" ---》 正整数\n\"传入对象 - 当前对象 【得到排序结果就是降序】\" ---》 负整数\n\"切记：TreeSet的排重机制并不是equals和HashCode，而是实现排序\n接口中CompareTo或Compare方法的返回值，\n只要返回值为0，TreeSet就会认为是同一个对象，进行排重操作\"\n\n//当前使用功能公式做计算时，如果遇到得到0时，出现排重效果，建议在\n得到0时在提供一个排序条件操作，或者算着List中sort方法排序\n使用这个公式进行排序时会面临到问题：\n问题1：此时排序数据类型时自定义类Student\n我们是不能使用 Student - Student 也不可能\n Student.CompareTo(Student)\n对自定义对象排序时，排序时自定义对象的属性，将当前公式变形为\n\"当前对象.属性 - 传入对象.属性 【得到排序结果就是升序】\" ---》正整数\n\"传入对象.属性 - 当前对象.属性 【得到排序结果就是降序】\" ---》负整数\n问题2：此时排序数据类型时系统类型Integer\n\"当前对象 - 传入对象 【得到排序结果就是升序】\" ---》 正整数\n\"传入对象 - 当前对象 【得到排序结果就是降序】\" ---》 负整数\n问题3: 如果遇到是引用类型无法使用减号进行计算时\n\"当前对象.compareTo(传入对象) 【得到排序结果就是升序】\" ---》正整数\n\"传入对象.compareTo(当前对象) 【得到排序结果就是降序】\" ---》负整数\n```\n\n**复制Student类创建Student2来进行Comparator接口操作**\n\nComparator接口对应的是TreeSet中有参构造方法，所以要使用Comparator进行排序就需要使用当前这个有参构造方法【传入实现Comparator接口的实现类对象】方可进行排序操作\n\n**提供两种实现Comparator接口的方式**:\n\n&ensp;&ensp;&ensp;&ensp;第一种:提供一个比较原则类实现Comparator接口，实现compare方法定义排序\n\n```java\npublic class Student2 \n{\n    private String name;\n    private int age;\n    private int height;\n    private int weight;\n    public Student2() \n    {\n    } \n    public Student2(String name, int age, int height, int weight) \n    {\n        this.name = name;\n        this.age = age;\n        this.height = height;\n        this.weight = weight;\n    } \n    public String getName() \n    {\n        return name;\n    }\n    public void setName(String name) \n    {\n        this.name = name;\n    } \n    public int getAge() \n    {\n        return age;\n    } \n    public void setAge(int age) \n    {\n        this.age = age;\n    } \n    public int getHeight() \n    {\n        return height;\n    } \n    public void setHeight(int height) \n    {\n        this.height = height;\n    } \n    public int getWeight() \n    {\n        return weight;\n    } \n    p\nublic void setWeight(int weight) \n    {\n        this.weight = weight;\n    } \n    @Override\n    public String toString() \n    {\n        return \"Student{\" +\n        \"name='\" + name + '\\'' +\n\", age=\" + age +\n        \", height=\" + height +\n        \", weight=\" + weight +\n        '}';\n    } \n} \n\nimport java.util.Comparator;\n//提供一个类实现Comparator接口\npublic class SortGZ implements Comparator<Student2> \n{\n    @Override\n    public int compare(Student2 o1, Student2 o2) \n    {\n        return o2.getAge()-o1.getAge();\n    } \n} \n\npublic class StudentTest2 \n{\n    public static void main(String[] args) \n    {\n        //调用TreeSet中具备Comparator接口方法,参数赋值就是实现Comparator接口的对象\n        TreeSet<Student2> treeSet = new TreeSet<>(new SortGZ());\n        treeSet.add(new Student2(\"张三\",18,178,100));\n        treeSet.add(new Student2(\"李四\",20,181,200));\n        treeSet.add(new Student2(\"王五\",16,200,10));\n        treeSet.add(new Student2(\"赵六\",19,145,150));\n        treeSet.add(new Student2(\"田七\",21,190,160));\n        treeSet.forEach(System.out::println);\n    } \n}\n```\n\n&ensp;&ensp;&ensp;&ensp;第二种方式：就是使用匿名内部类或者lambda表达式实现\n\n```java\nimport java.util.Comparator;\nimport java.util.TreeSet;\npublic class StudentTest3 \n{\n    public static void main(String[] args) \n    {\n        //调用TreeSet中具备Comparator接口方法,参数赋值就是实现\n        Comparator接口的对象\n        //匿名内部类版本\n        TreeSet<Student2> treeSet = new TreeSet<>(new\n        Comparator<Student2>() \n        {\n            @Override\n            public int compare(Student2 o1, Student2 o2) \n            {\n            return o1.getAge() - o2.getAge();\n            }\n        });\n        treeSet.add(new Student2(\"张三\",18,178,100));\n        treeSet.add(new Student2(\"李四\",20,181,200));\n        treeSet.add(new Student2(\"王五\",16,200,10));\n        treeSet.add(new Student2(\"赵六\",19,145,150));\n        treeSet.add(new Student2(\"田七\",21,190,160));\n        treeSet.forEach(System.out::println);\n        \n        //Lambda表达式\n        TreeSet<Student2> treeSet2 = new TreeSet<>((o1,o2) -> o2.getAge()-o1.getAge());\n        treeSet2.add(new Student2(\"张三\",18,178,100));\n        treeSet2.add(new Student2(\"李四\",20,181,200));\n        treeSet2.add(new Student2(\"王五\",16,200,10));\n        treeSet2.add(new Student2(\"赵六\",19,145,150));\n        treeSet2.add(new Student2(\"田七\",21,190,160));\n        treeSet2.forEach(System.out::println);\n    } \n}\n```\n\n## 总结Comparable和Comparator接口\n\n&ensp;&ensp;&ensp;&ensp;现在Java而言不仅只有TreeSet能排序，List集合也可以排序，Map集合也可以排序，合理规划使用排序即可，Comparable这个接口值专门针对TreeSet集合进行排序而设计一个接口，它的局限性在于它只适合自定义类存储在TreeSet进行使用，其他位置提供Sort方法是不使用Comparable作为参数，Comparator属于自定义排序接口，使用比较广泛，除了在TreeSet中可以使用之外，List集合中提供Sort和JavaAPI中提供其他Sort方法基本上都是使用Comparator参数类型，所以这两个接口建议优先掌握Comparator接口【使用广泛】，其次Comparable\n\n# <center>知识点十五：Set集合总结</center>\n\nSet集合是一个接口继承与Collection接口和Iterable接口,Set集合本身具备排重功能和存储无序\n\n```java\npublic interface Set <E> extends Collection<E>\n```\n\nSet集合集合主要的实现类有HashSet、LinkedHashSet和TreeSet，所以Set集合接口是支持多态创建对象\n\n```java\nSet<Integer> set1 = new HashSet<>();\nSet<Integer> set2 = new LinkedHashSet<>();\nSet<Integer> set3 = new TreeSet<>();\n```\n\nSet集合中提供可操作集合都是线程不安全，所以面临多线程处理数据的时候\n\n```java\nCollections.synchronizedSet(Set集合的对象); --》将一个Set集合对象变成线程安全集合\n```\n\n除了这种方式之外可以使用Java5开始提供java.util.concurrent包下提供线程集合完全类来进行操作\n\n**HashSet它是Set集合主要实现类，也是实际开发中使用比较广泛的一个类**，这个类的主要实现是Hash表，底层实现是创建一个HashMap对象作为HashSet的具体实现，并且向HashSet存储数据时，其实是向HashMap中key值的位置进行数据存储\n\n```java\n//构造方法\npublic HashSet() \n{\n    map = new HashMap<>();\n} \n//添加数据\npublic boolean add(E e) \n{\n    return map.put(e, PRESENT)==null;\n}\n```\n\nHashSet的默认容量是16，加载因子是0.75，扩容大小是原有一倍\n\n在Java8之前HashSet底层主要实现是Hash表【数组+链表】形式，从Java8开始对底层存储进行优化，提供存储和查询效果将原有Hash表进行优化【数组+链表或红黑树】，向Hash表中如果存储数据，**某个存储位置中链表长度大达到8的时候【存储了8个数据】，就将链表修改为红黑树，从而提高查询效率**\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291950536.png\" alt=\"红黑树\" style=\"zoom:50%;\" />\n\nHashSet存储自定义类对象时，如果需要进行排重操作，需要提供equals和hashcode重写\n\nLinkedHashSet是HashSet子类，本身不具备任何特殊方法，所有都是来源于Set接口，唯一特点就是提供一个链表来记录存储顺序，开发中是几乎与不用，它操作可有完全仿照HashSet\n\nTreeSet 是Set集合中一个排序排重的集合，这个集合使用 红黑树+Hash表，当使用TreeSet的无参构造方法创建对象时，向TreeSet集合存数据，这个存储的数据必须实现Comparable接口，也可使用TreeSet的有参构造方法，方法参数是Comparator类型，实现Comparator接口进行存储数据的自定义排序\n\nPS:不是只有TreeSet才可以排序，List和Map集合都可以进行排序操作，但是这个俩个集合都会使用到Comparator\n\n# <center>知识点十六：Collection集合</center>\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291950700.png\" alt=\"Collection集合\" style=\"zoom:50%;\" />\n\nCollection集合接口是List和Set集合接口父接口，Collection集合接口继承Iterable接口，所以List和Set集合接口都是支持迭代器操作，因为List和Set集合接口都是Collection集合子接口，所以List和Set集合接口的实现了可以作为Collection集合接口的实现类使用，所以支持多态创建\n\n```java\n//Collection集合接口创建对象\nCollection <Integer> c1 = new ArrayList<>();\nCollection <Integer> c2 = new LinkedList<>();\nCollection <Integer> c3 = new Vector<>();\nCollection <Integer> c4 = new HashSet<>();\nCollection <Integer> c5 = new LinkedHashSet<>();\nCollection <Integer> c6 = new TreeSet<>();\n```\n\n因为Collection是集合接口，所以里面的方法都已经讲解完毕\n\nPS：在实际开发中List集合接口中最常用类是ArrayList，Set集合接口中最常用类是HashSet\n\n# <center>知识点十七：Collections工具类</center>\n\n将集合中的元素反转\n\n&ensp;&ensp;&ensp;&ensp;Collections.reverse(List list)\n\n将集合中的元素随机打乱\n\n&ensp;&ensp;&ensp;&ensp;Collections.shuffle(List list)\n\n将集合中的元素排序 （必须要实现Comparable接口）\n\n&ensp;&ensp;&ensp;&ensp;Collections.sort(List list)\n\n```java\npublic class CollectionsDemo\n{\n    public static void main(String[] args)\n    {\n        List<String> list = new ArrayList<String>();\n        list.add(\"jack\");\n        list.add(\"大娃\");\n        list.add(\"二娃\");\n        list.add(\"rose\");\n        list.add(\"妖怪\");\n        list.add(\"蛇妖\");\n        list.add(\"蛇妖\");\n        System.out.println(list);\n        \n        //按照字典顺序\n        Collections.sort(list);\n        System.out.println(list);\n        \n        //将集合元素进行翻转\n        Collections.reverse(list);\n        System.out.println(list);\n        \n        //将集合中的元素进行随机打乱\n        Collections.shuffle(list);\n        System.out.println(list);\n        \n        //Arrays数组工具类 Collections集合工具类\n    }\n}\n```\n\n# <center>知识点十七：Map集合</center>\n\n![Map集合](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291953280.png)\n\n## <center>1、Map集合介绍</center>\n\n&ensp;&ensp;&ensp;&ensp;Map集合是两大集合之一和Collection之间是并存关系，Map不是Collection的子类，Map一般会和List和Set这两个集合并称三大集合【List、Set和Map】，因为Map和Collection并没有什么关系，所以Map集合和Iterable接口也没有任何关系，所以Map集合是不提供迭代器操作\n\n&ensp;&ensp;&ensp;&ensp;Map集合在Java提供一种存储数据方式，这种方式称之为“映射”【keyvalue键值对】，通过映射这种关系将将两个数据进行相连形成数据存储形式就是key-value键值对\n\nPS：key和value值不要过分纠结，只要提供Map存储数据数据类型就可以决定key值存储什么value值存储什么，他们在底层存储形式是以一种键值对相连的【情侣】\n\n&ensp;&ensp;&ensp;&ensp;映射的说明: 在数学中假设A，B两个非空集合，如果存在一个法则F，使用A集合中每一个元素按照法则F在B集合中有一个唯一对应，则成F为A到B集合映射关系\n\n在做映射关系时：\n\n&ensp;&ensp;&ensp;&ensp;提供key值要求是唯一的 ，A集合中相当于存储Key而**Key是唯一**的，所以可以想象存储key的集合其实就是Set集合提供vlaue值是可以不唯一的，B集合相当于存储Value而**value是不唯一的**，所以可以想象存储value的集合其实就是List集合\n\n提供一个链接法则【链接原则】 让A集合key可以和B集合中value进行一个链接形成一个键值对，Map提供存储方式就是这个方法Entry(key-value),Map中存储大量Entry实体存储就是相当与键值对存储了\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291954387.png\" alt=\"介绍\" style=\"zoom:50%;\" />\n\n## <center>2、Map集合主要实现类HashMap</center>\n\nHashMap与Map接口之间关系\n\n```java\npublic class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable\n```\n\n&ensp;&ensp;&ensp;&ensp;HashMap的主要实现接就是Map，HashMap也是Map接口的最主要实现类HashMap在官方文档中说明：基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外， HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变\n\n&ensp;&ensp;&ensp;&ensp;说明：HashMap的主要实现使用Hash表，但是在Java7之前使用的是原始Hash表的形式即【数组+链表】形式存储数据，但是从Java8开始HashMap集合提供Hash表实现从【数组+链表】转换为【数组+链表或红黑树】，当前向HashMap中某个“桶节点【即存储位置】”，添加的数据达到8个时，就会将链表结构转换红黑树，8这个数字在链表中的查询效果是可以控制，因为链表的查询方式是线性查询【从前之后】，所以最快效率是1，最慢效率N，平均值(1+N)/2,随着N值不断变大，这个查询效率会逐渐降低，所以在8节点时将链表转换为红黑树，就是为提高查询效率而是用，红黑树是平衡树，而且树的查询效率是【2倍效率】\n\nHashMap集合是线程不安全集合，在多线程前提现可以使用\n\nHashtable【之前做法】，现在开发不在使用Hashtable，如何解决线程不安全问题\n\n```java\nCollections.synchronizedMap(new HashMap()); ---> 得到一个线程安全集合或者\n                                                    使用线程安全Map集合---》ConcurrentHashMap集合\n```\n\nHashMap是存储key-value键值对形式集合，所以创建HashMap对象时需要提供Key和Value的泛型的数据类型，HashMap毕竟底层是Hash表所以在Java中初始容量16,加载因子0.75，扩容方式是原有容量2倍，并且会重新计算所有存储在HashMap中数据存储位置即从新计算key的存储位置\n\nHashMap在Java8之前和Java8之后API有很大的变化，将Java8之前API看做是基础API，将Java8提供API看做增强操作API即可\n\n## <center>3、HashMap常用方法(Java8之前)</center>\n\n```java\nimport java.util.*;\nimport java.util.function.BiConsumer;\npublic class Test3\n{\n    public static void main(String[] args) \n    {\n        //1.提供HashMap的对象创建方式\n        //1.1创建一个空HashMap集合对象【默认初始容量16，加载因子0.75】 ---> 常用\n        HashMap<String,Integer> map = new HashMap<>();\n        //1.2创建一个提供初始容量大小的HashMap集合对象【加载因子0.75】\n        HashMap<String,Integer> map2 = new HashMap<>(32);\n        //1.3创建一个提供初始容量大小和加载因子的HashMap对象---》提供的容量是16的倍数，加载因子不易过小\n        HashMap<Character,Double> map3 = new HashMap<> (32,0.5f);\n        //1.4将参数Map集合对象中存储数据赋值给当前HashMap集合对象进行存储 ---> 偶尔\n        HashMap<String, Integer> map4 = new HashMap<> (map);\n        \n        //提供常用API;\n        //1.向HashMap集合对象中添加数据 [第一个参数是存储的key值，第二个参数参数存储是value值]\n        map.put(\"1\",1);\n        System.out.println(map);//HashMap已经重写toString方法所以直接打印集合对象查看结果\n        //PS：在使用put方法向map集合对象中添加 \"1\",2 键值对\n        /*\n            1.向Map集合添加Key-value键值对时 key值必须是唯一的，又使用key = \"1\" 那么系统并没有\n                提示任何语法错误信息和异常信息，是否会出现运行时异常呢？ ---》不会出现异常\n            2.put方法的第二个作用：修改指定key对应value值\n                当使用put方法提供一个已经在map集合对象中存在key时，将put操作认为是覆盖原有已经存在map集合中key-value\n        */\n        map.put(\"1\",2);\n        System.out.println(map);\n        \n        //putAll(Map集合对象) --> 将参数Map集合对象中存储的数据赋值给Map集合\n        // clear() ---> 将Map集合中存储数据清空，map对象的引用是保留\n        // isEmpty() --->判断Map集合中是否有存储数据 存储数据返回false 没有存储返回true\n        \n        //判断Map集合中是否存在指定key值 --> 存储返回true 不存在返回false\n        System.out.println(map.containsKey(\"1\"));\n        //判断Map集合中是否存在指定value值 -->存储返回true 不存在返回false\n        System.out.println(map.containsValue(2));\n        \n        //获取存储在Map集合value值时 ---》key存在会得到对应value，key不存在会得到null值\n        Integer integer = map.get(\"2\");    //参数：key值\n        if(Objects.nonNull(integer)) //建议添加非null判断\n        { \n            integer.intValue();\n        } \n        \n        //将存储在Map集合中key-value键值对删除，条件是一个key值\n        map.remove(\"1\");\n        \n        System.out.println(\"获取Map集合中存储元素的个数：\"+map.size());\n        \n        // Map集合遍历方式比较麻烦，没有迭代器，不支持普通for循环遍历，不支持增强for\n        //获取map集合中所有key的值存储在一个Set集合中\n        Set<String> strings = map.keySet(); //通过这种方式获取到所有key\n        //获取map集合中所有value的值存储在一个Collection集合中\n        Collection<Integer> values = map.values(); //通过这种方式获取到所有value值\n        /*\n            Map提供了一种遍历方式entrySet方法 -->返回值是一个Set集合\n            Set集合存在一个泛型类型 Map.Entry ---》Set集合中存储的数据类型\n            Map.Entry<String,Integer> --> 相当Map.Entry类型中存储数据是 String类型key 和 Integer类型value\n            通过entrySet这个方法，返回一个Set集合这个集合存储这个Entry的类型，Entry类型的内部存储的是key-value兼职对\n        */\n        HashMap<String,Integer> map5 = new HashMap<>();\n        map5.put(\"key1\",1);\n        map5.put(\"key2\",2);\n        map5.put(\"key3\",3);\n        map5.put(\"key4\",4);\n        map5.put(\"key5\",5);\n        Set<Map.Entry<String, Integer>> entries = map5.entrySet();\n        System.out.println(entries);\n        //提供Set集合之增强for循环遍历\n        for(Map.Entry<String, Integer> entry : entries)\n        {\n            //entry就得到了存储在Set集合中key-value键值对 即 key1=1\n            System.out.println(\"Key的值是：\"+entry.getKey());\n            System.out.println(\"Value的值是：\"+entry.getValue());\n        } \n        //在Java8中时提供一个foreach方法可以便捷遍历集合中key和value\n        map5.forEach(new BiConsumer<String, Integer>() \n        {\n            /**\n            * \n            * @param s map集合中key值\n            * @param integer map集合汇总value\n            * 这个方法被出触发时可以获取map集合中每一对：keyvalue\n            */\n            @Override\n            public void accept(String s, Integer integer)\n            {\n                //这个可以进行操作但是只是打印的结果，不会影响最终map集合中的结果\n                System.out.println(s);\n                System.out.println(integer);\n            }\n        });\n        map5.forEach((k,v)-> System.out.println(k+\"=\"+v));\n    }\n}\n```\n\n## <center>4、HashMap常用方法(Java8之后)</center>\n\n```java\n/**\n* 提供HashMap基础API【Java8之后】\n*/\npublic class HashMapAPIDemo_2 \n{\n    public static void main(String[] args) \n    {\n        //1.提供HashMap的对象创建方式\n        //1.1创建一个空HashMap集合对象【默认初始容量16，加载因子0.75】 ---> 常用\n        HashMap<String,Integer> map = new HashMap<>();\n        //新Java8中方法\n        //1向map集合中添加数据 --->如果key已经存在则不添加，否则添加数据 【建议向Map集合存储数据使用】\n        map.putIfAbsent(\"1\",1);\n        map.putIfAbsent(\"2\",2);\n        map.putIfAbsent(\"3\",3);\n        map.putIfAbsent(\"1\",1000);\n        map.putIfAbsent(\"1\",10000);\n        System.out.println(map);\n        //2.提供了一个全系列对map集合中k和v进行存储的方法 ---》computeXXX方法\n        //2.1 map集合中指定key在map集合进行操作\n        /*\n        执行原理:\n            无论key是否存在都会执行参数中提供Lambda表达式\n            1.如果key值存在，后面提供Lambda表达式就会取出key所对应value并在Lambda表达式中进行操作，然后修改原有k和v值\n            2.如果key值不存在，后面提供Lambda表达式就会将key进行存到 map集合操作\n                第一个参数就是key值，第二个参数就是提供操作key对应Lambda表达式\n        */\n        map.compute(\"3\",(k,v) -> v == null ? 0 : v+1);\n        System.out.println(map);\n        map.compute(\"4\",(k,v) -> v == null ? 0 : v+1);\n        System.out.println(map);\n        //2.2 判断map集合key是否存在提供对应操作\n        /*\n        执行原理：\n            1.如果key存在，后面提供Lambda表达式就不会执行，并返回key对应value值\n            2.如果key不存储，后面提供Lambda表达式就会执行操作者并将Lambda表达式中处理\n            之后value值与key一起存储到map集合中\n            PS：Lambda表达式是你如何处理这个value操作 ，你自己决定\n            但是一定要返回这个value即添加return\n            第一个参数就是key值，第二个参数就是提供操作key对应Lambda表达式\n        */\n        Integer integer = map.computeIfAbsent(\"3\",key -> new Integer(5));\n        System.out.println(map);\n        map.computeIfAbsent(\"5\",key -> new Integer(5));\n        System.out.println(map);\n        //2.3 判断map集合key是否存在提供对应操作\n        /*\n        执行原理：\n            1.如果key存在，就执行后lambda表达式，并修改map集合key所对应value值\n            2.如果key不存在，就不会执行后面lambda表达式，不会像Map集合中做任何操作，但是方法会返回一个null\n            第一个参数就是key值，第二个参数就是提供操作key对应Lambda表达式\n        */\n        map.computeIfPresent(\"3\",(k,v) -> v+1);\n        /*\n            相当于 你调用map.containsKey() --》 在调用 map.get()--》得到value之后进行操作\n            在调用 --->map.put 这个存储回去\n        */\n        System.out.println(map);\n        map.computeIfPresent(\"6\",(k,v) -> v+1);\n        System.out.println(map);\n        \n        /*\n            getOrDefault这个方法作用是通过key值获取对应value，这个方法根get方法最大区别在于\n            这个方法提供一个默认值，如果key不存在则返回对应默认值， 存在则返回value值\n            get方法在则返回value不在则返回null值\n        */\n        //第一个参数是key值 第二个参数是默认值\n        Integer orDefault = map.getOrDefault(\"7\", Integer.MAX_VALUE);\n        \n        //merge(合并) --》方法含义 对存在在map集合中kv键值对进行更新操作【更新value值】\n        /*\n            第一个参数 是map集合存在key值\n            第二个参数 这个参数的作用是向Lambda表达式中提供方法参数中\n            第二个参数赋值 即 newVal\n            第三个参数 需要对存在在集合key所对应value所提供更新数据操作 --》 提供一个lambda\n            lambda中第一个参数即oldVal是获取出提供key所对应的value值\n            第二个参数即newVal或获取方法中第二个参数值\n            提供这两个参数计算更新key所对应value值\n        */\n        map.merge(\"1\",2,(oldVal,newVal)->oldVal+newVal);\n        System.out.println(map);\n        \n        //删除方法--》根据提供k和v值进行删除，如果存在在map中删除成功返回true，如果不存在删除失败返回false\n        boolean remove = map.remove(\"1\", 3);\n        System.out.println(remove);\n        System.out.println(map);\n        \n        //Java8中提供一个操作，官方文档意思在于使用这个方法替代put方法修改操作\n        //根据key值替换存储对应value值，如果key存在则替换，不存在则不替换\n        map.replace(\"2\",3);\n        System.out.println(map);\n        // 多参数版本 提供完整key-value键值对，进行替换操作 如果key和value匹配成功存在则替换，不存在则替换\n        /*\n            第一个参数是 key值\n            第二个参数是 key对应原理的value值\n            第三个参数是 新替换value值\n        */\n        map.replace(\"2\",3,4);\n        //只要满足lambda表达式提供替换条件，就会将value值进行替换\n        map.replaceAll((key,value)->\n        {\n            //提供替换操作者条件\n            if(key.length() >= 1)\n            {\n                //提供替换操作\n                value = 1;\n            } \n            //需要将替换的value值提提供return返回\n            return value;\n        });\n        System.out.println(map);\n        // forEach打印方法\n        map.forEach((k,v)-> System.out.println(k+\"=\"+v));\n    }\n}\n```\n\nHashMap有一个子类LinkedHashMap这个集合 操作方式和HashMap是一样，只不过就是存储结构有所变化多了一个链表存储，Hashtable已经不在使用了，所以这个API执行查看和HashMap操作一样的\n\n## <center>5、Map集合之TreeMap集合</center>\n\nTreeMap集合是Map集合实现类之一，TreeMap集合提供排序操作，TreeMap集合排序操作和TreeSet道理相同的，需要提供Comparator和Comaprable接口，根据使用TreeMap中构造方法决定说那个那个接口来实现排序操作\n\n在官方的API文档中的介绍：基于红黑树（Red-Black tree）的NavigableMap 实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法\n\nTreeMap集合的排序点在于存储的键值key，将要排序数据存储到key中就可以进行排序操作\n\n当调用无参构造方法创建TreeMap对象时，使用Comparable进行的比较操作\n\nTreeMap() 使用键的自然顺序构造一个新的、空的树映射\n\n当调用有参构造方法创建TreeMap对象时，使用Comparator进行的比较操作\n\nTreeMap(Comparator comparator) 构造一个新的、空的树映射，该映射根据给定比较器进行排序\n\n```java\nimport java.util.Comparator;\nimport java.util.TreeMap;\npublic class TreeMapDemo \n{\n    public static void main(String[] args) \n    {\n        TreeMap<Integer,String> treeMap = new TreeMap<>();\n        treeMap.putIfAbsent(10,\"value10\");\n        treeMap.putIfAbsent(8,\"value8\");\n        treeMap.putIfAbsent(15,\"value15\");\n        treeMap.putIfAbsent(7,\"value7\");\n        treeMap.putIfAbsent(1,\"value1\");\n        treeMap.putIfAbsent(9,\"value9\");\n        treeMap.putIfAbsent(20,\"value20\");\n        treeMap.putIfAbsent(13,\"value13\");\n        System.out.println(treeMap);\n        \n        TreeMap<Integer,String> treeMap2 = new TreeMap<> (new Comparator<Integer>() \n        {\n            @Override\n            public int compare(Integer o1, Integer o2) \n            {\n            return o2 - o1;\n            }\n        });\n        treeMap2.putIfAbsent(10,\"value10\");\n        treeMap2.putIfAbsent(8,\"value8\");\n        treeMap2.putIfAbsent(15,\"value15\");\n        treeMap2.putIfAbsent(7,\"value7\");\n        treeMap2.putIfAbsent(1,\"value1\");\n        treeMap2.putIfAbsent(9,\"value9\");\n        treeMap2.putIfAbsent(20,\"value20\");\n        treeMap2.putIfAbsent(13,\"value13\");\n        System.out.println(treeMap2);\n        \n        TreeMap<Integer,String> treeMap3= new TreeMap<> ((o1,o2)->o2 - o1);\n        treeMap3.putIfAbsent(10,\"value10\");\n        treeMap3.putIfAbsent(8,\"value8\");\n        treeMap3.putIfAbsent(15,\"value15\");\n        treeMap3.putIfAbsent(7,\"value7\");\n        treeMap3.putIfAbsent(1,\"value1\");\n        treeMap3.putIfAbsent(9,\"value9\");\n        treeMap3.putIfAbsent(20,\"value20\");\n        treeMap3.putIfAbsent(13,\"value13\");\n        System.out.println(treeMap3);\n    }\n}\n```\n\nTreeMap集合排序的时候也是会对key值进行排重操作，这个排重操作依据是提供Comparable和Comparator接口中方法实现时，如果结果为0，就会进行排重操作\n\n## <center>6、Collections工具类</center>\n\nCollections工具类类似于Arrays工具类，Collections工具类是为了给Collection集合提供便捷操作工具类，虽然Collection集合已经提供很多方法了，但是Collections工具类也提供一些操作方法，弥补开发时所需要自行定义方法\n\nCollections工具类提供方法大部分都是给Collection集合使用，极少部分是给Map集合使用\n\n```java\npublic class CollectionsAPIDemo \n{\n    public static void main(String[] args) \n    {\n        //1.一次性向Collection集合对象中添加多个数据--》【推荐】\n        List<Integer> list = new ArrayList<>();\n        //向集合中存这些数据：【 321,34,3,1,4,4231,4123,353,1】\n        list.add(321);\n        list.add(34);\n        list.add(3);\n        list.add(1);\n        list.add(4);\n        list.add(4231);\n        list.add(4123);\n        list.add(353);\n        list.add(1);\n        //不用上面这样麻烦操作了,直接使用addAll方法就可以了\n        //这个方法的第一个参数是 Collection集合对象， 第二个参数就是要存储值使用【,】分隔即可\n        Collections.addAll(list,321,34,3,1,4,4231,4123,353,1);\n        \n        //2.提供Collection集合排序操作【针对是List集合】\n        Collections.sort(list); //默认是升序排序操作【要去排序数据要么实现Comparable要么实现Comparator】\n        System.out.println(list);\n        //可以使用Collections工具类中提供静态方法进行降序排序【仅针对集合中存储系统引用类型有效】\n        Collections.sort(list,Collections.reverseOrder());\n\n        System.out.println(list); //指针对系统类型\n        \n        //自定义排序操作\n        Collections.sort(list, new Comparator<Integer>() \n        {\n            @Override\n            public int compare(Integer o1, Integer o2) \n            {\n                return o1 - o2;\n            }\n        });\n        Collections.sort(list,(o1,o2)->o2-o1);\n        \n        //从Java8开始List集合接口提供sort方法，所以可以直接调用List集合的sort方法进行排序操作\n        list.sort(new Comparator<Integer>() \n        {\n            @Override\n            public int compare(Integer o1, Integer o2) \n            {\n                return o1-o2;\n            }\n        });\n        list.sort((o1,o2)->o2-o1);\n        \n        //将List、set和Map集合转换为线程安全的集合\n        List<Integer> lists = Collections.synchronizedList(new ArrayList<Integer>());\n        Set<String> sets = Collections.synchronizedSet(new HashSet<String>());\n        Map<String, Integer> maps = Collections.synchronizedMap(new HashMap<String, Integer>());\n         \n        // 提供二分查找【要排序数据】 找到 下标 找不到 负数\n        int i = Collections.binarySearch(list, 1);\n        //交换List集合存储元素的位置 位置参数是下标\n        Collections.swap(list,0,list.size()-1);//第一个元素和最后一个元素互换\n        //打乱List集合对象中存储数据的顺序【将有序存储数据打乱存储】\n        Collections.shuffle(list);\n        //向List集合中填充同一个数据\n        Collections.fill(list,1);\n    }\n}\n```\n\n## <center>7、Collection集合和Map集合的总结</center>\n\nCollection是Java集合框架中根接口也是List和Set集合的父接口，Collection集合接口也继承Iterable接口所有Collection系的集合都支持迭代器进行遍历操作，在Collection集合接口中常用的就是List和Set接口，List和Set接口中常用的实现类集合**ArrayList【允许存储重复数据并且使用数组实现】和HashSet【不允许存储重复数据并且使用Hash表实现】**\n\nMap集合本身没是不在Collection范围内容，它是一个独立的集合，Map提供一种【键值对】即key-value的形式进行数据存储操作，在存储数据时要求key值必须是唯一的，value值可以不唯一，**在Map集合接口中主要使用实现类是HashMap**\n\n**PS：List集合使用ArrayList 、Set集合使用HashSet、Map集合使用HashMap**\n\n## <center>8、HashMap应用</center>\n\n- 可以使用Map 表示一个实体类\n- 可以使用List> 表示一个实体类集合\n\n```java\npublic class HashMapDemo02\n{\n    /**\n     * 在java一个用户对象\n     *      一个用户对象\n     *      public class user\n     *      {\n     *          private String username;\n     *          private String password;\n     *          private int age;\n     *          private String phone;\n     *          private String address;\n     *          ......\n     *      }\n     *      User user = new User(\"admin\",\"123\",30);\n     *\n     *      多个用户对象\n     *      以前：User[]\n     *      现在：List<User>\n     \n     * 在实战开发中，如果这个类使用不多，那么这个时候就没有必要创建一个User类\n     * 可以使用Map来代替\n     *      一个用户对象\n     *       HashMap<String,Object> map = new HashMap<>();\n     *       map.put(\"username\",\"admin\");\n     *       map.put(\"password\",\"123\");\n     *       map.put(\"age\",20);\n     *       多个用户对象\n     *       List<Map<String,Object>>\n     */\n}\n```\n\n## <center>9、HashMap底层实现原理</center>\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402292004683.png\" alt=\"实现原理\" style=\"zoom: 50%;\" />\n\n## <center>10、put的过程原码</center>\n\nput流程\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402292004096.png\" alt=\"put流程\" style=\"zoom:50%;\" />\n\n```java\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict)\n{\n    //tab表示存放Node节点的数据 p表示当前节点 n表示长度 i表示节点在数组中的下标\n    Node<K,V>[] tab; Node<K,V> p; int n, i;\n    //判断数组如果为空或者数组长度为0，那么就对数组进行扩容，数组默认初始大小为16\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    //将数组的长度-1与hash值进行与运算(计算的结果一定是0~数组长度-1)得到元素应该存放的下标\n    //如果当前下标位置为空，那么直接将Node节点存放在当前位置\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        tab[i] = newNode(hash, key, value, null);\n    //如果当前位置不为空(分为三种情况)\n    else\n    {\n        Node<K,V> e; K k;\n        //情况1：要添加的元素与当前位置上的元素相同(hash(hashCode)、key(equals)一致),则直接替换\n        if (p.hash == hash &&((k = p.key) == key || (key != null && key.equals(k))))\n            e = p;\n        //情况2:如果要添加的元素是红黑树节点，那么将其添加到红黑树上\n        else if (p instanceof TreeNode)\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n        //情况3:如果要添加的元素是链表，则需要遍历\n        else\n        {\n            for (int binCount = 0; ; ++binCount)\n            {\n                //将当前元素的下一个节点赋给e\n                //如果e为空，则创建新的元素节点放在当前位置的下一个元素上，并退出循环\n                if ((e = p.next) == null)\n                {\n                    p.next = newNode(hash, key, value, null);\n                    //如果链表的元素个数大于8个(且当数组中的元素个数大于64)，则将其转换成红黑树\n                    if (binCount >= TREEIFY_THRESHOLD - 1)     // -1 for 1st\n                        treeifyBin(tab, hash);\n                    break;\n                } \n                //要添加的元素与当前位置上的元素相同(hash(hashCode)、key(equals)一致),则直接退出循环\n                if (e.hash == hash &&((k = e.key) == key || (key != null && key.equals(k))))\n                    break;\n                p = e;\n            }\n         } \n          //如果返回的e不为null\n          if (e != null)\n          { \n              // existing mapping for key\n              //将e的值赋给oldValue\n              V oldValue = e.value;\n              if (!onlyIfAbsent || oldValue == null)\n                  e.value = value;afterNodeAccess(e);\n                  //返回以前的值(当添加的元素已经存在返回的是以前的值)\n               return oldValue;\n          }\n    } \n    ++modCount;\n    //如果数组的元素个数大于阈值则进行扩容\n    if (++size > threshold)resize();\n    afterNodeInsertion(evict);\n    return null;\n}\n```\n\n## <center>11、resize过程原码</center>\n\n扩容流程\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402292005741.png\" alt=\"扩容时机\" style=\"zoom:50%;\" />\n\n```java\nfinal Node<K,V>[] resize()\n{\n    //oldTab 表示原来数组(如果是第二次扩容：长度为16的那个)\n    Node<K,V>[] oldTab = table;\n    //oldCap 表示原数组的容量(长度)\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\n    //oldThr 表示数组原来的阈值 12\n    int oldThr = threshold;\n    //newCap 新数组的容量 newThr 新数组的阈值\n    int newCap, newThr = 0;\n    if (oldCap > 0)\n    {\n        if (oldCap >= MAXIMUM_CAPACITY)\n        {\n            threshold = Integer.MAX_VALUE;return oldTab;\n        } \n        //新数组的容量扩大一半 newCap 32\n        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY && oldCap >= DEFAULT_INITIAL_CAPACITY)\n        //新阈值扩大老阈值的一半 newThr 24\n        newThr = oldThr << 1; // double threshold\n    }\n    else if (oldThr > 0)     // initial capacity was placed in threshold\n    newCap = oldThr;\n    else \n    {\n        // zero initial threshold signifies using defaults\n        newCap = DEFAULT_INITIAL_CAPACITY;\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    }\n    if (newThr == 0)\n    {\n        float ft = (float)newCap * loadFactor;\n        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?(int)ft : Integer.MAX_VALUE);\n    } \n    //threshold 24\n    threshold = newThr;\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n    //创建一个长度为32的数组\n    Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n    //table指向新数组\n    table = newTab;\n    if (oldTab != null)\n    {\n        //将原数组中的元素拷贝到新数组中\n        for (int j = 0; j < oldCap; ++j)\n        {\n            Node<K,V> e;\n            //如果当前位置元素不为空\n            if ((e = oldTab[j]) != null)\n            {\n                oldTab[j] = null;\n                //情况1：当前位置上的下一个元素为空，则直接将这个元素拷贝到新数组中\n                if (e.next == null)newTab[e.hash & (newCap - 1)] = e;\n                //情况2：当前位置上的元素红黑树类型，则需要进行切割\n                else if (e instanceof TreeNode)((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                //情况3：当前位置上的元素链表类型，则需要进行分散拷贝\n                else\n                {\n                    // preserve order\n                    Node<K,V> loHead = null, loTail = null;\n                    Node<K,V> hiHead = null, hiTail = null;\n                    Node<K,V> next;\n                    do\n                    {\n                        next = e.next;\n                        if ((e.hash & oldCap) == 0)\n                        {\n                            if (loTail == null)loHead = e;\n                            else\n                                loTail.next = e;\n                             loTail = e;\n                        }\n                        else\n                        {\n                            if (hiTail == null)\n                                hiHead = e;\n                            else\n                                hiTail.next = e;\n                            hiTail = e;\n                        }\n                    }while ((e = next) != null);\n                    if (loTail != null)\n                    {\n                        loTail.next = null;\n                        newTab[j] = loHead;\n                    }\n                    if (hiTail != null)\n                    {\n                        hiTail.next = null;\n                        newTab[j + oldCap] = hiHead;\n                    }\n                }\n            }\n        }\n    }\n    return newTab;\n}\n```\n\n## <center>12、get的过程原码</center>\n\n```java\nfinal Node<K,V> getNode(int hash, Object key)\n{\n    Node<K,V>[] tab; Node<K,V> first, e;\n    int n;K k;\n    if ((tab = table) != null && (n = tab.length) > 0 &&(first = tab[(n - 1) & hash]) != null)\n    {\n        //当前first与要找到的hash和key都相等直接返回当前这个first元素\n        if (first.hash == hash && // always check first node\n            ((k = first.key) == key || (key != null && key.equals(k))))\n            return first;\n            //如果当前first不为空(有两种情况)\n            if ((e = first.next) != null) \n            {\n                //当前位置是一个红黑树\n                if (first instanceof TreeNode)\n                //根据hash、key从红黑树上找到对应的元素z\n                return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n                //当前位置是一个链表\n                do\n                {\n                    //循环进行比较直到找到向的hash和key的元素，并返回\n                    if (e.hash == hash &&((k = e.key) == key || (key != null && key.equals(k))))\n                        return e;\n                } while ((e = e.next) != null);\n            }\n     } \n    //如果数组的为空、数组的长度为0、当前下标位置上的值为null,这三种情况都返回null\n    return null;\n}\n```\n\n# <center>知识点十八：常见的集合面试面试题</center>\n\n- 1、简述：ArrayList、LinkedList、Vector的区别\n- 2、简述：HashSet、TreeSet的去重原理\n- 3、ArrayList、LinkedList底层实现\n- 4、HashMap、HashTable的区别\n- 5、HashMap底层实现原理\n- 6、HashMap扩容机制\n- 7、HashMap的数组容量为什么是2的次方数\n- 8、HashMap的负载因子为什么是0.75\n- 9、HashMap添加元素的过程\n- 10、谈谈了解的数据结构\n","tags":["Java"],"categories":["编程语言","Java"]},{"title":"19.常用工具类","url":"/post/a920af81.html","content":"\n# <center>知识点一：String类</center>\n\n### <center>1、String的创建</center>\n\n### 1）直接赋值\n\n```java\nString s1 = \"abcd\";\nSystem.out.println(s1);\n```\n\n### 2）通过构造方法\n\n```java\n//String s2 = new String();   //相当于String s2 = \"\";\nString s2 = new String(\"123\");  //相当于String s2 = \"123\";\nSystem.out.println(s2);\n//3.将一个byte类型数组作为数据参数传递到字符串中进行存储\n//ps:将byte数组中数据转换成对应ASCII码---》如果ASCII码范围就会转换为Unicode【万国码】\n//Unicode对应中国文字编码 ---》 UTF-8\nString str2 = new String(new byte[]{97,98,99});\nSystem.out.println(\"str2 = \"+str2);\n//4.将一个char类型数组作为数据参数传递到字符串中进行存储\nString str3 = new String(new char[]{'a','b','c'});\nSystem.out.println(\"str3 = \"+str3)\n```\n\n### 3）通过字节数组创建对象\n\n```java\nbyte b [] = {97,98,99,1};\nString s3 = new String(b,0,3);  //括号里的参数 第一个数组名 第二个从数组中的起始位置 第三个获取的长度\nSystem.out.println(s3);\n```\n\n### 4）通过字符数组创建对象\n\n```java\nchar c [] = {97,98,99,1};\nString s4 = new String(b,0,3);\nSystem.out.println(s4);\n```\n\n## <center>2、String类常用方法</center>\n\n### 1）获取方法\n\n#### 获取字符\n\n获取字符串中指定下标对应的字符，返回值为char类型\n语法：\n\n```java\n类名.charAt(下标);\n```\n\n```java\nString str = \"abcdefg\";\nchar sh = str.charAt(1);\nSystem.out.println(sh);\n```\n\n#### 获取下标\n\n获取字符串中指定字符串对应的下标，返回值为int类型\n\n如果有相同的字符串，那么返回值是第一个字符串对应的下标\n\n如果没有指定字符串，那么返回-1\n\n语法：\n\n```java\n数组名.indexOf(\"要指定的字符串\");\t\t从前往后找指定的字符串\n数组名.lastIndexOf(\"要指定的字符串\");\t从后往前找指定的字符串\n```\n\n```java\n//获取下标\nString str1 = \"asdfrgx\";\nint a = str1.indexOf(\"d\");\n//如果没有指定字符则返回-1\nint b = str1.indexOf(\"re\");\nSystem.out.println(a);\nSystem.out.println(b);\n//如果有相同的，取出最后面一个下标\nString str2 = \"abc,Java,de,Java,ga\";\nint c = str2.lastIndexOf(\"Java\");\nSystem.out.println(c);\n//提供一个重载方法，在指定下标位置开始向后查找 ，包含指定位置\n//只会返回第一次遇到该字符的位置 ，如果找不到就负数\nint f = str5.indexOf('f', 5);\nSystem.out.println(f);\n```\n\n#### 获取字符串长度\n\n返回值为int类型\n\n语法：\n\n```java\n数组名.length();\n```\n\n```java\n//获取字符串长度\nString str3 = \"admin\";\nint d = str3.length();\n//System.out.println(str3.length());\nSystem.out.println(d);\n```\n\n### 2）判断的方法\n\n返回值都是boolean类型\n\n判断两个字符串是否相等（**区分大小写**）\n\n语法：\n\n```java\n数组名1.equals(数组名2);\n```\n\n判断两个字符串是否相等（**不区分大小写**）\n\n语法：\n\n```java\n数组名1.equalsIgnoreCase(数组名2);\n```\n\n```java\n//判断两个字符串是否相等\nString str1 = \"abc\";\nString str2 = \"Abc\";\nboolean a = str1.equals(str2);  //区分大小写\nboolean b = str1.equalsIgnoreCase(str2); //不区分大小写\n//System.out.println(str1.equals(str2));\nSystem.out.println(a);\nSystem.out.println(b);\n```\n\n#### 比较字符串大小\n\n逐一对比两个字符串中对应位置的字符，并进行差值计算得到结果就是一个整数\n\n&ensp;&ensp;&ensp;&ensp;结果 > 0 当前字符串就大于传入字符串\n\n&ensp;&ensp;&ensp;&ensp;结果 == 0 当前字符串就等于传入字符串\n\n&ensp;&ensp;&ensp;&ensp;结果 < 0 当前字符串就小于传入字符串\n\n调用方法字符串是 当前字符串 参数赋值字符串是 传入字符\n\n只要有任何一对字符比较结果出现 >0 或 <0 的时候就返回结果值，否则就继续比较所有字符，直到一个字符为止\n\n```java\nString str1 = \"abc\";\nString str1_1 = \"ABC\";\nint i = str1.compareTo(str1_1);\nSystem.out.println(i);    //结果是32大于0 就证明str1 大于str1_1\n/* \nString str2 = \"你\";\nString str2_1 = \"您\";\nint i1 = str2.compareTo(str2_1);\nSystem.out.println(i1);\n*/\n```\n\n#### 判断字符串是否以指定的字符串开头或结尾\n\n开头\n\n语法：\n\n```java\n数组名.startsWith(\"指定的字符串\");\n```\n\n```java\nString str = \"18660416463\";\nSystem.out.println(str.startsWith(\"186\"));\n```\n\n结尾\n\n语法：\n\n```java\n数组名.endsWith(\"指定的字符串\");\n```\n\n```java\nString str3 = \"hello.java\";\nSystem.out.println(str3.endsWith(\".java\"));\n```\n\n#### 判断字符串中是否包含指定的字符串\n\n语法：\n\n```java\n数组名.contains(\"指定的字符串\");\n```\n\n```java\n//判断字符串中是否包含指定的字符串\nString str4 = \"java,WC\";\nSystem.out.println(str4.contains(\"WC\"));\n```\n\n#### 判断字符串是否为空\n\n语法：\n\n```java\n数组名.isEmpty();\n```\n\n```java\n//判断字符串是否为空，长度是否为零\nString str5 = \" \";  //里面有空格，不为空\nSystem.out.println(str5.isEmpty());\n```\n\n### 3）拼接方法\n\n#### 字符串拼接方法\n\n使用 + 进行拼接\n\n```java\nString str3 = \"hello \";\nString str3_1 = \"world\";\n//得到一个全新的字符串\nString s = str3 + str3_1;\nSystem.out.println(s);\n```\n\nconcat 方法参数是要字符串,返回一个全新字符串\n\n```java\n//因为方法返回的是一个全新字符串对象，所以可以继续的进行调用拼接\nString concat = str3.concat(str3_1).concat(\"Java is \").concat(\"NO.1\");\nSystem.out.println(concat);\n```\n\n#### 自定义拼接字符串\n\n自定义拼接字符串方式【格式化字符串】 ---》 静态方法\n\nString.format\n\n第一个参数是格式控制符 --》 %d 代表整数 %f 代表小数 %s代表字符串 %c代表字符\n\n第二个参数是与格式化控制符与之对应的数据【一一对应】\n\n```java\nString format = String.format(\"%f%s%c\", 12.345, \"字符串\", 'c');\nSystem.out.println(format);\n//Java中如何让小数保留小数点后几位 --》 使用使用%f 进行 %.几f ---》.几就是保留几位\n//保留小数点后两位【支持四舍五入】\nString format1 = String.format(\"%.2f\", 12.345);\nSystem.out.println(format1);\n//打印整数时候进行补位操作 ---》使用%d 进行 %0几d --》 不足几位就补几个0\n//不足2位补0\nString format2 = String.format(\"%02d\", 1);\nSystem.out.println(format2);\n```\n\n### 4）其他方法\n\n#### 将字符串变成字节数组\n\n语法：\n\n```java\n数组名.getBytes();\n```\n\n```java\n//将字符串变成字节数组\nString str = \"hello\";\nbyte a [] = str.getBytes();\nfor (int i = 0; i < a.length; i++)\n{\n    System.out.println(a[i]);\n}\n```\n\n#### 将字符串变成字符数组\n\n语法：\n\n```java\n数组名.toCharArray();\n```\n\n```java\nString str1 = \"hello\";\nchar ch [] = str1.toCharArray();\nfor (int i = 0; i < ch.length; i++)\n{\n    System.out.println(ch[i]);\n}\n```\n\n#### 取出指定的字符串\n\n语法：\n\n```java\n数组名.substring(起始下标,结束下标);\n```\n\n注意：String是一个字符串常量，一旦定义不能改变，一定要重新赋值\n\n```java\n//取出指定的字符串\nString str2 = \"hello,java!!!\";\n//参数1：起始下标 参数2：结束下标\nstr2 = str2.substring(6,10);  //在Java中区范围都是 左边闭区间，右边开区间\nSystem.out.println(str2);\n```\n\n#### 将字符串中指定的部分字符串改成指定的字符串\n\n语法：\n\n```java\n数组名.replace(\"原数组中指定的要更改的字符串\",\"新的字符串\");\n```\n\n注意：String是一个字符串常量，一旦定义不能改变，一定要重新赋值\n\n```java\n//将指定的字符串改成指定的字符串\nString str3 = \"hello,SB\";\nstr3 = str3.replace(\"SB\",\"**\");\nSystem.out.println(str3);\n```\n\n#### 按指定格式将字符串切割\n\n语法：\n\n```java\n数组名.split(\"切割的格式\");\n```\n\n```java\nString str4 = \"jack lin lida hdnpi\";\nString s [] = str4.split(\" \"); //按空格进行切割，切割完是一个字符串数组\nfor (int i = 0; i < s.length; i++)\n{\n    System.out.println(s[i]);\n}\n```\n\n#### 将字符串中的字母变成大写\n\n语法：\n\n```java\n数组名.toUpperCase();\n```\n\n返回值为String类型\n\n```java\nString str6 = \"ABC好\";\nSystem.out.println(str6.toLowerCase());\n```\n\n#### 去除字符串中前后的空格\n\n语法：\n\n```java\n数组名.trim();\n```\n\n注意：String是一个字符串常量，一旦定义不能改变，一定要重新赋值\n\n```java\nString str7 = \"hello java\";\nstr7 = str7.trim();    //str7指向了新的地址\nSystem.out.println(str7);\n```\n\n#### 将其他类型数据转换成String类型数据\n\n语法：\n\n```java\nString.valueOf(变量名);\n```\n\n返回值为String类型\n\n```java\nint d = 10;\nString str8 = String.valueOf(d);\nSystem.out.println(str8);\n```\n\n方式二\n\n```java\nint c = 10;\nString str9 = c + \"\";    //自动转化成String类型\nSystem.out.println(str9);\n```\n\n## <center>3、正则表达式</center>\n\n&ensp;&ensp;&ensp;&ensp;正则表达式是一个特殊字符串，可以根据正则表达式的语法规则构建一个字符串，利用这个字符串就可以验证其他字符串是否合法\n\n&ensp;&ensp;&ensp;&ensp;正则表达式其实就是提供字符串中内容约束，通过正则表达式就可以验证输入字符串是否满足指定需求。\n\n例如： 注册页面---》用户名验证、密码验证、邮箱验证、手机号码验证等等\n\n需求：在控制台上输入一个QQ 号码需要对QQ号码进行如下验证\n\n&ensp;&ensp;&ensp;&ensp;QQ号码必须满足5~15之间、而且必须全部是数字、首位数字不可以是0\n\n```java\npublic class QQMatches \n{\n    public static void main(String[] args) \n    {\n        /*\n        需求:在控制台上输入一个QQ 号码需要对QQ号码进行如下验证\n            QQ号码必须满足5~15之间、而且必须全部是数字、首位数字不可以是0\n        */\n        //1.在控制台上获取字符串\n        Scanner input = new Scanner(System.in);\n        //2.提供获取控制台数据操作\n        System.out.println(\"请输入QQ号码：\");\n        String qq = input.nextLine();\n        System.out.println(\"您输入的QQ是否合法?（true【合法】/false【不合法】）\"+checkQQ(qq));\n    } \n    public static boolean checkQQ(String qq)\n    {\n        //1.需要QQ号是5~15位之间【只要不在5~15之间就是不合法的】\n        if(qq.length() < 5 || qq.length() > 15)\n        {\n            return false;\n        } \n        //2.需要QQ号码是全数字【只要输入有不是数字的就不合法】\n        for(int i =0 ; i<qq.length();i++)\n        {\n            if(qq.charAt(i) < '0' || qq.charAt(i) > '9')\n            {\n                return false;\n            }\n        } \n        //3.首位不可以是数字0\n        char ch = qq.charAt(0);\n        if(ch == '0')\n        {\n            return false;\n        } \n        return true;//证明通过验证\n    }\n}\n```\n\n在验证QQ号码时需要提供复杂的逻辑判断，但是如果使用正则表达式就可以简化这个操作\n\n```java\npublic static boolean checkQQ2(String qq)\n{\n    //1。根据需求提供验证输入QQ号码的正则表达式\n    String regex = \"[1-9]\\\\d{4,14}\";// --》正则表达式\n    return qq.matches(regex);\n}\n```\n\n&ensp;&ensp;&ensp;&ensp;正则表达式就是一个以特殊符号组合而成一个字符串，用这个字符串可以验证其他字符串是否合法【满足规则】即正则表达式其实就是一个匹配规则，用来替代验证字符串复杂的if结构判断\n\n**&ensp;&ensp;&ensp;&ensp;在String类中提供一个方法matches，这个方法是用于接收一个正则表达式的字符串，验证调用方法的字符串是否满足正则表达式的条件，如果满足条件则返回true，否则返回false**\n\n### 正则表达式的基本使用\n\n&ensp;&ensp;&ensp;&ensp;提供一个语法规则： 使用[]中括号 匹配单个字符 --》在中括号中可以使用 【^ 取反 和 - 范围】就可以组合成如下效果：\n\n&ensp;&ensp;&ensp;&ensp;**1. [abc]代表a、或者b、或者c字符中任何一个**\n\n**&ensp;&ensp;&ensp;&ensp;2. [ ^abc] 代表除a、b、c以为任意字符**\n\n**&ensp;&ensp;&ensp;&ensp;3. [a-z] 代表a-z之间所有的小写字符中任意一个**\n\n&ensp;&ensp;&ensp;&ensp;**4. [A-Z] 代表A-Z之间所有的大写字符中任意一个**\n\n**&ensp;&ensp;&ensp;&ensp;5.[0-9] 代表0-9之间所有数字中任意一个**\n\n&ensp;&ensp;&ensp;&ensp;**6.[a-zA-Z0-9] 代表a~z之间、A~Z之间、0-9之间任意一个字符**\n\n&ensp;&ensp;&ensp;&ensp;**自定义范围[a-dm-p]代表 a~d之间 m~p之间的任意一个字符**\n\n案例：\n\n```java\npublic class RegexDemo1 \n{\n    public static void main(String[] args) \n    {\n        String str = \"abc\";\n        //不可以这样验证，这样是错误\n        System.out.println(str.matches(\"[abc]\"));//false判断某一个不是所有\n        //这样操作是对的\n        String str1 = \"a\";\n        System.out.println(str1.matches(\"[abc]\"));//true判断的是某一个字符\n        //1.验证某个字符串是否以h开头，以d结尾。中间是[a、e、i、o、u]中的某个字符\n        System.out.println(\"ead\".matches(\"h[aeiou]d\"));//false\n        System.out.println(\"hed\".matches(\"h[aeiou]d\"));//true\n        System.out.println(\"head\".matches(\"h[aeiou]d\"));//false\n        //2.验证某个字符串是否以a-z的任何一个小写字母开头，后缀ad\n        System.out.println(\"Aad\".matches(\"[a-z]ad\")); //false\n        System.out.println(\"aad\".matches(\"[a-z]ad\"));// true\n        //3.验证某个字符串是否以a-d或者m-p之间某个字符靠头，后缀ad\n        System.out.println(\"nad\".matches(\"[a-dm-p]ad\")); //true\n        System.out.println(\"Mad\".matches(\"[a-dm-p]ad\"));//false\n    }\n}\n```\n\n### 正则表达式之逻辑运算符\n\n可以在上面语法中增加逻辑运算符 ，正则表达式中逻辑运算符有【&&并且 、 | 或者】\n\n```java\npublic class RegexDemo2 \n{\n    public static void main(String[] args) \n    {\n        //需求：判断某个字符串是小写辅音字母开头，后跟ab，剩余字母除aeiou之外，其他辅音字母\n        System.out.println(\"\".matches(\"[aeiou]ab[^aeiou]\"));\n        //需求：开头字母必须是a-z之间小写字母并且不在aeiou中\n        System.out.println(\"\".matches(\"[a-z&&[^aeiou]]\"));\n        //[]这个语法是存在或者含义 ---》[abc] --》得到结果是a或b或c中一个\n        //需求：要求字符串首字母必须是aeiou中任意一个，后面ad\n        System.out.println(\"\".matches(\"[aeiou]ad\"));\n        System.out.println(\"\".matches(\"[a|e|i|o|u]ad\")); //能表明含义\n    }\n}\n```\n\n### 正在表达式之预定义字符【需要记住】\n\n|  \"\\d\" 任何数字[0-9]的简写   | \\s 任意空白字符[\\t\\n\\x)B\\f\\r]简写 |\n| :-------------------------: | :-------------------------------: |\n| “\\w单词字符[a-zA-Z0-9]简写” |   \"\\D\" 任何非数字[ ^0-9]的简写    |\n|  \\S 非空白字符 [ ^\\s]简写   |      “\\W 非单词字符[\\w]简写”      |\n\n特殊说明\n\n1. Java中单个 【\\】代表的是转移字符 即 本身字母d是没有任何含义 配合使用 【\\】就代表数字了，我们不能直接在字符串中使用 \\d的形式 需要将\\体现出来让 \\d成为一个整体 而不是使用 \\ 去转义d ---》就需要使用到【\\\\】 --》 即需使用【\\\\d】\n2. \".\" 点在正则表达式中代表任意字符，如果必要表示一个字符点，那么需要使用【\\\\.】\n\n案例：\n\n```java\npublic class RegexDemo3 \n{\n    public static void main(String[] args) \n    {\n        System.out.println(\"判断9是否是数字：\"+(\"9\".matches(\"[0-9]\")));\n        System.out.println(\"判断9是否是数字：\"+(\"9\".matches(\"\\\\d\")));\n        System.out.println(\"判断258是否是数字：\"+(\"258\".matches(\"[0-9][0-9][0-9]\")));\n        System.out.println(\"判断258是否是数字：\"+(\"258\".matches(\"\\\\d\\\\d\\\\d\")));\n        System.out.println(\"判断字符串是否满足内容需求【h.d】\"+ (\"h.d\".matches(\"h\\\\.d\")));\n        System.out.println(\"判断字符串是以h开头中间任意字符并且以d结尾\"+ (\"h%d\".matches(\"h.d\")));\n        //需求：--》 验证输入手机号是合法\n        //手机号一般是由11位组成 ---》可以提供一个简单版本正则表达式---》提供 11个\\\\d\n        //手机号第一位是1组成，第二位是由一定范围变换，除此之外剩余就是简单数字\n        System.out.println(\"13888888888\".matches(\"1[3|4|5|6|7|8|9]\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d\"));\n    }\n}\n```\n\n### 正则表达式之数量词\n\n&ensp;&ensp;&ensp;&ensp;正则表达式中的数量词其实就是指定正则表达式出现的次数 --》X【代表单个正则表达式的条件\n\n或者 可以代表组】\n\n&ensp;&ensp;&ensp;&ensp;**X?：0次或1次 ---》 \\\\d? --》代表当前数字可以出现0次或1次**\n\n**&ensp;&ensp;&ensp;&ensp;X\\*：0次或多次 --》 \\\\d\\* --》 代表当前数字可以出现0次或多次**\n\n**&ensp;&ensp;&ensp;&ensp;X+：1次或多次 --》\\\\d+ --》 代表当前数字可以出现1次或多次**\n\n&ensp;&ensp;&ensp;&ensp;**X{n}：正好n次--》\\\\d{9} --》 代表当前数字可以出现9次**\n\n**&ensp;&ensp;&ensp;&ensp;X{n,}：至少n次(包含n) --》 \\\\d{9,} --》 代表当前数字至少出现9次或多次**\n\n&ensp;&ensp;&ensp;&ensp;**X{n，m}：至少n次~m次(n和m都是包含) --》 \\\\d{4,14} --》代表当前数字出现4~14次**\n\n案例：\n\n```java\npublic class RegexDemo4 \n{\n    public static void main(String[] args) \n    {\n        String str = \"258\";\n        //验证str是否满足3位数字\n        System.out.println(str.matches(\"[0-9]{3}\"));\n        System.out.println(str.matches(\"\\\\d{3}\"));\n        System.out.println(\"a58\".matches(\"\\\\d{3}\"));//false\n        System.out.println(str.matches(\"\\\\d+\")); //true\n        System.out.println(str.matches(\"\\\\d?\")); //false\n        System.out.println(str.matches(\"\\\\d*\")); //true\n        System.out.println(str.matches(\"\\\\d{3,}\"));//true\n        System.out.println(str.matches(\"\\\\d{3,13}\"));//true\n        //需求：--》 验证输入手机号是合法\n        //手机号一般是由11位组成 ---》可以提供一个简单版本正则表达式---》提供 11个\\\\d\n        //手机号第一位是1组成，第二位是由一定范围变换，除此之外剩余就是简单数字\n        System.out.println(\"13888888888\".matches(\"1[3|4|5|6|7|8|9]\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d\"));\n        //修改\n        System.out.println(\"13888888888\".matches(\"1[3|4|5|6|7|8|9]\\\\d{9}\"));\n    }\n}\n```\n\n### 正则表达式值组\n\n**组的出现可以将条件统一化，将多个条件捆绑到一起 ---》 小括号()**\n\n需求：提供一个字符串写出对应的正则表达式 --》“d0a3911a-a8e9-4e5e-b9e7-c2c53324d50d”\n\n```java\npublic class RegexDemo5 \n{\n    public static void main(String[] args) \n    {\n        String str = UUID.randomUUID().toString();\n        //String str = \"d0a3911a-a8e9-4e5e-b9e7-c2c53324d50d\";\n        String regex = \"[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}\";\n        //可以将上述正则表达式进行组的划分\n        String regex2 = \"([a-z0-9]{8})(-[a-z0-9]{4}){3}(-[a-z0-9]{12})\";\n        System.out.println(str.matches(regex2));\n        //呵呵嘿嘿哈哈--》提供正则表达式与之匹配 ---》 点【.】可以匹配任意字符\n        String str2 = \"呵呵嘿嘿哈哈\";\n        System.out.println(str2.matches(\"(.){2}(.){2}(.){2}\"));\n        System.out.println(str2.matches(\"((.){2}){3}\"));\n        String str3 = \"呵呵\";\n        System.out.println(str3.matches(\"(.){2}\"));\n        //(.)代表第一组【一组条件】 \\\\1表示第一组在出现一次(.)\\\\1--》(.)(.)\n        System.out.println(str3.matches(\"(.)\\\\1\"));\n        //如何修改(.)\\\\2第二组的(.)在出现一次 (.)\\\\3第三组的(.)在出现一次\n        System.out.println(str2.matches(\"(.)\\\\1(.)\\\\2(.)\\\\3\"));\n        System.out.println(\"高兴高兴\".matches(\"(..)\\\\1\"));\n    }\n}\n```\n\n![转义符](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271928546.jpg)\n\n![数量表示](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271929293.jpg)\n\nString类中匹配正则表达式作为参数方法一共有三个【常用】\n\n&ensp;&ensp;&ensp;&ensp;matches()方法：根据方法的参数进行对字符串匹配操作，满足条件范围true，不满足返回false\n\n&ensp;&ensp;&ensp;&ensp;split()方法:【拆分、切分、分割】字符串，根据参数中指定条件进行字符串拆分操作\n\n&ensp;&ensp;&ensp;&ensp;replaceAll()方法: 根据方法中第一个参数的正则表达式条件，替换字符串中指定内容【替换的内容是第二个参数】\n\n```java\npublic class RegexDemo6 \n{\n    public static void main(String[] args) \n    {\n        //验证字符串是否合法\n        String phoneNumber = \"13112345678\";\n        String regex = \"1[3|4|5|6|7|8|9]\\\\d{9}\";\n        System.out.println(phoneNumber.matches(regex));\n        //根据条件进行字符串拆分，将拆分结果存储到一个String类型数组中并返回\n        //这个方法比较常用，但是拆分不一定非要是正则表达式，只要满足拆条情况都是可以\n        String time = \"20:39:49\";\n        //获取时间中 小时、分钟和秒\n        String[] split = time.split(\":\");\n        for (String t : split)\n        {\n            System.out.println(t);\n        } \n        //这个方法主要是用于批量字符串替换，它是需要第一个参数提供正则条件\n        String str = \"43eh5hj34l4h23jh4233h42oru3ohfh3rihf3hf3hgf4568632485rewh34\";\n        //需求：将字符串中所有的数字都替换成*\n        char[] chars = str.toCharArray();\n        for (int i= 0; i<chars.length;i++)\n        {\n            if (Character.isDigit(chars[i]))\n            {\n                chars[i] = '*';\n            }\n        } \n        String str2 = new String(chars);\n        System.out.println(str2);\n        String s = str.replaceAll(\"\\\\d+\", \"*\");\n        System.out.println(s);\n    }\n}\n```\n\n## <center>4、String的内存分配</center>\n\n![String的内存分配](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271929031.jpg)\n\nPS：字符串是引用类型，所以比较时候依旧使用equals进行比较内容，不要因为有池机制在就是用 == 进行比较，受众面比较小\n\n## <center>5、StringBuffer、StringBuilder类</center>\n\n&ensp;&ensp;&ensp;&ensp;String这个字符串是一个不可变字符串，不可以修改String中存储的内容，所以当我们调用大部分String方法的时候都会得到一个新String字符串\n\n&ensp;&ensp;&ensp;&ensp;Java中提供两个可变的字符串StringBuffer和StringBuilder，这两字符串创建之后，任何的修改都会对字符串内容提供修改操作即直接修改字符串内容\n\n&ensp;&ensp;&ensp;&ensp;PS：StringBuffer和StringBuilder本质上并不是字符串，它属于一个字符串“构建器”，允许将String中内容存储到这个“构建器”，进行修改从而得到修改之后的效果\n\n&ensp;&ensp;&ensp;&ensp;StringBuffer和StringBuilder都可以提供对字符串操作，并且两个类API是完全相同的，\n\n&ensp;&ensp;&ensp;&ensp;StringBuffer是线程安全【在多线程操作前提下可以保证字符串操作的正确性】但是效率低，\n\n&ensp;&ensp;&ensp;&ensp;StringBuilder是线程不安全【在多线程操作前提下不可以保证字符串操作正确】但是效率高，大多数的情况下都是使用【单线程】在进行编程，所以建议优先使用StringBuilder，如果遇到多线程操作字符串时在修改为StringBuffer使用即可\n\nStringBuffer的对象创建及常用方法：\n\n```java\npublic class StringBuilderAPIDemo \n{\n    public static void main(String[] args) \n    {\n        //1.StringBuffer和StringBuilder本身并不是字符串，所以不可以使用String直接赋值方式进行创建\n        //StringBuilder bs = \"abc\";\n        //2.需要使用StringBuilder的构造方法来创建StringBuilder对象进行字符串操作者处理\n        //2.1 创建一个空的StringBuilder对象【没有存储任何字符串内容】\n        /*\n            通过观察可以发现在调用StringBuilder无参构造创建StringBuilder对象是 会调用父类有参\n            构造方法\n            执行 value = new char[capacity];构建一个字符数组作为存储数据的依据\n            capacity的值是 --》默认值为 16\n            ---》在创建空的StringBuilder对象时，创建一个初始容量为16的字符数组进行数据存储操作\n        */\n        StringBuilder bs = new StringBuilder();\n        /*\n            面试问题：在创建StringBuilder对象是默认会初始化一个大小为16的字节数组作为存储数据的方式\n            那么如果存储数据超过16时，是否可以正常的存储数据值，还是截取多余数据值仅保留16个字符？\n            答案：StringBuilder是可以正常存储数据的，为什么可以存储？\n            就是因为StringBuilder的底层存储过程中会对value这个数组进行“动态扩容操作”，\n            当到某个临街值的时候\n            执行Arrays.copyOf这个方法将原来value中数据赋值到新创建的数组中，并且将新数据引用赋值给value\n            这样一来给外界开发人员造成的感觉就是我们使用在操作同一个字符串\n        */\n        bs.append(\"12345678901234567890\");\n        System.out.println(bs);\n        //2.2创建StringBuilder对象同时向StringBuilder中存String字符串\n        //StringBuilder如果使用字符串进行初始化创建，会使用参数字符串的长度+16这个默认值作为初始容量value字符数组的大小\n        StringBuilder bs2 = new StringBuilder(\"abc\");\n        //2.3PS：这个构建方式是以前开发时常用的一种方式\n        //自定义初始化数组容量【要创建一个空的StringBuilder对象必然使用这个方法】\n        StringBuilder bs3 = new StringBuilder(80);\n        //常用API\n        //1.最常用的方法 append 追加---》向StringBuilder中追加存储内容\n        // 没出使用append方法时都是向原有字符串末尾添加数据 --》这个方法十分强大基本上减容各种数据类型进行存储\n        bs2.append(\"d\");\n        bs2.append('e');\n        //append这个方法的特殊点在于，这个方法的中内部使用使用this关键字作为方法参数传递\n        //因为这个方法返回的是调用方法的对象，所以可以使用多次[.]点的方式连续追加\n        //Java管这种编程方式叫做“链式编程”--》他是StreamAPI【简称流式编程前身】\n        bs2.append(\"f\").append('g');\n        System.out.println(bs2);\n        //2.获取字符串长度\n        System.out.println(bs2.length());\n        //3.删除字符串中指定位置字符串 ---> 根据两个参数决定删除范围【下标】\n        /*\n            第一个参数 是从什么位置开始删除（包含）\n            第二个参数 到什么位置结束（不包含）\n        */\n        bs2.delete(0,3);\n        System.out.println(bs2);\n        //4.删除指定位置的字符【下标】\n        bs2.deleteCharAt(0);\n        System.out.println(bs2);\n        //5.在指定位置插入字符串【不能超出下标范围】，插入内容不受长度限制\n        bs2.insert(1,\"漫威\");\n        System.out.println(bs2);\n        //6.替换指定位置的字符串\n        /*\n            第一个参数 从什么位置开始替换（包括）\n            第二个参数 到什么位置结束（不包括）\n            第三个参数 替换的字符串\n            PS：替换的字符串长度不受替换位置大小限制的\n        */\n        bs2.replace(1,3,\"复仇者联盟5\");\n        System.out.println(bs2);\n        //7.反转字符串\n        bs2.reverse();\n        System.out.println(bs2);\n        //8.修改执行位置的字符\n        bs2.setCharAt(bs2.length()-1,'♂');\n        System.out.println(bs2);\n        //9.StringBuilder和String之间互相转换\n        //将StringBuilder变成String\n        String string = bs2.toString();\n        String string2 = new String(bs2);\n        //将String变成StringBuilder\n        StringBuilder bs4 = new StringBuilder(\"ancd\");\n    }\n}\n```\n\nStringBuffer操作与上面同理，只需要将Builder变换为Buffer就可以了\n\n## <center>6、String、StringBuffer、StringBuilder区别</center>\n\n这三个类都可以用于表示字符串\n\n&ensp;&ensp;&ensp;&ensp;1）String类是字符串常量类，一旦定义不能改变\n\n&ensp;&ensp;&ensp;&ensp;2）StringBuffer、StringBuilder是可变的字符串,自带有缓冲区。默认缓冲区大小16个字符\n\n&ensp;&ensp;&ensp;&ensp;3）StringBuffer是线程安全的，所以效率低 StringBuilder是线程不安全的，所以效率高\n\n总结：实际开发中更常用的是String类型，但在大量的字符串拼接的时候，使用 StringBuffer、StringBuilder。而不考虑线程安全的时候，选择StringBuilder，否则选择StringBuffer\n\n```java\npublic class Demo01\n{\n    public static void main(String[] args)\n    {\n        //需求：做100000次字符串拼接//获取当前系统时间的毫秒数 4918\n        //记录一个开始时间\n        //long start = System.currentTimeMillis();\n        //String str = \"\";\n        //for (int i = 0; i < 100000; i++)\n        //{\n        //    str = str + \"a\";\n        //}\n        //记录一个结束时间\n        //long end = System.currentTimeMillis();\n        //System.out.println(\"耗时\"+(end -start));\n        \n        //long start = System.currentTimeMillis();\n        //StringBuffer sb = new StringBuffer();\n        //for (int i = 0; i < 10000000; i++)\n        //{\n        //    sb.append(\"a\");\n        //}\n        //long end = System.currentTimeMillis();\n        // System.out.println(\"耗时\"+(end -start));   //239\n\n        long start = System.currentTimeMillis();\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < 10000000; i++)\n        {\n            sb.append(\"a\");\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(\"耗时\"+(end -start));    //90\n    }\n}\n```\n\n## <center>7、String和StringBuilder作为方法参数问题</center>\n\n```java\npublic class StringMethodDemo \n{\n    public static void main(String[] args) \n    {\n        String str = \"abc\";\n        System.out.println(\"没有修改str字符串之前的内容是：\"+str);\n        changeString(str);\n        System.out.println(\"修改之后str字符串中内容是：\"+str);\n        System.out.println(\"-------------------------处理修改方式--------------------------\");\n        str = changeString2(str);\n        System.out.println(str);\n        System.out.println(\"-------------------------处理修改方式2--------------------------\");\n        StringBuilder builder = new StringBuilder(str);\n        changeString3(builder);\n        System.out.println(builder);\n        } \n        /**\n            String是引用类型没有问题，但是是一个特殊的引用类型，平时在外界进行的修改是可以操作\n            但是如果将String类型作为方法的参数，此时是无法通过方法内部对String类型参数进行修改影响到\n传递参数\n            主要是跟字符串的存储机制有关，一个值字符串字符串池机制和底层存储机制【private final char[] value】\n            对String字符串进行操作时都等于重新创建一个新的String对象\n            下面方法发生执行过程\n            首先：通过外界main方法中调用changeString(str) 将 str赋值给方法参数str\n            即执行 方法参数赋值过程 String str = str ---》 String str = \"abc\"\n            参数str会得到字符串\"abc\"的引用地址\n            然后：在方法的【内部对方法参数str进行了修改】将str修改为一个新的引用执行 \"bcd\"\n            所有的修改过程都是对 方法参数空间引用str进行操作，是不会影响到外界str的\n            这样就造成如果使用String类型作为方法参数时，是无法修改外界传递字符串数据\n        */\n        private static void changeString(String str) \n        {\n            str = \"bcd\";\n        } \n        //可以进行修改操作\n        /*\n        第一种： 提供返回值，将方法内部修改之后地址赋值给外界字符串\n        */\n        private static String changeString2(String str) {\n        str = \"bcd\";\n        return str;\n        } \n        /* \n            第\n二种： 存储在自定义类、数组或集合\n        */\n        // private static void changeString3(这里的参数需要是存储String类型数据的【自定义类、数组或集合】) \n        //{\n        // 方法内部通过这个存储方式进行字符串修改操作\n        // }\n        /*\n            第三种：提供StringBuffer和StringBuilder作为方法参数\n            StringBuilder是引用类型而且是一个可变字符串，底层存储【char[] value】,所以是一个可变操作\n            对StringBuilder做到任何修改都是影响到其内部存储内容\n        */\n        private static void changeString3(StringBuilder builder) \n        {\n            builder.replace(0,builder.length(),\"bcd\");\n        }\n}\n```\n\n# <center>知识点二：Object类</center>\n\n## <center>1、含义</center>\n\n在Java继承树上最顶层的父类\n\n所有的类都是直接或者间接的继承自Object\n\n所有的类型都有Object类提供的方法\n\n```java\npublic class Person{} --》此时是默认继承Object这个类\npublic class Person extends Object{} --》 显式继承与Object这个类，这样两种创建方式都是一样，就是语法区别\n```\n\nPS：在API中Object类一共提供11个方法，这11方法中只有clone这个方法在开发中几乎与不使用\n\n## <center>2、常用方法</center>\n\n### 1）getClass()\n\n&ensp;&ensp;&ensp;&ensp;返回该对象的真实类型(运行期类型)\n\n&ensp;&ensp;&ensp;&ensp;ObjectDemo类\n\n```java\npublic class ObjectDemo\n{\n    public static void main(String[] args)\n    {\n        Person student = new Student();\n        //获取对象的真是类型（类对象）\n        System.out.println(student.getClass());\n\n        //判断str和tea是否同一个类型\n        Person str = new Student();\n        Person tea = new Teacher();\n        System.out.println(str.getClass() == tea.getClass());\n        //以前方法\n        if (str instanceof Student && tea instanceof Student\n            || str instanceof Teacher && tea instanceof Teacher)\n        {\n            System.out.println(\"同一个类型\");\n        }\n        else\n        {\n            System.out.println(\"不同一个类型\");\n        }\n    }\n}\n```\n\nPerson类\n\n```java\npublic class Person\n{\n}\n```\n\nStudent类\n\n```java\npublic class Student extends Person\n{\n}\n```\n\nTeacher类\n\n```java\npublic class Teacher extends Person\n{\n}\n```\n\n### 2）toString方法\n\n&ensp;&ensp;&ensp;&ensp;全限定名+@+十六进制的hash值(地址)如果直接输出一个对象，那么默认会调用这个对象的toString方法，而toString方法是Object类提供的，返回的是“对象的地址”。但是我们一般输出对象希望输出的是对象的属性信息，所以可以重写父类的toString方法\n\nObjectDemo2类\n\n```java\npublic class ObjectDemo2\n{\n    public static void main(String[] args)\n    {\n        //Student stu = new Student();\n        //com.qf.object.Student@1b6d3586 对象的内存地址\n        //如果直接输出一个对象，实际上是调用了这个对象的toString方法，输出的是这个对象的地址\n        //System.out.println(stu);\n        //但是通常情况下，我们输出对象就希望输出对象的属性信息，所以通常我们会重写Object的toString方法\n        Student stu = new Student(\"jack\",20);\n        System.out.println(stu);    //隐式调用toString方法,stu.toString()显式调用\n    }\n}\n```\n\nPerson类\n\n```java\npublic class Person\n{\n}\n```\n\nStudent类\n\n```java\npublic class Student extends Person\n{\n    private String name;\n    private int age;\n\n    public Student(String name, int age)\n    {\n        this.name = name;\n        this.age = age;\n    }\n\n    public Student()\n    {\n    }\n\n    public String getName()\n    {\n        return name;\n    }\n\n    public void setName(String name)\n    {\n        this.name = name;\n    }\n    /**\n    * 当进行toString方法重写的时候IDEA会默认提供一个toString实现的方式\n    * 这个方式的实现就是 打印Person类型中所提供属性值\n    * 在开发中可以根据个人的需求进行定制，无需使用IDEA提供默认实现，自行实现即可\n    * 只要能得到一个字符串就可以\n    */\n    @Override\n    public String toString()\n    {\n        return \"Student{\" +\n                \"name='\" + name + '\\'' +\n                \", age=\" + age +\n                '}';\n    }\n}\n```\n\n### 3）hashCode方法\n\nhash值作用：\n\n区分对象\n\n&ensp;&ensp;&ensp;&ensp;1、返回该对象的十进制的哈希吗值\n\n&ensp;&ensp;&ensp;&ensp;2、hash值是由hash算法通过对象的地址、对象中的字符串、数字等，计算出来的\n\n&ensp;&ensp;&ensp;&ensp;3、相同的对象应当返回相同的哈希吗值，不同的对象尽量返回不同的哈希码值\n\n&ensp;&ensp;&ensp;&ensp;不同的对象有可能会出现hash冲突\n\nObjectDemo03类\n\n```java\npublic class ObjectDemo03\n{\n    public static void main(String[] args)\n    {\n        Student stu1 = new Student(\"jack\",20);\n        System.out.println(stu1.hashCode());\n        Student stu2 = new Student(\"jack\",20);\n        System.out.println(stu2.hashCode());\n        //hash冲突\n        String s1 = \"通话\";\n        String s2 = \"重地\";\n        System.out.println(s1.hashCode());\n        System.out.println(s2.hashCode());\n    }\n}\n```\n\nStudent类和Person类与ObjectDemo2相同\n\n### 4）equals方法\n\n&ensp;&ensp;&ensp;&ensp;Object类的equals方法的作用是比较两个对象是否相等。默认比较的是内存地址。其底层代码的是==如果不想比较内存地址，那么需要重写equals方法。系统默认重写过后的equals方法，只要属性一致，那么结构返回true\n\n&ensp;&ensp;&ensp;&ensp;String类就重写父类equals，从而比较的是内容，所以String类中只要两个字符串内容相等，那么equals就返回true。\n\n快捷方法：alt+INS ==>equals()and hashCode() ==>第一个界面需要打勾的 打勾第一个 ==>剩下全部下一步\n\nPS：如果遇到自定义类中所创建对象需要比较相等，那么就需要在这个自定义类中提供equals方法的重新操作，才可以进行比较。\n\n重写equals的同时重写hashcode方法的原因\n\n&ensp;&ensp;&ensp;&ensp;因为在Java中协定，只要两个对象使用equals比较相等，那么两个对象的hahsi值也必须相等\n\n在HashSet等集合的底层去重原理? ( 如何比较两个对象是否相等? )\n\n&ensp;&ensp;&ensp;&ensp;在java中会优先比较两个对象的hash值，如果hash值不一致，那么两个对象就不相同。\n\n&ensp;&ensp;&ensp;&ensp;如果hash值一致，进而再比较equals，如果equals 方法也相等，那么这两个对象就等同。\n\n训练提示\n\n&ensp;&ensp;&ensp;&ensp;（1）提供一个公民类，属性有【姓名和ID】\n\n&ensp;&ensp;&ensp;&ensp;（2）提供一个数据存储工具类，工具类中存储一下数据信息，提供一个方法可以获取到这些数据信息\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;姓名 ID\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;张学友, 9999\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;刘德华, 8888\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;郭富城, 7777\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;吴奇隆，6666\n\n&ensp;&ensp;&ensp;&ensp;（3） 设计一个机场安检系统类，提供控制台输入姓名和ID的操作存储到公民对象中，提供操作完成公民信息与数据类中提供数据信息比较操作，如果信息一致则提示机场想起了警报，来了一群便衣将XXX带走了，否则祝XXX旅途愉快！\n\n公民类\n\n```java\npublic class Citizen \n{\n    private String name;\n    private int ID;\n    public Citizen() \n    {\n    } \n    public Citizen(String name, int ID) \n    {\n        this.name = name;\n        this.ID = ID;\n    } \n    public String getName() \n    {\n        return name;\n    } \n    public void setName(String name) \n    {\n        this.name = name;\n    } \n    public int getID() \n    {\n        return ID;\n    } \n    public void setID(int ID) \n    {\n        this.ID = ID;\n    } \n    //提供一个toString重写打印公民类中的属性信息\n    @Override\n    public String toString() \n    {\n        return \"Citizen{\" +\n        \"name='\" + name + '\\'' +\n        \", ID=\" + ID +\n        '}';\n    }\n}\n```\n\n公民信息存储工具类\n\n```java\npublic class CitizenDB \n{\n    //1.工具类是不会提供对象创建\n    private CitizenDB()\n    {}\n    //2.工具类中提供方法和属性都是静态的\n    //2.1提供一个静态数组存储公民信息\n    private static final Citizen[] db = {\n    new Citizen(\"张学友\",9999),\n    new Citizen(\"刘德华\",8888),\n    new Citizen(\"郭富城\",7777),\n    new Citizen(\"吴奇隆\",6666),\n    };\n    //2.2 提供一个共有静态方法可以访问到这个数据数据\n    public static Citizen[] getCitizenDB()\n    {\n        return db;\n    }\n}\n```\n\n机场安检系统\n\n```java\npublic class AirPortSystem \n{\n    public static void main(String[] args) throws InterruptedException \n    {\n        System.out.println(\"-----------------------欢迎进入机场安检系统-------------------------\");\n        Scanner input = new Scanner(System.in);\n        System.out.println(\"请输入您的姓名：\");\n        String name = input.next();\n        System.out.println(\"请输入您的ID：\");\n        int ID = input.nextInt();\n        /*\n            注意: 要比较信息数据是存储在公民数组中，公民数组中存储都是一个一个公民对象，每个公民对\n象中存储就是具体数据信息\n            所以需要将name和ID信息封装一个公民信息对象中，与公民数组中存储对象进行比较\n            此时就需要使用到Object类中所提供equals方法进行对象的比较操作\n        */\n        Citizen citizen = new Citizen(name,ID);\n        System.out.println(\"-----------------请稍等，系统正在比对您的信息-------------------------\");\n        Thread.sleep(2000); //为了让系统有一个卡顿的效果【模拟查找数据库】\n        if (checkCitizenInfo(citizen))\n        {\n            System.out.println(\"机场想起了警报，来了一群便衣将：\"+citizen+\"带走了\");\n        }\n        else\n        {\n            System.out.println(\"祝:\"+citizen+\"旅途愉快！\");\n        }\n    }\n    /**\n    * 检查公民信息的方法\n    * 公民信息对象\n    * 证明是要逮捕的人 false 证明就不是要逮捕人\n    */\n    public static boolean checkCitizenInfo(Citizen citizen)\n    {\n        for (Citizen citizen1 : CitizenDB.getCitizenDB())\n        {\n            //利用数据中每一个公民对象与传递进来公民对象进行比较操作\n            if (citizen1.equals(citizen))\n            {\n                return true;\n            }\n        } \n        return false;\n    }\n}\n```\n\n&ensp;&ensp;&ensp;&ensp;通过上面代码执行我们可以发现Objcet类提供equals方法无法满足子类比较的需求，所以需要重新equals方法进行对象比较的操作\n\n&ensp;&ensp;&ensp;&ensp;如果认为两个引用类型“相等“即equals比较值为true，认为只要引用类型中存储的数据内容是一致的就认为这个两个引用类型相等，即equals比较结果为true，否则equals比较结果为false\n\n&ensp;&ensp;&ensp;&ensp;针对自定义类中创建对象使用equals进行比较时，重写equals方法中提供方式是即当前类中定义属性，根据需求，要么全部都相等 或者 部分相等\n\n在公民类（Citizen）中重写equals方法\n\n```java\n//公民类\npublic class Citizen \n{\n    private String name;\n    private int ID;\n    public Citizen() \n    {\n    } \n    public Citizen(String name, int ID) \n    {\n        this.name = name;\n        this.ID = ID;\n    } \n    public String getName() \n    {\n        return name;\n    } \n    public void setName(String name) \n    {\n        this.name = name;\n    } \n    public int getID() \n    {\n        return ID;\n    } \n    public void setID(int ID) \n    {\n        this.ID = ID;\n    } \n    //提供一个toString重写打印公民类中的属性信息\n    @Override\n    public String toString() {\n    return \"Citizen{\" +\n    \"name='\" + name + '\\'' +\n    \", ID=\" + ID +\n    '}';\n    } \n    //提供equals方法的重写\n    /*\n        观察这个方法时可以发现，方法的参数类型是Object类型，使用是父类类型作为方法的参数\n        这样可以达到方法的最大通用性，任何类重写equals方法的时候可以满足类的需求---》这就是多态的\n好处\n    */\n    @Override\n    public boolean equals(Object o)\n    {\n        /*\n            在这个类中提供比较原则，使用this代表当前对象， other传入对象\n            外界调用这个方法就是this，当做方法参数传递的就是other对象\n            这个编程需求是需要比较类中所有全部相等，所以需要提供属性操作，又因为使用是父类Object类\n                型作为方法参数【为了达到最通用性】\n            但是传入到这个方法中对象会被执行【对象的向上转型】提升为Object类型，此时是无法调用子类\n属性和方法\n            需要将这个提升之后对象转换为原有的数据类型\n        */\n        Citizen other = (Citizen)o;\n        /*\n            类中属性的操作方式：如果类中属性是系统引用类型，直接调用equals方法即可【因为系统引用类\n            型基本上都重写了Object类中equals方法】\n            如果类中属性是基本数据类型，直接使用 == 比较即可\n            name属性是String类型所以可以直接使用String类提供equals方法重写比较\n            ID属性是int类型所以可以直接使用 == 进行比较操作\n        */\n        return this.name.equals(other.name) && this.ID == other.ID;\n    }\n}\n```\n\n总结：== 和 equals的区别\n\n&ensp;&ensp;&ensp;&ensp;两个东西都是用于比较的\n\n&ensp;&ensp;&ensp;&ensp;== 可以用于基本类型和引用类型==在基本类型的比较中，比较的值是否相等，如果相等返回true，否则返回false\n\n&ensp;&ensp;&ensp;&ensp;==在引用类型的比较中，比较的地址是否相等，如果相等返回true，否则返回false\n\n&ensp;&ensp;&ensp;&ensp;equals只能用于引用类型的比较equals方法是Object类提供的方法，其底层实现是==比较，所以在没有重写父类的equals方法时。比较的也是地址。如果希望两个对象的属性一样，就认为两个对象是相同的对象，那么需要重写equals方法，但是重写了equals的同时也需要重写hashcode方法，因为java中约定两个对象相等，那么两个对象的hash值也应该相等\n\n### 5）finalize方法\n\n当垃圾回收器回收垃圾对象的时候，自动调用\n\n```java\npublic class Test5\n{\n    public static void main(String[] args)\n    {\n        Person p = new Person();\n        //手动将对象标记为垃圾对象\n        p = null;\n        //触发垃圾回收器，回收垃圾对象\n        System.gc();\n     }\n}\nclass Person\n{\n    @Override\n    protected void finalize() throws Throwable\n    {\n        super.finalize();//不要删除\n        System.out.println(\"finalize方法执行了\");\n    }\n}\n```\n\n# <center>知识点三：包装类</center>\n\n## <center>1、概念</center>\n\n什么是包装类？\n\n&ensp;&ensp;&ensp;&ensp;包装类就是【基本数据类型对应引用数据类型版本】，基本数据类型在网络数据传输时，效率是极低的，就是因为基本数据类型没有执行序列化接口，所以提供对应引用类型版本进行替换操作，提高基本数据类型在网络中传递效率\n\n&ensp;&ensp;&ensp;&ensp;在后学习中我们会接触到一个更加便利的数据存储形式---》集合，集合中存储数据只能是引用类型，所以基本数据类型无法存储到集合中，所以就需要使用包装类即基本数据类型对应引用类型版本\n\n&ensp;&ensp;&ensp;&ensp;基本数据类型只提供基础数据存储与定义操作，并没有提供任何对存储数据的操作方法,包装类就提供常用数据方法，字符串转换为整数，int类型就无法完成，就需要使用包装类Integer\n\nPS：包装类是类，即引用类型【但是需要注意是一个“特殊”的引用类型】\n\n## <center>2、包装类的类型及定义</center>\n\n| 基本类型 | 作为属性默认值 | 包装类型  | 作为属性默认值 |\n| :------: | :------------: | :-------: | :------------: |\n|   byte   |       0        |   Byte    |      null      |\n|  short   |       0        |   Short   |      null      |\n|   int    |       0        |  Integer  |      null      |\n|   long   |       0        |   Long    |      null      |\n|  float   |      0.0       |   Float   |      null      |\n|  double  |      0.0       |  Double   |      null      |\n|   char   |  不可见空字符  | Character |      null      |\n| boolean  |     false      |  Boolean  |      null      |\n\nPS：基本数据类型中除了int和char类型之外，所有对应保证类都是首字母大写，而int对应包装类Integer，char对应包装类Character\n\n以下操作者都已Integer类为主要操作，其余包装类与之操作是一样，就是改变类名而已\n\n## <center>3、拆箱和装箱</center>\n\n```java\npublic class IntegerDemo \n{\n    public static void main(String[] args) \n    {\n        //以Integer为例讲解包装类 拆箱与装箱操作\n        //什么是装箱？\n        /*\n            装箱操作其实就是在形容: 将基本数据类型转换为对应包装类类型\n            这个过程我们形容为【装箱操作】 ---》 装箱操作分为自动装箱和手动装箱\n            手动装箱是Java5以前提供--》需要将基本数据类型转换为对应包装类类型\n            包装类类型 对象名 = new 包装类类型(对象包装类的基本数据类型值)\n            自动装箱是Java5以后提供 --》将基本数据类型转换为对应包装类类型是\n            无需在使用new创建包装类对象，而是直接对包装类赋值即可\n            包装类类型 对象名 = 对象包装类的基本数据类型值;\n            Java5以后是支持自动和手动装箱操作\n        */\n        //手动装箱\n        int age = 19;\n        //将int类型age变量转换为对应Integer类型进行存储\n        Integer integer = new Integer(age);\n        //自动装箱\n        int age2 = 19;\n        //将int类型age2变量转换为对应Integer类型进行存储\n        Integer integer1 = age2;\n        //这种两种方式创建的Integer对象存储的空间是不一样的，所以不要使用 == 比较\n        //引用类型不要使用 == 比较比较是内存地址，要使用equals进行比较操作\n        System.out.println(integer == integer1);\n        System.out.println(integer.equals(integer1));\n        //什么是拆箱操作？\n        /*\n            拆箱操作其实就是在形容: 将包装类中存储的数据转换为对应基本数据类型进行存储\n            这个过程我们形容为【拆箱操作】 ---》 拆箱操作分为自动拆箱和手动拆箱\n            手动拆箱是Java5以前提供--》需要包装类类型对象调用包装类中提供XXXValue()方法，转换为对应基本数类型\n            这个的XXX是包装类对象对应基本数据类型---》例如 Integer包装类 对应的就是 int类型 所以XX就是int\n            对应转换包装类的基本数据类型 变量 = 包装类对象.XXXValue();\n            自动拆箱是Java5以后提供 --》无需调用繁琐XXXValue()方法，只需要将包装类对象赋值给对应基本数据类型变量即可\n            对应转换包装类的基本数据类型 变量 = 包装类对象;\n            Java5以后是支持自动和手动拆箱操作\n        */\n        //手动拆箱\n        int i = integer.intValue();\n        System.out.println(\"拆箱之后的int类型数：\"+i);\n        //自动拆箱\n        int i2 = integer1;\n        System.out.println(\"拆箱之后的int类型数：\"+i2);\n        //现在的开发使用包装类计算或在计算时自动拆箱\n        System.out.println(\"求存储在包装类对象integer和integer1中年龄和:\"+\n(integer+integer1));\n    }\n}\n```\n\n## <center>4、Number类</center>\n\nNumber是Byte、Short、Integer、Long、Float、Double的父类\n\nNumber提供一组方法用于将其中某一种类型转换成其他类型 \n\n语法：\n\n```java\nxxxValue()方法\n```\n\n```java\nInteger a = 100;\nByte b = a.byteValue();\nShort c = a.shortValue();\nLong d = a.longValue();\nFloat e = a.floatValue();\nDouble f = a.doubleValue();\nInteger g = a.intValue();\n```\n\n## <center>5、常用包装类</center>\n\n开发中用的最多：Integer 、Double\n\n定义方式\n\n```java\n//Integer、Double的定义方式\nInteger ii1 = new Integer(100);\n//或者\nInteger ii1 = 100;\nDouble dd1 = new Double(100.2);\n//或者\nDouble dd1 = 100.2;\n```\n\n### 常用属性\n\n```java\nSystem.out.println(Integer.MAX_VALUE);\nSystem.out.println(Integer.MIN_VALUE);\nSystem.out.println(Double.MAX_VALUE);\nSystem.out.println(Double.MIN_VALUE);\n```\n\n### 常用方法\n\n前端传入后端的数据一般是字符串类型\n\n所以需要将字符串类型的数值转换成int或者是double类型\n\n```java\n//常用方法\n//字符串转Integer\n//第一种方法（常用）\nint number = Integer.parseInt(\"23\");\nSystem.out.println(number);\n//第二种方法\nint number1 = Integer.valueOf(\"234\");\nSystem.out.println(number1);\n//字符串转Double\n//第一种方法(常用)\ndouble price = Double.parseDouble(\"23.4\");\nSystem.out.println(price);\n//第二种方法\ndouble price1 = Double.valueOf(\"23.45\");\nSystem.out.println(price1);\n```\n\n## <center>6、Integer缓冲区</center>\n\n整数型的包装类定义缓冲区(-128~127)，如果定义的数在这个范围你之内，那么直接从缓存数组中获取，不需要new\n\n```java\npublic class Demo02\n{\n    public static void main(String[] args){\n        /*** 面试题：整数型包装类缓冲区\n        * 整数型的包装类定义缓冲区(-128~127)，如果定义的数在这个范围你之内，那么直接从缓存数组中获取，\n        * 否则，重新new新的对象\n        */\n        Integer i1 = new Integer(10);\n        Integer i2 = new Integer(10);\n        System.out.println(i1 == i2); //false\n        System.out.println(i1.equals(i2));//true\n        \n        Integer i3 = 1000; //Integer i3 = new Integer(1000);\n        Integer i4 = 1000; //Integer i3 = new Integer(1000);\n        System.out.println(i3 == i4); //false\n        System.out.println(i3.equals(i4));//true\n        \n        Integer i5 = 100; //IntegerCache.cache[i + (-IntegerCache.low)]\n        Integer i6 = 100; //IntegerCache.cache[i + (-IntegerCache.low)]\n        System.out.println(i5 == i6);//true\n        System.out.println(i5.equals(i6));//true}}\n    }\n}\n```\n\n&ensp;&ensp;&ensp;&ensp;Integer类内部实现的原则 ---》【享元原则】它是Java中设计的一种优化，外部使用自动装箱进行Integer创建时，设计了一个范围 【-128~127】只要是这个范围内创建出来Integer对象，他们都会得到堆中相同地址，相当于Integer中出现一个缓存数据 Integer cache[] = {-128，.... ,127} ,只要存储这个范围内的值就直接返回存储好地址，这样一来就说明了存储123时通过 == 比较得到结果是true ，存储300时 == 比较得到结果是false，因为300超出了Integer缓存范围，机会触发valueOf方法 new Integer，得到就是堆地址\n\n## <center>7、包装类作为方法参数类型</center>\n\n&ensp;&ensp;&ensp;&ensp;需求：提供给一个测试类，在main方法中提供一个Integer类型包装类对象存储数据1000【形式不限】，然后再测试类中提供static方法，将Integer设置为当前方法参数类型，并在方法内部将外界传递Integer数据【1000】，修改为99999，然后再mian方法中调用方法执行，打印修改之后的数据\n\n```java\n//包装类作为方法参数类型时问题\npublic class PackageClassMethod \n{\n    public static void main(String[] args) \n    {\n        //包装类就是引用类型,但是是一个“特殊”引用类型\n        //Integer i1 = null;\n        //提供一个Integer类型的对象存储数据1000\n        Integer integer = 1000;\n        //toHexString 将十进制转换为十六进制 toBinaryString 将十进制转换为二进制\n        //toOctalString 将十进制转换为八进制\n        System.out.println(\"main方法中integer对象的内存地址是：\"+Integer.toHexString(integer.hashCode()));\n        changeIntegerValue(integer);\n        System.out.println(\"main方法调用changeIntegerValue方法之后integer对象的内存地\n            址是：\"+Integer.toHexString(integer.hashCode()));\n    } \n    public static void changeIntegerValue(Integer integer)\n    {\n        System.out.println(\"main方法中将integer对象存储的地址赋值给changeIntegerValue\n        方法参数integer的地址：\"+Integer.toHexString(integer.hashCode()));\n        integer = 99999;\n        System.out.println(\"changeIntegerValue方法将Integer对象中存储数据修改之后的地\n            址是：\"+Integer.toHexString(integer.hashCode()));\n    }\n}\n```\n\n包装类是一个特殊的引用类型，将包装类作为方法参数之后，在方法内部提供数据修改之后无法\n\n得到修改之后的结果，原因在于其内部存储\n\n```java\n//原码中Integer存储数据时做的操作\n/**\n    value就是Integer类型存储数据时的成员“变量（常量）”\n*/\nprivate final int value;\n/**\n    调用构造方法创建Integer对象提供存储数据都是存储在value这个成员“变量”\n*/\npublic Integer(int value) {\n\tthis.value = value;\n}\n```\n\n&ensp;&ensp;&ensp;&ensp;综上所属：包装类其实是一个特殊的引用类型，当在方法体进行操作时，相当于是“重新”创建了一个地址，所以的修改都不是在原有地址上执行，而是在这个新的地址执行，这样一来就造成了无法修改的问题，除此之外在原码中可以发现，存储数据是使用【 private final int value】，value是final修饰，所以每次对Integer赋值操作时，都是得到一个新的地址。\n\n提供可以正常修改方案：\n\n&ensp;&ensp;&ensp;&ensp;第一种方式：对方法添加返回值类型，利用return关键字将修改之后地址，返回出来，并让外界原来对象，存储这个新的地址，间接的修改了\n\n&ensp;&ensp;&ensp;&ensp;第二种方式：使用自定义类，将Integer作为类的属性类型存在，修改Integer时，传递自定义类作为参数类型，在方法内部通过get和set进行修改，这样也可以改变\n\n&ensp;&ensp;&ensp;&ensp;第三种方式：存储到数据结构中 ---》数组或集合\n\n包装类与包装类之间关系\n\n&ensp;&ensp;&ensp;&ensp;基本数据类型除了boolean类型之外，都可以参与到数据类型转换过程中。但是包装类彼此之间\n\n&ensp;&ensp;&ensp;&ensp;是互相独立，非要找一些关联化，数值类型【Byte、short、Integer、Long、Float和Double】\n\n&ensp;&ensp;&ensp;&ensp;他们有一个共同父类是Number，除此之外包装类是存在在java.lang包中\n\n# <center>知识点四：Dete类</center>\n\n## <center>1、含义</center>\n\n表示日期\n\n## <center>2、创建</center>\n\n创建java.util.Date对象\n\n获取系统当前时间：Date date = new Date();\n\n自己定义时间：Date date = new Date(定义年 - 1900,定义月-1,定义日);\n\n获取时间戳：先new Date\t形式：变量名.getTime();\n\n需要定义变量保存\n\n```java\npublic class dateDemo01\n{\n    public static void main(String[] args)\n    {\n        //创建java.util.Date对象\n        //获取系统当前时间\n        //Date date = new Date();\n        //System.out.println(date);\n\n        /**\n         * year：默认从1900年开始\n         * moth：0-11\n         */\n        //使用Date类表示指定时间\n        //Date date = new Date(2020-1900,10-1,29);\n        //System.out.println(date);\n\n        //获取当前Date对应时间的毫秒数（时间戳）\n        //获取到的时间戳是从1970年开始计算\n//        Date date = new Date();\n//        long time = date.getTime();\n//        System.out.println(time);\n\n        //计算活了多少天\n        //1、获取当前系统时间\n        Date date = new Date();\n        //2、获取出生时间\n        Date date1 = new Date(2000-1900,6-1,29);\n        //3、获取两个时间对应的时间戳相减\n        long time = date.getTime() - date1.getTime();\n        System.out.println(\"我活了\"+ time/1000/60/60/24);\n    }\n}\n```\n\n# <center>知识点五：SimpleDateFormat类</center>\n\n## <center>1、含义</center>\n\n用于日期格式化\n\n## <center>2、作用</center>\n\n1）将Date类转换成字符串类型\n\n2）将字符串类型转换成Date类型\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271929805.jpg\" alt=\"时间表达\" style=\"zoom:67%;\" />\n\n提供对应字符中常用主要有【y（年）、M（月）、d（日）、H（小时）、m（分钟）、s（秒）】\n\nSimpleDateFormat常用方法\n\n&ensp;&ensp;&ensp;&ensp;public String format(Date date): 根据提供日期格式将Date对象格式化成String对象\n\n&ensp;&ensp;&ensp;&ensp;public Date parse(String source): 根据提供日期格式将String对象解析为Date对象\n\n&ensp;&ensp;&ensp;&ensp;public void applyPattern(String pattern): 可以通过参数String类型字符串设置日期格式\n\nps：这个方法主要应对的是使用SimpleDateFormat无参的构造方法所创建对象\n\n```java\npublic class SimpleDateFormatDemo\n{\n    public static void main(String[] args) throws ParseException\n    {\n        //将Date转换字符串\n        //创建一个Date对象\n//         Date date = new Date();\n//         //创建日期格式化对象 2021年03月12日 14:15:30\n//         SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\");\n//        String time = sdf.format(date);\n//        System.out.println(time);\n        \n        //将字符串类型转换成Date类型\n        String time = \"2022-04-13 20:32:29\";\n        //此时的格式必须要与字符串中的日期格式一致\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        //转换\n        Date date = sdf.parse(time);\n        System.out.println(date);\n    }\n}\n```\n\n## <center>3、Calender日历类</center>\n\n&ensp;&ensp;&ensp;&ensp;Calender类是有Java提供用来代替Date类使用的一个日历类【PS：但是设计者脑残了，这个类存在一个缺陷】，这类所存在的包时java.util中，它是一个抽象类，不能创建对象，所以需要使用到它的子类GregorianCalendar类来完成，这个子类无需直接创建对象，只需要使用Calender类中getInstance()静态方法获取到子类对象即可\n\n```java\npublic class CalendarDemo \n{\n    public static void main(String[] args) \n    {\n        //1.提供Calendar对象创建\n        Calendar c = Calendar.getInstance();\n        //不能像打印Date一样打印Calendar对象，因为Calendar对象中存储的是日历信息\n        System.out.println(c);\n        /*\n            java.util.GregorianCalendar[time=1637913526755,areFieldsSet=true,\n            areAllFieldsSet=true,lenient=true,\n            zone=sun.util.calendar.ZoneInfo[id=\"Asia/Irkutsk\",\n            offset=28800000,dstSavings=0,useDaylight=false,\n            transitions=67,lastRule=null],firstDayOfWeek=1,\n            minimalDaysInFirstWeek=1,ERA=1,YEAR=2021,MONTH=10,\n            WEEK_OF_YEAR=48,WEEK_OF_MONTH=4,DAY_OF_MONTH=26,\n            DAY_OF_YEAR=330,DAY_OF_WEEK=6,DAY_OF_WEEK_IN_MONTH=4,\n            \\AM_PM=1,HOUR=3,HOUR_OF_DAY=15,MINUTE=58,SECOND=46,\n            MILLISECOND=755,ZONE_OFFSET=28800000,DST_OFFSET=0]\n        */\n        //这个日历类中操作时一定要注意月份问题，月份的基础范围【0~11】代表【1~12月】\n        /*\n        Calendar中打印存储的是日历信息，所以利用Calendar中提供一个方法\n        public int get(int Field) --》参数是Calendar类中字段---》通过参数传入的字段获取\n        当前日历类中数据\n        提供一些常用字段：\n            Calendar.YEAR : 年\n            Calendar.MONTH ：月\n            Calendar.DAY_OF_MONTH：月中的日期 --》还有一个字段可以获取 Calendar.DATE 月中的日期\n            Calendar.HOUR：小时\n            Calendar.MINUTE：分钟\n            Calendar.SECOND：秒\n            Calendar.DAY_OF_WEEK：星期\n        */\n        System.out.println(c.get(Calendar.YEAR)+\"年\"\n\t\t\t\t+(c.get(Calendar.MONTH)+1)+\"月\"\n        \t\t+c.get(Calendar.DATE)+\"日\"\n\t\t\t\t+\" \"+c.get(Calendar.HOUR)+\"时\"\n        \t\t+c.get(Calendar.MINUTE)+\"分\"\n\t\t\t\t+c.get(Calendar.SECOND)+\"秒\");\n        //将Calendar对象转换为Date对象\n        Date time = c.getTime();\n        //可以通过Calendar中提供set方法进行指定的时间设置\n        Calendar c1 = Calendar.getInstance();\n        //可以通过这样方式进行时间设置，参数第一个是对应时间字段，第二个是对应的时间数据\n        // c1.set(Calendar.YEAR,2021);\n        //建议使用下面这个方法完成 ,上面执行操作太繁琐\n        //设置月份的时候一定要-1操作【范围是0~11】\n        c1.set(2021,10,26);\n        System.out.println(\"这是这一年的第：\"+c1.get(Calendar.DAY_OF_YEAR)+\"天\");\n        System.out.println(\"这是这一年的第：\"+c1.get(Calendar.WEEK_OF_YEAR)+\"周\");\n        System.out.println(\"这是这个月的第：\"+c1.get(Calendar.DAY_OF_MONTH)+\"天\");\n    }\n}\n```\n\n日历类中存在的一些小问题：\n\n1. 中国人的第一个天是星期一， 外国人第一天是星期日\n2. 日历类中的月份是从【0~11】结束\n\n# <center>知识点六：System类</center>\n\n## <center>1、含义</center>\n\n系统类\n\n## <center>2、作用</center>\n\n1）返回当前系统时间的毫秒数 从1970年开始计算\n\n&ensp;&ensp;&ensp;&ensp;System.currentTimeMillis();\n\n系统当前时间纳秒值\n\n&ensp;&ensp;&ensp;&ensp;System.nanoTime();\n\n2）终止Java虚拟机的运行 参数表示终止的状态 0表示正常退出，负数异常终止\n\n&ensp;&ensp;&ensp;&ensp;System.exit(0);\n\n```java\npublic class SystemDemo01\n{\n    public static void main(String[] args)\n    {\n        //获取当前时间的毫秒数    1970年开始\n        long time = System.currentTimeMillis();\n        System.out.println(time);   //时间戳\n        //日期格式化类可以对long类型的毫秒数进行格式化\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        System.out.println(sdf.format(time));\n\n        //终止虚拟机运行  0表示正常退出 非0非正常关机\n        System.exit(0);\n        System.out.println(\"会执行么\");\n\n        //并不会直接使用垃圾回收器回收垃圾，只会将不用的对象主动添加到垃圾队列\n        System.gc();\n        //数组复制\n        int[] src = {1,2,3,4,5,6,7,8,9};\n        int[] des = new int[20];\n        /*\n            第一个参数 是原数组即被要复制的数据\n            第二个参数 从原数组中那个位置开始复制【下标】\n            第三个参数 是目标数组即复制内容到那个数组中\n            第四个参数 是目标数组的位置【下标】，从目标数组中什么位置开始写入数据\n            第五个参数 被复制的长度\n        */\n        System.arraycopy(src,2,des,5,4);\n        System.out.println(Arrays.toString(des));\n    }\n}\n```\n\n# <center>知识点七：Math类</center>\n\n## <center>1、含义</center>\n\n数学计算的工具类\n\n```java\npublic class MathDemo\n{\n    public static void main(String[] args)\n    {\n        //求a的b次方法 参数1：底数 参数2：幂数\n        double num1 = Math.pow(2, 10);\n        System.out.println(num1);\n        //求a平方根 参数1：要开方的数\n        System.out.println(Math.sqrt(100));\n        //求a立方根 参数1：要开立方的数\n        System.out.println(Math.cbrt(27));\n        //向上取整  10.1    11\n        System.out.println(Math.ceil(10.2));\n        //向下取整  10.6    10\n        System.out.println(Math.floor(10.9));\n        //四舍五入\n        System.out.println(Math.round(10.5));\n        //随机数 默认的范围[0,1)\n        System.out.println(Math.random());\n        //需求：随机一个两位数 [0,1)*90   [0,90) + 10\n        int num8 = (int)(Math.random()*90+10);\n        System.out.println(num8);\n        //1.8API中提供新的方法\n        int max = Integer.MAX_VALUE;//获取int类型最大值存储到max中\n        int i = 1;\n        System.out.println(max+i);//最大值进行+1之后的到溢出结果不会报错，这样可能影响计算结果\n        //正确计算整数之间求和 ---》 一旦超过了最大值范围就会抛出异常提示 --> ArithmeticException: integer overflow\n        //System.out.println(Math.addExact(max,i));\n        System.out.println(max);\n        //安全的递减操作 ---》让数值-1 ，如果超过最小值范围 抛出异常提示\n        System.out.println(Math.decrementExact(max));\n        //安全的递增操作 ---》 让数值+1，如果超过最大值范围 抛出异常提示\n        // System.out.println(Math.incrementExact(max));\n        //提供除法操作【都是安全】\n        System.out.println(Math.floorDiv(6,3));\n        //提供取余操作【都是安全】\n        System.out.println(Math.floorMod(6,3));\n        //提供一个安全乘法计算.如果超过范围 抛出异常提示\n        System.out.println(Math.multiplyExact(10,10));\n        //提供一个安全相减操作.如果超过范围 抛出异常提示\n        System.out.println(Math.subtractExact(10,4));\n    }\n}\n```\n\n# <center>知识点八：Random类</center>\n\n```java\npublic class RandomDemo \n{\n    public static void main(String[] args) \n    {\n        /*\n            Random是Java中提供随机数类，可以得到随机数\n            但是这个随机数类是一个“伪随机数” --》Random如果使用相同“种子”创建对象，随机出来数据\n就是相同\n            Random中一共两个构造方法 --》 无参 和 有参\n            开发时多数使用无参--》使用系统随机种子\n            有参可以运行出伪随机效果 ---》 参数是一个种子值，但是不是随机范围\n        */\n        //标准使用方式\n        Random random = new Random();\n        //他们可以随机正数 --> 参数是范围\n        int i = random.nextInt(100);\n        System.out.println(i);\n        System.out.println(\"-------------------------------------------------\");\n        //伪随机效果\n        Random r1 = new Random(10);\n        System.out.println(r1.nextBoolean());\n        System.out.println(r1.nextDouble());\n        System.out.println(r1.nextInt());\n        System.out.println(r1.nextInt(100));\n        Random r2 = new Random(10);\n        System.out.println(r2.nextBoolean());\n        System.out.println(r2.nextDouble());\n        System.out.println(r2.nextInt());\n        System.out.println(r2.nextInt(100));\n    }\n}\n```\n\n```java\npublic class RandomDemo\n{\n    public static void main(String[] args)\n    {\n        //创建Random对象\n        Random random = new Random();\n        //随机一个[0,100)\n        int num = random.nextInt(50);\n        System.out.println(num);\n\n        System.out.println(randomCode());\n    }\n    //需求随机生成一个思维的验证码\n    public static String randomCode()\n    {\n        String str = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n        //将字符串转换成char数组\n        char ch [] = str.toCharArray();\n        //2、产生4个随机数\n        Random random = new Random();\n        StringBuffer a = new StringBuffer();\n        for (int i = 0; i < 4; i++)\n        {\n            int index = random.nextInt(str.length());\n            a.append(ch[index]);\n        }\n        return a.toString();\n    }\n}\n```\n\n# <center>知识点九：BigDecimal类</center>\n\n## <center>1、为什么使用BigDecimal?</center>\n\n以下的代码的错误原因是0.9在计算中中的二进制是一个无限循环的\n\ndouble保存时近似值，所以计算的结果不精确\n\n```java\n/*\n    Java中已经提供浮点（小数）数据类型 --》 float和double但是他们在日常计算中还是可以使用\n    但对于数据的精度有要求操作时float和double就不可以的【金融、电信、电力完全禁用float和double】\n    Java提供了一个超精度的小数BigDecimal，可以适用于【金融、电信、电力】，日常也可以使用\n*/\npublic static void showBigDecimal()\n{\n    //为什么double 和float被称之为不精准计算\n    /*\n        计算出这个结果其实是一个“超精确的结果” 数学中提供一个悖论 1/3 = 0.33333333333\n        数学中一个理论 0.333333*3 = 0.9999999 不等于1\n        0.99999无限接近于1的所以 约等于\n    */\n    System.out.println(\"0.09+0.01=\"+(0.09+0.01));//0.1\n    System.out.println(\"1.0-0.33=\"+(1.0-0.33));//0.67\n    System.out.println(\"4.015*1000=\"+(4.015*1000));//4015\n    System.out.println(\"12.3/100=\"+(12.3/100));//0.123\n    //建议使用 BigDecimal进行 计算操作\n    // BigDecimal bigDecimal1 = new BigDecimal(0.09);\n    // BigDecimal bigDecimal2 = new BigDecimal(0.01);\n    /*\n        BigDecimal创建出来的是对象，所以不能使用算数运算符进行计算，不可能对象+对象\n        BigDecimal提供一套计算方法\n        使用BigDecimal计算之后数据得到\n        0.1799999999999999933386618522490607574582099914550781250\n        这个值比double计算更加离谱，这个不是离谱，这个叫做“超级精度”\n        BigDecimal在计算时或精确计算小数点后128位置\n        通过观察JavaAPI文件发现 ---》BigDecimal中调用参数double类型构造方法时，有一个明确\n的说明\n        此构造方法的结果有一定的不可预知性,如果向BigDecimal中存储0.1这个double类型的数据\n        传入到构造方法的值不会正好等于 0.1（虽然表面上等于该值），原因在与Java中是无法精确表\n示0.1这个值\n        所以存储到BigDecimal中得到结果等于\n        0.1000000000000000055511151231257827021181583404541015625\n        所以计算时就会得到一个BigDecimal的精确计算，所以不能调用参数为double类型\n        BigDecimal构造方法来创建\nBigDecimal对象\n        建议在创建BigDecimal对象是，如果需要将数据存储到BigDecimal中建议使用，参数为\nString类型构造方法\n        因为\"0.1\"字符串它是一个常量，并且可以精准表示这个数据\n        写入 new BigDecimal(\"0.1\") 将创建一个 BigDecimal，它正好 等于预期的 0.1\n        开发中，官方的一个建议，优先使用包装类中Double.toString(double类型数据)，将数据转\n换为String类型\n        然后调用BigDecimal中String类型参数构造方法创建对象\n    */\n    double d = 0.09;\n    String string = Double.toString(d);\n    BigDecimal bigDecimal1 = new BigDecimal(string);\n    BigDecimal bigDecimal2 = new BigDecimal(\"0.01\");\n    /*\n        add --> 求和 subtract --> 减法 multiply --> 乘法 divide -->除法\n    */\n    System.out.println(bigDecimal1.add(bigDecimal2));\n}\n```\n\n## <center>2、基本用法</center>\n\n位置：java.math包中\n\n作用：精确计算浮点数\n\n创建方式：\n\n```java\nBigDecimal bd=new BigDecimal(“1.0”);\n```\n\n|                    方法名                     | 描述 |\n| :-------------------------------------------: | :--: |\n|   要运算的数变量名1.add(要运算的数变量名2)    |  加  |\n| 要运算的数变量名1.subtract(要运算的数变量名2) |  减  |\n| 要运算的数变量名1.multiply(要运算的数变量名2) |  乘  |\n|  要运算的数变量名1.divide(要运算的数变量名2)  |  除  |\n\n```java\npublic class BigDecimalDemo\n{\n    public static void main(String[] args)\n    {\n        //演示情况\n        double d1 = 1.0;\n        double d2 = 0.9;\n        System.out.println(d1-d2);  //0.09999999999999998\n        //因为：java中的浮点型在保存小数的时候是近似存储，所以计算的结果不准确\n        //1、创建BigDecimal对象\n        BigDecimal b1 = new BigDecimal(\"1.0\");\n        BigDecimal b2 = new BigDecimal(\"0.9\");\n        System.out.println(b1.subtract(b2));    //减\n        System.out.println(b1.add(b2)); //加\n        System.out.println(b1.multiply(b2)); //乘\n        //除法运算：要设置保留位数和模式\n        //ArithmeticException 算术异常\n        /**\n        * 参数说明：\n        * 参数1：被除数\n        * 参数2：保留小数位数\n        * 参数3：舍入模式\n        *     ROUND_CEILING 向上取整\n        *     ROUND_FLOOR 向下取整\n        *     ROUND_HALF_UP 四舍五入\n        */\n        System.out.println(b1.divide(b2,2,BigDecimal.ROUND_HALF_UP));//除\n    }\n}\n```\n\n# <center>知识点十：BigInteger类</center>\n\n主要应用场景在于当我们遇到long类型都无法存储整数数据时，可以使用这个类型来进行存储计算\n\n```java\nprivate static void showBigInteger() \n{\n    //参数类型要使用Sting类型\n    BigInteger integer = new\n\tBigInteger(\"7777777777777777777777777777777777777\" +\n        \"7777777777777777777777777777777777777777777777777777777777777777777777\" +\n        \"777777777777777777777777777777777777777777777777777777777777\");\n    //可以调用BigInteger中提方法进行计算\n    //mod这个方法是求余数\n    BigInteger mod = integer.mod(new BigInteger(\"7\"));\n    System.out.println(mod);\n    int i = integer.intValue();\n    System.out.println(i);\n}\n```\n\n# <center>知识点十一：Runtime类</center>\n\n```java\n/* \n    每个Java 应用程序都有一个 Runtime 类实例，\n    使应用程序能够与其运行的环境相连接。可以通过 getRuntime 方法获取当前运行时。\n    Runtime这个实例就相当于是虚拟机\n*/\nprivate static void showRuntime() \n{\n    //1.获取正在运行虚拟机对象\n    Runtime runtime = Runtime.getRuntime();\n    System.out.println(\"JVM的核心数量：\"+runtime.availableProcessors());\n    System.out.println(\"JVM的总内存大小：\"+(runtime.totalMemory()/1024/1024));\n    System.out.println(\"JVM的空闲内存大小：\"+(runtime.freeMemory()/1024/1024));\n    System.out.println(\"JVM的最大内存大小：\"+(runtime.maxMemory()/1024/1024));\n    //2.通过runtime这个对象加快GC的回收\n    runtime.gc(); //只能是加快，但是不是立即\n    //3.终止虚拟机 如果是负数就是异常终止 如果正数就是正常终止\n    //这个效果只有虚拟机中有，外界无法查看\n    runtime.exit(1);\n    System.out.println(\"如果没有关闭我必然执行\");\n}\n```\n\n","tags":["Java"],"categories":["编程语言","Java"]},{"title":"18.接口","url":"/post/fe7ab1f0.html","content":"\nPS：接口是一个特殊的抽象父类\n\n什么接口?\n\n&ensp;&ensp;&ensp;&ensp;硬件接口：指的是两个硬件设备之间的链接方式,硬件接口即包括物理上接口，还包括逻辑上接口(数据传输协议)\n\n&ensp;&ensp;&ensp;&ensp;软件接口：程序代码,特殊的抽象类，表示的是一种规范,是具有N个方法的特征的集合在封装的时候，手机大多会留有一个接口，这个接口就会出现充电和耳机要遵守的一些协议,,通过这些协议可以约束数据可以通过什么样的方式来进行数据的传输(多使用在硬件的方向)\n\n&ensp;&ensp;&ensp;&ensp;在Java中，接口表示一种规范/约束/要求实现者必须遵守该规范,约束使用这该怎么做，Java中接口还可以解决一些非继承关系的问题例如：飞机是会飞的,鸟也是可以飞,这两个类有一个共同行为叫做飞，飞机和鸟能是一个共同的父类？不能，即想约束飞机和鸟必须存在飞的这个方法，又不提供继承的这种样式操作，接口就可以做到这个效果\n\n&ensp;&ensp;&ensp;&ensp;接口无非就是在设计一套要遵守的行为规范，但是这个规范并没有强加联系(彼此之间不是强关联[继承关系])，而是约束关系,如果要象按照这个规则形式就必须实现接口\n\n&ensp;&ensp;&ensp;&ensp;接口只是定义类应当遵守的规范，却不不关心这些类内部数据和其功能的具体实现细节,站在程序角度上接口只规定了类中必提供方法，从而分析了规范和实现,增强了可扩性和可维护性\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271927662.jpg\" alt=\"接口分析\" style=\"zoom: 50%;\" />\n\n&ensp;&ensp;&ensp;&ensp;避开继承关系，又能约束子类必须实现某些方法，可以提供接口，接口中提供方法就是对类的约束【必须实现这些方法，否则无法使用】\n\n# <center>知识点一：基本语法</center>\n\n## <center>1、语法</center>\n\n```java\n//Java中现在接口可以分为两个版本：\nJava8之间版本【不包含Java8】\npublic interface 接口名字\n{\n    public static final 数据类型 常量名 = 值;\n    public abstract 返回值类型 方法名(参数列表);\n} \nJava8之后版本【包含Java8】\npublic interface 接口名字\n{\n    public static final 数据类型 常量名 = 值;    //静态常量\n    public abstract 返回值类型 方法名(参数列表);   //抽象方法\n    public default 返回值类型 方法名(参数列表)//它就是类中成员方法\n    { \n        提供方法实现\n        return;\n    } \n    public static 返回值类型 方法名(参数列表)    //他就是类中静态方法\n    { \n        提供方法实现\n        return；\n    }\n} \n    PS：从Java9开始允许接口中定义 private 方法\n//实现接口：\npublic class 实现类(子类) implements 接口\n{\n}\n```\n\n接口中只能包含：\n\n&ensp;&ensp;&ensp;&ensp;公开的静态常量\n\n&ensp;&ensp;&ensp;&ensp;公开的抽象方法\n\n&ensp;&ensp;&ensp;&ensp;不能有普通属性、构造方法、静态代码块\n\n## <center>2、特点</center>\n\n1. 接口是没有构造方法的，所以接口就更不可能直接创建对象\n\n即 接口名 对象名 = new 接口名(); ----》这种操作是不可实现\n\n2. 上面语法中体现修饰符【public、static 、final、abstract】，都可以省略不写，接口是默认修饰原则，自动\n\n就添加了【static方法中static不可以省略，default方法中default不可以省略】\n\n3. 接口本意是让类来实现约束使用，所以接口修饰必须是public\n4. 接口和类之间关系【实现关系】（其实这个关系就是隐式继承）\n\n&ensp;&ensp;&ensp;&ensp;可以将接口看做是父类 实现接口类是子类\n\n5. 类与接口建立联系时使用的【实现关系】，所以使用关键字是【 implements】\n6. 因为接口与类之间是【实现关系（隐式继承）】，所以接口支持多态并且接口是引用类型\n\n7、接口中只能有抽象方法\n\n8、接口中的抽象方法必须要被非抽象类重写\n\n例：提供一个接口文件\n\n```java\npublic interface InterfaceForJDK_8 \n{\n    //1. 可以在接口中定义静态全局常量\n    int NUM = 10;//接口是一个默认修饰原则 ---》等价于 --》 public static final int\n    NUM = 10;\n    //2.提供抽象方法的定义\n    void show();//接口是一个默认修饰原则 ---》等价于 --》 public abstract void show();\n    //3.允许接口中提供default方法【这个方法带有方法体（相当于是类中成员方法），实现接口子类可以重写这个方法】\n    default void showInfosDefault()//接口是一个默认修饰原则 ---》等价于 --》 public\n    {\n        default void showInfosDefault()\n        System.out.println(\"接口中default方法\");\n    } \n    //4.允许接口中提供static方法【这个方法带有方法体（相当于是类中静态方法），实现接口子类不可以重写这个方法】\n    static void showInfosStatic()    //接口是一个默认修饰原则 ---》等价于--》public\n    {\n        static void showInfosStatic()\n        System.out.println(\"接口中static方法\");\n    }\n}\n```\n\n普通类如果实现接口，必须实现接口中所有抽象方法【接口利用抽象方法约束类进行方法实现操作】\n\n```java\npublic class Person implements InterfaceForJDK_8\n{\n    @Override\n    public void show() \n    {\n        System.out.println(\"实现接口中show方法\");\n        System.out.println(\"可以在接口的实现类中调用接口中定义全局常量：\"+NUM);\n    } \n    //选择向重写接口中提供default方法\n    @Override\n    public void showInfosDefault() \n    {\n        //这里就间接证明类与接口属于间接继承效果\n        //InterfaceForJDK_8.super.showInfosDefault();\n        System.out.println(\"重写接口中default方法\");\n    }\n}\n```\n\nTest类\n\n```java\npublic class Test \n{\n    public static void main(String[] args) \n    {\n        //1.可以使用接口的实现类创建对象完成操作\n        Person person = new Person();\n        person.show();\n        person.showInfosDefault();\n        //接口与类之间虽然是实现关系，但是属于隐式继承，所以可以使用多态效果创建接口对象\n        InterfaceForJDK_8 interfaceForJDK8 = new Person();\n        interfaceForJDK8.show();\n        interfaceForJDK8.showInfosDefault();\n        //接口中静态方法与常量只能使用接口名调用\n        InterfaceForJDK_8.showInfosStatic();\n        System.out.println(InterfaceForJDK_8.NUM);\n    }\n}\n```\n\n## <center>3、接口使用时注意事项</center>\n\n1. 在开发中设计接口时，接口名字，都是以大写字母【I】开头，除非单词首字符是【I】除外，代表是一个接口，接口实现类命名在最后单词结尾要添加Impl，代表实现接口类\n\n```java\npublic interface IPerson\n{\n    void showInfosPerson();\n} \npublic class PersonImpl implements IPerson\n{\n    @Override\n    public void showInfosPerson()\n    {\n    }\n}\n```\n\n2. 一类可以实现多个接口【相当于是多继承模拟】,接口名逗号分隔，并给还可以继承另外一个类\n\n```java\npublic interface IPerson\n{\n    void showInfosPerson();\n} \npublic interface IStudent\n{\n    void showInfosStudent();\n} \npublic abstract class Man{}\npublic class OldMan extends Man implements IPerson,IStudent{}\n```\n\n3. 接口和接口之间存在继承关系，而且允许多继承【可以得到继承接口中所有操作】\n\n```java\npublic interface IPerson\n{\n    void showInfosPerson();\n} \npublic interface IStudent\n{\n    void showInfosStudent();\n} \npublic interface IMan extends IPerson,IStudent{}\n```\n\n4. 可以使用抽象类实现接口，选择性实现接口中抽象方法\n\n```java\npublic interface IStudent\n{\n    void showInfosStudent();\n} \npublic abstract class ManImpl implements IStudent\n{\n    //抽象类可以选择性实现接口中抽象方法，也可以不实现\n}\n```\n\n# <center>知识点二：接口的作用</center>\n\n## <center>1、从微观上讲</center>\n\n作用：扩充类的能力\n\n原因：一个类只能继承一个父类，如果父类提供的方法不能满足子类的时候，这是我们可以通过实现接口的方式，为这个扩容功能。一个类可以实现多个接口\n\nAnimal类\n\n```java\npublic class Animal //父类\n{\n    public void eat()\n    {\n        System.out.println(\"吃\");\n    }\n    public void sleep()\n    {\n        System.out.println(\"睡\");\n    }\n}\n```\n\nDog类\n\n```java\npublic class Dog extends Animal implements Runnable,Swimming  //子类 （Dog已经拥有两个能力(吃\\睡)）\n{\n    //需要为Dog扩充跑的能力\n    @Override\n    public void run()\n    {\n        System.out.println(\"跑...\");\n    }\n    //需要为Dog扩充游泳的能力\n    @Override\n    public void swimm()\n    {\n        System.out.println(\"游泳...\");\n    }\n}\n```\n\nRunnable接口\n\n```java\npublic interface Runnable   //能力\n{\n    //跑的方法  跑的能力\n    void run();\n}\n```\n\nSwimming接口\n\n```java\npublic interface Swimming   //能力\n{\n    //游泳能力\n    void swimm();\n}\n```\n\nTest类\n\n```java\npublic class Test\n{\n    public static void main(String[] args)\n    {\n        Dog dog = new Dog();\n        dog.eat();  //从父类继承而来\n        dog.sleep();    //从父类继承而来\n        dog.run();  //通过接口而扩展的能力\n        dog.swimm();    //通过Swimming接口而扩展的能力\n    }\n}\n```\n\n## <center>2、从宏观上讲</center>\n\n作用：定义类的约束\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271927680.jpg\" alt=\"接口宏观1\" style=\"zoom: 67%;\" />\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271928512.jpg\" alt=\"接口宏观2\" style=\"zoom:67%;\" />\n\nProduact类\n\n```java\npublic class Produact\n{\n     int id; //商品的id（唯一表示）\n      String name;   //商品名称\n     double price;   //商品价格\n​\n    public Produact(int id, String name, double price)\n    {\n        this.id = id;\n        this.name = name;\n        this.price = price;\n    }\n​\n    public Produact()\n    {\n    }\n​\n    public int getId()\n    {\n        return id;\n    }\n​\n    public void setId(int id)\n    {\n        this.id = id;\n    }\n​\n    public String getName()\n    {\n        return name;\n    }\n​\n    public void setName(String name)\n    {\n        this.name = name;\n    }\n​\n    public double getPrice()\n    {\n        return price;\n    }\n​\n    public void setPrice(double price)\n    {\n        this.price = price;\n    }\n}\n```\n\nProductService接口\n\n```java\n//这个接口是在定义标准，定义规范，未来对于商品的操作，必须要按照一下标准进行编写\npublic interface ProductService     //增删改查\n{\n    //增加\n    void addProduct(Produact produact);\n    //删除\n    void deleteProduct(int id);    //id是唯一的的，所以删除操作是按照id进行删除\n    //修改\n    void updateProduct(Produact produact);\n    //查询\n    Produact[] selectProduct();\n}\n```\n\nProductServiceImpl类\n\n```java\npublic class ProductServiceImpl implements ProductService{\n    @Override\n    public void addProduct(Produact produact){\n    }\n\n    @Override\n    public void deleteProduct(int id){\n    }\n\n    @Override\n    public void updateProduct(Produact produact){\n\n    }\n\n    @Override\n    public Produact[] selectProduct(){\n        return new Produact[0];\n    }\n}\n```\n\nTest类\n\n```java\npublic class Test{\n    public static void main(String[] args){\n        //面向接口编程，父类的引用指向子类对象（多态）\n        ProductService productService = new ProductServiceImpl();\n        productService.addProduct(null);\n        productService.updateProduct(null);\n        productService.deleteProduct(1);\n        productService.selectProduct();\n    }\n}\n```\n\n# <center>知识点三：接口的关系</center>\n\n## <center>1、类与类的关系</center>\n\n在Java中，类与类是继承关系，只能单继承（extends）\n\n## <center>2、类与接口的关系</center>\n\n在Java中，类与接口是实现，可以多实现（implements）\n\n## <center>3、接口与接口的关系</center>\n\n在Java中，接口与接口是继承关系，接口与接口之间是多继承（extends）\n\n## <center>4、接口常量</center>\n\n接口只有公开的静态常量（在接口中定义很多的静态常量（用于表示状态（已支付、未支付、支付未发货、已收货....）））\n\n在以后开发中可以使用枚举来替代\n\n# <center>知识点四：接口回调</center>\n\n先有接口的使用者，后有接口的实现者\n\nMyClass类\n\n```java\npublic class MyClass implements MyInterface\n{\n    //后有接口的实现者\n    @Override\n    public boolean isZS(int num)\n    {\n        for (int i = 2; i < num; i++)\n        {\n            if (num % i == 0)\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\nMyInterface接口\n\n```java\npublic interface MyInterface\n{\n    //判断一个数是否是质数\n    boolean isZS(int num);\n}\n```\n\nTest类\n\n```java\npublic class Test\n{\n    public static void main(String[] args)\n    {\n        gdbh(14,new MyClass());\n    }\n    //先有接口的使用者\n    public static void gdbh(int num,MyInterface myInterface)\n    {\n        if(num < 6 || num % 2 != 0)\n        {\n            System.out.println(\"传入参数不合法\");\n            return;\n        }\n        for (int i = 2; i <= num/2; i++)\n        {\n            if (myInterface.isZS(i) && myInterface.isZS(num-1))\n            {\n                System.out.println(num + \"=\" + i + \"+\" + (num-i));\n            }\n        }\n    }\n}\n```\n\n# <center>知识点五：内部类</center>\n\nPS:被称之为“万恶的内部类”，对于JavaEE开发 或 大数据开发而言，内部类近乎于不会在开发中出现，内部可以达到的效果可以完成一些数据结构的实现【链表 或 树等等】，在Android开发中内部会大量使用\n\nJava中内部类分为以下4种：\n\n1. 成员内部类, 内部类在定义时没有使用static修饰（知晓）\n2. 静态内部类，内部类在定义时使用static修饰【Java中唯一可以使用static修饰类的方法】（知晓）\n3. 局部内部类，内部类在定义时定义在方法体内部（了解）\n4. 匿名内部类，它属于局部类类的特殊形态（必须会用）\n\n内部类也是类，所以也会被JVM进行编译生成字节码文件【.class文件】\n\n1. 成员内部类生成字节码文件： 外部类类名$成员内部类类名.class\n2. 静态内部类生成字节码文件： 外部类类名$静态内部类类名.class\n3. 局部内部类生成字节码文件： 外部类类名$数字局部内部类类名.class\n4. 匿名内部类生成字节码文件： 外部类类名$数字.class\n\nPS： 数字是从1开始逐渐递增【随着类的增加而增加】\n\n## <center>1、含义</center>\n\n定义在一个类的里面的类为内部类，在外面的类成为外部类\n\n## <center>2、内部类的分类</center>\n\n### 成员内部类\n\n外部类可以使用权限修饰符为 public 和 默认的和abstract，成员内部类可以使用【4种权限修饰符和abstract修饰】，可以将**成员内部类看做就是在类中声明成员变量或成员方法，所以成员内部类是属于对象的**\n\n外部类\n\n```java\npublic class Outter \n{\n    //外部类中提供成员变量和方法、静态变量和方法\n    String name = \"小白\";\n    double PI = 3.14;\n    static int age = 10;\n    public static void showInfos()\n    {\n        System.out.println(\"外部类静态方法\");\n    } \n    public void display()\n    {\n        System.out.println(\"外部类的成员方法\");\n        //需要提供内部类对象创建，才可以使用成员内部类中所提供成员变量和成员方法\n        InnerClass innerClass = new InnerClass();\n        innerClass.name =\"z\";\n        innerClass.show();\n    }\n    //提供成员内部类 ---》 成员内部类就是定义在类中类，可以使用任何修饰符除static外\n    public class InnerClass    //成员内部类\n    { \n        //可以在成员内部类中提供类的基础定义，但是不可以提供static修饰的属性和方法\n        //static double PI = 3.14;\n        String name = \"小黑\";\n        public void show()\n        {\n            System.out.println(\"成员内部类中成员方法\");\n            //如果说在成员内部类中调用与外部类同名属性\n            //this代表的是InnerClass对象，所以使用this.name\n            System.out.println(this.name);\n            //这种方式访问外部类的成员变量\n            System.out.println(Outter.this.name);\n            //调用外部类的成员方法【如果没有重名的效果，就不需要使用，外部类类名.this.方式调用】\n            display();\n            System.out.println(PI);\n            //成员内部类中是可以调用外部类静态属性和方法\n            System.out.println(age);\n            showInfos();\n        }\n    }\n}\n```\n\n测试\n\n```java\nclass Test\n{\n    public static void main(String[] args) \n    {\n        //如何在外部创建成员内部类的对象\n        //成员内部类是属于外部类所有的，所以提供方式就是\n        // 外部类类名.内部类类名 内部类对象名 = new 外部类().new 成员内部类();\n        Outter.InnerClass innerClass = new Outter().new InnerClass();\n        innerClass.show();\n    }\n}\n```\n\n总结： 成员内部类是定义在类中，不使用static修饰，可以使用4种权限修饰符，可以使用abstract和final修饰，允许继承类与实现接口，成员内部类中不可以定义static修饰变量与方法，成员内部类是可以直接访问外部类定义属性和方法，**如果成员内部类出现了与外部类属性重名，可以使用【this 和 外部类.this】进行区分**，外部类要访问成员内部类的属性和行为时，提供成员内类的对象---》 \n\n**外部类类名.内部类类名 内部类对象名 = new 外部类().new 内部类();**\n\n### 静态内部类\n\n静态内部类和成员内部类几乎与是一样的，唯一不点在于静态内部类使用static进行了修饰\n\nPS：这是Java中类唯一可以使用static修饰的形式\n\n```java\n//外部类\npublic class Outter\n{\n    //外部类中提供成员变量和方法、静态变量和方法\n    String name = \"小白\";\n    double PI = 3.14;\n    static int age = 10;\n    public static void showInfos()\n    {\n        System.out.println(\"外部类静态方法\");\n    } \n    public void display()\n    {\n        System.out.println(\"外部类的成员方法\");\n        //调用静态内部类中静态属性和方法 ---》 静态内部类类名.静态属性和静态方法即可\n        System.out.println(InnerClass.name);    //如果要跨类调用，则需要前面加上外部类的类名\n        //调用静态内部类中成员属性和方法 ---》 需要提供静态内部类的对象\n        new Outter.InnerClass().show();\n    } \n    //提供静态成员内部类 ---》 静态内部类就是定义在类中类，可以使用static修饰符修饰\n    public static class InnerClass    //静态内部类\n    { \n        // 静态内部类可以提供普通类中所有可以提供操作【成员变量和方法、静态变脸和方法】\n        double PI = 3.15;\n        static String name = \"小黑\";\n        public void show()\n        {\n            //在静态内部类中是不用担心 属性重名问题\n            //不是可以使用 外部类类名.this方法访问外部的属性【static中是不允许使用this和super关键字】\n            //只能在静态内部类中创建外部类对象，才可以访问外部类成员变量和成员方法\n            System.out.println(new Outter().name);\n            //调用外部类静态方法和静态属性 --> 外部类类名.静态属性或静态方法即可\n            System.out.println(Outter.age);\n            Outter.showInfos();\n            //静态内部类中的属性和方法直接调用即可\n            System.out.println(PI);\n            System.out.println(name);\n        }\n    }\n}\n```\n\n测试\n\n```java\nclass Test{\n    public static void main(String[] args) {\n        //提供静态内部类对象创建\n        //外部类类名.静态内部类类名 对象名 = new 外部类类名.静态内部类类名();\n        Outter.InnerClass innerClass = new Outter.InnerClass();\n        innerClass.show();\n    }\n}\n```\n\n总结： 静态内部就是使用static修饰类【Java中只有这个类可以使用static修饰】，可以使用所有权限修饰符，abstract和final修饰，静态内部类和静态属性和静态方法是一样都属于类，静态内部类中是可以定义【成员变量和方法、静态变量和方法】，静态内部类中不允许明确访问方式获取外部类this对象即【外部类类名.this】,所以在静态内部类中访问外部类成员变量和成员方法，需要提供外部对象才可以，外部类静态变量和静态方法直接访问即可，如果有重名【外部类类名.静态变量/静态方法】\n\n静态内部类如果要创建对象\n\n&ensp;&ensp;&ensp;&ensp;外部类类名.静态内部类类名 对象名 = new 外部类类名.静态内部类类名();\n\n### 局部内部类\n\n这个内部类不允许使用任何修饰符，只能定义在方法内部与局部变量是平级关系，**访问作用域仅限在方法的内部**\n\n```java\n//外部类\npublic class Outter \n{\n    //提供一个成员方法\n    public void show()\n    {\n        //局部变量\n        final int age = 18;\n        //提供局部内部类【局部变量是平级关系】\n        class InnerClass\n        {\n            //局部内部类中是不允许定义static修饰属性和方法\n            //允许提供成员变量和成员方法\n            String gender = \"男\";\n            public void display()\n            {\n                //在局部内部类中访问方法中局部变量\n                /*\n                    IDEA提供错误提示信息\n                    Variable 'age' is accessed from within inner class, needs to be\nfinal or effectively final\n                    如果局部内部类使用方法提供的局部变量，这个局部变量必须是final修饰\n                */\n                System.out.println(age);\n            }\n        } \n        //局部内部类只能在方法体的内部创建对象和使用，外界是无法访问到这个类中\n        new InnerClass().display();\n        //在此在方法体的内部修改成员变量\n        // age = 20;\n    }\n}\n```\n\n为什么，局部内部类访问局部变量之后需要使用final声明？\n\n&ensp;&ensp;&ensp;&ensp;final修饰局部变量的存储空间会发生改变,存储不再是栈中，而是方法区中常用池，局部变量就会变成“引用”常量\n\n&ensp;&ensp;&ensp;&ensp;局部内部类是声明在方法体内部，就会存在一个问题，局部内部类是随着方法而开始创建空间，随着方法消亡开始回收空间，如果在方法内声明局部变量存储空间是栈【随着方法开始而创建随着方法消亡会销毁】，如果局部内部类使用了这个局部变量，那么堆中地址就会和栈中位置产生一个联系，堆中局部内部类就会引用到栈中局部变量，如果发生方法执行完毕，栈中空间空间会进行立即回收，但是堆中局部内部类是不会被立即回收【GC机制】，就会出现堆栈存在一个“指向空”引用，内报错了，所以使用final修饰符将局部变量修改为局部常量，将存储从栈中移动到方法区中常量池，这样一来就算栈中空间被回收，但是方法区种空间还在，所以可以等待堆中局部内部正常回收之后断练习，保证不会出现引用错误\n\n注意：局部内部类只能访问局部常量\n\n&ensp;&ensp;&ensp;&ensp;原因：局部变量在方法结束之后就会被销毁，而局部内部类是由垃圾回收器回收进行销毁，由于垃圾回收器的销毁时间不确定有可能在方法结束之后还没被销毁，所以有可能对象还在变量早没了\n\n### 匿名内部类\n\n&ensp;&ensp;&ensp;&ensp;匿名内部类是局部类型的一种特殊属性形式，**匿名内部类主要的作用就是提供便捷接口实现**\n\n&ensp;&ensp;&ensp;&ensp;在某些情况下，会使用接口作为方法参数存在，如果需要将接口实现类传递到这个方法中时，需要创建一个类并实现接口，通过当前类创建对象并将当前对象传递给当前方法参数进行赋值操作，这样一来方法内部就可以 操作接口对象【利用多态---》接口与类之间是隐式继承，可以将接口看做是类父类，实现类是接口子类】\n\n&ensp;&ensp;&ensp;&ensp;但是，某些方法进行接口参数传递时，只会使用这一次接口操作【即调用方法的位置使用一次接口就结束】，创建类实现接口，在创建类对象传递到方法中操作就十分繁琐，而且类只会方法中使用一次，类的存在就没有太大意义，不便于管理，【**所有在这种情况下，就可以利用匿名内部类方式完成对接口实现并传递到方法参数中**】\n\n语法：\n\n```java\nnew 父类(){\n    \n};\n```\n\n```java\n//抽烟接口\npublic interface ISmoking \n{\n    /**\n    * 抽烟方法\n    * @param name 抽烟的名字\n    */\n    void smoke(String name);\n}\n```\n\n按照以往的方法实现接口\n\n```java\npublic class Outter implements ISmoking \n{\n    @Override\n    public void smoke(String name) \n    {\n        System.out.println(\"正在抽的烟是:\"+name);\n    }\n}\n```\n\n测试\n\n```java\npublic class Test \n{\n    public static void main(String[] args) \n    {\n        //调用抽烟方法展示抽象操作\n        //1.提供实现ISmoking接口对象\n        Outter outter = new Outter();\n        //2.通过outter对象调用smoke方法就可以执行抽烟操作\n        outter.smoke(\"华子\");\n        //这个方法可以接收的对象必须是实现ISmoking接口的对象【利用就是面向兑现中多态】\n        showInfosSmokeName(outter);\n        //但是，如果当前实现接口类只使用一次，不在重复使用了，这样创建方式就比较繁琐也不利于管理\n        //所以Java就提供了一个更加便捷处理方式，提供匿名内部类作为接口的实现操作\n        /*\n            第一种 主要是针对与方法参数为接口类型进行赋值操作 --》完全匿名内部类\n            new 接口名()\n            {\n                提供接口中抽象方法的实现;\n            }\n        */\n        new ISmoking(){\n            @Override\n            public void smoke(String name) \n            {\n                System.out.println(\"完全匿名内部类实现接口：\"+name);\n            }\n        }.smoke(\"芙蓉王\"); //这种形式主要是针对方法参数赋值使用的\n        //调用smoke方法而不是对于方法参数传递\n        /*\n            第二种方式，针对匿名内部类所创建对象进行存储操作\n            接口名 对象名 = new 接口名()\n            {\n                接口抽象方法的实现\n            }\n        */\n        //smoking 存储的就是匿名内部类的引用【使用 new ISmoking的形式将后面的匿名内部类进\n        行对象向上转型】\n        ISmoking smoking = new ISmoking() \n        {\n            @Override\n            public void smoke(String name) \n            {\n                System.out.println(\"使用匿名内部类创建了接口对象：\"+name);\n            }\n        };\n        smoking.smoke(\"煊赫门\");\n        //可以使用匿名内部类的这种语法便捷的对方法中参数进行赋值操作\n        showInfosSmokeName(new ISmoking() \n        {\n            @Override\n            public void smoke(String name) \n            {\n                System.out.println(\"匿名内部类对接口参数赋值：\"+name);\n            }\n        });    // 使用匿名内部类形式对接口参数进行赋值操作\n    } \n    //提供一个方法这个方法的参数类型是接口类型\n    public static void showInfosSmokeName(ISmoking smoking)\n    {\n        smoking.smoke(\"小熊猫\");\n    }\n}\n```\n\n&ensp;&ensp;&ensp;&ensp;匿名内部类就是提供接口便捷实现方式，并赋值给方法中使用接口作为参数类型，但是接口实现不能太复杂，只会使用一次这样方式是最便捷的\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271928787.jpg\" alt=\"接口例程结果\" style=\"zoom: 50%;\" />\n\n特点：\n\n&ensp;&ensp;&ensp;&ensp;1）匿名内部类本身是一个对象\n\n&ensp;&ensp;&ensp;&ensp;2）匿名内部类的父类通常是接口或者抽象（为了可以重写然后调用）\n\n&ensp;&ensp;&ensp;&ensp;3）匿名内部类一般不会定义自己的属性和方法\n\n&ensp;&ensp;&ensp;&ensp;4）匿名内部类最多场景就是在方法的参数为接口的时候使用\n\n# <center>知识点六：Lambda</center>\n\n## <center>1、介绍</center>\n\nPS： λ（lambda符号）希腊文，Lambda是Java8中提供新特性【也是最值得学习的新特性之一】，Lambda的操作在其他语言中也别广泛的使用，Lambda是Java8中提供一个新特性而已\n\n&ensp;&ensp;&ensp;&ensp;Lambda表达式的目的在Java中是为了解决匿名内部类繁琐实现\n\n&ensp;&ensp;&ensp;&ensp;Lambda表达式的引入也代表着Java正式进入到【函数式编程】\n\nPS:2014年【移动互联网结束Android和IOS】---》VR/AR、人工智能、大数据【三个风口】人工智能（python --》【爬虫】）、大数据（Java【hadoop/spark】)【二个风口】--》2021年元宇宙【新风口 ----》VR/AR】 ---》 后台【首选Java】\n\n什么是函数式编程？\n\n&ensp;&ensp;&ensp;&ensp;函数式编程被称为函数式程序设计，首先它是一个规范，它是将函数逻辑应用到电脑编程，将编程视为一个一个函数，它允许函数作为输入【引用】和输出【传出数据】操作，完成代码的编辑\n\nLambda表达式在作用\n\n&ensp;&ensp;&ensp;&ensp;就是简化匿名内部类实现代码作为方法接口实现参数的传递\n\n```java\npublic class LambdaDemo1 \n{\n    public static void main(String[] args) \n    {\n        //lambda表达式于匿名内部类之间区别\n        //提供一个Integer类型数据【Integer理解为int类型】\n        Integer[] arr = {23,4132,2,123,512345,2463,2234,343};\n        /*\n            在Arrays工具类中有有一个排序方法，可以提供方给我们使用\n            这个方法中有两个参数版本，这个版本中第二个参数就是接口，这个接口叫做Comparator\n接口\n            Comparator接口是一个比较接口，对接口进行实现来执行排序的方式\n        */\n        Arrays.sort(arr, new Comparator<Integer>() \n        {\n            @Override\n            public int compare(Integer o1, Integer o2) \n            {\n                return o2-o1; //降序\n            }\n        });\n        System.out.println(\"arr数据排序之后：\"+Arrays.toString(arr));\n        /*\n            使用匿名内部类实现起来是比较繁琐的，代码太多了，看起来会比较繁琐\n            此时就可以利用Lambda表达式代替匿名内部的实现进行方法中接口参数的传递操作\n        */\n        Arrays.sort(arr,((o1,o2)->o2-o1));\n        System.out.println(\"lambda表达式的实现排序：\"+Arrays.toString(arr));\n    }\n}\n```\n\nPS：Lambda表达式的实现形式也是将来学习StreamAPI【流式编程】必备的语法\n\n&ensp;&ensp;&ensp;&ensp;Lambda表达式与匿名内部类一样，适合一次使用的效果，多次重复使用Lambda表达式就不是很便捷【根匿名内部类一样】，但是Lambda表达式可以更加便捷实现，替换匿名内部类的繁琐实现\n\n## <center>2、语法</center>\n\n语法：\n\n```java\n()->{} 或者 (参数)->{}\n```\n\nPS：Lambda语法对应不是接口【public interface 接口名】，Lambda对应是接口中抽象方法\n\n&ensp;&ensp;&ensp;&ensp;**所以将Lambda表达式理解为是接口中抽象方法实现**\n\n&ensp;&ensp;&ensp;&ensp;Lambda表达式中 () 【小括号】对应就是 抽象方法的 ()【小括号】 --》抽象方法参数列表\n\n&ensp;&ensp;&ensp;&ensp;你定义【实现】抽象方法有参数列表，使用Lambda表达式实现时候就需要添加参数\n\n&ensp;&ensp;&ensp;&ensp;Lambda表达式可以根据实现抽象方法中参数列表态推断数数据类型，所以在Lambda表达式中定义参数时，可以省略数据类型，指定义参数名字即可\n\n详细说明：\n\n&ensp;&ensp;&ensp;&ensp;Lambda表达式中小括号【()】 : Lambda表达式中参数定义位置，它是与对应实现接口中抽象方法与之对应，抽象方法中有参数有什么Lambda中就有参数定义，抽象方法中没有参数那么Lambda中就没有参数定义，并且Lambda表达式可以省略参数数据类型【提供自动推断】\n\n&ensp;&ensp;&ensp;&ensp;Lambda表达式中箭头指向【->】: 没有任何特殊意义，就是语法要求\n\nPS：理解方法引用---》C语言 ----》函数指针【指针函数】\n\n&ensp;&ensp;&ensp;&ensp;Lambda表达式中大括号【{}】：和方法中大括号是一个概念，代表方法的实现体，即的对抽象方法的具体实现，代表着Lambda表达式中对抽象方法的具体实现\n\n```java\n//提供多个接口分别使用Lambda表达式实现\npublic interface InterfaceA \n{\n    void showA();//定义一个无参的抽象方法\n} \ninterface InterfaceB \n{\n    void showB(int b);//定义一个有一个参数抽象方法\n} \ninterface InterfaceC \n{\n    void showB(int c,int d);//定义一个有两个参数抽象方法\n} \ninterface InterfaceD\n{\n    int showD(int c,int d);//定义一个带有返回值和多个参数的方法\n} \nclass Demo\n{\n    //在这个类中main中方法中使用Lambda表达式实现接口\n    public static void main(String[] args) \n    {\n        //Lambda表达式对应的是接口中抽象方法 接口中抽象方法是如何定义的Lambda表达式就仿\n        照定义\n        //1.使用Lambda表达式实现一个接口【抽象方法是无返回值无参的状态】\n        InterfaceA a1 = () ->{\n        System.out.println(\"Lambda表达式实现接口中showA方法\");\n        };\n        //调用接口中方法\n        a1.showA();\n        //如果lambda表达式对抽象方法实现方式体只有一句代码可以省略大括号\n        InterfaceA a2 = () -> System.out.println(\"Lambda表达式实现接口中showA方法\");\n        //2.使用Lambda表达式实现一个接口【抽象方法是无返回值有一个参数的状态】\n        InterfaceB b1 = (int b) ->{\n            System.out.println(\"Lambda表达式实现接口中showB方法：\"+b);\n        };\n        //Lambda表达式可以对定义参数提供自动类型推断，省略参数中定义数据类型\n        InterfaceB b2 = (b) ->{\n        System.out.println(\"Lambda表达式实现接口中showB方法：\"+b);\n        };\n        //Lambda表达式实现抽象方法是一个参数的，可以省略数据类型和小括号\n        //如果实现方法体只有一句代码可以省略大括号\n        InterfaceB b3 = b -> System.out.println(\"Lambda表达式实现接口中showB方法：\"+b);\n        //3.使用Lambda表达式实现一个接口【抽象方法是无返回值有多个参数的状态】\n        //直接利用上面所提供有些优化策略直接操作者【数据类型自定推断（省略参数类型）】\n        InterfaceC c1 = (c,d)->{\n        System.out.println(\"Lambda表达式实现抽象方法showC\"+(c+d));\n        };\n        //4.使用Lambda表达式实现一个接口【抽象方法是有返回值有多个参数的状态】\n        //如果实现抽象方法只有一句执行语句，此时return关键字可以省略不写【这个方法需要带有返回值才可以】\n        InterfaceD d1 = (c,d)->c + d;\n        //如果需要在使用Lambda表达式实现时有多个条代码语句，就需要书写return关键字\n        InterfaceD d2 = (c,d)->{\n            if(c > d)\n            {\n                return c+d;\n            }\n            else\n            {\n                return d-c;\n            }\n        };\n    }\n}\n```\n\n练习：提供一个接口InterfaceE，在接口中定义一个抽象方法 showE，并且有一个参数，带有返回，提供一个执行类在执行类中定义一个静态方法，方法参数类型时InterfaceE，并在静态方法调用接口中showE并执行效果\n\n```java\n//提供一个InterfaceE的接口\npublic interface InterfaceE \n{\nboolean showE(boolean b);\n} \nclass Test\n{\n    public static void main(String[] args) \n    {\n        //使用匿名内部类的实行使用方法的实现\n        boolean res = result(new InterfaceE() \n        {\n            @Override\n            public boolean showE(boolean b) \n            {\n                return b;\n            }\n        },true);\n        System.out.println(\"匿名内部类实现方法得到的返回值是：\"+res);\n        //使用Lambda表达式实现操作\n        boolean res2 = result(b -> b, false);\n        System.out.println(\"Lambda表达式实现方法得到的返回值是：\"+res2);\n    } \n    //提供一个静态方法，这个方法参数列表中有InterfaceE这个接口类型\n    public static boolean result(InterfaceE e,boolean res)\n    {\n        return e.showE(res);\n    }\n}\n```\n\n## <center>3、Lambd表达式的局限性</center>\n\n需要注意Lambda表达式不是万能的，Lambda表达式不能替代所有的匿名内部类的操作，Java8中提供的这个新的特性Lambda表达式存在一个实现弊端\n\n```java\npublic interface InterfaceF \n{\n    //添加两个抽象方法\n    void showF();\n    void showFF(int f);\n} \nclass Test2\n{\n    public static void main(String[] args) \n    {\n        //使用匿名内部类实现InterfaceF接口\n        InterfaceF interfaceF = new InterfaceF() \n        {\n            @Override\n            public void showF() \n            {\n                System.out.println(\"匿名内部类实现InterfaceF接口\");\n            } \n            @Override\n            public void showFF(int f) \n            {\n                System.out.println(\"匿名内部类实现InterfaceF接口\");\n            }\n        };\n        //使用Lambda表达式实现InterfaceF接口\n        /*\n            IDEA中提供错误提示\n            Multiple non-overriding abstract methods found in interface\n            com.qfedu.lambda.InterfaceF\n            这个就是Lambda表达式的局限性，Lambda表达式只能实现接口中只存在一个抽象方法\n            Lambda表达式实现接口中，提供抽象方法有且仅能有一个\n        */\n        /* InterfaceF interfaceF1 = () ->{\n        System.out.println(\"\");\n        }*/\n    }\n}\n```\n\n&ensp;&ensp;&ensp;&ensp;Lambda表达式实现接口是有一个要求，接口中只能提供一个抽象方法，这样接口才适合Lambda做简便实现，无法实现接口中同时拥有多个抽象方法，这就是Lambda的弊端\n\n&ensp;&ensp;&ensp;&ensp;所以Java为了保证Lambda表达式可以正确实现接口方法，Java对接口提供一个注解约束，约束接口中只能用一个抽象方法，那么我们称这样接口叫做函数式接口【专门提供给Lambda表达式实现】\n\n```java\n//添加这样一个注解在接口上方，他会检查接口中是否提供多个抽象方法，如果提供多个抽象方法就会报错\n//提供这样注解的接口就是专门对于Lambda提供实现操作的\n@FunctionalInterface\npublic interface InterfaceF \n{\n    //添加两个抽象方法 --》 这个接口中提供两个抽象方法就会出现错误\n    /* void showF();\n        void showFF(int f)\n    */\n    void showF(); //仅提供一个抽象方法就不会报错了\n}\n```\n\n注解@FunctionalInterface就是为了满足Lambda可以正确实现接口而提供，如果你在定义接口时，此时接口可以使用Lambda表达式实现建议在接口上方法添加这个注解\n\nPS：这个注解只限制接口中抽象方法的个数，不限制default和static方法的个数\n","tags":["Java"],"categories":["编程语言","Java"]},{"title":"17.面向对象","url":"/post/76fa8c0d.html","content":"\n# <center>知识点一：面向对象的编程思想</center>\n\n面向对象程序设计(Object Oriented Programming) \n\n什么是编程思想？\n\n思想：其实思想就是你大脑中对某些事务的思维，通过思维完成这些事务\n\n编程思想：就是你大脑中对代码中需要完成思维逻辑所提供一种思维，编程思想就是编程思路\n\n在开发中我们接触比较经典编程思想一种面向过程和一种面向对象\n\nPS：面向对象编程思想是从面向过程转变而来，所以面向对象中也会掺杂着面向过程\n\n面向过程的编程思想：\n\n强调的是过程，必须清楚每一个步骤，然后按照步骤一步一步去实现\n\n面向对象的编程思想：\n\n强调的是对象，通过调用对象的行为来实现功能，从而完成需求，面向对象并不是我们自己一步一步去操作实现\n\n举例对比说明：\n\n同样是处理洗衣服事物\n\n&ensp;&ensp;&ensp;&ensp;面向过程角度而言：把衣服脱下来 --》找一个盆--》放点洗衣粉--》加点水--》浸泡10分钟--》揉一揉--》清洗衣服--》拧干--》晾起来\n\n&ensp;&ensp;&ensp;&ensp;面向对象角度而言：把衣服托脱下来 --》找一个对象【女朋友/男朋友】让他去完成【洗】\n\n同样是要吃饭\n\n&ensp;&ensp;&ensp;&ensp;面向过程角度而言：买菜--》洗菜--》炒菜--》吃\n\n&ensp;&ensp;&ensp;&ensp;面向对象角度而言：找一个饭店/点一份外卖 --》 付钱\n\n从Java程序角度来思考：需求：打印数组中存储数据，打印格式为[元素1，元素2，元素3，....]\n\n```java\npublic class printArray \n{\n    public static void main(String[] args) \n    {\n        //1.先提供一个数据\n        int[] arr = {1,1,3,4,5,6,7,2,67};\n        //以面相过程的角度而言，一步一步进行打印操作\n        System.out.print(\"[\");\n        for(int i =0 ; i<arr.length;i++)\n        {\n            if(i != arr.length-1)\n            {\n                System.out.print(arr[i]+\",\");\n            }\n            else\n            {\n                System.out.println(arr[i]+\"]\");\n            }\n        } \n        //以面向对象角度而言，只需要找到可以打印数组数据对象即可\n        System.out.println(Arrays.toString(arr));\n    }\n}\n```\n\n总结：\n\n&ensp;&ensp;&ensp;&ensp;无论是面向过程还是面向对象都是一种编程思想【就是你编写代码的思维逻辑】，区别在于\n\n&ensp;&ensp;&ensp;&ensp;面向过程：注重的是步骤，必须清楚每一个步骤，按照步骤一步一步去实现\n\n&ensp;&ensp;&ensp;&ensp;面向对象：注重的是对象，无需清楚每一个步骤，只需要使用对象调用行为来完成需求即可\n\n&ensp;&ensp;&ensp;&ensp;面向过程在之前学习知识点时候就已经慢慢的在学习使用，面向对象的这个编程思想，如何在代码中体现，如何在代码中写出自己的面向对象思想？---》如**果在代码中要体现面向对象编程思想，需要提供类和对象，通过类对对象进行描述，在通过对象完成思维逻辑**\n\n# <center>知识点二：类和对象的概述</center>\n\n## <center>类的概述</center>\n\n什么是类？\n\n&ensp;&ensp;&ensp;&ensp;类是用来描述一类具有共同属性和行为事物的统称，所以其实类在客观现实世界中是不存在，是\n\n抽象的，只是用来描述信息\n\n例如：\n\n&ensp;&ensp;&ensp;&ensp;人类 ---》 描述人的 狗类 ---》描述狗 手机类---》描述手机 动物类 ---》 描述动物类提供描述使用的，这个描述要是共有属性和行为统称在一起---》称为类\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271923636.jpg\" alt=\"类举例\" style=\"zoom:33%;\" />\n\n上图中所表述意义在于，每一个单独个体具备共有属性和行为，抽取出来，形成一个描述，这个描述就是就类， 上图中描述就是人类\n\n属性和行为？\n\n&ensp;&ensp;&ensp;&ensp;属性： 就是该事物的状态信息 --》人类：身高、体重、年龄、性别等等\n\n&ensp;&ensp;&ensp;&ensp;行为：就是该事物能够做什么 --》 人类：说话、吃、喝、睡觉等等\n\n总结：\n\n&ensp;&ensp;&ensp;&ensp;需要将现实生活中描述类的操作转变为代码在编程中进行体现，，明确类是用来描述一群具有共\n\n同属性和行为事物的统称，类是一个抽象的，看不见，摸不着，用来描述信息的操作\n\n类的组成：\n\n&ensp;&ensp;&ensp;&ensp;属性 ---》 成员变量\n\n&ensp;&ensp;&ensp;&ensp;行为 ---》 成员方法\n\n成员变量是什么？\n\n&ensp;&ensp;&ensp;&ensp;它就是定义在类中用来描述现实生活中属性的，在代码中体现就是定义变量\n\n成员方法是什么？\n\n&ensp;&ensp;&ensp;&ensp;方法其实就是对某些事物的处理途径，将某些处理事物的代码放置到一个大括号中，然后对这个大括号起一个名字，外界只需要使用这个名字就要可以完成对事物的操作\n\n&ensp;&ensp;&ensp;&ensp;方法就是对你实现功能代码进行一个封装操作，外界只需要调用方法名就可以完成处理事物逻辑\n\nPS：在某些语言中将方法称之为函数，但是在Java中我们建议称之为方法，只有面向过程语言才称之为函数，而Java是面向对象语言称之为方法\n\n只要在代码中定义一个类，并在类中提供属性和行为就可以进行现实生活中事物的描述\n\nPS：成员方法就是不使用static进行修饰的方法类具备的操作就是描述操作，并不具备具体处理事物的能力，就需要将类具现化出来，所以提供对象来具现化类\n\n## <center>对象的概述</center>\n\n对象是类的一个实例【具体存在的例子】，具体存在的，看得见的摸得着，并且具备该类事物的属性和行为\n\n对象的属性：对象的属性具有特定值\n\n对象的行为：对象可以操作的行为\n\n人类： 人的描述\n\n&ensp;&ensp;&ensp;&ensp;提供对象进行具体的体现： 班班老师\n\n狗类：狗的描述\n\n&ensp;&ensp;&ensp;&ensp;提供对象进行具体的体现： 柯基狗狗\n\n手机类：描述手机\n\n&ensp;&ensp;&ensp;&ensp;提供对象进行具体的体现：华为手机\n\n举例：\n\n&ensp;&ensp;&ensp;&ensp;对象：你手上手机\n\n&ensp;&ensp;&ensp;&ensp;属性: 华为，19999， 4核CPU ，256G内存 1TB存储空间 支持10G\n\n&ensp;&ensp;&ensp;&ensp;对象属性就是具体的值，因为类描述的时候属性是没有具体数据值\n\n&ensp;&ensp;&ensp;&ensp;行为： 可以打电话，上网，发短信等等。对象可以具体完成哪些操作\n\n总结：\n\n&ensp;&ensp;&ensp;&ensp;对象就是类的实例，具体存在的，看得见摸得着，对象属性具有具体数据值的，对象的行为其实就是可以使用的功能\n\n&ensp;&ensp;&ensp;&ensp;Java中面向对象思想，就是需要你在代码中提供类和对象来完成是现实生活中的思维逻辑，类是对象的操作，对象是类的具现化来完成事物操作过程\n\n## <center>类和对象的关系</center>\n\n类是对一类具有共同属性和行为的事物统称，是抽象的\n\n对象是一类事物的具体是实例，看得见，摸得着，真实存在的实体，是具体的\n\n总结：类是对象的抽象，对象是类的实例化\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271923275.jpg\" alt=\"类和对象的关系\" style=\"zoom:50%;\" />\n\n总结：\n\n对象是根据类创建出来的，类可以看成是对象的【数据类型】，所以类是Java中引用类型\n\nPS：现如今为止：引用类型：数组、类、Scanner\n\n&ensp;&ensp;&ensp;&ensp;他们所创建出来的空间都是在“堆中的”\n\n类中有什么属性和行为，对象就具备哪些属性和行为，因为类对对象描述\n\n&ensp;&ensp;&ensp;&ensp;现在所说的这些都是概念性的东西，在现实生活中，对象是真实存在，如果要处理某些事物，只需要找到对应对象就可以完成这个事物【面向对象思想】，但是编写代码的程序是不具备这些类和对象，所以我们就需要用过上述这些概念，进行描述与操作\n\nPS：从现在开始完后所有开发使用都是面向对象的思想来进行的，而且面向对象是最符合人类思维的一种途径，现在的编码结构也是以面向对象为切入点进行模块式的开发\n\n# <center>知识点三：类、对象</center>\n\n## <center>1、类的定义</center>\n\n类的是描述一群具有共同属性和行为的操作\n\n**类的组成**\n\n&ensp;&ensp;&ensp;&ensp;属性：该类事物的状态信息，在类中以成员变量形式来体现\n\n&ensp;&ensp;&ensp;&ensp;行为：该类事物有什么功能，在类中提供成员方法来体现\n\n现阶段在定义一个类来，描述事物就需要提供属性和行为即成员变量和成员成方法\n\n**类的格式：**\n\n```java\npublic class 类名\n{\n    //提供描述属性 ---》 属性在类中体现就是【成员变量（PS：就是在类中定义一个变量多个权限修饰符）】\n    访问权限修饰符 数据类型 变量名;\n    //提供描述行为 ---》 行为在类中体现就是【成员方法（和之前学习方法定义是一样，只不多去掉了static关键字）】\n    访问权限修饰符 返回值类型 方法名(参数列表)\n    {\n        执行代码【你要操作什么】\n        return ;\n    }\n}\n```\n\n代码演示：需求：定义一个手机类，类名【phone】，类中属性有：品牌（brand）、价格（price）,类中行为有 打电话（call），发短信（sendMessage）\n\n```java\n/* \n    从现在开始编写面向对象编程思想时候需要注意对创建类就存在分类操作\n    在面向对象中类有两个基础分类：\n    一个是叫做 “描述类” 这个类主要提供对对象描述使用类【提供描述中所需要定义操作】 \n    这个类是不提供 main 方法\n    一个是叫做 ”执行类“ 这个类主要数提供面向对象编程实现具体执行操作类，\n    这个类会将描述类进行具现化提供对象\n    来处理业务逻辑，所以这个类会提供 main 方法\n*/\n//这个phone这个类就是一个描述类，所以不提供main方法\npublic class Phone \n{\n\n    /*\n        在类中定义属性即成员变量是支持Java中全套的权限修饰符\n        现阶段可以使用权限修饰符有 public【公有的】 default/package【默认的(不提供任何全新修饰符书写)】\n        PS:因为在写面向对象时，会使用到一个描述操作，此时String类型就比较适合使用\n        简单介绍String：String在Java中是一个类是引用类型的代表Java代码中所有字符串对象\n        只要在代码中 使用 \"\" 提供操作 就是String类的对象\n        如果成员变量使用String类型如何进行赋值操作\n        例如： String brand = \"华为\";\n    */\n    //需求：定义一个手机类，类名【phone】，类中属性有：品牌（brand）、价格（price）\n    public String brand; //这个成员变量就是public权限修饰符\n    int price; //这个成员变量就是默认权限修饰符\n    // 类中行为有 打电话（call），发短信（sendMessage）\n    //这个方法就是成员方法，不使用static修饰\n    public void call()\n    {\n        System.out.println(\"手机可以打电话\");\n    } \n    public String sendMessage(String content)\n    {\n        System.out.println(\"发送的信息是:\"+content);\n        return \"发送信息成功\";\n    }\n}\n```\n\n## <center>2、对象的创建与使用</center>\n\n### 创建对象的语法：\n\n```java\n//语法：\n    类名 对象名 = new 类名(); ---》类其实就是对象的数据类型，类是引用类型【佐证：使用new关键字】\n//例如：\n    Phone huawei = new Phone(); --》相当于创建Phone类的对象huawei，huawei对象数据类型是phoen\n    Dog xiaobia = new Dog(); --》相当于创建Dog类的对象xiaobai，xiaobai对象数据类型是Dog\n    Scanner input = new Scanner(System.in); --》 相当于创建Scanner类的对象\ninput，input对象数据类型是Scanner\n//类中提供对象所描述属性和行为，通过类创建对象之后，对象就可以使用类中所提供属性和行为即可以通过对象访问成员变量和成员方法\n    访问类中成员变量\n        获取成员变量的值 ---》 对象名.成员变量名;\n        对成员变量进行赋值 ---》 对象名.成员变量名 = 值;\n    访问类中成员方法\n        对象名.成员方法的名字(提供参数赋值);\n```\n\n需求：创建Phone类对象，并对类中提供属性和行为进行操作\n\n```java\n//这个类主要就是提供Phone这个描述的操作使用的，所以这个类就是执行类，要添加main方法\npublic class PhoneTest \n{\n    public static void main(String[] args) \n    {\n        //1.创建Phone这个类的对象\n        Phone huwei = new Phone();\n        //对成员变量进行访问\n        System.out.println(\"手机的品牌：\"+huwei.brand);\n        System.out.println(\"手机的价格：\"+huwei.price);\n        /*\n            之前在学习中已经接触了局部变量，即定义在方法体内部变量就是局部变量\n            但是在方法体内部定义局部变量，必须进行初始化之后才可以进行使用，作用域仅限在方法体内部\n            成员变量是定义在类中的，声明在类中成员变量是存在默认值的即只提供定义操作没有提供赋值操作\n            那么这个变量也可以使用并且有默认值存在\n            成员变量的默认值会根据数据类型来决定\n            整数类型【byte、short、int、long】 --》默认值:0\n            小数类型【float 和 double】 ---》 默认值: 0.0\n            字符类型【char】 ---》 默认值 一个不可见空字符\n            布尔类型【boolean】 ---》 默认值 false\n            引用类型【自定义类、数组、Scanner、String....】 ---》 默认值 null\n        */\n        //对成员变量进行赋值操作\n        huwei.brand = \"华为\";\n        huwei.price = 19999;\n        System.out.println(\"手机的品牌：\"+huwei.brand+\"手机的价格：\"+ huwei.price);\n        //使用对象对成员方法进行访问操作\n        huwei.call();\n        String content = huwei.sendMessage(\"你好欢迎使用\");\n        System.out.println(content);\n    }\n}\n```\n\n## <center>3、单个对象在内存中存储</center>\n\n![单个对象在内存中存储](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271924171.jpg)\n\n总结：只要是创建对象【使用new关键字】，就会在堆中开辟一段空间\n\n&ensp;&ensp;&ensp;&ensp;只要调用方法，就会在栈中开辟一段空间，用来执行该方法\n\n&ensp;&ensp;&ensp;&ensp;栈中空间是系统回收操作，堆中空间是Java提供GC【垃圾回收机制】进行回收操作\n\n```java\npublic class Student \n{\n    String name;//姓名\n    int age;//年龄\n    //行为 ---》 学习\n    public void study()\n    {\n        System.out.println(\"正在努力的学习Java......\");\n    }\n}\n```\n\n```java\npublic class StudentTest \n{\n    public static void main(String[] args) \n    {\n        //1. 创建Student类的对象\n        Student xiaoming = new Student();\n        //2. 利用学生对象打印成员变量的值\n        System.out.println(\"姓名：\"+xiaoming.name);\n        System.out.println(\"年龄：\"+xiaoming.age);\n        //3. 利用学生对象对成员变量进行赋值操作\n        xiaoming.name = \"小明\";\n        xiaoming.age = 18;\n        System.out.println(\"姓名：\"+xiaoming.name);\n        System.out.println(\"年龄：\"+xiaoming.age);\n        //打印学生对象\n        /*\n            打印学生对象方式 ---> Student@1b6d3586 --> 理解为学生对象地址【在堆中地址】\n            Student ---> 证明xiaoming这个对象时属于Student类的\n            @ ---> 没有任何意义就是一个连接符号\n            1b6d3586 ---> 学生对象记录的堆中开辟空间地址\n        */\n        System.out.println(\"学生对象：\"+xiaoming);\n    }\n}\n```\n\n## <center>4、多个对象在内存中存储</center>\n\n![多个对象在内存中存储](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271924816.jpg)\n\n总结: 一个类是可以创建多个对象的，多个对象在堆中存储，都有不同内存划分【就是多个对象都使用new关键字创建】，**成员变量是存储在各自的内存区域中，成员方法是多个对象共一份【类文件只有一个】**\n\n&ensp;&ensp;&ensp;&ensp;凡是使用new关键字创建的对象都会在堆中开辟一段新的存储空间\n\n&ensp;&ensp;&ensp;&ensp;对象和对象之的关系是相互独立的【只要是使用new关键字创建出来】\n\n```java\npublic class StudentTest2 \n{\n    public static void main(String[] args) \n    {\n        //1. 创建Student类的对象\n        Student xiaoming = new Student();\n        //2. 利用学生对象打印成员变量的值\n        System.out.println(\"姓名：\"+xiaoming.name);\n        System.out.println(\"年龄：\"+xiaoming.age);\n        //3. 利用学生对象对成员变量进行赋值操作\n        xiaoming.name = \"小明\";\n        xiaoming.age = 18;\n        System.out.println(\"姓名：\"+xiaoming.name);\n        System.out.println(\"年龄：\"+xiaoming.age);\n        //打印学生对象\n        /*\n            打印学生对象方式 ---> Student@1b6d3586 --> 理解为学生对象地址【在堆中地址】\n            Student ---> 证明xiaoming这个对象时属于Student类的\n            @ ---> 没有任何意义就是一个连接符号\n            1b6d3586 ---> 学生对象记录的堆中开辟空间地址\n        */\n        System.out.println(\"学生对象：\"+xiaoming);\n        xiaoming.study();\n        //在利用Student类创建一个xiaohong对象，并访问成员变量\n        Student xiaohong = new Student();\n        System.out.println(\"姓名：\"+xiaohong.name);\n        System.out.println(\"年龄：\"+xiaohong.age);\n    }\n}\n```\n\n## <center>5、多个对象指向同一个对象在内存那种存储</center>\n\n![多个对象指向同一个对象在内存存储](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271924888.jpg)\n\n总结： 当多个对象的引用指向同一个内存空间时【对象所记录地址都是一样的】，只要有任何一个对象修改了内存中数据，随之无论使用哪一个对象进行数据获取，都是修改之后的数据\n\n当创建多个对象时，如果你需要某个对象与另外一个对象的空间是一致，只需要将其中创建好的对象存储空间地址赋值给另外一个对象即可，此时引用就是同一个空间\n\n当创建多个对象时，需要对象彼此之间互相独立不干扰，只需使用new关键字分别创建即可， 就可以在堆中开辟不同存储空间了\n\n```java\npublic class StudentTest3 \n{\n    public static void main(String[] args) \n    {\n        //1. 创建Student类的对象\n        Student xiaoming = new Student();\n        //2. 利用学生对象打印成员变量的值\n        System.out.println(\"姓名：\"+xiaoming.name);\n        System.out.println(\"年龄：\"+xiaoming.age);\n        //3. 利用学生对象对成员变量进行赋值操作\n        xiaoming.name = \"小明\";\n        xiaoming.age = 18;\n        System.out.println(\"姓名：\"+xiaoming.name);\n        System.out.println(\"年龄：\"+xiaoming.age);\n        //打印学生对象\n        /*\n            打印学生对象方式 ---> Student@1b6d3586 --> 理解为学生对象地址【在堆中地址】\n            Student ---> 证明xiaoming这个对象时属于Student类的\n            @ ---> 没有任何意义就是一个连接符号\n            1b6d3586 ---> 学生对象记录的堆中开辟空间地址\n        */\n        System.out.println(\"学生对象：\"+xiaoming);\n        xiaoming.study();\n        //不在使用Student类创建对象，而是使用创建xiaoming对象对另外一个xiaohong对象进行赋值\n        Student xiaohong = xiaoming;\n        System.out.println(\"姓名：\"+xiaohong.name);\n        System.out.println(\"年龄：\"+xiaohong.age);\n    }\n}\n```\n\n# <center>知识点四：成员变量和局部变量</center>\n\n成员变量（实例变量）：定义在类的里面，方法的外面的变量称之为成员变量\n\n局部变量：定义在方法内部的变量称为局部变量\n\n成员变量和局部变量的区别：\n\n&ensp;&ensp;&ensp;&ensp;1、位置不同\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;成员变量：在类中、方法外\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;局部变量：在方法内部\n\n&ensp;&ensp;&ensp;&ensp;2、初始值不同（变量必须要初始化才能使用）\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;成员变量：系统会赋值默认值（与之前讲的数组一致）\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;局部变量：没有默认值\n\n&ensp;&ensp;&ensp;&ensp;3、作用域不同\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;成员变量：在类中都可以使用\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;局部变量：只能在作用域中使用（在它所在的{ }中）\n\n&ensp;&ensp;&ensp;&ensp;4、重名问题\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;成员变量不能重名，局部变量在不同作用域中是可以重名的\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;如果当局部变量和成员变量重名的时候，Java中遵循就近原则\n\n&ensp;&ensp;&ensp;&ensp;5、生命周期不同\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;成员变量：变量会随着对象的销毁而销毁。对象什么时候销毁呢（Java中GC垃圾回收机制）\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;语句变量：当变量出了作用域就会被销毁\n\n# <center>知识点六：构造方法</center>\n\n## <center>1、定义</center>\n\n&ensp;&ensp;&ensp;&ensp;构造方法是一个特殊的方法，主要是完成对象的创建和对象数据的初始化方法\n\n&ensp;&ensp;&ensp;&ensp;构造方法的提供主要是为了可以保证对象可以正确创建，以及对成员变量的从初始化的操作，在不使用构造方法之前，对类中所提供成员变量进行赋值的，只能通过对象，一个一个的进行赋值，如果类中成员变量过多，这个操作是很繁琐，因为对象创建过程中，是需要进行内存开辟空间，构造方法可以保证类所创建对象可以正确创建出来\n\nPS：在实际开发中构造方法主要有两类，一类被称之为“**无参构造方法**”和一类被称之为“**有参构造方法**”\n\n## <center>2、语法</center>\n\n```java\npublic class 类名\n{\n    访问权限修饰符 数据类型 变量名; //属性\n    访问权限修饰符 返回值类型 方法名(参数列表)\n    {\n        //行为\n        方法体 ;\n        return ;\n    } \n    访问权限修饰符 类名()    //无参构造方法\n    { \n    } \n    访问权限修饰符 类名(参数列表)    //有参构造方法\n    {        \n        提供类中属性【成员变量】的初始化操作\n    } \n    /* \n        构造方法的说明：\n        1.构造方法只能在类中定义，无法在其他位置提供定义\n        2.构造方法使用权限修饰符【常用public】，除此之外在某些特殊情况下可以将构造方法使用private【私有的】进行修饰\n        3.构造方法的方法名与类名必须是相同的\n        4.构造反方没有返回值类型，甚至都不需要使用void进行表示，更不可能在构造方法中使用return关键字\n    */\n    //无参构造方法的调用\n    类名 对象名 = new 类名();\n    //有参构造方法的调用\n    类名 对象名 = new 类名(实参1,实参2,.....);\n}\n```\n\n例：需求：提供一个Person类，属性【姓名，年龄，性别】，行为【吃】，在提供类中构造方法定义\n\n```java\npublic class Person \n{\n    //属性描述\n    String name; //姓名\n    int age; //年龄\n    String gender; //性别\n    //行为的描述\n    public void eat()\n    {\n        /*\n            在同一个类中，成员方法是可以直接访问本类中提供成员变量和其他成员方法\n        */\n        System.out.println(name+\"正在吃饭...\");\n    }\n     //提供Person类的无参构造方法\n    public Person()    // 无参构造方法【方法的参数列表不做任何参数定义】\n    {\n        /*\n            PS：在实际开发中，无参构造方法主要是定义的作用，基本上在构造方法体中很少进行初始操作\n            如果在无参构造方法进行属性的初始化，所有调用无参构造方法创建对象都会都会具备这个属性值\n        */\n        //给属性进行初始化操作 --》 手动进行赋值\n        name = \"xiaoming\";\n    }\n    //提供Person类的有参构造方法\n    /*\n        Person的有参构造方法一定会提供参数列表？ 这个参数列表如何定义？\n        给那些类中属性进行赋值【初始化】，参数列表就定义那些数据\n        定义参数需要和类中属性数据类型是一直，这样方便进行赋值操作\n    */\n    public Person(String n,int a, String g)\n    {\n        //这个操作就是使用参数对类中属性进行初始化赋值操作\n        name = n;\n        age = a;\n        gender = g;\n    }\n}\n```\n\nPersonTest\n\n```java\npublic class PersonTest \n{\n    public static void main(String[] args) \n    {\n        //使用Person类中无参构造方法【分别构建两个对象】\n        Person person1 = new Person();\n        Person person2 = new Person();\n        //调用Person类中提供name属性\n        System.out.println(\"person1对象中的name属性值：\" + person1.name);    //都是午餐构造里面的值\n        System.out.println(\"person2对象中的name属性值：\" + person2.name);\n        //使用Person类中有参构造方法在创建对象的同时对属性进行初始化\n        Person person3 = new Person(\"小红\",18,\"女\");//小括号中提供具体数据，调用就是有参构造方法\n        //打印person3对象中属性值\n        System.out.println(person3.name + \" \" + person3.age + \" \" + person3.gender);\n    }\n}\n```\n\n## <center>3、注意的事项</center>\n\n1）如果在类中并没有明确提供构造方法的定义，此时**系统将提供一个默认无参构造方法，让创建对象时使用**\n\n```java\npublic class Man \n{\n    //Man这个类中并没有明确提供构造方法\n    String name;\n} \nclass Test\n{\n    public static void main(String[] args) \n    {\n        //但是系统会为Man提供一个默认的无参构造方法\n        Man man = new Man();\n    }\n}\n```\n\n2）如果在类中**明确提供了构造方法【无论是有参还无参】此时系统提供的默认构造方法将消失，不在提供对外操作**\n\n```java\npublic class Man2 \n{\n    String name;\n    //明确提供一个有参构造方法【系统无参构造方法将无法在次调用，如果需要使用无参构造方法必须手动提供】\n    public Man2(String n)\n    {\n        name = n;\n    }\n} \nclass Test2\n{\n    public static void main(String[] args) \n    {\n        //调用Man2这个类中无参构造方法进行对象创建\n        //IDEA提供错误提示\"Man2(java.lang.String)' in 'Man2' cannot be applied to'()'\"\n        //Man2 man2 = new Man2();\n    }\n}\n```\n\n3）一个类中是可以提供多个构造方法，但是在同一个类中有一个要求，定义方法签名【方法名+参数列表】不能重复，那么为什么还可以提供一个无参构造方法和一个有参构造方法呢？\n\n### 重载\n\n**这里我们利用到一个方法的概念【特点】 ---》 这个特点叫做方法的“重载【overload】”**\n\n在同一个类中，定义方法签名是不允许重复，但是利用重载这个概念完成方法名相同操作【无参构造方法与有参构造方法的名字是相同，但是没有报错】，虽然名字相同，但是参数列表是不同就会触发重载操作\n\n重载的要求，只要满足以下**三者之一**就可以成为重载\n\n&ensp;&ensp;&ensp;&ensp;**1.方法名相同但是参数列表不同，定义的顺序不同，就可以称之为重载**\n\n**&ensp;&ensp;&ensp;&ensp;2.方法名相同但是参数列表不同，定义的数据类型不同，就可以称之为重载**\n\n**&ensp;&ensp;&ensp;&ensp;3.方法名相同但是参数列表不同，定义的个数不同，就可以称之为重载**\n\n所以，当前类中所提供的**无参构造方法与有参构造方法就是方法的重载，可以利用这个特性提供多个方法**\n\n4）构造方法必须与类同名，必须没有返回值类型，并且void也不可以，不可以使用return关键字\n\n```java\npublic class Man3 \n{\n    /*\n        为了保证类与类之间继承关系，为了保证JavaBean合理定义\n        一般会在一个描述类中提供一个有参和无参的构造方法\n        有参构造方法，一般是针对类中所有属性记性初始化操作\n    */\n    String name;\n    int age;\n    //类中基本提供方式\n    public Man3()\n    { //无参构造方法\n    } \n    public Man3(String n,int a)\n    {\n        //有参构造方法\n        name = n;\n        age = a;\n    } \n    //还可以利用重载的特点，进行多个构造方法的提供【因人而异，因项目要求而异】\n    public Man3(String n)\n    {\n        name = n;\n    } \n    public Man3(int a)\n    {\n        age = a;\n    }\n}\n```\n\n**PS：重载这个概念也适用于其他方法**\n\n# <center>知识点七：对象的内存分配</center>\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271925009.jpg\" alt=\"对象内存分配\" style=\"zoom: 50%;\" />\n\n# <center>知识点九：三大特征</center>\n\n面向对象这个编程思想是贴近与现实生活逻辑一种编程思想，在这个编程思想中利用三个特征完成面向对象的编程逻辑，面向对象中的三大特征：“**封装、继承和多态**”\n\n这三者体现了什么？\n\n封装性:封装就是一个事物包裹起来，使外界不了解它内部的情况，在面向对象中，封装就把相关的数据和代码结合成一个有机的整体，形成数据和代码操作的封装体，提供一个对外部暴露的接口，可以方便外界使用这个封装\n\n继承性：从已有类中创建新类的过程，提供继承信息的被称之为父类，得到继承信息称之为子类，父子之间存在一个关系就是【继承】，继承可以使Java中类与类之间形成一个层次机构，利用这个继承简便的进行代码的开发。\n\n多态性： 多态是允许程序中出现多种状态的对象。同一个事物被不同对象所触发，得到结果不同就称之为多态【主要体现就是对象的转型操作】\n\n以上的三个特征会在编程中所有体现，从而完善面向对象编程\n\n## <center>1、封装</center>\n\n需求：创建一个Cat类，对Cat类提供属性【姓名和年龄】，然后再执行类中创建Cat类对象对属性进行操作及打印\n\n```java\npublic class Cat \n{\n    String name;\n    int age;\n    public Cat(){\n    } \n    public Cat(String n, int a)\n    {\n        name = n;\n        age = a;\n    }\n} \n\npublic class CatTest \n{\n    public static void main(String[] args) \n    {\n        Cat cat = new Cat();\n        cat.age = 1;\n        cat.name = \"小花\";\n        System.out.println(\"猫的名字：\"+cat.name);\n        System.out.println(\"猫的年龄：\"+cat.age);\n        //但是 --> 对age属性进行赋值操作\n        /*\n            首先下面这个语法在开发中是没有问题，是可以对age属性进行负数赋值操作\n            age属性是int数据类型 ，int数据类型可以存储数据范围【-21亿~21亿】之间\n            赋值这个-1 很明显是满足这个存储范围操作的【语法是没有问题】\n            在客观现实生活中，猫的年龄是绝对不可能出现 负数的\n            如果在实际开发中，让外界可以直接对成员变量进行访问操作，是会存在安全隐患的\n        */\n        cat.age = -1;\n        System.out.println(\"猫的年龄：\"+cat.age);\n    }\n}\n```\n\n在开发中如果我们直接访问成员变量，可能会出现安全隐患，在代码中age属性赋值操作就已经出\n\n现问题，应该如何解决？\n\n解决方式: 提供变量不对外直接访问的途径【即对属性进行封装操作】\n\n&ensp;&ensp;&ensp;&ensp;在学习类的时候在定义属性【成员变量】时，可以对属性进行权限修饰符的使用，现在接触的权限修饰符主要所有【**public（公有） 和 default/package（默认/包权限）**】，使用他们修饰之后外界还是可以进行访问的，所以想让属性不在提供对方直接访问【使用封装概念来完成操作】 --》可**以使用一个权限修饰符【private（私有）】，这权限修饰符是所有权限修饰符中在最低权限，利用private对成员变量的修饰以达到封装的目的**\n\n解决方法：修改Cat类代码对属性提供private修饰\n\n```java\npublic class Cat \n{\n    String name;\n    private int age; //属性的私有化就是封装的体现\n    public Cat()\n    {\n    } \n    public Cat(String n, int a)\n    {\n        name = n;\n        age = a;\n    }\n}\n```\n\n&ensp;&ensp;&ensp;&ensp;面向对象的封装其实就是一个编程的要求，将信息隐藏起来，把不需要外界知道的信息隐藏，尽可能隐藏对象功能实现细节，向外直接提供他可以访问方法，保证外界无法破坏原有内部信息，这就是封装特性\n\n&ensp;&ensp;&ensp;&ensp;在写面向对象思想时，封装效果体现其实已经在，在写类的时候就已经是封装的效果，类就是将属性和方法封装在一个类中，除了这种体现方式之外，可以对属性进行私有化操作即使用private进行修饰，主要的目的是为了保证成员变量安全，所以**private私有化成员变量只是封装特定一个体现而已**\n\n&ensp;&ensp;&ensp;&ensp;封装确实可以保证age属性的安全性，外界无法直接破坏内部存储信息的途径，但是正常使用age属性时，也无法完成，所以封装中还有有一句话很重要“**向外直接提供他可以访问方法**”\n\n### Getter和Setter方法\n\n&ensp;&ensp;&ensp;&ensp;当对属性提供private权限修饰符时，确实让属性更加安全体现封装的一个特点，但是并不是完全封装特性展示，“**封装细节之后还是要提供一种访问方式**”\n\n如果属性使用private进行修饰之后，就要对属性配套提供对应Getter和Setter方法\n\n&ensp;&ensp;&ensp;&ensp;因为属性已经被private修饰了，提供Getter和Setter方法的目的是为了提供操作属性途径，所以这两方法必然使用public修饰\n\n```java\n/*\nGetter方法定义方式\n    public 返回值类型 getXXX()\n    {\n        return 属性名;\n    } \n解释说明：\n    1. Getter方法主要的作用就是提供获取属性方法\n    2. 这个方法必须有【返回值类型】，这个【返回值类型】如何定义？ --》 你提供get方法获取的\n    是哪个属性值，这个方法的【返回值类型】就与属性的【属性类型】一致即可\n    3. 方法名是固定的叫做【getXXX】---》get是固定代表是Getter方法获取属性值用---》\n        XXX是你通过get获取哪个属性，这个XXX就是属性字\n    外界使用get方法时，可以通过方法名得知使用是哪个属性\n    4. 这个方法的参数列表定义是空的，没有任何参数定义\n    5. 这个方法必须添加return关键字\n        5.1 这个get方法是获取属性值，如果不return数据如何得到值\n        5.2 这个方法定义返回值类型，所以方法必须添加return关键字对应操作\n            return关键字后面跟值是什么？你获取的是哪个属性值， return就哪个属性\n*/\n```\n\n```java\n/*\nSetter方法定义方式\n    public void setXXX(参数列表)\n    {\n        使用定义参数对属性进行赋值\n    } \n解\n释说明：\n    1. Setter方法的主要作用就是对进行赋值操作\n    2. 因为Set方法是对属性赋值，所以这个方法不需要返回值类型，所以方法使用void定义\n    3. setXXX这个名字是固定的，set主要说明这个方法是Setter方法对属性赋值使用，XXX是针对堆\n    那个属性赋值，XXX就是那个属性名字，这样一来外界调用这个方法时就可以得知对那个属性的操作\n    4. 这里一定需要定义【参数列表】，因为set方法主要作用是赋值，所以需要通过方法参数对属性进\n        行赋值操作，你对那个属性记性赋值 那么这个参数列表定义就与属性定义相同即可\n    5. set方法体提供的是对属性的赋值操作【利用参数对属性赋值】\n    6. 一定没有return关键字\n*/\n```\n\n修改Cat类提供Getter和Setter方法\n\n```java\npublic class Cat \n{\n    String name;\n    private int age; //属性的私有化就是封装的体现\n    public Cat(){\n    } \n    public Cat(String n, int a)\n    {\n        name = n;\n        age = a;\n    } \n    //提供private修饰属性的Getter和Setter方法\n    public int getAge()\n    { //获取属性值\n        return age;\n    } \n    public void setAge(int a)\n    { // 属性进行赋值操作\n    //非法拦截\n        if(a < 0)\n        {\n            System.out.println(\"您提供年龄不合法，无法赋值！\");\n        }\n        else \n        {\n            age = a;\n        }\n    }\n}\n```\n\n```java\npublic class CatTest \n{\n    public static void main(String[] args) \n    {\n        Cat cat = new Cat();\n        cat.setAge(1);\n        cat.name = \"小花\";\n        System.out.println(\"猫的名字：\"+cat.name);\n        System.out.println(\"猫的年龄：\"+cat.getAge());\n        \n        cat.setAge(-1);\n        System.out.println(\"猫的年龄：\"+cat.getAge());\n    }\n}\n```\n\n### this关键字\n\n&ensp;&ensp;&ensp;&ensp;需求：定义一个User类提供属性name和age并且私有化，提供有参无参构造方法，提供Getter和Setter方法，并且要求，在定义有参和Set方法是，定参数列表名需要和属性名一致，创建一个User对象，分别使用有参、无参构造方法完成，在调用set修改任何属性值，并提供get方法打印出来？\n\n```java\npublic class User \n{\n    private String name;\n    private int age;\n    public User()\n    {\n    } \n    public User(String name ,int age)\n    {\n        name = name;\n        age = age;\n    } \n    public String getName() \n    {\n        return name;\n    } \n    public void setName(String name) \n    {\n        name = name;\n    } \n    public int getAge() \n    {\n        return age;\n    } \n    public void setAge(int age) \n    {\n        age = age;\n    }\n} \npublic class UserTest \n{\n    public static void main(String[] args) \n    {\n        //1.使用无参构造方法 ---》 创建User对象\n        User user = new User();\n        //通过user对象调用setName方法进行name属性赋值操作\n        user.setName(\"小明\");\n        System.out.println(\"user的姓名：\"+user.getName());\n        //2.使用有参构造方法 ---》创建User对象\n        User user2 = new User(\"小红\",20);\n        System.out.println(\"user2的姓名：\"+user2.getName());\n        System.out.println(\"user2的年龄：\"+user2.getAge());\n    }\n}\n```\n\n执行完代码之后，打印属性值发现\n\n&ensp;&ensp;&ensp;&ensp;user的姓名：null\n\n&ensp;&ensp;&ensp;&ensp;user2的姓名：null\n\n&ensp;&ensp;&ensp;&ensp;user2的年龄：0\n\n打印出来属性值都是默认值，这是为什么呢？\n\n&ensp;&ensp;&ensp;&ensp;在说这个问题之前，介绍一个【关键字this】，这个关键字可以在当前类中使用，主要使用在【构造方法和成员方法】中，this关键字在类中代表什么？【代表的是当前对象--》谁触发，谁就是this】\n\n#### 1）调用本类属性\n\n在本类中调用本类的属性，this关键字可以省略，但是如果局部变量和成员变量同名时，若时 this.属性名  则是调用成员变量，若直接  属性名，则是调用局部变量（就近原则）\n\n#### 2）调用本类方法\n\n在调用本类的方法的时候，this关键字完全可以省略不写\n\n#### 3）调用本类的构造方法\n\n在构造方法里调用另外一个构造方法\n\n注意点：\n\n&ensp;&ensp;&ensp;&ensp;a）在构造方法中用 this 再调用本类的其它构造方法的时候，这一行代码必须出现在构造方法的第一行\n\n&ensp;&ensp;&ensp;&ensp;b）避免在构造方法中调用自身这个构造，这会出现无穷递归。\n\n```\n/*\nthis关键字的作用:\n    1. 可以通过this关键字访问当前类中成员变量进行操作 ---》 this.成员变量\n    2. 可以通过this关键字访问当前类中成员方法进行操作 ---》 this.成员方法（参数赋值）;\n    3. 可以通过this关键字在当前类中构造方法中访问其他的本类构造方法\n        ----》 this();【访问本类的无参构造方法】 ----》this(参数赋值);【访问本类的有参构造方法】\n        ----》 特别说明: 这个调用构造方法的方式只能在构造方法中使用，并且必须在构造方法体中第一句\n                不允许构造通过this关键字调用自身构造方法\n    4. 可以通过this关键字作为方法参数传递【代表当前对象】\n*/\nps：上述的作用中只有一个对于我们开发是有用的，其余的都是已经很少使用甚至不用\n    ---》使用this关键字访问成员变量 ，在构造方法中和setter方法中区分成员变量和参数名字\n```\n\n使用this关键字修改User类\n\n```java\npublic class User \n{\n    private String name;\n    private int age;\n    public User()\n    {\n        //name = \"1\";\n        //在这个构造方法中使用this关键字调用本类的其他构造方法【很少使用】\n        //this(); //不允许使用this关键字调用自身构造方法\n        //必须在构造方法中第一行，不允许在它之前出现任何其他代码\n        this(\"小白\",18); //不允许构造互相调用【不允许在无参中调用有参，在有参中调用无参】\n    } \n    public User(String name ,int age)\n    {\n        /*原因就是出现在这个赋值操作过程中，Java中如何认定一个变量属于谁？\n        使用是就近原则，name离谁最近name就是谁，name这个变量和参数列表中name是最近的\n        所以这个赋值操作其实 就是在用参数name 对参数name进行赋值，根本就没有属性name进行赋值操作\n        虽然这个name 与属性name是同名，但是根本就没有操作到，IDEA没有办法区分属性名与参数名相同时\n        那个是属性，那个是参数 ---》出现了二义性\n        */\n        //使用this关键字调用成员变量的方式区分 成员变量名字和参数的名字\n        this.name = name;\n        this.age = age;\n    } \n    public String getName() \n    {\n        return name;\n    } \n    public void setName(String name) \n    {\n        this.name = name;\n    } \n    public int getAge() \n    {\n        return age;\n    } \n    public void setAge(int age) \n    {\n        this.age = age;\n    } \n    //提供两个成员方法\n    public void show()\n    {\n        System.out.println(\"show成员方法\");\n    } \n    public void showInfos()\n    {\n    //使用this关键字访问本类中成员变量和成员方法\n    System.out.println(\"本类name属性：\"+this.name);\n    this.show();\n    //但是，实际开发中可以省略this不写 ，上下代码操作是完全一样\n    //下面的操作属于上面操作的简化，实际在底层依旧是在执行 this.name 和 this.show()\n    System.out.println(\"本类name属性：\"+name);\n    show();\n    }\n}\n```\n\n总结：this关键字使用方式是有很多的的，但是使用应用主要还是会使用【this.成员变量】方法进行与相同参数名的区分操作，其余的功能进本上很少在使用\n\n### 标准类的制作\n\n&ensp;&ensp;&ensp;&ensp;Java中我们要定义一个类是有一个标准，这个标准叫做JavaBean，JavaBean是Java语言编写类第一种规范，符合JavaBean的类，要求**类必须是公有的**，**属性需要使用private修饰**，并且**提供有参和无参构造方法**，还要提供**成员变量的set和get方法** ---》 这样类就称之为JavaBean标准类\n\n```java\npublic class Product\n{\n     private int id;\n     private String name;\n     private double price;\n    //进入后：选Constructor  + 选全部 + ok = 生成全参构造方法\n    public Product(int id, String name, double price)\n    {\n        this.id = id;\n        this.name = name;\n        this.price = price;\n    }\n    //进入后：选Constructor + 不用选 + Select None = 生成无参构造\n    public Product()\n    {\n    }\n    //进入后：选Getter and Setter + 选全部 + ok = 生成公共访问\n    public int getId()\n    {\n        return id;\n    }\n\n    public void setId(int id)\n    {\n        this.id = id;\n    }\n\n    public String getName()\n    {\n        return name;\n    }\n\n    public void setName(String name)\n    {\n        this.name = name;\n    }\n\n    public double getPrice()\n    {\n        return price;\n    }\n\n    public void setPrice(double price)\n    {\n        this.price = price;\n    }\n    \n    public 返回值类型 方法名(参数列表)\n    {\n        方法体;\n        return ;\n    }\n}\n```\n\n总结：在通过题意针对某些类进行定义时，尽量使用JavaBean标准类定义的要求【私有属性、有参无参构造方法、Getter和Setter方法】进行类的定义，剩余的可以根据实际需求动态在类中记性增删添加即可\n\n## <center>2、继承</center>\n\n### 1）含义\n\n&ensp;&ensp;&ensp;&ensp;继承是面向对象三大特征之一，也是面向对象编程中不可缺少的一个操作，继承是一个比较好理解的概念和现实生活中继承是相同\n\n&ensp;&ensp;&ensp;&ensp;在Java中继承概念: 在Java中指的是“一个类”可以“继承自”另外一个类，“被继承的类”叫做“父类/基类/超类”，“继承其他类的类”叫做 “子类/派生类”，继承之后“子类”中就拥有“父类”中所有【可见】的成员【成员变量和成员方法】，子类就不需要在重复定义了，不仅如此子类还可以提供自身独有的【成员变量和成员方法】提供继承概念可以最大限度提高代码之间复用性【减少代码冗余、相同代码重复利用】，并且可以让类与类之间产生关联\n\n案例:西游记中角色定义:\n\n&ensp;&ensp;&ensp;&ensp;唐僧: 姓名/性别/年龄/ 念经\n\n&ensp;&ensp;&ensp;&ensp;悟空: 姓名/性别/年龄/ 七十二变, 打妖怪\n\n&ensp;&ensp;&ensp;&ensp;八戒: 姓名/性别/年龄/ 三十六变, 调戏嫦娥\n\n&ensp;&ensp;&ensp;&ensp;沙僧: 姓名/性别/年龄/ 挑担, 求救\n\n&ensp;&ensp;&ensp;&ensp;白龙马:姓名/性别/年龄/ 走\n\n提供创建类的分析：\n\n1. 设计唐生类，属性有3个【姓名/性别/年龄】，定义成成员变量，行为念经定成方法\n2. 设计悟空类，属性有3个【 姓名/性别/年龄】，定义成成员变量，行为七十二变, 打妖怪\n3. 设计八戒类，属性有3个【 姓名/性别/年龄】，定义成成员变量 ，行为 三十六变, 调戏嫦娥\n4. 设计沙僧类，属性有3个【姓名/性别/年龄】，定义成成员变量 ，行为 挑担, 求救\n5. 设计白龙马类，属性有3个【姓名/性别/年龄】，定义成成员变量 ，行为走\n\n当前5个类中有相同的属性都是需要定义三个属性分贝为【姓名/性别/年龄】，只是当前每个类中行为不同而已\n\n![继承解析](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271925657.jpg)\n\n### 2）语法\n\n在Java中需要完成继承操作，需要使用到一个关键字【extends】 表示继承\n\nPS： extends关键字的本身含义是“扩展的意思”，但是为了复合国人学习编程习惯，所以翻译成继承\n\n```java\n//提供继承信息的是父类 --》如何定义【你平时如何定义类就如何定义父类】\npublic class 父类名字{\n    成员变量;\n    构造方法;\n    Getter和Setter方法;\n    成员方法 ;\n} \n//得到继承信息的是子类 --》 如何定义\npublic class 子类名字 extends 父类名字{ \n    //类与类之间继承\n    子类可以得到父类所有的可见属性和方法【不是用private修饰】\n    从父类继承而来就无需重复定义，直接使用即可\n    除此之外，子类还可以提供子类自身定义的\n    成员变量;\n    构造方法;\n    Getter和Setter方法;\n    成员方法 ;\n} \n    在开发中父类就是一个模板类，给所有子类提供一些基础信息【属性和行为】，所以父类基本上是不\n    会直接创建对象，子类是继承父类而来，所以子类会比父类更加强大，不仅可以得到父类提供【属性和\n    行为】，而且子类自身也可以继续定义【属性和行为】，在开发中多是以子类作为创建对象依据来进行操作\n    //在Java中所有类与类之间关系都是【单一继承】，一个子类只能有一个直接父类\n    例如：这种定义在Java中不被允许的\n    public class A{} //父类\n    public class B{} //父类\n    public class C extends A,B 或者 public class C extends A B\n    或者 public class C extends A extends B ---》 都是错误语法\n    //Java中一个类是不允许直接继承多个父类的即多继承\n    //虽然Java中类不存在多继承的这种效果，但是Java中类允【间接继承（多重或多层继承）】\n    例如：\n    public class A{}\n    public class B extends A{}\n    public class C extends B{}\n    语法说明： A类是父类，对于B类而言A是B类父类，B是A的子类\n    对于C类而言B是C类父类，C是B的子类\n    因为B类是继承与A类，而C类是继承与B类，所有A类是C的间接父类，C也是A类间接子类\n    通俗的看待：A类就是爷爷 B类就父亲 C类就是孙子\n    其实你在Java中所有开发了类基本上都是继承关系类，也会存在间接继承的问题，Java中提供了一\n    个超级（根）类【Object】，Java所有的类都是直接或间接的继承于Object\n    每当在项目中创建一个类的时候，此时Java都是隐式的继承与Object这个类\n    例如：\n    public class A{} //定义了一个A类，虽然表面上看着就是一个A类，但是实际上它是等价于\n    public class A extends Object{}\n    Java中是没有多继承，那么如果编写代码时明确继承与某一个类，那么 extends Object 会发生什么 \n    public class B \n    {}\n    public class A extends B{} //明确继承之后，原有继承Object类操作就会被覆盖，提供给父\n    类继承，形成间接继承效果，只要提供一个类都是要继承与Object类的，就选明确继承了某个类，但\n    是父类也是要继承与Object类，所以类都是直接或间接继承与Object\n```\n\nPS:先写父类还是先写子类\n\n&ensp;&ensp;&ensp;&ensp;一般的，在开发时都会对你开发程序予以设计，这个设计中就会确定父类与子类，只需要通过这设计方案提供父类与子类实现就可以完成操作\n\n&ensp;&ensp;&ensp;&ensp;在开发中发现某些类之间存在一些联系和一些固定属性和行为，可以二次封装出父类个人开发建议：尽量根据需求分析出是否存在父类，如果存在就提供实现，如果不存在就正常开发就可以\n\n#### 好处和特点\n\n好处：实现代码的复用，避免代码的冗余\n\n特点：\n\n&ensp;&ensp;&ensp;&ensp;a）子类继承父类，子类可以继承父类中的属性和方法\n\n&ensp;&ensp;&ensp;&ensp;b）子类可以拥有自己独有的属性和方法\n\n&ensp;&ensp;&ensp;&ensp;c）单继承，即在java中一个子类只能继承一个父类，但一个父类可以拥有多个子类\n\n&ensp;&ensp;&ensp;&ensp;d）多重继承，即一个父类还可以继承另外一个类，java中最大的父类的是Object（如果一个类没有显示的写出extends，那么这个继承Object类）\n\n#### 不能被继承情况\n\n&ensp;&ensp;&ensp;&ensp;a）使用 修饰的属性和方法不能被子类继承\n\n&ensp;&ensp;&ensp;&ensp;b）构造方法不能被继承（构造方法是用来创建类的对象）\n\n&ensp;&ensp;&ensp;&ensp;c）父类中使用默认的修饰符的修饰的属性和方法在不同包的子类中不能被继承 \n\n#### 以继承角度完成练习：\n\n贵妇从宠物店购买了宠物狗、宠物猫，某天，家里举行聚会，向朋友介绍起自家豢养的宠物的情形。\n\n训练提示\n\n&ensp;&ensp;&ensp;&ensp;a）设计宠物狗类，属性有4个【姓名，性别，年龄，品种】，行为【吃、睡觉】\n\n&ensp;&ensp;&ensp;&ensp;b）设计宠物狗类，属性有4个【姓名，性别，年龄，品种】，行为【吃、卖萌】\n\n&ensp;&ensp;&ensp;&ensp;c）设计贵妇类，属性有姓名，思考是有可以将狗和猫作为贵妇的属性存在，如果作为属性，那么如何在贵妇中提供方法介绍自己的从宠物狗和宠物猫\n\n//父类宠物类，这个类中提供宠物狗和宠物猫共有属性和行为\n\n```java\npublic class Pet \n{\n    //共有属性【姓名、性别、年龄、品种】\n    private String name;\n    private String gender;\n    private int age;\n    private String kind;\n    //在Java代码中可以利用编译器快捷的生成 构造方法、Get和Set\n    //快捷键 alt+Insert ---》帮组我们生成需要【构造方法、Get和Set】\n    public Pet() \n    {\n    } \n    public Pet(String name, String gender, int age, String kind) \n    {\n        this.name = name;\n        this.gender = gender;\n        this.age = age;\n        this.kind = kind;\n    } \n    public String getName() \n    {\n        return name;\n    } \n    public void setName(String name) \n    {\n        this.name = name;\n    } \n    public String getGender() \n    {\n        return gender;\n    } \n    public void setGender(String gender) \n    {\n        this.gender = gender;\n    } \n    public int getAge() \n    {\n        return age;\n    }\n    public void setAge(int age) \n    {\n        this.age = age;\n    } \n    public String getKind() \n    {\n        return kind;\n    } \n    public void setKind(String kind) \n    {\n        this.kind = kind;\n    } \n    //所有宠物中都有一个吃的行为\n    public void eat()\n    {\n        System.out.println(name+\"正在吃\");\n    }\n}\n```\n\n宠物猫类\n\n```java\npublic class PetCat extends Pet \n{\n    //无需再PetCat中在定义 属性和吃行为 【因为继承Pet，所以子类可以得到属性和行为】\n    public void meng()\n    {\n        System.out.println(getName()+\"吃饱之后正在卖萌....\");\n    }\n}\n```\n\n宠物狗子类\n\n```java\npublic class PetDog extends Pet \n{\n    //无需再PetDog中在定义 属性和吃行为 【因为继承Pet，所以子类可以得到属性和行为】\n    //提供一个咬人行为即可\n    public void bite()\n    {\n        System.out.println(getName()+\"吃饱之后正准备咬人....\");\n    }\n}\n```\n\n贵妇类\n\n```java\n/*\n    在一个类中使用另外一个类属性和行为时，如何处理？\n    第一种： 在使用类中，将另外一个类作为本类属性存在\n        好处：因为是属性所以在整个类中和类外都可以访问操作【使用范围广泛】\n        坏处：需要满足一些客观现实规律\n    第二种： 在使用类中， 提供一个方法【一般是成员方法】将另外一个类作为本方法的参数定义使用\n        好处：可以不用受到一些客观现实规律约束\n        坏处：使用范围仅限于方法的内部，在其他位置无法使用\n*/\npublic class Lady \n{\n    private String name;\n    public Lady()\n    {\n    } \n    public Lady(String name)\n    {\n        this.name = name;\n    } \n    public String getName() \n    {\n        eturn name;\n    } \n    public void setName(String name) \n    {\n        this.name = name;\n    }\n     //提供两个行为：介绍宠物猫和宠物狗\n    //PetCat cat:是一个类类型(引用类型)，在mian方法中new对应的类再把new出来的对象名传进来，这里就相当于PetCat cat = new PetCat();     \n    public void showInfosPetCat(PetCat cat)    \n    {\n        System.out.println(\"猫的名字：\"+cat.getName());\n        System.out.println(\"猫的性别：\"+cat.getGender());\n        System.out.println(\"猫的年龄：\"+cat.getAge());\n        System.out.println(\"猫的品种：\"+cat.getKind());\n        cat.eat(); //这个方法在PetCat类中并无定义，是从父类继承而来\n        cat.meng();\n    } \n    public void showInfosPetDog(PetDog dog)\n    {\n        System.out.println(\"猫的名字：\"+dog.getName());\n        System.out.println(\"猫的性别：\"+dog.getGender());\n        System.out.println(\"猫的年龄：\"+dog.getAge());\n        System.out.println(\"猫的品种：\"+dog.getKind());\n        dog.eat(); //这个方法在PetCat类中并无定义，是从父类继承而来\n        dog.bite();\n    }\n}\n```\n\n测试\n\n```java\npublic class Test \n{\n    public static void main(String[] args) \n    {\n        PetCat cat = new PetCat();\n        cat.setName(\"小花\");\n        cat.setAge(1);\n        cat.setGender(\"母\");\n        cat.setKind(\"美短\");\n        PetDog dog = new PetDog();\n        dog.setName(\"小白\");\n        dog.setAge(1);\n        dog.setGender(\"公\");\n        dog.setKind(\"柯基\");\n        Lady lady = new Lady();\n        lady.showInfosPetCat(cat);//这里就把对应的对象名(引用类型)传过去\n        lady.showInfosPetDog(dog);//这里就把对应的对象名(引用类型)传过去\n    }\n}\n```\n\n问题:\n\n&ensp;&ensp;&ensp;&ensp;a）子类中如果需要对属性初始化，如何提供构造方法，想在创建子类的同时就完成对属性初始化操作，如何完成？\n\n&ensp;&ensp;&ensp;&ensp;b）父类中提供了一个吃的方法eat，但是狗与猫之间吃的东西是不同的，需要在狗类中描述狗吃肉，需要在猫类中描述猫吃鱼，父类提供的方法实现就不能满足子类需求了，子类如何处理继承而来方法不能满足子类需求？\n\n### 4）super关键字\n\n#### 定义\n\nsuper关键字，它只能在子类中使用，并且super关键字相当于是提供一个父类的引用\n\nsuper关键字一共有三个功能：\n\n&ensp;&ensp;&ensp;&ensp;在子类可以通过super关键字调用父类提供成员变量 ---》super.父类定义成员变量名\n\n&ensp;&ensp;&ensp;&ensp;在子类可以通过super关键字调用父类提供成员方法 ---》 super.父类定义成员方法名(参数赋值);\n\n&ensp;&ensp;&ensp;&ensp;PS：这个操作是最主要的途径\n\n&ensp;&ensp;&ensp;&ensp;在子类的构造方法中调用父类的构造方法来进行属性初始化\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;---》super() 调用就是父类无参构造方法 \n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;---》super(参数赋值) 调用父类的有参构造方法\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;---》必须在子类构造方法的第一句\n\n#### 作用\n\n&ensp;&ensp;&ensp;&ensp;a）调用父类的属性\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;如果当子类和父类中没有重名属性时，那么super和this关键字表示的属性是一致的，都是调用父类的\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;如果当子类和父类中有重名属性时，那么 super.属性名 表示：父类的属性，this.属性名 表示：子类的属性\n\n&ensp;&ensp;&ensp;&ensp;b）调用父类的方法\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;如果当子类和父类中没有重名方法时，那么super和this关键字表示的方法是一致的，都是调用父类的\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;如果当子类和父类中有重名方法时，那么 super.方法名 表示：父类的方法，this.方法名 表示：子类的方法\n\n&ensp;&ensp;&ensp;&ensp;c）调用父类的构造方法\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;注意：创建子类对象之前，必须要先创建父类的对象\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;（a）super();调用的是父类的无参构造。是可以完全省略的，省不省略都会执行(建议：保留父类的无参构造)\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;（b）super调用父类的有参构造，要放到构造方法第一行。super和this不能同时出现 \t\n\n父类\n\n```java\npublic class Person \n{\n    private String name;\n    char gender;\n    //提供构造方法\n    public Person() \n    {\n    } \n    public Person(String name, char gender) \n    {\n        this.name = name;\n        this.gender = gender;\n    } \n    //提供Get和Set方法\n    public String getName() \n    {\n        return name;\n    } \n    public void setName(String name) \n    {\n        this.name = name;\n    } \n    public char getGender() \n    {\n        return gender;\n    } \n    public void setGender(char gender) \n    {\n        this.gender = gender;\n    }\n}\n```\n\n子类\n\n```java\npublic class Man extends Person\n{\n    /*\n        子类继承父类之后，可以得到父类中所有的可见属性和行为【非private】\n        子类还可以提供自己独有属性和行为\n    */\n    private int age;\n    /*\n        发生继承之后 子类是不可以继承父类构造方法，所以子类需要提供自己的构造方法\n        子类依旧要提供有参和无参构造方法\n    */\n    public Man()\n    {\n    } \n    /*\n        子类的有参构造方法如何提供，子类的构造方法一般会将从父类得到属性和子类的属性都进行创建对象\n初始化\n        所以建议在子类构造方法中 提供父类得到属性和子类的属性同一操作\n    */\n    public Man(String name, char gender,int age)\n    {\n        //如何对父类初始化呢？ --> 使用父类中提供set方法对父类属性初始化\n        // setName(name); //问题在于 如果属性过多，子类构造方法就要大量调用set方法\n        //此时就可以使用super关键字调用父类的构造方法来辅助子类初始化继承属性\n        //super(); //调用无参构造方法\n        super(name,gender);// 调用父类的有参构造方法\n        this.age = age;\n        /*\n            PS：非常推荐使用这种方式进行属性初始化操作，简便易懂其他开发人员如何查看你编写代码\n            发现这个构造方法时，就可以知道那些属性是父类提供【super关键字初始化】，那些属性\n是子类提供【使用this】\n        */\n    } \n        //成员方法\n    public void show()\n    {\n        //调用父类中属性\n        System.out.println(super.gender);\n        //调用父类中成员方法\n        super.getGender();\n    }\n}\n```\n\n总结：super关键字在子类中最大作用就是调用父类的构造方法，辅助子类完成属性初始化\n\nthis关键字与Super关键字的不同？\n\n1. this关键字可以使用在任何类中，并且可以作为方法参数传递\n2. super关键字只能使用在子类中，并且不可以作为方法参数传递\n3. this关键字代表的是当前对象， super关键字代表的是父类对象的引用\n\n### 5）方法重写\n\n#### 定义\n\n&ensp;&ensp;&ensp;&ensp;当父类提供成员方法实现，无法满足子类需求时，子类可以在本类中提供父类成员方法重新实现的操作，子类中有与父类相同签名的方法 称之为 方法重写 \n\n&ensp;&ensp;&ensp;&ensp;相同签名：方法名相同、参数相同、返回值相同、\t访问修饰符（子类要比父类更宽泛(看上面表格)）\n\n#### 应用\n\n&ensp;&ensp;&ensp;&ensp;因为父类的方法无法满足子类的需求，所以需要重写父类的方法 \n\n&ensp;&ensp;&ensp;&ensp;子类方法重写的格式：子类中出现重写父类方法操作是，父类方法如何定义，子类方法就如何定义，只是子类将原有方法的实现重新完成(重写方法名回车)\n\n&ensp;&ensp;&ensp;&ensp;一旦子类发生重写父类方法之后，外界在调用方法必然执行子类重写之后的方法，无法在调用到父类原有方法\n\nPS：非要看到父类方法的原有实现：\n\n&ensp;&ensp;&ensp;&ensp;外界方式实现即在子类外部查看：提供父类对象创建，并使用父类对象调用方法【极少使用】\n\n&ensp;&ensp;&ensp;&ensp;内界方法实现即在子类内部查看：使用super关键字调用父类原有方法即可\n\n#### 注解：@Override\n\n&ensp;&ensp;&ensp;&ensp;建议在重写方法的时候，加上注解\n\n&ensp;&ensp;&ensp;&ensp;作用：检测是否是满足方法重写。必须满足重写的要求，否则报错\n\n&ensp;&ensp;&ensp;&ensp;注意：父类中的是私有方法，子类无法重写（私有方法不能被继承，所以不能被重写）\n\n&ensp;&ensp;&ensp;&ensp;需求: 创建一个父类鸟类（Brid），父类就提供一个方法fly，在创建两个子类麻雀类和鸵鸟类\n\n父类鸟类\n\n```java\npublic class Bird \n{\n    //提供一个飞翔方法\n    public void fly()\n    {\n        System.out.println(\"可以飞翔\");\n    }\n}\n```\n\n子类麻雀\n\n```java\nclass Sparrow extends Bird\n{\n    //子类可以得到父类提供公有fly方法\n}\n```\n\n子类鸵鸟\n\n```java\nclass Ostich extends Bird\n{\n    //子类可以得到父类提供公有fly方法\n    //提供对父类fly方法重写操作【最简单的原则，父类方法如何定义，\n    // 子类重写时就如何定义，只要提供不同的实现即可】\n    //这就是当前子类重写父类方法的操作定义\n    @Override //注解，作用就是提供给编译器说明子类有重写父类方法\n    public void fly() \n    {\n        // super.fly(); ---》 这种方式就可以调用到父类方法的原有实现\n        //只需要在这个方法中提供子类自己实现方式即可---》 重写\n        System.out.println(\"我不会飞，但是跑的很快！！！\");\n    }\n}\n```\n\n测试\n\n```java\nclass Test\n{\n    public static void main(String[] args)\n    {\n        Sparrow sparrow = new Sparrow();\n        Ostich ostich = new Ostich();\n        /*\n            麻雀可以飞翔是没问题的，但是鸵鸟是不会飞的，所以如果鸵鸟这个对象调用\n            fly方法打印出可以“可以飞翔”和明显不符合要求的\n            触发了一个原则，父类提供方法无法满足子类需求，子类可以重写父类方法\n        */\n        sparrow.fly();\n        //子类一旦重写父类方法之后在调用方法，必然是子类重写之后的实现啊\n        ostich.fly();\n    }\n}\n```\n\n#### 重写完成要求：\n\n1. 若**父类的方法使用private、static或final修饰中任意一个修饰符修饰，那么子类都不可以重写这个方法**\n\n2. 重写方法必须所有继承关系，没有继承关系两个类是不可以重写对方方法\n\n3. 重写成员成员方法方法签名必须相同【方法签名=方法名+参数列表】\n\n4. 子类重写父类方法是，提供原有父类方法返回值类型的子类类型或同类型\n\n5. 在重写时，子类提供方法访问权限修饰符要大于等于父类的方法权限修饰符\n\n6. 在重写时,父类的方法提供异常类抛出，子类提供异常类型必须相同类型或子类类型\n\n#### 方法重载与方法重写的区别\n\n|          | 位置 | 方法名 | 返回值类型 | 参数列表 | 访问修饰符 |\n| :------: | :--: | :----: | :--------: | :------: | :--------: |\n| 方法重载 | 本类 |  一致  |    无关    |  不一致  |    无关    |\n| 方法重写 | 子类 |  一致  |    一致    |   一致   |  子类更宽  |\n\n#### 继承中子类实例化过程\n\n&ensp;&ensp;&ensp;&ensp;PS:在Java中继承实例化过程是遵守现实客观规律，现实生活中一定是先有你父亲再有你\n\n父类\n\n```java\npublic class Father \n{\n    private int age;\n    public Father()\n    {\n    System.out.println(\"父类的无参构造方法调用\");\n    } \n    public Father(int age)\n    {\n        this.age = age;\n        System.out.println(\"父类的有参构造方法调用\");\n    } \n    public int getAge() \n    {\n        return age;\n    } \n    public void setAge(int age) \n    {\n        this.age = age;\n    }\n}\n```\n\n子类\n\n```java\nclass Son extends Father\n{\n    //提供子类构造方法\n    public Son()\n    {\n        System.out.println(\"子类的无参构造按方法被调用\");\n    }\n    public Son(int age)\n    {\n        //使用set方法对age进行\n        setAge(age);\n        System.out.println(\"子类的有参构造方法被调用\");\n    }\n}\n```\n\n测试\n\n```java\nclass Test\n{\n    public static void main(String[] args) \n    {\n        //分别使用子类的无参和有参构造方法创建对象\n        Son son = new Son();\n        System.out.println(\"-----------------\");\n        Son son1 = new Son(1);\n    }\n}\n```\n\n&ensp;&ensp;&ensp;&ensp;发生子类继承父类之后，在创建子类对象过程时，**是先调用父类无参构造方法，然后再调用子类的构造方法创建对象，先创建父类的对象，在创建子类对象，继承之后子类的实例化过程**\n\n**&ensp;&ensp;&ensp;&ensp;子类的构造方法中【会默认调用父类无参构造方法】，所以父类要提供无参构造方法，让子类只可以正确的创建对象**\n\n&ensp;&ensp;&ensp;&ensp;某些情况下缺失父类忘记了提供无参构造方法，但是提供其他的构造方法，是否可以辅助子类构造对象呢？ ---》 可以，如果父类没有明确提供无参构造方法，但是**提供其他的有参构造方法，子类只需要在本类中构造方法位置明确调用父类的构造方法即可---》使用super关键字**\n\n&ensp;&ensp;&ensp;&ensp;子类实例化完整说明：子类在继承父类之后，**子类中提供构造方法是默认调用父类无参构造方法来辅助创建对象，若父类没有明确提供无参构造方法，可以使用super关键调用父类其他的构造方法在子类构造方法中辅助创建对象，所以子类对象创建一定是先创建父类对象，在创建子类对象**\n\n#### 子类继承父类之后内存存储\n\n&ensp;&ensp;&ensp;&ensp;继承体系内存图原理--》父类的空间优于子类对象产生\n\n&ensp;&ensp;&ensp;&ensp;在每次创建子类对象时，先初始化父类空间，在创建其子类对象本身，目的在与子类对象中包含了其对应的父类空间，便可以包含父类的成员，如果父类成员非private修饰，则子类可以随意使用父类成员，代码体现在子类的构造方法调用时，是默认调用父类无参构造方法的\n\n![子类继承父类之后内存存储](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271926956.jpg)\n\n&ensp;&ensp;&ensp;&ensp;当子类调用方法的原则时，优先扫描子类中是否存在当前方法【定义和重写的】，如果子类存在这方法就调用子类方法，如果子类不存在次方法到调用父类方法\n\n&ensp;&ensp;&ensp;&ensp;如果子类中出现与父类中重名属性，是不存在【属性重写概念】，对象执行调用时，优先扫描子类中所存在属性，如果子类定义类就获取子类属性，如果子类中没有扫描父类中继承而来属性\n\n## <center>3、多态</center>\n\n### 1）定义\n\n&ensp;&ensp;&ensp;&ensp;多态在Java中定义原则：同一个事物被不同对象所触发，得到结果不同就称之为多态\n\n&ensp;&ensp;&ensp;&ensp;在生活中，比如跑的动作，小猫、小狗和大象，跑去起来都是不一样的，再比如飞的动作，昆虫、鸟和飞机，飞起来也是不一样的，所以可见，同一个行为，通过不同事物，可以体现出不同的行为，这就是多态的描述\n\n在现实生活中家里饲养了一些宠物\n\n&ensp;&ensp;&ensp;&ensp;养了宠物狗： 叫声 ----》 汪汪汪\n\n&ensp;&ensp;&ensp;&ensp;养了宠物猫： 叫声 ----》 喵喵喵\n\n在Java中将多态体现在代码中行为有哪些？\n\n【方法多态】：方法多态的体现就是“重载”,同一个方法被不同参数所触发，得到方法的结果不同就是方法多态\n\n【对象多态】：同一个方法，对不同对象触发可以得到不用表现形式\n\n**&ensp;&ensp;&ensp;&ensp;发生对象多态有一个必要前提**：**必须存在【继承或实现】关系**、需要有子类重写方法的实现【可以让多态先更加完善】\n\n&ensp;&ensp;&ensp;&ensp;对象多态中对于我们开发而言最主要的就是【里氏代转换原则】，通过这个原则可以发挥多态最大效力\n\n### 里氏代转换原则\n\n&ensp;&ensp;&ensp;&ensp;里氏代转换原则在程序最主要体现就是提供了【子类与父类之间的转换操作】，这里这个操作就可以动态概念改变当前对象，从而满足不同开发需求\n\n&ensp;&ensp;&ensp;&ensp;如果要体现里氏代转换原则，是有一个必要前提【需要存在【继承或实现】关系】\n\n&ensp;&ensp;&ensp;&ensp;即类与类之间必须是继承关系 类与接口之间是实现关系\n\n&ensp;&ensp;&ensp;&ensp;没有任何联系的类是无法完成这个操作\n\n&ensp;&ensp;&ensp;&ensp;例如： 类Dog和类Person，这两两个类都是独立的，那么Dog类和Person了就不能完成里氏代转换原则\n\n### 2）特点\n\n&ensp;&ensp;&ensp;&ensp;编译看左边，运行看右边\n\n&ensp;&ensp;&ensp;&ensp;如果发生多态，那么无法调用子类独有的方法（编译看左边（左边是父类））\n\n&ensp;&ensp;&ensp;&ensp;如果发生多态，那么调用的一定是子类重写的方法（运行看右边）\n\n### 3）多态产生条件\n\n&ensp;&ensp;&ensp;&ensp;（1）必须要有继承\n\n&ensp;&ensp;&ensp;&ensp;（2）必须要有方法重写\n\n&ensp;&ensp;&ensp;&ensp;（3）必须要父类的引用指向子类的对象\n\n### 4）向上向下转型\n\n**&ensp;&ensp;&ensp;&ensp;向上转型**：父类引用指向子类对象\n\n语法：\n\n```java\n父类类型 对象名字 = new 子类类型();\n```\n\n此时这个类子类就会被默认提升为父类类型，当前对象只能调用父类中提供属性和行为，无法调用子类中提供自有属性和行为\n\nPS：这也是开发中唯一创建父类对象一种方式，不会使用父类直接创建对象\n\n【即 父类类型 对象名 = new 父类类型();】\n\n**&ensp;&ensp;&ensp;&ensp;向下转型**：将父类引用强转成子类类型\n\n语法：\n\n```java\n子类类型 对象名 = (子类类型)提升为父类类型对象;\n```\n\n&ensp;&ensp;&ensp;&ensp;此时这个对象就会被转换为原来子类类型，当前对象即可以调用父类中提供可见属性和行为，也可以调用子类自有属性和行为\n\n&ensp;&ensp;&ensp;&ensp;如果发生多态，那么无法调用子类独有的方法。如果要调用子类独有的方法，那么必须发生向下转型，前提是先发生过向上转型，否则会报错\n\n### 5）instanceOf关键字\n\n&ensp;&ensp;&ensp;&ensp;可以利用instanceof这个关键字检查 提升之后对象是否是某一个子类类型对象即【当前提升之后对象是否属于某个子类类型】\n\n```java\n语法：\n    提升之后对象 instanceof 子类类型\n    \n上面这个表达式就会帮组你判断，提升之后对象是否属于但当前提供子类类型\n    返回值为 true 【证明当前对象是由当前子类类型提升而来】\n            false 【证明当前对象不是当前子类类型提升而来】\n```\n\n```java\n//父类动物类\npublic class Animal \n{\n    private String name;\n    private String gender;\n    public Animal() \n    {\n    } \n    public Animal(String name, String gender) \n    {\n        this.name = name;\n        this.gender = gender;\n    }\n    public String getName() \n    {\n        return name;\n    } \n    public void setName(String name) \n    {\n        this.name = name;\n    } \n    public String getGender() \n    {\n        return gender;\n    } \n    public void setGender(String gender) \n    {\n        this.gender = gender;\n    }\n} \n//子类狗类\npublic class Dog extends Animal\n{\n    private int age;\n    public Dog()\n    {\n    } \n    public Dog(String name,String gender,int age)\n    {\n        super(name,gender);\n        this.age = age;\n    } \n    public int getAge() \n    {\n        return age;\n    } \n    public void setAge(int age) \n    {\n        this.age = age;\n    }\n} \n//子类猫类\npublic class Cat extends Animal\n{\n    private String kind;\n    public Cat()\n    {\n    } \n    public Cat(String name, String gender, String kind)\n    {\n        super(name,gender);\n        this.kind = kind;\n    } \n    public String getKind() \n    {\n        return kind;\n    }\n    public void setKind(String kind) \n    {\n        this.kind = kind;\n    }\n} \n//测试\npublic class Test \n{\n    public static void main(String[] args) \n    {\n        //1.提供对象向上转型\n        /*\n            父类引用可以接收一个子类的引用\n            此时会将Dog类型对象提升为父类Animal类型\n            此时只能调用父类中属性和行为，不能调用子类自己属性和行为\n            如果子类重写父类的方法，提升之后对象调用方法执行时，依旧执行子类重写效果\n        */\n        Animal animal = new Dog();\n        animal.getName();\n        //animal.getAge(); //getAge方法是子类自身的，并不是父类的\n        //2.提供对象向下转型\n        /*\n            将一个提升为父类类型对象转换为原有子类类型操作就叫做对象向下转型\n            此时会将提升之后父类对象animal转换为原有子类类型Dog\n            转型之后不仅可以调用子类的属性和方法，而且也可以调用父类属性和方法\n        */\n        Dog dog = (Dog)animal;\n        dog.getName();\n        dog.getAge();\n\n        //对象向下转型会存在一个问题，如果转型失败会出现一个异常问题，而这个问题不会在编译阶段进行提示只能在运行时提示\n\n        //此时明显animal是Dog类型提升的，并不是Cat，所以这个操作是有问题，但是编译阶段是不会提示错误\n        //系统就会提示 ClassCastException --> 强制类型转换异常\n        // Cat cat = (Cat)animal;\n        //所以为了避免这个问题发生，可以使用instanceof这个关键字进行转换对象判断\n        if(animal instanceof Cat)\n        { //判断animal对象是否是Cat类型对象 ---》 true 是 / false 不是\n            Cat cat = (Cat)animal;\n        }\n        else\n        {\n            System.out.println(\"animal不是Cat类型无法进行对象向下转型\");\n        }\n    }\n}\n```\n\n&ensp;&ensp;&ensp;&ensp;综上所述：在进行对象向下转型时，为了保证对象可以正确转换到对应子类类型中，建议使用instanceof关键字进行，对象子类类型检查，在进行检查时会配合if语句使用，如果检查成功就会在if语句执行代码中进行向下转型操作，使用仅限在if大括号内部，提高范围使用就建议将对象声明定义在if语句外部\n\n&ensp;&ensp;&ensp;&ensp;PS：在实际开发，如果你能确定子类类型是什么，那么就不写instanceof操作\n\n&ensp;&ensp;&ensp;&ensp;以上这些就是多态的一些操作点和概念,多态主要就是提供可扩展和可维护性,好处就可以利用多态让方法使用起来更加高效(子类类型都可以),可以辅助抽象类和接口创建对象,弊端在于如果利用父类作为方法参数类型或返回值类型的时候,返回和接受的属性都会被向上转型为父类类型,子类的自己的属性和方法就不能调用,这样会牺牲一部分灵活性,如何弥补就是向下转型\n\n### 6）多态的引用场景\n\n&ensp;&ensp;&ensp;&ensp;（1）方法的参数\n\n&ensp;&ensp;&ensp;&ensp;（2）方法的返回值\n\n例：\n\n设计一个员工类，其中有计算员工薪水方法，根据不同的员工计算薪水的方法不同\n\n&ensp;&ensp;&ensp;&ensp;员工类型 薪水构成\n\n&ensp;&ensp;&ensp;&ensp; == == == == == == == == == ===\n\n&ensp;&ensp;&ensp;&ensp;经理 底薪+奖金\n\n&ensp;&ensp;&ensp;&ensp;销售人员 底薪+提成\n\n&ensp;&ensp;&ensp;&ensp;普通员工 底薪+补贴\n\n设计一个测试类，场景如下，年终，领导找员工谈话，让员工介绍介绍自己的薪水\n\n分析：\n\n1. 在公司除了老板都是员工，经理、销售、普通员工都是员工\n2. 既然这三者【经理、销售、普通员工】都是员工，可以根据他们共有属性和行为提供一个统一父类\n3. 分别在使用这三者【经理、销售、普通员工】进行与父类至今继承关系从而到需要属性和行为\n4. 设一个方法年终领导让员工介绍自己，如果没有多态之前，三个员工就需要提供是三个自我介绍方法【公司员工暴增300人，又到一年年末自我介绍 ---》提供300个方法（方法管理与维护都是十分麻烦）】，此时可以将方法提供为最大通用性，只提供一个方法进行员工介绍， 利用多态的特点，将参数设计为父类类型，这样一来只要继承父类员工类，都可以进入到这个方法中进行执行操作\n\n员工父类\n\n```java\npublic class Employee \n{\n    //提供共有的属性和行为\n    private int money; \t\t//底薪\n    private String name;\t//员工姓名\n    public Employee() \n    {\n    } \n    public Employee(int money, String name) \n    {\n        this.money = money;\n        this.name = name;\n    } \n    public int getMoney() \n    {\n        return money;\n    } \n    public void setMoney(int money) \n    {\n        this.money = money;\n    }\n    public String getName() \n    {\n        return name;\n    } \n    public void setName(String name) \n    {\n        this.name = name;\n    } \n    /* \n        经理、普通员工和销售都有自己计算薪水方法\n        父类中提供一个方法，让子类来进行重写操作\n        因为这个方法必然被子类重写，所以就不提供具体实现，由子类自己进行重写操作\n    */\n    public void showMoney(){}\n}\n```\n\n子类经理类\n\n```java\npublic class Manager extends Employee\n{\n    private int jiangjin;\n    public Manager() \n    {\n    } \n    public Manager(int money, String name, int jiangjin) \n    {\n        super(money, name);\n        this.jiangjin = jiangjin;\n    } \n    public int getJiangjin() \n    {\n        return jiangjin;\n    } \n    public void setJiangjin(int jiangjin) \n    {\n        this.jiangjin = jiangjin;\n    } \n    //提供介绍字节薪水的方式\n    @Override\n    public void showMoney() \n    {\n        System.out.println(getName()+\"是经理,底薪：\" + getMoney()+\" 奖金：\"\n                        +jiangjin+\" 综合工资：\"+\n(getMoney()+jiangjin));\n    }\n}\n```\n\n子类销售类\n\n```java\npublic class Sales extends Employee\n{\n    private int ticheng;\n    public Sales() \n    {\n    } \n    public Sales(int money, String name, int ticheng) \n    {\n        super(money, name);\n        this.ticheng = ticheng;\n    }\n    public int getticheng() \n    {\n       return ticheng;\n    } \n    public void setticheng(int ticheng) \n    {\n        this.ticheng = ticheng;\n    } \n    //提供介绍字节薪水的方式\n    @Override\n    public void showMoney() \n    {\n        System.out.println(getName()+\"是销售,底薪：\"\n        +getMoney()+\" 奖金：\"+ticheng+\" 综合工资：\"+(getMoney()+ticheng));\n    }\n}\n```\n\n子类普通员工类\n\n```java\npublic class Staff extends Employee\n{\n    private int butie;\n    public Staff() \n    {\n    } \n    public Staff(int money, String name, int butie) \n    {\n        super(money, name);\n        this.butie = butie;\n    } \n    public int getbutie() \n    {\n        return butie;\n    } \n    public void setbutie(int butie) \n    {\n        this.butie = butie;\n    } \n    //提供介绍字节薪水的方式\n    @Override\n    public void showMoney() \n    {\n        System.out.println(getName()+\"是普通员工,底薪：\"\n            +getMoney()+\" 奖金：\"+butie+\" 综合工资：\"+(getMoney()+butie));\n    }\n}\n```\n\nBoss测试类进行员工信息测试操作\n\n```java\npublic class BossTest \n{\n    public static void main(String[] args) \n    {\n        //提供老板、经理、销售和普通员工对象进行操作\n        BossTest boss = new BossTest();\n        Manager manager = new Manager(1000,\"张三\",2000);\n        Sales sales = new Sales(100,\"大宝\",10000);\n        Staff staff = new Staff(10000,\"李四\",200000);\n        //普通实现\n        // boss.showInfosManager(manager);\n        // boss.showInfosSales(sales);\n        // boss.showInfosStaff(staff);\n        //利用多态的对象向上转型操作，方法中参数是父类类型，他可以接收当前这个父类类型的所有子类引用\n        /*\n            此时 方法参数类型是Employee父类类型 参数赋值是 子类类型manager\n            所以参数赋值时就形成了 Employee employee = manager 即 Employee employee =\nnew Manager(1000,\"张三\",2000);\n        */\n        boss.showInfosEmployee(manager);\n        boss.showInfosEmployee(sales);\n        boss.showInfosEmployee(staff);\n    } \n    //在不使用多态的前提下【如果不使用多态就会面临一个问题，如果员工个数增加了，这里就需要添加多个方法】\n    // 随着员工增加与删减，这样我们方法所在类就会被进行频繁的修改，这样并不利于方法管理与维护\n    public void showInfosManager(Manager manager)\n    {\n        manager.showMoney();\n    } \n    public void showInfosSales(Sales sales)\n    {\n        sales.showMoney();\n    } \n    public void showInfosStaff(Staff sales)\n    {\n        sales.showMoney();\n    } \n    /* \n        多态的就出现了，可以利用多态的特点将多态进行方法参数或返回值类型设置，这样就可以提高代码的通\n用性和重用性\n        此时并不需要设置多个方法，只需要提供一个方法，方法参数设置为父类类型\n        利用多态中对象向上转型操作，就可以得到具体实现\n    */\n    public void showInfosEmployee(Employee employee)\n    {\n        employee.showMoney();\n    }\n}\n```\n\n# <center>知识点十：三个修饰符</center>\n\n## <center>1、abstract关键字</center>\n\n### 1）含义\n\n抽象的\n\n### 2）抽象类含义：被abstract修饰的类称之为抽象类\n\n特点：\n\n1. 抽象类不能直接创建对象，即不能通过new 抽象类类名()的方式完成，因为抽象类中会存在抽象方法，这个抽象方法没有方法体，如果抽象类可以使用new 抽象类类名()的方式完成，那么抽象类和抽象方法就没有存在的意义了\n2. 抽象类中是可以选择性包含抽象方法的，如果包含了抽象方法的抽象类被子类继承时，子类需要重写抽象父类中抽象方法【其他的成员方法也可以选择性重写】，如果没有包含抽象方法的抽象类被子类继承时，子类可以选择性重写其他方法\n3. 抽象类提供目的是为了保证父类的完成操作的前提下，让父类具备一些其他功能【抽象方法和防止直接创建对象】，所以抽象类需要提供构造方法\n4. 抽象类的提供就是为了让子类继承而提供的，所以抽象类是允许多态概念的使用\n\n作用：\n\n&ensp;&ensp;&ensp;&ensp;抽象类定义方式其实就是父类的定义方法，会在抽象类中提供所有父类的操作，抽象类在类中主要的作用就是作为父类存在\n\nPS:抽象类就是一个特殊父类\n\n```java\n//语法格式：\npublic abstract class 类名    //这个类就是抽象类\n{ \n    父类如何定义，抽象类的内部就如何定义\n    成员变量\n    构造方法\n    成员方法\n    静态变量\n    静态方法\n    方法重写\n    抽象方法\n} \n//抽象类就是多了一个abstract关键字的父类\n```\n\nPS：建议在以后开发中，**如果确定这个类是一个父类就建议优先声明成“抽象类”**\n\n&ensp;&ensp;&ensp;&ensp;抽象类可以像普通类一样使用可以继承，可以实现，可以定义类中所有定义的东西，但是就是不允许直接创建抽象类对象【即 抽象类类名 对象 = new 抽象类类名();】,抽象类是它支持多态\n\n```java\n//创建抽象类葵花宝典\npublic abstract class SunflowerBible \n{\n}\n```\n\n### 3）抽象方法\n\n含义：使用abstract关键字修饰并且没有方法体，存在在抽象类中叫做抽象方法\n\n特点：\n\n&ensp;&ensp;&ensp;&ensp;（1）抽象方法必须出现在抽象类中\n\n&ensp;&ensp;&ensp;&ensp;（2）抽象方法不能有方法体（方法的实现{}）并且在小括号后面添加【;】\n\n&ensp;&ensp;&ensp;&ensp;（3）抽象方法必须要在非抽象子类中重写\n\n&ensp;&ensp;&ensp;&ensp;（4）抽象方法修饰符不能使用private、static和final，只要使用这三个修饰符，这个方法就无法在进行重写实现了，所以就失去抽象方法的目的了\n\n```java\n//抽象方法的格式\npublic abstract 返回值类型 方法名(参数列表);\n```\n\n抽象类和抽象方法什么时候用？\n\n&ensp;&ensp;&ensp;&ensp;抽象类我们一般用比较少，未来更多是使用接口\n\n&ensp;&ensp;&ensp;&ensp;在接口中全部都是抽象方法，抽象方法的作用就是为了让子类去重写\n\n练习：\n\n&ensp;&ensp;&ensp;&ensp;设计一个公司抽象类，具有抽象方法 -- 营业，休息\n\n&ensp;&ensp;&ensp;&ensp;设计一个快递公司类作为公司类的子类\n\n&ensp;&ensp;&ensp;&ensp;设计一个顺丰快递类，作为快递类的子类\n\n&ensp;&ensp;&ensp;&ensp;需求：实例化一个顺丰快递的对象，从控制台录入一个24以内的数据，如果数据在8~18点之间，顺丰营业。否则，顺丰快递公司休息\n\n提供一个公司的抽象类\n\n```java\npublic abstract class Company \n{\n    private String companyName;\n    public Company() \n    {\n    } \n    public Company(String companyName) \n    {\n        this.companyName = companyName;\n    } \n    public String getCompanyName() \n    {\n        return companyName;\n    } \n    public void setCompanyName(String companyName) \n    {\n        this.companyName = companyName;\n    } \n    //营业的抽象方法\n    public abstract void open();\n    //休息的抽象方法\n    public abstract void close();\n}\n```\n\n快递公司在需求中并没有做任何特殊说明\n\n此时可以将这个类作为一个抽象类\n\n使用一个抽象类继承与另外一个抽象类，当前这个抽象子类可以选择性实现或者不实现抽象父类中抽象方法\n\n不是先父类抽象方法原因，是因为这个也是抽象类，也可以存储抽象方法所以抽象子类可以选择性实现抽象方法\n\n```java\npublic abstract class CourierServicesCompany extends Company \n{\n    public CourierServicesCompany() \n    {\n    } \n    public CourierServicesCompany(String companyName) \n    {\n        super(companyName);\n    }\n}\n```\n\n顺丰快递公司子类\n\n如果使用一个普通类继承与抽象类，必须实现抽象类中所提供抽象方法\n\n```java\npublic class SFCompany extends CourierServicesCompany \n{\n    public SFCompany() \n    {\n    } \n    public SFCompany(String companyName) \n    {\n        super(companyName);\n    } \n    @Override\n    public void open() \n    {\n        System.out.println(getCompanyName()+\"正在营业，欢迎光临.....\");\n    } \n    @Override\n    public void close() \n    {\n    System.out.println(getCompanyName()+\"下班休息，下次再来.....\");\n    }\n}\n```\n\nTest类（测试类）\n\n```java\npublic class Test2 \n{\n    public static void main(String[] args) \n    {\n        Scanner input = new Scanner(System.in);\n        System.out.println(\"请输入时间:\");\n        int time = input.nextInt();\n        SFCompany sfCompany = new SFCompany(\"顺丰快递\");\n        if(time >= 8 && time <= 18)\n        {\n            sfCompany.open();\n        }\n        else \n        {\n            sfCompany.close();\n        }\n    }\n}\n```\n\n## <center>2、static关键字</center>\n\n### 1）含义\n\n静态的\n\n### 2）作用\n\n修饰：成员变量、成员方法、成员变量、代码块、内部类\n\n### 3）静态和成员之间的区别\n\n![静态和成员之间的区别](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271926050.jpg)\n\n### 4）static修饰成员变量\n\n&ensp;&ensp;&ensp;&ensp;当 static 关键字修饰成员变量时，该变量被称为静态变量【类变量】,该类的**每个对象都对这个变量是共享的状态**，任何对象都可以改变静态变量中存储的数据，改变之后其他对象将修改之后值，但可以在不创建该类对象化的前提下操作这个静态变量【这个才是正确操作方式】当 static 关键字修饰成员变量时，该变量被称为静态变量【类变量】,该类的每个对象都对这个变量是共享的状态，任何对象都可以改变静态变量中存储的数据，改变之后其他对象将修改之后值，但可以在不创建该类对象化的前提下操作这个静态变量【这个才是正确操作方式】\n\n定义方式\n\n```java\n访问权限修饰符 static 数据类型 变量名;\n```\n\n访问方式\n\n```java\n不推荐方式 ---》 对象.静态变量名\n推荐方式 ---》如果是在当前类中访问本类的静态变量 ---》静态变量名\n        ---》如果是在其他类中访问类的静态变量 ---》 类名.静态变量名\n```\n\n演示案例\n\n```java\npublic class ChinesePeople \n{\n    //提供两个变量一个成员变量和静态变量\n    String name;\n    static String country;\n} \nclass Test\n{\n    public static void main(String[] args) \n    {\n        //在不同类中访问静态变量[静态变量是存在默认值]\n        System.out.println(ChinesePeople.country);\n        // 所有静态变量存储在类所创建对象都是共享这个静态变量\n        ChinesePeople p1 = new ChinesePeople();\n        p1.name = \"张三\";\n        /*\n            可以通过对象.静态变量方式访问静态变量的，但是推荐推荐\n            IDEA提示的警告信息：\n            Static member 'com.qfedu.Static.ChinesePeople.country' accessed via\n            instance reference\n            不建议的\n        */\n        p1.country = \"中国\";\n        ChinesePeople p2 = new ChinesePeople();\n        System.out.println(\"p2这个对象的国籍：\"+p2.country);\n    }\n}\n```\n\n### 5）static修饰成员方法\n\n&ensp;&ensp;&ensp;&ensp;被static修饰成员方法被称之为静态方法【类方法】，该静态方法可以使用类名直接调用\n\n语法\n\n```java\n访问权限修饰符 static 返回值类型 方法名(参数列表)\n{\n    执行语句\n    return\n}\n```\n\n访问方式\n\n```java\n不推荐方式 ---》 对象.静态方法名字(参数赋值);\n推荐方式 ---》 如果在同一个类中，访问本类定义静态方法时 ---》 静态方法名字(参数赋值);\n        ---》 如果在其他类中，访问类中静态方法是 ---》 类名.静态方法名字(参数赋值);\n```\n\n#### 静态方法被使用时注意事项\n\n1. 静态方法中不允许出现this关键字\n2. 静态方法中只能直接访问静态变量和其他的静态方法\n3. **静态方法中是不可以直接访问成员变量和成员方法**\n\n**&ensp;&ensp;&ensp;&ensp;如果在静态方法中访问成员变量或成员方法，需要创建当前类的对象，通过对象才可以访问**\n\n案例演示\n\n```java\npublic class StaticMethod \n{\n    //演示类中静态方法\n    //提供成员变量和成员方法\n    String name;\n    public void show()\n    {\n        //在成员方法中 访问 成员变量 和成员方法 还有静态变量和静态方法\n        System.out.println(name);\n        System.out.println(age);\n        display();\n        //show(); ---》注释的原则是防止死递归\n        //可以使用this和super关键字\n    } \n    //提供静态变量和静态方法\n    static int age;\n    public static void display()\n    {\n        //在静态方法中 访问 成员变量 和成员方法 还有静态变量和静态方法\n        System.out.println(age);\n        // display(); ---》注释的原则是防止死递归\n        //在静态方法中是不可以直接访问成员变量和方法，不可以使用this和super关键字\n        //如果要访问成员变量和成员方法，那么就必须创建对象\n        /** \n            System.out.println(name);\n            show();\n        */        \n    }\n}\n```\n\n### 6）静态代码块\n\n#### 含义\n\n&ensp;&ensp;&ensp;&ensp;static可以用于修饰代码块，称之为静态代码块\n\n&ensp;&ensp;&ensp;&ensp;代码块：指的是在程序中出现的一个代码片段，直接使用{}包裹\n\n&ensp;&ensp;&ensp;&ensp;静态代码块：指的是用static修饰的代码块\n\n#### 特点\n\n&ensp;&ensp;&ensp;&ensp;静态代码块在类加载的时候自动执行，无需手动调用，代码块会按照先后顺序一次执行，优先于代码块、构造方法执行，静态代码块只会在类加载的时候执行一次（初始化的时候使用）。\n\nPS：利用static修饰代码块来执行一些“耗时的操作”，优先执行\n\n类加载的触发时机\n\n&ensp;&ensp;&ensp;&ensp;（1）创建类的对象时候（new）\n\n&ensp;&ensp;&ensp;&ensp;（2）创建子类对象的时候（先要创建其父类对象）\n\n&ensp;&ensp;&ensp;&ensp;（3）在调用类中的静态属性和静态方法的时候\n\n&ensp;&ensp;&ensp;&ensp;（4）Class类中提供的静态方法 Class.forName() 方法的时候（放射）\n\n```java\npublic class StaticBlock \n{\n    public StaticBlock()\n    {\n        System.out.println(\"无参构造方法\");\n    } \n    static\n    {\n        System.out.println(\"静态代码块\");\n    }\n} \nclass Test2\n{\n    public static void main(String[] args) \n    {\n        new StaticBlock();\n        new StaticBlock();\n    }\n}\n```\n\n&ensp;&ensp;&ensp;&ensp;在普通类定义操作的时候，是很少使用静态的方式来完成，在有开发项目中，通常会需要使用到一些“全局变量”和“全局方法”，这些全局变量和全局方法会被单独定义在一个类中，并且都使用static进行修饰，可以访问外界直接对变量和方法访问，这样类叫做工具类，在创建工具类需要提供一个包util，包中提供工具类的名字 XXXUtil 或 XXXTools\n\n&ensp;&ensp;&ensp;&ensp;像：Arrays就是一个工具类，工具类的特点是类中变量必须是static修饰静态变量，类中方法必须是static修饰静态方法，而且这个类不提供对象创建，这样类就是工具类\n\n## <center>3、final关键字</center>\n\n### 1）含义\n\n&ensp;&ensp;&ensp;&ensp;不可变，不可改变，最终，不可以修改，修饰关键字主要可以用途修饰【类，变量和方法】\n\n### 2）作用\n\n修饰的类\n\n&ensp;&ensp;&ensp;&ensp;特点：使用final修饰的类不能被继承（太监类）\n\n修饰的方法\n\n&ensp;&ensp;&ensp;&ensp;特点：使用final修饰的方法不能被重写，但是可以被继承\n\n修饰的属性\n\n&ensp;&ensp;&ensp;&ensp;称之为：常量\n\n&ensp;&ensp;&ensp;&ensp;特点：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1、常量必须要赋值\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;常量的最后赋值时机：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;a、非静态常量（没有static修饰的）\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1)直接赋值\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;2)在代码块中赋值\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;3)在构造方法中赋值(注意：如果一个类有多个构造方法，那么必须在每一个构造方法中赋值)\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;b、静态常量（使用static修饰的）\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1)直接赋值\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;2)在静态代码块中赋值\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;2、常量不能修改\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;基本类型值不能改变\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;引用类型地址不能改变\n\n### 使用final修饰符修饰局部变量\n\n&ensp;&ensp;&ensp;&ensp;局部变量是定义在方法内部变量就是局部变量\n\n```java\n//使用final关键字修饰局部变量\npublic class FinalVarDemo \n{\n    public static void main(String[] args) \n    {\n        /*\n            final修饰变量同时并赋值【此时就会定义常量，不可以被修改】\n            语法： final 数据类型 变量名(这个变量名要大写代表是常量) = 值\n       */                        \n        final double PI = 3.14;\n        //IDEA 错误提示 Cannot assign a value to final variable 'PI'\n        //不能修改使用final修饰PI\n        //PI = 3.15;\n        //final修饰变量先定义，在赋值【只能赋值一次】\n        /*\n            final 数据类型 变量名(这个变量名要大写代表是常量);\n            变量名(这个变量名要大写代表是常量) = 值;\n        */\n        final int age;\n        age = 18;\n        //IDEA的错误提示 Variable 'age' might already have been assigned to\n        //不允许进行二次赋值\n        //age = 20;\n    }\n}\n```\n\n### 使用final修饰符修饰成员变量和静态变量\n\n&ensp;&ensp;&ensp;&ensp;当使用final修饰符修饰完毕之后，就会形成常量，不允许再次修改存储数据\n\n### final修饰成员变量\n\n```java\npublic class FinalVarDemo2 \n{\n    //使用final修饰符修饰成员变量\n    final double PI = 3.14;\n    public static void main(String[] args) \n    {\n        System.out.println(new FinalVarDemo2().PI);\n        //IDEA错误提示信息Cannot assign a value to final variable 'PI' 不允许修改这个值\n        //new FinalVarDemo2().PI = 3.15;\n    }\n}\n```\n\n### final修饰静态变量\n\n&ensp;&ensp;&ensp;&ensp;这个中修饰方式是比较常见，在一些工具类中或者正常类中定义一个不可以改变量，并且所有对象共享，就可以使用这种方式\n\n```java\npublic class FinalVarDemo3 \n{\n    //final修饰静态变量会变成静态常量\n    //一共有两种创建于赋值方式\n    static final double PI = 3.14;\n    //先定义，在使用静态代码块进行赋值操作\n    static final String STR;\n    static\n    {\n        STR = \"字符串\";\n    }\n}\n```\n\n### 使用final关键字修饰成员方法\n\n&ensp;&ensp;&ensp;&ensp;使用final关键字修饰成员方法，此时这个方法会变成【最终方法】，此方法不可以被子类重写，但是子类可以继承\n\n&ensp;&ensp;&ensp;&ensp;final关键字修饰成员方法的时机：父类只提供方法继承，但是不允许子类重写就可以使用final关键字\n\n```java\npublic class Father \n{\n    //定义一个final修饰的方法\n    public final void show()\n    {\n        System.out.println(\"子类只能继承不能重写\");\n    }\n    } \n    class Son extends Father\n    {\n        //IDEA的错误提示信息 cannot override 'show()' in 'com.qfedu.Final.Father';\n        // overridden method is final\n        //提示这个方式使用final修饰无法重写，但是允许继承\n        @Override\n        public void show()\n        {\n        }\n}\n```\n\n","tags":["Java"],"categories":["编程语言","Java"]},{"title":"16.数组","url":"/post/86a3300e.html","content":"\n# <center>知识点一：数组的概念</center>\n\n数组在内存中是一块 连续的空间，可以保存 相同类型 多个数据的容器 \n\n# <center>知识点二：数组的特点</center>\n\n数组中保存数据必须是相同的数据类型\n\n数组是定长的（数组一旦定义不能改变长度）\n\n# <center>知识点三：数组的创建</center>\n\n## <center>1、静态初始化语法</center>\n\n```java\n语法1：数据类型[] 数组名 = {数据1,数据2,...};\n\n语法2：数据类型 数组名[] = {数据1,数据2,...};\n\n语法3：数据类型[] 数组名 = new 数据类型[]{数据1,数据2,...};\n```\n\n\n\n## <center>2、动态初始化语法</center>\n\n```java\n语法1: 数据类型[] 数组名 = new 数据类型[数组的长度];\n语法2: 数据类型 数组名[] = new 数据类型[数组的长度];\n```\n\n```java\nint[] arr = new int[3];\n//存数据\narr[0] = 11;\narr[1] = 22;\narr[2] = 33;\n//取数据\nSystem.out.println(\"第二个元素为：\"+arr[1]);\nSystem.out.println(\"第三个元素为：\"+arr[2]);\n//获取数据的长度\nSystem.out.println(arr.length);\n//错误：数组下标越界\nSystem.out.println(arr[3]);\n```\n\n## <center>3、数组的细节</center>\n\n1）数组中每一个数据称之为一个元素\n\n2）数组的元素通过下标（索引）进行访问    \t数组名[下标]\n\n3）数组下标范围为：0~数组长度-1\n\n4）数组长度获取方式：\n\n&ensp;&ensp;&ensp;&ensp;数组名.length  属性获取\n\n5）数组在定义的时候就需要确定长度\n\n&ensp;&ensp;&ensp;&ensp;数组的长度如果超出的边界会报错（ArrayIndexOutOfBoundsException数组下标越界异常） \n\n```java\npublic class Demo05\n{\n    public static void main(String[] args)\n    {\n        //1、定义数组\n        //int[] arr = {12,13,14,2,3,4};\n        int arr[] = {12,13,14,2,3,4};\n        //如果定义数组，直接输出数组那么输出的是数组地址（数组名是地址）\n        //System.out.println(arr);\n        //存值：静态初始化的数组，已经赋好值，如果再进行赋值，那么就会覆盖原来的数据\n        System.out.println(\"数组的第一个元素为：\"+arr[0]);\n        arr[0] = 120;\n        arr[2] = 1400;\n        //取值\n        System.out.println(\"数组的第一个元素为：\"+arr[0]);\n        System.out.println(\"数组的第一个元素为：\"+arr[2]);\n        //获取数组的长度\n        System.out.println(\"数组的长度为:\"+arr.length);\n    }\n}\n```\n\n# <center>知识点四：数组在内存中存储与操作</center>\n\n内存是计算中的重要组件，临时存储的区域，作为运行程序所使用的，我们编写的程序是存放在磁盘中，但是磁盘是不会运行程序，如果要运行程序就需要放置到内存中才可以运行，运行完毕会清空内存，Java中虚拟机[VM],必须要对内存进行空间分配与管理，才可以正常运行lava程序\n\nJVM中对内存会划分为五个区域: 重点了解 “栈与堆[特别是堆区]，其实方法区，剩余了解即可“\n\n|       区域名称       |                           简要说明                           |\n| :------------------: | :----------------------------------------------------------: |\n| 程序计数器【寄存器】 |                  给cup使用，和我们开发无关                   |\n|      本地方法栈      |     JVM在使用操作系统功能的时候需要使用，和我们开发无关      |\n|        方法区        |            存储课运行的class文件、常量、静态变量             |\n|         堆区         | 存储对象或者数组的区域，它是通过代码中new创建出来，即使用new关键字创建的都是存在这个区域中，这个区域中存储数据叫做“引用类型” |\n|         栈区         | 方法运行时使用区域（包含了定义变量）这个区域是系统自行管理（栈区遵守先进后出的原则） |\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271922067.jpg\" alt=\"数组在内存中存储与操作\" style=\"zoom:67%;\" />\n\n在创建数据时会根据数组定义的存储元素数据类型，来决定数组中默认值\n\n1. 整数型数组默认值：0\n\n&ensp;&ensp;&ensp;&ensp;byte、short、int、long\n\n2. 浮点型数组默认值：0.0\n\n3. 布尔类型数组默认值：false\n\n4. 字符型数组默认值：0 或者 ' ' 或者 '\\u0000'\n\n5. 引用类型数组默认值：null \n\n&ensp;&ensp;&ensp;&ensp;null：一种特殊的值，表示当前对象在内存中没有指向任何地址\n\n&ensp;&ensp;&ensp;&ensp;\" \"表示空字符串，在内存中有对应的内存地址 \n\nJava中提供为了方便开发人员对数组中存储数据进行操作，提供一个操作概念，这个操作概念“下标”\n\n# <center>知识点五：数组的遍历</center>\n\n定义：将数组中的元素逐个获取、赋值的过程（数组的任何操作都要先遍历数组）\n\n获取数组中存储的数据----》数组名[下标值];\n\n修改或添加数据到数组中存储0----》数组名[下标值] = 值;\n\n获取数组的长度----》数组名.length\n\n数组下标从0开始到数组长度-1结束\n\n**普通for循环遍历**\n\n原理：循环变量代替数组下标进行使用，从而达到使用下标操作数据目的\n\n语法：\n\n```java\nfor(int i = 下标值 【默认值为0】;i < 数组长度;i++){\n\n    在for循环中定义循环变量i就是数组下标从0开始到数组长度-1结束这个范围内，所以使用i变量就相当于在\t使用下标，就可以在循环体重复使用\n\n    数组名[循环变量] ---》间接的等于操作数组中值\n}\n```\n\nPS：此循环是比较推荐日常使用，虽然比较繁琐【需要使用下标】，但是它可以完成对数据的所有【增删改查】\n\n```java\npublic class Demo02\n{\n    public static void main(String[] args)\n    {\n        //提供一个数组\n        int [] arr = {32,323,32,42,4,5,235,353,456323,456,1};\n        //打印数组中每一个数据值\n        //首先不可能使用打印数组名字方式进行打印\n        System.out.println(arr);    //数组地址\n        //其次这种方式也不可取，使用下标一个一个打印---》如果数组中存储数据特别多：1000个\n        System.out.println(arr[0]);\n        System.out.println(arr[1]);\n        System.out.println(arr[2]);\n        System.out.println(arr[3]);\n        System.out.println(arr[4]);\n        System.out.println(arr[5]);\n        System.out.println(arr[6]);\n        System.out.println(arr[7]);\n        System.out.println(arr[8]);\n        System.out.println(arr[9]);\n        System.out.println(arr[10]);\n        System.out.println(\"----------------------------------------------------\");\n        //使用循环方式才是处理数组的真正方式\n        for (int i = 0; i < arr.length; i++)\n        {\n            //利用原理：i值这个循环变量，使用i这个循环变量变换范围，即 下标的范围从而进行数组的操作\n            System.out.println(arr[i]);\n        }\n    }\n}\n```\n\n**增强for循环遍历**\n\n&ensp;&ensp;&ensp;&ensp;增强for循环是Java专门为了数组和集合而提供一个操作方式，它只能适用于数组或集合，其他的操作不能使用增强for循环\n\n**快捷方式：**\n\n&ensp;&ensp;&ensp;&ensp;**数组名.for+回车**\n\n语法：\n\n```java\nfor(数组中存储数据(元素)的数据类型 变量名 : 数组名字){\n    \n\t此时for循环中小括号中定义变量会分别获取到数组每一个数据的值，可以在循环体内操作这个变量\n}\n```\n\n**PS：增强for循环只适合简单打印和计算，不适合对数据中值进行改变操作（增删改查）**\n\n```java\n//使用增强for循环变量数组中每一个元素\nfor (int a:arr)\n{\n    //a变量就会获取数组中每一个数据值\n    System.out.println(a);\n}\n```\n\n```java\npublic class Demo06\n{\n    public static void main(String[] args)\n    {\n        //遍历数组---->取值\n        int arr [] = {12,3,4,12,45,5};\n        for (int i = 0; i < arr.length; i++)    //i：代表数组的下标数\n        {\n            System.out.println(arr[i]);\n        }\n        //遍历数组--->存值\n        Scanner sr = new Scanner(System.in);\n        int arr1[] = new int[4];\n        for (int i = 0; i < arr1.length; i++)\n        {\n            System.out.println(\"请输入第\"+(i+1)+\"个数\");\n            //给数组中每一个元素赋值\n            arr1[i] = sr.nextInt();\n        }\n        //遍历数组进行输出\n        for (int i = 0; i < arr1.length; i++)\n        {\n            System.out.println(arr1[i]);\n        }\n    }\n}\n```\n\n# <center>知识点六：数组的使用问题</center>\n\n```java\npublic class Demo\n{\n    public static void main(String[] args)\n    {\n        /**\n         * 数组是引用类型，因为使用new关键字创建数组，在堆会开辟中间存储数组中数据\n         * 在Java中有一个数据可以专门针对引用类型进行赋值----》null 【空】\n         * null会代表引用类型在堆中没有开辟空间\n         */\n        //定义一个int类型数组arr，使用null进行赋值操作\n        int [] arr = null;\n        /**\n         * 一定要注意：因为使用null作为arr数组初始化操作，所以证明在堆中并没有堆arr数组进行空间开开辟\n         *          所以这样数组千万别使用，否则就会出现，空指针异常问题NullPointerException\n         */\n        //System.out.println(\"获取数组中第一个元素的值：\"+ arr[1]);\n        //System.out.println(arr); //null\n\n        //创建一个int类型数组，可以存储10个元素\n        int [] arr2 = new int [10];\n        //此时证明数组在堆中开辟了10个存储空间可以存储10个数据\n        System.out.println(\"获取数组中第一个元素的值：\"+ arr2[0]);\n\n        arr2 = null;\t//因为arr2是引用类型，所以被赋值为null值，这样赋值相当于将arr2与堆中地址切断联系\n        //此时arr2就不能再进行操作了，因为已经没有堆中地址，如果进行操作就会出现 空指针异常问题NullPointerException\n        //System.out.println(arr2[2]);\n    }\n}\n```\n\n# <center>知识点七：数组的应用</center>\n\n```java\npublic class Demo02\n{\n    public static void main(String[] args)\n    {\n        int nums [] = {23,345,2,3,45,63,23};\n        System.out.print(\"最大值为：\");\n        System.out.println(max(nums));\n        System.out.print(\"最小值为：\");\n        System.out.println(min(nums));\n        System.out.print(\"平均值为：\");\n        System.out.println(mean(nums)/nums.length);\n        System.out.println(\"结果为：\");\n        int num = 34;\n        System.out.println(same(nums,num));\n    }\n    //最大值\n    public static int max(int nums1[])\n    {\n        int max1 = nums1[0];\n        for(int i = 0; i < nums1.length; i++)\n        {\n            if(max1 < nums1[i])\n            {\n                max1 = nums1[i];\n            }\n        }\n        return max1;\n    }\n    //最小值\n    public static int min (int nums2[])\n    {\n        int min1 = nums2[0];\n        for (int i = 0; i < nums2.length; i++)\n        {\n            if (min1 > nums2[i])\n            {\n                min1 = nums2[i];\n            }\n        }\n        return min1;\n    }\n    //平均值\n    public static int mean(int nums3[])\n    {\n        int sum = 0;\n        for (int i = 0; i < nums3.length; i++)\n        {\n            sum += nums3[i];\n        }\n        return sum;\n    }\n    //给定一个数组，传入一个数字，如果在数组中存在这个数字，输出这个数字在数组中的下标，否则输出-1\n    public static int same (int nums4[],int nums5)\n    {\n        for (int i = 0; i < nums4.length; i++)\n        {\n            if (nums5 == nums4[i])\n            {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n```\n\n# <center>知识点八：数组的扩容与缩容</center>\n\n步骤1：定义一个新数组，新数组的长度比原数组长（扩）、短（缩）\n\n步骤2：将原来数组的元素拷贝到新数组中\n\n步骤3：将数组名指向新数组的地址\n\n扩容：\n\n```java\npublic class Demo03\n{\n    public static void main(String[] args)\n    {\n        int arr [] = {1,2,3};\n        num (arr);\n    }\n    public static void num(int arr1[])\n    {\n        //定义一个新数组\n        int newArr[] = new int[arr1.length+1];\n        for (int i = 0; i < arr1.length; i++)\n        {\n            //将老数组的元素拷贝到新数组中\n            newArr [i] = arr1[i];\n        }\n        //数组名指向新数组的地址\n        arr1 = newArr;\n        //验证\n        arr1[3] = 4;\n        for (int i = 0; i < arr1.length; i++)\n        {\n            System.out.println(arr1[i]);\n        }\n    }\n}\n```\n\n缩容：\n\n```java\n//定义原数组\nint[] arr1 = {1,3,46,22,11};\n//1、定义新数组\nint[] arr2 = new int[arr1.length-1];\n//2、数组拷贝\nfor (int i = 0; i < arr2.length; i++)\n{\n    arr2[i] = arr1[i];\n}\n//3、将原数组的变量指向新数组\narr1 = arr2;\nfor (int i = 0; i < arr2.length; i++)\n{\n    System.out.println(arr1[i]);\n}\n```\n\n# <center>知识点九：数组拷贝</center>\n\n## <center>1、通过自定义循环将原数组中的元素拷贝到新数组中</center>\n\n## <center>2、System类提供数组拷贝方法</center>\n\n### 语法\n\n```java\nSystem.arraycopy(src,srcPos,dest,destPos,length);\n参数说明：\n    src：原数组\n    srcPos：指定原数组的起始地址\n    dest：目标数组\n    destPos：目标起始位置\n\tlength：拷贝元素的个数\n```\n\n```java\npublic class Demo04\n{\n    public static void main(String[] args)\n    {\n        int arr[] = {11,33,66};\n        int newArr[] = new int[arr.length+5];\n        System.arraycopy(arr,1,newArr,1,2);\n        for (int i = 0; i < newArr.length; i++)\n        {\n            System.out.print(newArr[i]+\"\\t\");\n        }\n    }\n}\n```\n\n## <center>3、Arrays类提供数组拷贝方法</center>\n\n### 语法\n\n```java\n新数组类型 新数组名 = Arrays.copyOf(original,newLength);\n参数说明：\n    original：原数组\n    newLength：新数组的长度\n    返回值：返回新数组\n```\n\n```java\npublic class Demo04\n{\n    public static void main(String[] args)\n    {\n        int arr[] = {11,33,66};\n        int newArr[] = Arrays.copyOf(arr,arr.length+5);\n        for (int i = 0; i < newArr.length; i++)\n        {\n            System.out.print(newArr[i]+\"\\t\");\n        }\n    }\n}\n```\n\n# <center>知识点十：数组中的增删改查操作</center>\n\n## <center>1、增加数据</center>\n\n数组对于开发而言最主要作用就是对数据存储操作，存储数据化必然需要向数据中增加数据操作\n\n向数组中添加数据:可以使用方式有很多“文件、数据库、键盘输入、随机数等等”\n\n既然是增加数据分为两种添加方式“一种叫做静态添加和一种叫做动态添加”\n\n一般静态添加使用较少，它的操作还就是在数组的时候，直接数组中存储数据\n\n```java\nint[] arr = new int[]{1,2,3,4,5,6,7};\nint[] arr2 = {1,2,3,4,5,5,6,7};\n```\n\n多使用动态添加，键盘输入数据、随机数、文件读取内容之后存储、数据库操作之后存储\n\n现在而言可以使用基本上‘“键盘输入和随机数据”\n\n```java\npublic class ArrayDemo\n{\n    public static void main(String[] args) \n    {\n        //定义一个int类型数组，数组的长度为10\n        int[] arr = new int[10];\n        //1.随机数赋值\n        for(int i = 0 ; i<arr.length;i++)\n        {\n            arr[i] = (int)(Math.random()*100);\n        }\n        //或者\n        //2.通过控制台输入\n        Scanner input = new Scanner(System.in);\n        for(int i = 0 ; i<arr.length;i++)\n        {\n           arr[i] = input.nextInt();\n        }\n    }\n}\n```\n\n## <center>2、查找和修改数据</center>\n\n数组中查找某个元素是否存在，一共有两种方式“线性（顺序）查找 和 二分（折半）查找”\n\n单从效率而言“二分查找远远高于线性查找”，从书写代码而言“线性查找要远远简单于二分查找”\n\n线性（顺序）查找执行原理：就是从数组第一个元素逐一向后查找每一个元素\n\n线性查找最优解 1次 【数组第一个元素就是要查找的元素】\n\n线性查找最坏解 数组长度次数 【数组最后一个元素是要查找的元素】\n\n线性查找最大有点就是简单易用，效率确实不高\n\n```java\npublic class ArrayDemo2\n{\n    public static void main(String[] args)\n    {\n        //1.提供一个int类型数组，数组长度10\n        int[] arr = new int[10];\n        //2.通过随机数向数组中进行赋值操作\n        for(int i = 0 ; i<arr.length;i++)\n        {\n            arr[i] = (int) (Math.random() * 100);\n        }\n        System.out.print(\"arr数组中存储数据是:[\");\n        for(int i =0 ; i<arr.length;i++)\n        {\n            if(i != arr.length-1)\n            {\n                System.out.print(arr[i]+\",\");\n            }\n            else\n            {\n                System.out.println(arr[i]+\"]\");\n            }\n        }\n        System.out.println(\"请输入您要在arr数组中要查找的数据：\");\n        Scanner input = new Scanner(System.in);\n        int num = input.nextInt();\n        //提供线性(顺序)查找，判断要查找数据是否存在在当前的数组中\n        for(int i = 0 ;i<arr.length;i++)\n        {\n            if(arr[i] == num)\n            {\n                //提供修改\n                // arr[i] = 10000;\n                //提示找到了数据\n                System.out.println(\"您输入数据是在数组中存储的下标为：\"+i);\n                return;\n            }\n        }\n        System.out.println(\"没有找到数据\");\n    }\n}\n```\n\n## <center>3、删除数据</center>\n\n在没有使用数组的“减容”之前，数组中是没有真正删除的\n\n什么时“减容”？根据删除元素个数动态缩小数组容量（大小/长度）\n\n如何在数组中执行删除操作？\n\n根据中存储元素类型来决定，如果数组中存储的是基本数据类型，采用后一个数据覆盖前一位数据的方式进行删除，并记录删除个数以便在打印时，可以不输出多余数据【这个操作不是”减容“，数组长度不会改变】，如果数组中存储的是引用数据类型，依旧会采用后一个数据覆盖前一个数据方式，会在最后一个数据位置添加 null值，或者直接要删除的赋值为null，并记录删除个数以便在打印中，不输出多余的数据\n\n```java\npublic class ArrayDemo3 \n{\n    public static void main(String[] args) \n    {\n        //1.提供一个int类型数存储10个元素\n        int[] arr = new int [10];\n        //2.提供动态赋值同时打印数组中数据\n        System.out.print(\"arr数组中存储的数据[\");\n        for(int i = 0 ; i<arr.length;i++)\n        {\n            arr[i] = (int)(Math.random()*100);\n            if(i != arr.length-1)\n            {\n                System.out.print(arr[i]+\",\");\n            }\n            else\n            {\n                System.out.println(arr[i]+\"]\");\n            }\n        } \n        System.out.println(\"删除之前arr数组的长度：\"+arr.length);\n        //3.提供外界输入的数据进行删除操作\n        System.out.println(\"请输入您要删除的数据:\");\n        Scanner input = new Scanner(System.in);\n        int num = input.nextInt();\n        //提供一个变量存储删除数据的个数\n        int count = 0;\n        //3.1提供一个循环遍历数组寻找要删除数据\n        for(int i = 0; i<arr.length;i++)\n        {\n            if(arr[i] == num)\n            {\n                //如果if语句成立就证明数组中是存在要删除的数据的\n                //3.2在提供一个循环使用删除数据位置的后一个数据向前覆盖操作\n                for(int j = i;j<arr.length-1;j++){\n                arr[j] = arr[j+1];\n            } \n            //循环结束之后就证明删除完成，统计计数\n            count++;\n        }\n        } \n        //真删除【减容】\n        //在创建一个数组存储删除之后的数据\n        /* int[] temp = new int[arr.length-count];\n        for(int i = 0 ; i<arr.length-count;i++)\n        {\n            temp[i] = arr[i];\n        } \n        //将存储着真删除数据的数据引用赋值给arr\n        arr = temp;\n        temp = null; //删除temp与堆中关联\n        //在打印arr数组就是真删除，长度也改变了\n        System.out.println(\"真删除之后arr数组的长度：\"+arr.length);*/\n        //4.提供打印操作\n        System.out.print(\"删除数组中数之后arr数组中元素：[\");\n        for(int i = 0 ; i<arr.length-count;i++)\n        {\n            if(i != arr.length-1-count)\n            {\n               System.out.print(arr[i]+\",\");\n            }\n            else\n            {\n                System.out.println(arr[i]+\"]\");\n            }\n        } \n        System.out.println(\"删除之后arr数组的长度：\"+arr.length);\n    }\n}\n```\n\n# <center>知识点十一：数组的排序</center>\n\n数组的排序主要的目的是为了让数组中存储数据有一定顺序（升序或降序），在对数组中数据进行排序时提供很多种算”冒泡、选择、插入、快速、归并和堆排序“\n\nPS：这里提供排序的目的是为了让大家掌握一种对数组中数据操作方式，除此之外就是为了应该笔试操作，在实际开发中基本你上Java都是使用系统提供好的排序方法，除非你开发公司要求，排序操作需要个人实现，否则都会使用是系统提供排序，因为系统排序简单而且效率高\n\n## <center>1、冒泡排序</center>\n\n冒泡排序的规则：将数组中相邻的两个元素进行比较，如果前一个元素大于后一个元素，交换当前两个元素的位置，这个逻辑依次执行，直到所有元素都执行比较操作之后，就会有一个数据放置到数组中正确位置上\n\nPS：**在没有强调使用排序时是升序还是降序的前提下，默认所有排序都是升序**\n\n升序是指从小到大的一个排序 降序是指从大到小一个排序\n\n模拟一轮冒泡排序对数组的操作\n\n```java\n*假设数组中存储数据是【6,9,1,3,5】 使用冒泡对数组中数据进行排序操作：原则就相邻数据进行比较*\n*第一次首先执行是6和9之间元素的比较，如果6>9成立，交换两个元素的位置，否则不交换*\n*第一次执行完毕的结果是【6,9,1,3,5】*\n*第二次执行9和1之间元素的比较，如果9>1成立，交换两个元素的位置，否则不交换*\n*第二次执行完毕的结果是【6,1,9,3,5】*\n*第三次执行9和3之间元素的比较，如果9>3成立，交换两个元素的位置，否则不交换*\n*第三次执行完毕的结果是【6,1,3,9,5】*\n*第四次执行9和5之间元素的比较，如果9>5成立，交换两个元素的位置，否则不交换*\n*第四次执行完毕的结果是【6,1,3,5,9】*\n此时经过冒泡的一轮排序之后，数组中存储的数据9，出现在了正确位置上，冒泡排序在进行排序时，\n是先将数据中最大值放置到正确位置，类似于“水中出现气泡都要上浮，按照身高站排”\n```\n\n```java\npublic class ArrayDemo4 {\n    public static void main(String[] args) \n    {\n        //提供一个int类型数组，存储10个元素\n        int[] arr = new int[10];\n        //随机向int数组进行赋值操作\n        System.out.print(\"arr数组在没有排序之前数组中数据[\");\n        for(int i =0 ; i<arr.length;i++)\n        {\n            arr[i] = (int)(Math.random()*100);\n            if(i != arr.length-1)\n            {\n                System.out.print(arr[i]+\",\");\n            }\n            else\n            {\n                System.out.println(arr[i]+\"]\");\n            }\n        } \n        System.out.println(\"-----------使用冒泡排序对数据进行排序-----------\");\n        for(int i= 0 ;i<arr.length;i++) \n        {\n            //冒泡排序核心代码执行多次，原则就是有多少个数据就执行多少次核心\n            for (int j = 0; j < arr.length - 1; j++) \n            {\n                if (arr[j] > arr[j + 1]) \n                {\n                    //交换两个元素的位置\n                    int tmp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = tmp;\n                }\n            }\n        } \n        System.out.print(\"arr数组在排序之后数组中数据[\");\n        for(int i =0 ; i<arr.length;i++)\n        {\n            if(i != arr.length-1)\n            {\n                System.out.print(arr[i]+\",\");\n            }\n            else\n            {\n                System.out.println(arr[i]+\"]\");\n            }\n        }\n    }\n}\n```\n\n## <center>2、选择排序</center>\n\n选择排序的规则：选择排序会固定一个位置，依次和后面每一个数据进行比较，如果固定位置值大于后续位置数据，交换两个位置值，然就重复上述的操作，直到一轮结束之后，会有一个数据放到正确的位置上\n\nPS：在没有强调使用排序时时升序还是降序的前提下，默认所有排序都是升序\n\n升序是指从小到大的一个排序 降序是指从大到小一个排序\n\n利用选择排序执行一轮操作\n\n```java\n*假设数组中存储数据是【6,9,1,3,5】 使用选择对数组中数据进行排序操作：原则就固定位置数据\n与后续数据进行比较，起始固定值就是数组中第一个元素的位置，固定数据位置依次和后续数据进行比较*\n*第一次固定位置数据是6与后续数据9进行比较操作 如果 6>9 交换两个元素的位置，否则不交换*\n*第一次比较操作之后的结果是：【6,9,1,3,5】*\n*第二次固定位置数据是6与后续数据1进行比较操作，如果 6>1 交换两个元素的位置，否则不交换*\n*第二次比较操作之后的结果是：【1,9,6,3,5】*\n*第三次固定位置数据是1与后续数据3进行比较操作，如果 1>3 交换两个元素的位置，否则不交换*\n*第三次比较操作者之后的结果是：【1,9,6,3,5】*\n*第四次固定位置数据是1与后续数据5进行比较操作，如果 1>5 交换两个元素的位置，否则不交换*\n*第四次比较操作者之后的结果是：【1,9,6,3,5】*\n选择排序执行完一轮操作之后，有一个数据放置到正确的位置上，对于选择排序而言，先排序出正确位\n置的数据是最小值\n```\n\n```java\npublic class ArrayDemo5 \n{\n    public static void main(String[] args) \n    {\n        //提供一个int类型数组，存储10个元素\n        int[] arr = new int[10];\n        //随机向int数组进行赋值操作\n        System.out.print(\"arr数组在没有排序之前数组中数据[\");\n        for(int i =0 ; i<arr.length;i++)\n        {\n            arr[i] = (int)(Math.random()*100);\n            if(i != arr.length-1)\n            {\n                System.out.print(arr[i]+\",\");\n            }\n            else\n            {\n                System.out.println(arr[i]+\"]\");\n            }\n        } \n        System.out.println(\"-----------使用选择排序对数据进行排序------------\");\n        //选择排序的核心操作，比较排序数组中数据的原则就是数组中有多少个数据就排序多少次\n        for(int i = 0 ; i<arr.length;i++)\n        { //这个循环是排序次数\n            /*\n            选择排序的固定数据位置如何提供？ 外层循环执行一次内层循环执行多次，\n            外层循环的循环变量在没有内层循环执行完毕之前，不会进行自增操作的，可以 利用外层的\n            循环变量作为固定位置\n            内层的循环操作与循环变量作为后续每一个数据进行比较操作\n            */\n            for(int j = i+1;j<arr.length;j++)\n            {\n                if(arr[i] > arr[j])\n                {\n                    int tmp = arr[i];\n                    arr[i] = arr[j];\n                    arr[j] = tmp;\n                }\n            }\n        } \n        System.out.print(\"arr数组在排序之后数组中数据[\");\n        for(int i =0 ; i<arr.length;i++)\n        {\n            if(i != arr.length-1)\n            {\n                System.out.print(arr[i]+\",\");\n            }\n            else\n            {\n                System.out.println(arr[i]+\"]\");\n            }\n        }\n    }\n}\n```\n\n## <center>3、折半查找法</center>\n\n二分查找也是数组中查找数据一种算法，比线性（顺序）查找效率高很多，每次查找数据的时候，都是当前查找数据量一半，这样可以大大减少无用数据比较查找，但是二分查找书写比线性查找要复杂，除此之外二分查找有一个必须要实现的规则“数组中数据必须进行排序”，二分查找虽然效率高但是实现复杂要求多\n\n**我们要实现二分查找数据之前，必须对数组中的数据进行排序操作**\n\n![折半查找法解析](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271922077.jpg)\n\n条件：要排序好的数据\n\n思路：\n\n&ensp;&ensp;&ensp;&ensp;首先找到数组中的中间的元素，与要查找元素进行比较，如果相等，那么就直接找到了\n\n&ensp;&ensp;&ensp;&ensp;如果比中间的元素大，那么表示查找元素在中间值的右边。所以最小值的下标等于中间值的下标+1\n\n&ensp;&ensp;&ensp;&ensp;如果比中间的元素小，那么表示查找元素在中间值的左边。所以最大值的下标等于中间值的下标-1 \n\n```java\npublic class ArrayDemo6 \n{\n    public static void main(String[] args) \n    {\n        //1.提供一个int类型数组，存储数据10个\n        int[] arr = new int[10];\n        //2.随机向数组中填充数据\n        for(int i = 0 ; i<arr.length;i++)\n        {\n            arr[i] = (int)(Math.random()*100);\n        } \n        //对数组中数据提供排序操作\n        for (int i= 0 ;i<arr.length;i++)\n        {\n            for(int j = i+1;j<arr.length;j++)\n            {\n                if(arr[i] > arr[j])\n                {\n                    int temp = arr[i];\n                    arr[i] = arr[j];\n                    arr[j] = temp;\n                }\n            }\n        } \n        System.out.print(\"arr数组排序之后结果是:[\");\n        for (int i = 0 ; i<arr.length;i++)\n        {\n            if(i != arr.length-1)\n            {\n                System.out.print(arr[i]+\",\");\n            }\n            else\n            {\n                System.out.println(arr[i]+\"]\");\n            }\n        } \n        System.out.println(\"请输入您要查找的数据：\");\n        Scanner input = new Scanner(System.in);\n        int num = input.nextInt();\n        //提供二分查找的核心代码\n        //提供开始值和结束值\n        int beginIndex = 0;\n        int endIndex = arr.length-1;\n        //提供中间值计算\n        int middleIndex = (beginIndex+endIndex)/2;\n        //因为我们也不能确定执行多少次循环可以将数据查找到，所以可以提供一个死循环\n        while(true)\n        {\n            //如果查找的数据 > 中间值获取的数据\n            if(num > arr[middleIndex])\n            {\n                //移动beginIndex的值\n                beginIndex = middleIndex+1;\n\n            }\n            else if(num < arr[middleIndex])    //如果查找的数据 < 中间值获取的数据\n            {\n                //移动endIndex的值\n                endIndex = middleIndex -1;\n            }\n            else\n            {\n                //说明查找的数据是 == 中间值获取的数据【找到了】\n                System.out.println(\"要查找的数据在数组中下标的位置：\"+middleIndex);\n                break;\n            } \n            //只要不执行 else操作 就证明 数据没有找到并且移动了beginIndex 或 endIndex的值 所以要重新计算middleIndex\n            middleIndex = (beginIndex+endIndex)/2;\n            //还需要提供一个判断，移动了beginIndex和endIndex之后需要判断是否\n            beginIndex>endIndex来决定不需要在查找\n            if(beginIndex > endIndex)\n            {\n                System.out.println(\"要查找的数据不在数组中！！！\");\n                break;\n            }\n        }\n    }\n}\n```\n\n## <center>4、Arrays工具类排序</center>\n\n什么是工具类?\n\n&ensp;&ensp;&ensp;&ensp;工具类是当前项目中大量使用到的一些常用方法被统一的封装到一个类中进行管理,通过这类就可以调用类中所提供方法进行操作完成需要需求,这样类就叫做工具类\n\n&ensp;&ensp;&ensp;&ensp;而在JavaAPI中有大量工具类,是Java原码开发人员为了方便Java程序猿在开发程序时,使用到一些普遍的方法进行了统一的实现,提供给程序猿使用,程序猿无需二次实现,只需要调用方法就可以完成处理逻辑需求.\n\n&ensp;&ensp;&ensp;&ensp;现在学习数组结构并不是非常方便,因为我们需要对数组进行增删改查操作时候需要自身手动完成代码还有一些排序等操作,在这种情况下Java开发人员为了方便我们使用个数组专门提供这个样一个工具类,类中封装了一些常用方法,以便我们使用数组进行开发\n\n#### API的使用\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271923503.jpg\" alt=\"API的使用\" style=\"zoom: 50%;\" />\n\nString的排序规则是：每一个字符在Unicode码表中都对应有一个数据\n\n```java\n//Arrays工具类的使用【常用方法】\npublic class ArraysDemo \n{\n    public static void main(String[] args) \n    {\n        //1. toString方法 ---》 可以将数组中内容转换为字符串形式可以方便打印查看\n        /*\n        PS:刚刚观察API中可以发现Arrays工具类中方法都是使用static修饰的\n        如果使用static修饰方法在同一个类中（文件）调用是可以直接使用方法名方式进行调用\n        如果使用static修饰方法在不同类中（文件）调用此时就需要明确这个方法出自于那个类所以\n        提供调用方式\n        类名.静态方法(参数赋值操作);\n        */\n        //提供一个int类型数组，数组中存储了一些数据\n        int[] arr = new int[10];\n        for(int i = 0 ; i<arr.length;i++)\n        {\n            arr[i] = (int)(Math.random()*100);    //强转int Math.random：产生随机数\n        } \n        System.out.println(\"数组中存储的数据是：\"+Arrays.toString(arr));\n        //2.对数组中数据提供排序操作 参数就是排序的数组\n        Arrays.sort(arr); //默认是升序\n        System.out.println(\"排序之后数组中数据是：\"+Arrays.toString(arr));\n        /*\n            这个方法是可以降序的，但是以现在所学暂时做不到，所以降序排序还是需要提供【选择或冒泡】\n排序\n            如果使用这个方法进行降序排序，需要实现一个Comparator接口指定排序规则才可以降序操作\n        */\n        /*\n            3.提供二分查找【使用这个方法之前必须对数组进行排序操作，如果在数组中找到数据则返回对应\n            数据下标\n            如果找不到数据就返回一个负数】\n            方法的第一个参数是 要查找的数组\n            方法的第二个参数是 要在数组中查找的数据\n        */\n        int index = Arrays.binarySearch(arr, 55);\n        System.out.println(\"55这个数据是否存在arr数组中？\"+(index >= 0));\n        /*\n            4. 可以使用这个方法更加便捷进行数组的扩容 和 减容操作\n            copyOf 提供一个可以对数据进行复制（数组中内容）的方法，并且这个方法会得到一个返回\n            值【新的数组】\n            第一个参数是要复制的数组\n            第二个参数是要新数组长度\n        */\n        int[] ints = Arrays.copyOf(arr, 20);\n        System.out.println(\"复制arr数组之后的全新数组ints中的内容：\"+Arrays.toString(ints));\n        /*\n            5. 可以使用这个方法对数据中某个范围数据进行复制并生成一个全新数组\n            PS:复制位置是数据下标位置\n            第一个参数是复制的数组\n            第二个参数是从那个下标位置开始复制（这个位置是包含在内）\n            第三个参数是到那个下标位置结束复制（这个位置是不包含在内）\n        */\n        int[] ints1 = Arrays.copyOfRange(arr, 2, 5);\n        System.out.println(Arrays.toString(ints1));\n        /*\n            6. 如何判断两个数组是相等的\n            数组是引用类型，所以判断引用类型是否相等是不可以使用 基本数据类型中使用 == 进行比较操\n作\n            如果使用 == 比较两个引用类型，那么比较就是引用类型【实际在内存中地址】\n            如果两个引用类型都是new出来，地址是不会相等，所有引用类型是不可以使用 == 进行比较作\n            所以需要比较两个引用类型是否相等，就需要使用到Java中所提供equals方法\n            这个方法是Java专门针对引用类型所提供比较方法，它主要的比较的是引用类型中存储数据是否相等\n            即如果两个数组中存储数据 个数和内容是完全一样，那么equals方法就会认为这两个数组是相等\n        */\n        int[] arr1 = {1,2,3};\n        int[] arr2 = {1,2,3};\n        System.out.println(\"使用 == 比较arr1和arr2是否相等？\"+ (arr1 == arr2));\n        System.out.println(\"使用equals方法比较arr1和arr2是否相\n等？\"+Arrays.equals(arr1,arr2));\n    }\n}\n```\n\n# <center>知识点十二：二维数组</center>\n\n## <center>1、定义</center>\n\n一维数组中的每一个元素，存储的是一个数据\n\n二维数组中的每一个元素，存储的是一个一维数组\n\n```tex\n{{},{},{}}，里面的大括号就是一个二维数组数，打括号里面打括号里面的元素个数就是一维数组的个数\n```\n\n## <center>2、创建二维数组</center>\n\n### （1）静态初始化语法\n\n```java\n语法1：数据类型 数组名 = {{元素1,元素2,...},{元素1,元素2,...},.....};\n语法2：数据类型 数组名 = new 数据类型{{元素1,元素2,...},{元素1,元素2,...},.....};\n```\n\n### （2）动态初始化语法\n\n```java\n语法：数据类型 数组名 = new 数据类型  [二维数组的长度][一维数组长度];\n注意：二维数组的长度必须要定义，一维数组的长度可以暂时不定义 \n```\n\n## <center>3、二维数组的使用</center>\n\n注意：\n\n&ensp;&ensp;&ensp;&ensp;1）在定义二维数组的时候，一维数组可以暂时不用定义，等使用的时候再定义，如果定义就表示每一个一维数组的长度是一样的了。\n\n&ensp;&ensp;&ensp;&ensp;2）第一个为行数，第二个为列数\n\n&ensp;&ensp;&ensp;&ensp;3）二维数组的长度是二维数组中有几个一维数组长度就是多少\n\n```java\npublic class Demo01\n{\n    public static void main(String[] args)\n    {\n        //静态初始化\n        int arr[][] = {{13,42,42},{34,16,34,2},{42,3,6,1}};\n        //使用数组\n        System.out.println(\"二维数组中第一个一维数组中的第一个元素：\"+arr[0][0]);\n        System.out.println(\"二维数组中第二个一维数组中的第三个元素：\"+arr[1][2]);\n        System.out.println(\"二维数组的长度：\"+arr.length);\n        //动态初始化\n        int arr1 [][] = new int[32][];\n        //此时，arr1[0](一维数组长度)这个数组还没有定义\n        arr1 [0] = new int [2];\n        arr[0][0] = 11;\n        arr1[0][1] = 22;\n        arr1[1] = new int[1];\n        arr[1][0] = 88;\n        System.out.println(\"二维数组中第一个一维数组中的第一个元素：\"+arr1[0][0]);\n        System.out.println(\"二维数组中第二个一维数组中的第一个元素：\"+arr1[1][0]);\n        System.out.println(arr1.length);\n    }\n}\n```\n\n## <center>4、二维数组遍历</center>\n\n```java\nfor (int i = 0; i < arr.length; i++) //遍历遍历出每一个一维数组（行数）\n{\n    for (int j = 0; j < arr[i].length; j++) //遍历出每一个一维数组中的元素\n    {\n        System.out.print(arr[i][j]+\"\\t\");\n    }\n    System.out.println();\n}\n```\n\n## <center>5、二维数组的应用</center>\n\n```java\npublic class Demo06\n{\n    public static void main(String[] args)\n    {\n        int[][] yhArr = new int[5][];\n        //二维数组遍历\n        for (int i = 0; i < yhArr.length; i++)\n        {\n            //yhArr[i] 表示每一个一维数组，暂未初始化\n            yhArr[i] = new int[i+1];\n            //遍历一维数组进行赋值\n            for (int j = 0; j < yhArr[i].length; j++)\n            {\n                if(j == 0 || i == j)\n                {\n                    yhArr[i][j] = 1;\n                }\n                else\n                {\n                    yhArr[i][j] = yhArr[i-1][j-1] + yhArr[i-1][j];\n                }\n            }\n        }\n        for(int i = 0;i<yhArr.length;i++)\n        {\n            for(int j = 0;j<yhArr[i].length;j++)\n            {\n                System.out.print(yhArr[i][j]+\"\\t\");\n            }\n            System.out.println();\n        }\n    }\n}\n```\n\n# <center>知识点十三：可变参数</center>\n\n可变参数是专门用于设计方法中参数而提供一种方式，使用在参数列表的，可变参数的好处在于，允许在对参数进行赋值时，可以不进行任何操作，也可以接收多个值\n\n将方法参数列表中设计了可变参数，可变参数是可以接收任意个数据，也可以接收一个数组【一维数组（即数组只有一个中括号）】，**解决了如果方法实则参数为数组类型时，在调用方法时，不需要传递数组，但是因为数组是引用类型，如果不需要传递必须赋值为null，如果赋值为null值在方法内部使用，容易出现“NullPointerException”**\n\n## <center>1、定义</center>\n\n参数的个数是动态的，可有可没有，可以多个\n\n## <center>2、语法</center>\n\n```java\n数据类型... 参数名 \n```\n\n## <center>3、特点</center>\n\n1）可变参数，在调用的时候，可以传递0~N个参数\n\n2）可变参数，可以直接当做是一个数组来使用（可变参数不能等同于数组）\n\n3）可变参数，必须放在参数列表末尾（即一个方法只能有一个可变参数）\n\n使用：定义方法求和，参数个数不确定\n\n```java\npublic class ArrayDemo7 \n{\n    public static void main(String[] args) \n    {\n        //当调用showInfosIntArray这个方法时，不需要传递int类型数据对arr赋值\n        //showInfosIntArray(null);    //err：NullPointerException\n        //外界调用可变参数方法时：\n        showInfosIntArray2(true); //可变参数不赋值\n        showInfosIntArray2(false,1);//赋值一个参数\n        showInfosIntArray2(true,1,2,3,4,5,6,7,8);//赋值多个\n        showInfosIntArray2(false,new int[]{1,2,3,4,5}); //允许赋值数组\n    } \n    //提供一个方法 方法参数类型是一个int类型数组\n    public static void showInfosIntArray(int[] arr)\n    {\n        for(int i = 0 ; i<arr.length;i++)\n        {\n            System.out.println(arr[i]);\n        }\n    } \n    //利用更加便捷方式设置方法参数--》就是使用可变参数\n    /*\n        在方法中使用可变参数需要注意：\n        1. 一个方法中参数列表只允许定义一个可变参数\n        2. 定义可变参数必须在参数列表中 定义的最后一个位置\n        3. 可变参数定义语法: 数据类型... 变量名\n        4. 可变参数即代表可变的状态，可变参数可以接收N个数据，也可以一个都不接收\n        允许使用一维数组进行赋值操作\n    */\n    public static void showInfosIntArray2(boolean res,int... arr)\n    {\n        //可变参数在方法内部的操作就是数组操作\n        for(int i = 0 ; i<arr.length;i++)\n        {\n        System.out.println(arr[i]);\n        }\n    }\n}\n```\n\n# <center>知识点十四：值传递和引用传递</center>\n\n值传递：传递的是值本身，对原来变量的值本身没有影响，所有的基本类型（栈）+String（常量区）都属于值传递\n\n引用传递：传递的是地址，对原来变量是有影响，所有的引用数据类型都属于引用传递\n\n```java\npublic class Demo08\n{\n    public static void main(String[] args)\n    {\n        //通过方法形式的传递\n        // int a = 10;\n        // System.out.println(\"传递之前a的值为：\"+a);\n        // m1(a);\n        // System.out.println(\"传递之后a的值为：\"+a);\n        //\n        // String s = \"hello\";\n        // System.out.println(\"传递之前s的值为：\"+s);\n        // m2(s);\n        // System.out.println(\"传递之后s的值为：\"+s);\n        //\n        // double[] d = {1,2,3};\n        // System.out.println(\"传递之前d[0]的值为：\"+d[0]);\n        // m3(d);\n        // System.out.println(\"传递之后d[0]的值为：\"+d[0]);\n        //通过变量形式的传递\n        int a = 10;\n        int b = a;\n        b = 20;\n        System.out.println(a);\n        String s = \"a\";\n        String s1 = s;\n        s1 = \"b\";\n        System.out.println(s);\n        int[] arr1 = {1,2,3};\n        int[] arr2 = arr1;\n        arr2[0] = 100;\n        System.out.println(arr1[0]);\n    }\n    public static void m1(int a)\n    {\n        a = 20;\n    }\n    public static void m2(String s)\n    {\n        s = \"world\";\n    }\n    public static void m3(double[] d)\n    {\n        d[0] = 100;\n    }\n}\n```\n\n","tags":["Java"],"categories":["编程语言","Java"]},{"title":"15.方法（函数）","url":"/post/6749388c.html","content":"\n之前学习了循环结构【while 、do-while、for】，学习循环的目的解决一些重复性执行的操作代码，但是循环解决的重复性从操作是有要求：【解决重复问题（操作代码）是有一定次数要求（有规律），语法格式近乎与是相同（循环变量赋初值、循环条件、循环变量的自增或自减、重复操作的语句【重复执行的代码】）】，循环是否可以解决所有的重复性问题？\n\n例如：开发一款游戏，游戏“坦克大战”，这里必然有一个操作“发射炮弹”【玩游戏的时候，炮弹发射是一直执行】，坦克大战是分为“玩家”和“电脑”，也就意味着“玩家“和“电脑”的坦克都要发射炮弹，如果让两者都来完成这个操作呢？ ---》可以将发射炮弹的操作分别对“玩家”和“电脑”提供发射炮弹的实现【同样发射炮弹的代码要实现两遍】\n\n**PS：方法：其实就是一段功能代码封装，只要利用方法中提供名字，就可以在任意位置执行一段功能代码**\n\n将一段功能代码写入到一个代码块中【大括号括起来就是代码块】，这个代码块有一个名字，每次要执行这段功能代码的时候只需要写入这个名字，就可以完成代码的执行 ---》这个就是方法\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271920306.jpg\" alt=\"方法\" style=\"zoom:67%;\" />\n\n**PS：方法与函数的关系**\n\n在某些语言中，对于上述概念所描述封装的操作叫做“函数”，在Java中我们是不区分函数和方法的名称，所以方法就是函数，函数就是方法。但是，因为Java是一门面向对象的语言所以建议称之为“方法”，“函数”的叫法偏向于面向过程\n\n# <center>知识点一：方法的定义和组成</center>\n\n## <center>1、定义</center>\n\n方法：封装了一些为了解决某个问题而编写的代码片段称之为一个方法。可以反复使用\n\n```java\n通用语法：\n访问权限修饰符 [其他修饰符] 返回值类型 方法名(参数列表)\n{\n    方法体【方法可以执行的操作】\n    return\n} \n```\n\n对应的含义：\n\n1. 访问权限修饰符：作用当前这个方法谁可以调用，在Java中权限修饰符一共有4个，这4个修饰符都可以用于修饰方法，“**这里我们先固定使用一个修饰 public【公有的】**”\n2. 其他修饰符：可以在通用语法中可以看到，使用中括号将其他修饰符括起来，代表意思是可以省略不写，从Java8开始其他修饰符一共有4个【其中包含接口中1个】，“这里我们先**固定**使用一个修饰符 **static**【静态的】”\n3. 返回值类型：作用外界调用【触发】这个方法之后可以得到一个什么样的结果返回值类型在方法中一共有三种:\"**基本数据类型、引用类型和void**【无返回值类型（方法专用）】\"这三种类型将决定可以得到一个什么样的结果\n\n&ensp;&ensp;&ensp;&ensp;PS：这个返回值类型与方法内部中return关键字有很大的关联\n\n4. 方法名： 就是方法名字，方便记忆与调用，但是需要遵守某些规则【基础规则：满足标识符命名规则，进阶规则：不要使用拼音、拼音缩写、不要写中文，英文单词（有意义），单词组成要遵守小驼峰的规则（首个单词首字母小写，后续每个单词首字母大写 ---》getStudentAge）】\n5. 参数列表: 作用提供方法从外界获取到数据在方法内部使用（参数列表写法就是在定义变量，**每个变量之间都使用【 , 】逗号分隔**）在定义方法时，方法的参数列表一共有两种定义形态：\n\n&ensp;&ensp;&ensp;&ensp;5.1 如果方法中没有使用外界传递数据在方法内部使用，此时可以不定义参数列表，直接使用空的小括号()\n\n&ensp;&ensp;&ensp;&ensp;5.2 如果方法中使用外界传递数据在方法内适用，必须定义与传递数据类型一致的变量进行接收，有多少个数据传递进来就可以定义多少个变量，但是变量与变量之间必须使用逗号分隔\n\n6. { }大括号：方法的主体，提供方法内部实现代码就写在这个大括号中\n7. 在方法体中机大括号中，可以使用到一个关键字return这个关键具备两个意义\n\n&ensp;&ensp;&ensp;&ensp;return关键字的作用是：结束一个方法或结束一个方法并带回一个返回值\n\n&ensp;&ensp;&ensp;&ensp;return关键字的使用跟返回值类型有关：\n\n&ensp;&ensp;&ensp;&ensp;如果方法的返回值类型使用void，此时方法中可以使用return关键字也可以不使用，但是如果使用绝对不允许带有返回值\n\n&ensp;&ensp;&ensp;&ensp;如果方法返回值类型使用基本数据类型或引用数据类中的一种，方法必须使用return关键字，return关键字带回的返回值需要和返回值类型一致并且有一个值\n\n方法在类文件中书写的位置\n\n1. Java中最小的程序单元是类不是方法\n2. Java中所有方法都是平级关系，不允许出现方法嵌套方法的定义\n3. Java中定义方法不存在先后顺序，影响方法的顺序是方法调用的\n\n```java\npublic class MethodDemo1\n{\n    public static void main(String[] args)\n    {\n    }\n    /\n/方法定义操作\n    /*\n    访问权限修饰符 [其他修饰符] 返回值类型 方法名(参数列表)\n    {\n        方法体\n        return;\n    } \n    *\n/\n    //方法与方法之间是平级关系，所以定义方法的时候需要定义在main方法的外部\n    /*\n    如果这个方法提供操作代码并不参与其他运算中，此时这个方法就可以定义为void返回值类型\n    */\n    public static void isLeapYear(int year)\n    {\n        //在这个方法内部提供方法的实现即可\n        if((year%4==0 && year%100!=0) ||(year%400==0)\n        {\n            System.out.println(\"是闰年：\"+year);\n        }\n        else\n        {\n            System.out.println(\"不是闰年：\"+year);\n        }\n    }\n    /\n* 加入\n    计算闰年的这个方法会参与到其他发的运算之中时，那么就需要提供返回值类型\n    表示是否是闰年方法最好的返回值类型就是 boolean类型【true代表是闰年 false代表不是闰年】\n    PS：在同一个类文件中方法是不可以出现重名，方法名字必须是唯一\n    */\n    public static boolean isLeapYear2(int year)\n    {\n        //一个方法中可以存在多个return语句，但是需要使用分支或循环语句进行分隔\n        //计算方法中有多个return语句存在，但是只会有一个return执行\n        if((year%4==0 && year%100!=0) ||(year%400==0))\n        {\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n    }\n}\n```\n\n# <center>知识点二：方法的定义和调用</center>\n\n## <center>1、无参无返回值</center>\n\n### 1）定义形式\n\n```java\npublic static void 形参名(){\n    \n} \n```\n\n### 2）调用形式\n\n```java\n形参名( );\n```\n\n案例：定义一个方法，实现关门\n\n```java\npublic class Demo01\n{\n    public static void main(String[] args)\n    {\n        //调用\n        closeDoor();\n    }\n    public static void closeDoor()\n    {\n        System.out.println(\"关门...\");\n    }\n}\n```\n\n## <center>2、有参无返回值</center>\n\n### 1）定义形式\n\n```java\npublic static void 形参名(数据类型 参数名,数据类型 形参名,...){\n    \n} \n```\n\n### 2）调用形式\n\n```java\n形参名(实参);\n```\n\n注意：调用有参方法的时候，要保证形参和实参一致（个数一致，顺序一致，类型一致）\n\n案例：定义一个方法，打印三角形（三角形行数由调用者来确定，而且三角形打印的字符由调用者来定）\n\n```java\npublic class Demo01\n{\n    public static void main(String[] args)\n    {\n        printSjx1(5,'>');\n    }\n    public static void printSjx1(int num,char c)\n    {\n        for (int i = 1; i <= num; i++)\n        {\n            for (int j = 1; j <= i ; j++)\n            {\n                System.out.print(c);\n            }\n        }\n        System.out.println();\n    }\n}\n```\n\n## <center>3、无参有返回值</center>\n\n### 1）定义形式\n\n```java\npublic static 返回值数据类型 形参名(){\n    \n} \n```\n\n### 2）调用形式\n\n```java\n返回值类型 变量名 = 形参名(); \nSystem.out.println(形参名); \n```\n\n案例：定义一个方法，求100质数的个数 \n\n```java\npublic class Demo01\n{\n    public static void main(String[] args)\n    {\n        int num = count();\n        System.out.println(num);\n    }\n    public static int count()\n    {\n        int count = 0;\n        for (int j = 2; j < 100; j++)\n        {\n            //定义一个信号量表示是否是质数，true表示是质数\n            boolean flag = true;\n            /*质数：只有被1或本身整除的数，也就是循环判断除了1或本身以外的数能否被整除，如果有一能\n            则不是质数 */\n            for(int i = 2 ; i < j ; i++)\n            {\n                if(j % i == 0)\n                {\n                    //这个数不是质数\n                    flag = false;\n                }\n            }\n            //等循环结束，如果没有走进过if语句，那么可以证明这个数是一个质数\n            if(flag == true)\n            {\n                //计算有几个质数\n                count++;\n                System.out.println(\"质数：\"+j);\n            }\n        }\n        //返回质数的个数\n        return count;\n    }\n}\n```\n\n## <center>4、有参有返回值</center>\n\n### 定义形式\n\n```java\npublic static 返回值数据类型 方法名(数据类型 形参名,...){\n    \n} \n```\n\n### 调用形式\n\n```java\n返回值类型 变量名 = 形参名(实参);\nSystem.out.println(形参名);\n```\n\n案例：定义一个方法，求1-n的阶乘\n\n```java\npublic class Demo02\n{\n    public static void main(String[] args)\n    {\n        int jc = jc(5);\n        //System.out.println(jc);\n        //如果一个方法的返回值，而且想输出方法返回值的结果，或将返回值作为另一个方法的参数，那么可以写在方法的参数上。\n        System.out.println(jc(5));\n    }\n    public static int jc(int n)\n    {\n        //定义一个变量保存乘积的结果（注意不能默认值为0）\n        int jc = 1;\n        for(int i = 1;i <=n;i++)\n        {\n            jc *= i;\n        }\n        return jc;\n    }\n}\n```\n\n# <center>知识点三：方法的调用</center>\n\n只需要在使用方法的位置使用语法： 方法名(赋值参数);\n\n说明：\n\n1. 赋值参数的提供需要和调用方法时，**方法是否提供的参数列表的定义决定**\n\n如果方法在定义时提供了方法参数列表，调用方法时就必须对参数列表赋值\n\n如果方法在定义时没有提供方法参数列表，调用方法时就必须不能对参数列赋值\n\n2. 如果方法提供返回值类型定义，调用方法时允许接收方法得到结果，不仅如此还可以参与到表达式中，还可以参与到其他方法调用时的赋值操作，无论是接收、参与表达式计算、参与其他方法调用赋值，必须与返回值类型时一致的\n3. 如果方法没有提供返回值类型定义即使用void关键字，调用方法时是不允许接收结果，不允许参与到表达式中和对其他方法调用尽心赋值操作\n\nPS：在定义方法时方法定义顺序是没有任何影响，但是方法调用遵守的是基础的顺序执行所以谁先调用谁先执行\n\n```java\np\nublic class MethodDemo1\n{\n    public static void main(String[] args)\n    {\n        /*\n            调用方法的原则，必须在方法内部调用其他方法\n            调用格式 方法名(参数赋值);\n            调用原则 如果有返回值接收返回值，参与计算，参与到其他赋值操作\n            如果没有返回值即使用void声明方法，不允许进行任何接收操作也不允许参与计算和赋值\n        */\n        //1.调用无返回值类型判断闰年的方法\n        //给方法参数中定义的变量赋值，既可以是常量，也可以是变量\n        isLeapYear(2000); //无返回值的方法多用与打印语句操作【在方法内部使用打印语句输出效果】\n        //2.调用有返回值类型判断闰年的放方法\n        // 给方法参数中定义的变量赋值，既可以是常量，也可以是变量\n        //可以接收方法得到返回值，但是必须提供与方法定义返回值类型一样变量进行接收\n        boolean res = isLeapYear2(1999);\n        System.out.println(res);\n        //还可以参与到计算中---》因为这个方法的返回值是boolean类型所以可以使用if分支语句判断中\n        if(isLeapYear2(2000))\n        {\n            System.out.println(\"输入的数据是闰年\");\n        }\n        else\n        {\n            System.out.println(\"输入的数据不是闰年\");\n        } \n        //有返回值类型的方法可以使用在打印语句中\n        System.out.println(\"2021年是否是闰年?\"+isLeapYear2(2021));\n    } \n    //方法定义操作\n    /*\n        访问权限修饰符 [其他修饰符] 返回值类型 方法名(参数列表)\n        {\n            方法体\n            return;\n        } \n    \n\t*/\n    //方法与方法之间是平级关系，所以定义方法的时候需要定义在main方法的外部\n    /*\n    \t如果这个方法提供操作代码并不参与其他运算中，此时这个方法就可以定义为void返回值类型\n    */\n    public static void isLeapYear(int year)\n    {\n        //在这个方法内部提供方法的实现即可\n        if((year%4==0 && year%100!=0) ||(year%400==0))\n        {\n            System.out.println(\"是闰年：\"+year);\n        }\n        else\n        {\n            System.out.println(\"不是闰年：\"+year);\n        }\n    } \n    /* 加入\n    计算闰年的这个方法会参与到其他发的运算之中时，那么就需要提供返回值类型\n    表示是否是闰年方法最好的返回值类型就是 boolean类型【true代表是闰年 false代表不是闰年】\n    PS：在同一个类文件中方法是不可以出现重名，方法名字必须是唯一\n    */\n    public static boolean isLeapYear2(int year)\n    {\n        //一个方法中可以存在多个return语句，但是需要使用分支或循环语句进行分隔\n        //计算方法中有多个return语句存在，但是只会有一个return执行\n        if((year%4==0 && year%100!=0) ||(year%400==0))\n        {\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n    }\n}\n```\n\n# <center>知识点四：方法使用注意细节</center>\n\n1、在Java中，方法不予许被嵌套（方法不能定义在另一个方法中，方法要定义在类里面，其他方法的外面）..\n\n2、一个方法定义没有调用，不会执行\n\n3、调用有参的方法的时候，我们要保证形参和实参一致（个数一致，顺序一致，类型一致）\n\n4、如果一个方法有返回值，那么这个方法必须要有return 值，而且值的类型必须要与定义返回值类型保持一致（允许自动类型转换）\n\n5、如果一个方法有返回值，可以不接收方法的返回值，也可以正常的调用方法\n\n6、如果一个方法有返回值，那么在方法内部的每一个分支下都需要有返回值\n\n# <center>知识点五：return关键字</center>\n\nreturn关键字的作用：表示结束当前方法\n\nreturn可以用在有返回值的方法中：\n\n&ensp;&ensp;&ensp;&ensp;表示方法返回值(必须)：return 值，一个方法只能有一个返回值\n\nreturn也可以用在没有返回值的方法中：\n\n&ensp;&ensp;&ensp;&ensp;表示结束方法： return;\n\n在return的后面不能直接写任何代码，因为不可能执行的到\n\n没有返回值的方法可以写return，有返回值的方法必须要写return 返回值\n\n# <center>知识点六：方法的重载</center>\n\n## <center>1、引入</center>\n\n使用方法完成两个数求和计算\n\n```java\npublic static int getSum(int a,int b)\n{\n    return a+b;\n}\n```\n\n上面这段代码完成两个整数的求和操作，随着时间发展，你的老板需要你在提供一个求两个小数和的操作\n\n```java\npublic static double getSum1(double d1,double d2)\n{\n    return d1+d2;\n}\n```\n\n过两天，你的老板又来，要你定义两个byte类型和两个short类型变量进行进行求和操作\n\n```java\npublic static int getSum2(byte b1,byte b2)\n{\n\treturn b1+b2;\n}\npublic static int getSum3(short s1,short s2)\n{\n    return s1+s2;\n}\n```\n\n又过了两天，你的老板有来，需要爱提供其他数据类型进行求和计算，此时方法的方法名就需要提供多个，外界使用方法的然就需要记忆多个方法名字，通过记忆方法名字来区分不同的方法参数是什么，才可以方便我们的调用，无形之中就对开发人员增加了压力，一个项目中多数方法都是这样，开发人员就需要大量记忆，那么有没有什么办法既可以减少记忆又可以满足不同数据计算原则\n\n## <center>2、方法重载的定义</center>\n\n方法定义的名字是有规则的，在一个类中是不允许出现重名方法的，即每个方法的方法签名是唯一【方法签名 = 方法名+参数列表】，在这种情况下，为了方便程序猿的开发并且对方法记忆，可以使用Java中提供方法重载来完成操作\n\n## <center>3、方法重载的规则</center>\n\n方法名相同，参数列表不同【只要满足其一即可：“参数定义类型不同、参数定义个数不同、参数定义顺序不同”】即是重载\n\n## <center>4、重载的好处</center>\n\n使用重载可以减少同样逻辑方法名字的定义【就是方法参数不同，实现逻辑是一样的】，减少程序猿对同样实现逻辑的方法记忆，提高开发效率，编译器会自动选择最合适方法进行操作\n\n在一个类中同名不同参的方法称之为方法的重载\n\n重载的特点：\n\n&ensp;&ensp;&ensp;&ensp;1）同方法名不同参（参数个数、顺序、类型要不一样）\n\n&ensp;&ensp;&ensp;&ensp;2）与返回值和访问修饰符无关\n\n重载的好处：\n\n&ensp;&ensp;&ensp;&ensp;屏蔽了使用时的差异\n\n例：\n\n&ensp;&ensp;&ensp;&ensp;使用重载完成，两个数的求和\n\n```java\npublic class OverloadMethodDemo\n{\n    public static void main(String[] args)\n    {\n        //只需要记忆getSum这个方法可以求得两个数据之和就可以了\n        //IDEA就会动态选择合适方法提供给我们调用实现，这样就可以减少程序员对方法名字记忆，方法调用\n        getSum(1,2);\n    } \n    //提供一个方法，求两个数的和\n    /*\n    此时 getSum这个方法就发生了重载，他们方法名字相同，但是参数列表定义不同\n    */\n    public static int getSum(int a,int b)\n    {\n        return a+b;\n    }\n    public static double getSum(double d1,double d2)\n    {\n        return d1+d2;\n    }\n}\n```\n\nPS：但是不能这样重载\n\n```java\npublic class OverloadMethodDemo2\n{\n    public static void main(String[] args) \n    {\n        //如果提供这样数据参与操作\n        byte num1 = 1;\n        byte num2 = 1;\n        /*\n        Ambiguous method call. Both getSum(byte,short) in\n        OverloadMethodDemo2 and\n        getSum(short,byte)in OverloadMethodDemo2 match\n        出现这个报错的原因在于，提供两个方法都可以满足调用需求，此时IDEA无法分辨出调用那个方法\n        方法出现了二义性，在定义重载时，设置参数尽量都是同时一个数据类型，这样可以避免出现二义\n        性问题\n        */\n        getSum(num1,num2);\n    } \n    //不可以这样提供重载\n    /* \n        public static int getSum(byte b1,short s1)\n        {\n            return b1+s1;\n        } \n        public static int getSum(short s1,byte b1)\n        {\n            return s1+b1;\n        }\n    */\n    //修改为\n    public static int getSum(byte b1,byte s1)\n    {\n        return b1+s1;\n    } \n    public static int getSum(short s1,short b1)\n    {\n        return s1+b1;\n    }\n}\n```\n\n# <center>知识点五：方法的内存调用</center>\n\n需求：使用方法完成两个数的交换，并在调用之后打印交换过后的值\n\n```java\npublic class MethodDemo2\n{\n    public static void main(String[] args)\n    {\n        int a = 1;\n        int b = 2;\n        System.out.println(\"交换之前a的值是：\"+a);\n        System.out.println(\"交换之前b的值是：\"+b);\n        //在不使用方法的前提下交换两个数据的值\n        /* //提供第三方变量进行数据存交换\n            int tmp = a; //tmp中存储是a变量值\n            a = b; //将b变量的值存储在a中 a就具有b的值\n            b = tmp; //将tmp的值赋值b，间接的等于将a的值赋值给b，所以b中存储这个a值\n        */\n        //使用方法交换两个数据的值\n        swap(a,b);\n        System.out.println(\"交换之后a的值是：\"+a);\n        System.out.println(\"交换之后b的值是：\"+b);\n    } \n    public static void swap(int a, int b)\n    {\n        int tmp = a; //tmp中存储是a变量值\n        a = b; //将b变量的值存储在a中 a就具有b的值\n        b = tmp; //将tmp的值赋值b，间接的等于将a的值赋值给b，所以b中存储这个a值\n    }\n}\n```\n\n![JVM内存调用](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271921086.jpg)\n\n# <center>知识点六：方法的递归</center>\n\n## <center>1、定义</center>\n\n什么是递归？\n\n&ensp;&ensp;&ensp;&ensp;解决具有既定规律的问题时，在方法内部再次调用自身方法的一种编程方式。\n\n何时使用递归？\n\n&ensp;&ensp;&ensp;&ensp;当需要解决的问题可以拆分成若干个小问题，大小问题的解决方式相同，方法中自己调用自己。\n\n&ensp;&ensp;&ensp;&ensp;使用循环解决的常规问题，都可以替换为递归解决。\n\n如何正确使用递归？\n\n&ensp;&ensp;&ensp;&ensp;设置有效的出口条件，可以让调用链上的每个方法都可以正确返回，避免无穷递归\n\n## <center>2、递归过程</center>\n\n1）递进：大问题简化小问题\n\n2）回溯：一步一步地给出结果\n\n## <center>3、应用</center>\n\n案例1：求某个数的阶乘 \n\n```java\npublic class Demo03\n{\n    public static void main(String[] args)\n    {\n        int a = jc(5);\n        System.out.println(a);\n    }\n    public static int jc(int num)\n    {\n        if(num == 1)\n        {\n            return  1;\n        }\n        return num * jc(num-1);  //jc()相当于调用(重复调用达到循环效果)\n    }\n}\n```\n\n案例2：求斐波那契数列第n项\n\n```java\npublic class Demo03\n{\n    public static void main(String[] args)\n    {\n//        int a = fb(5);\n//        System.out.println(a);\n        System.out.println(fb(5));\n    }\n    public static int fb(int n)\n    {\n        if(n == 1 || n==2)\n        {\n            return  1;\n        }\n        return fb(n-1) + fb(n-2);\n    }\n}\n```\n\n# <center>知识点七：调用</center>\n\n## 调用变量：\n\n（1）有static修饰\n\n&ensp;&ensp;&ensp;&ensp;方式：类名.静态变量名\n\n（2）无static修饰\n\n&ensp;&ensp;&ensp;&ensp;方式：类名 自定义名 = new 类名();\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;自定义名.方法名();\n\n## 调用方法：\n\n（1）有static修饰\n\n&ensp;&ensp;&ensp;&ensp;方式：类名.方法名();\n\n（2）无static修饰\n\n&ensp;&ensp;&ensp;&ensp;方式：类名 自定义名 = new 类名();\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;自定义名.方法名();\n\n不同包调用变量和方法\n\n&ensp;&ensp;&ensp;&ensp;只有static修饰的才可以访问\n\n&ensp;&ensp;&ensp;&ensp;import static 对应到类文件的路径.*;\t\n\n&ensp;&ensp;&ensp;&ensp;*：类中所有static修饰的都可以访问\n\n&ensp;&ensp;&ensp;&ensp;*可以替换对应类中某一个指定的方法或者变量\n","tags":["Java"],"categories":["编程语言","Java"]},{"title":"14.语句","url":"/post/43a94ea1.html","content":"\n# <center>知识点一：Scanner键盘输入语句</center>\n\n步骤 ：\n\n&ensp;&ensp;&ensp;&ensp;1）导入该类的所在包, java.util.*\n\n&ensp;&ensp;&ensp;&ensp;2）创建该类对象（声明变量）\n\n&ensp;&ensp;&ensp;&ensp;3）调用里面的功能\n\n```java\n//导入canner类(找包)\nimport java.util.Scanner;//表示把 java.util 下的 Scanner 类导入\npublic class Demo01\n{\n    public static void main(String[] args)\n    {\n        //创建一个键盘录取对象，sc 就是 Scanner 类的对象\n        Scanner sc = new Scanner(System.in);    //如果没有导入Canner类可以：ctrl + enter\n        //3、使用Scanner对象扫描输入的内容\n        //整数\n        System.out.println(\"请输入一个数字\");\n        int num = sc.nextInt();\n        System.out.println(\"你输入的数字为：\"+num);\n        //字符串\n        System.out.println(\"请输入一个字符串：\");\n        String s = sc.next();   //遇到空格结束\n        System.out.println(\"你输入的字符串为：\"+s);\n        //作用：用于读取上面输入的回车\n        sc.nextLine();\n        System.out.println(\"请输入一个字符串\");\n        String s1 = sc.nextLine();  //遇到回车结束\n        System.out.println(\"你输入的字符串为：\"+s1);\n        //小数\n        System.out.println(\"请输入一个小数：\");\n        double s2 = sc.nextDouble();\n        System.out.println(\"你输入的小数为：\"+s2);\n    }\n}\n```\n\n# <center>知识点二：分支语句（选择语句）</center>\n\n## <center>1、单分支</center>\n\n### 语法：\n\n```java\nif(逻辑条件(boolean类型)) {\n    满足逻辑条件执行的代码\n} \n```\n\n执行流程：\n\n&ensp;&ensp;&ensp;&ensp;①首先计算关系表达式的值\n\n&ensp;&ensp;&ensp;&ensp;②如果关系表达式的值为true就执行语句体\n\n&ensp;&ensp;&ensp;&ensp;③如果关系表达式的值为false就不执行语句体\n\n&ensp;&ensp;&ensp;&ensp;④继续执行后面的语句内容\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271917443.jpg\" alt=\"分支流程图\" style=\"zoom: 33%;\" />\n\n案例：输入一个人的年龄，如果年龄大于等于18岁允许上网\n\n```java\np\nublic class IfDemo\n{\n    public static void main(String[] args)\n    {\n        //需求：输入一个人的年龄，如果年龄大于等于18岁允许上网\n        //Java代码如何在控制台上获取到数据输入【固定写法】\n        //需要在自定义类文件中第一行的位置添加 import java.util.Scanner;导入操作\n        Scanner input = new Scanner(System.in);\n        System.out.println(\"请输入您的年龄：\");\n        //在控制台获取到int类型数据存储到age变量中，通过后续操作age变量就相当于操作控制台输入\n        数据\n        int age = input.nextInt();// nextInt就可以获取到控制台输入int类型数据了，\n        if(age >= 18)\n        {\n            System.out.println(\"允许上网\");\n        }\n    }\n}\n```\n\n## <center>2、双分支</center>\n\n### 语法：\n\n```java\nif(boolean类型条件){​\n    满足逻辑条件执行的代码​(语句体1)\n}\nelse{​\n    不满足逻辑条件执行的代码(语句体2)\n}\n```\n\n执行流程：\n\n&ensp;&ensp;&ensp;&ensp;①首先计算关系表达式的值\n\n&ensp;&ensp;&ensp;&ensp;②如果关系表达式的值为true就执行语句体1\n\n&ensp;&ensp;&ensp;&ensp;③如果关系表达式的值为false就执行语句体2\n\n&ensp;&ensp;&ensp;&ensp;④继续执行后面的语句内容\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271917356.jpg\" alt=\"双分支流程图\" style=\"zoom:33%;\" />\n\n案例：如果用户名为admin、密码为123456，则跳转首页，否则跳转登录页面\n\n```java\nimport java.util.Scanner;\npublic class Demo03\n{\n    public static void main(String[] args)\n    {\n        Scanner stc = new Scanner(System.in);\n        System.out.println(\"请输入用户名：\");\n        String username = stc.next();\n        System.out.println(\"请输入密码：\");\n        int password = stc.nextInt();\n        //String类型比较时尽量使用equals方法（==两边比较的是同一个空间里，字符串在常量区而输入的是在堆区）\n        if(username.equals(\"admin\") && password == (123456))\n        {\n            System.out.println(\"跳转首页\");\n        }\n        else\n        {\n            System.out.println(\"跳转登陆页面\");\n        }\n    }\n}\n```\n\n## <center>3、多分支</center>\n\n注意：苛刻条件写前面\n\n### 语法：\n\n```java\nif(boolean类型条件1)\n{\n    满足逻辑条件1执行的代码(语句体1)\n}\nelse if(boolean类型条件2)\n{\n    //隐藏条件(不满足条件1)\n    满足逻辑条件2执行的代码(语句体2)\n}\nelse if(boolean类型条件3)    \n{ \n    //隐藏条件(不满足条件1、2)\n    满足逻辑条件3执行的代码(语句体3)\n}\nelse    (可以没有else)\n{\n    不满足以上所有逻辑条件执行的代码(语句体n+1)\n} \n```\n\n执行流程：\n\n&ensp;&ensp;&ensp;&ensp;①首先计算关系表达式1的值\n\n&ensp;&ensp;&ensp;&ensp;②如果值为true就执行语句体1；如果值为false就计算关系表达式2的值\n\n&ensp;&ensp;&ensp;&ensp;③如果值为true就执行语句体2；如果值为false就计算关系表达式3的值\n\n&ensp;&ensp;&ensp;&ensp;④…\n\n&ensp;&ensp;&ensp;&ensp;⑤如果没有任何关系表达式为true，就执行语句体n+1\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271917195.jpg\" alt=\"多分支流程图\" style=\"zoom:33%;\" />\n\n案例：根据手上的余额选择购买的手机品牌\n\n&ensp;&ensp;&ensp;&ensp;如果大于10000, 买个苹果\n\n&ensp;&ensp;&ensp;&ensp;如果大于7000, 买个华为\n\n&ensp;&ensp;&ensp;&ensp;如果大于5000,买个小米\n\n&ensp;&ensp;&ensp;&ensp;如果大于3000,买个诺基亚\n\n&ensp;&ensp;&ensp;&ensp;否则,去打公共电话\n\n```java\nSystem.out.println(\"请输入余额\");\nint money = sc.nextInt();\nif(money > 10000)\n{\n    System.out.println(\"苹果手机\");\n}\nelse if(money > 7000)\n{ //money <= 10000\n    System.out.println(\"华为手机\");\n}\nelse if(money > 5000)\n{\n    System.out.println(\"小米手机\");\n}\nelse if(money > 3000)\n{\n    System.out.println(\"诺基亚手机\");\n}\nelse\n{\n    System.out.println(\"打公共电话\");\n}\n```\n\n## <center>4、嵌套if分支</center>\n\n在一个分支结构中又完整的嵌套了另一个完整的分支结构， 里面的分支的结构称为内层分支外面的分支结构称为外层分支。 老师建议: 不要超过 3 层 （可读性不好）\n\n### 语法：\n\n```java\nif(boolean类型条件1){​\n    if(boolean类型条件2)\n    {\n        满足boolean类型条件1且满足条件2执行的代码\n    }\n    else\n    {\n        满足boolean类型条件1但不满足条件2执行的代码\n    }\n}\nelse\n{\n    不满足boolean类型条件1执行的代码\n}\n```\n\n例：\n\n```java\nimport java.util.Scanner;\npublic class Demeo04\n{\n    public static void main(String[] args)\n    {\n        Scanner str = new Scanner(System.in);\n        System.out.println(\"请输入你的成绩：\");\n        double score = str.nextDouble();\n        if (score < 15)\n        {\n            System.out.println(\"请输入你的性别：\");\n            String sex = str.next();\n            if (sex.equals(\"男\"))\n            {\n                System.out.println(\"进入男子决赛组\");\n            }\n            else\n            {\n                System.out.println(\"进入女子决赛组\");\n            }\n        }\n        else\n        {\n            System.out.println(\"很遗憾你被淘汰\");\n        }\n    }\n}\n```\n\n## <center>5、分支语句细节</center>\n\n注意1：\n\n&ensp;&ensp;&ensp;&ensp;在java中 == 比较的是内存地址，String类的equals比较的是内容\n\n&ensp;&ensp;&ensp;&ensp;基本数据类型使用==比较。\n\n&ensp;&ensp;&ensp;&ensp;String类型使用equals比较\n\n注意2：\n\n&ensp;&ensp;&ensp;&ensp;在if分支中，大括号可以省略不写，但是如果不写大括号，那么这个if分支只能控制一行代码（一般不这么写）\n\n注意3：\n\n&ensp;&ensp;&ensp;&ensp;多重if中要将苛刻条件写前面\n\n## <center>6、switch语句</center>\n\nswitch中的值的类型\n\n&ensp;&ensp;&ensp;&ensp;byte  short  int  char  String   枚举\n\n### 语法：\n\n```java\nswitch(值){​\n    case 值1:\n        switch中的值与值1相等时候执行的代码\n        break;\n    case 值2:\n        switch中的值与值2相等时候执行的代码\n        break;\n    case 值3:\n        switch中的值与值3相等时候执行的代码\n        break;\n    case 值4:\n        switch中的值与值4相等时候执行的代码\n        break;\n    default:\n        switch中的值与以上所有值都不相等时候执行的代码\n        break;\n} \n```\n\n案例：\n\n&ensp;&ensp;&ensp;&ensp;选择1：查询操作\n\n&ensp;&ensp;&ensp;&ensp;选择2：增加操作\n\n&ensp;&ensp;&ensp;&ensp;选择3：删除操作\n\n&ensp;&ensp;&ensp;&ensp;选择4：修改操作\n\n&ensp;&ensp;&ensp;&ensp;选择5：退出系统\n\n&ensp;&ensp;&ensp;&ensp;选择其他：提示输入有误 \n\n```java\nSystem.out.println(\"请输入你的选择\");\nint option = sc.nextInt();\nswitch(option)    \n{\n    case 1:\n    System.out.println(\"查询操作\");\n    break;\n    case 2:\n    System.out.println(\"增加操作\");\n    break;\n    case 3:\n    System.out.println(\"删除操作\");\n    break;\n    case 4:\n    System.out.println(\"修改操作\");\n    break;\n    case 5:\n    System.out.println(\"退出系统\");\n    break;\n    default:\n    System.out.println(\"输入有误\");\n    break;\n}\n```\n\n## <center>7、switch语句细节</center>\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271918301.jpg\" alt=\"switch语句细节\" style=\"zoom: 50%;\" />\n\n例：\n\n&ensp;&ensp;&ensp;&ensp;在不考虑平闰年的前提下，通过控制台输入1-12月之间任意一个月份，输出对应的天数\n\n&ensp;&ensp;&ensp;&ensp;如果不适用switch语句穿透效果，那么需要提供12个case进行数据匹配，但是在12个case中有多个case执行效果都是一样的\n\n&ensp;&ensp;&ensp;&ensp;2月份 28天 4,6,9,11 月份30天 1,3,5,7,8,10,12 月份 31天\n\n&ensp;&ensp;&ensp;&ensp;利用case穿透特性节约代码，解决不同case条件但是执行语句操作相同的方式\n\n```java\ni\nmport java.util.Scanner;\npublic class SwitchDemo2\n{\n    public static void main(String[] args)\n    {\n        Scanner input = new Scanner(System.in);\n        System.out.println(\"请输入(1~12)之间数字代表月份：\");\n        int month = input.nextInt();\n        switch (month)\n        {\n            case 2:\n                System.out.println(\"28天\");\n                break;\n            case 4:\n            case 6:\n            case 9:\n            case 11:\n                System.out.println(\"30天\");\n                break;\n            default:\n                System.out.println(\"31天\");\n                break;\n        }\n    }\n}\n```\n\n## <center>8、总结 switch 和 if 分支</center>\n\n1）如果判断的具体数值不多， 而且符合 byte、 short 、 int、 char, enum[枚举], String 这 6 种类型。虽然两个语句都可以使用， 建议使用 swtich 语句。\n\n2）其他情况： 对区间判断， 对结果为 boolean 类型判断， 使用 if， if 的使用范围更广\n\n多重if中可以做关系运算，在swtich中只能做等值判断 \n\nPS:实际开发中还是使用if分支语句较多\n\n# <center>知识点三：循环语句</center>\n\n例如：在控制台上每一秒钟输出一行Hello World，打印语句就是重复性操作\n\n&ensp;&ensp;&ensp;&ensp;开发一个机器人踢足球程序，程序中会有一个问题，如果没有进入到射门范围内，此时就需要让机器人持续的带球，重复性操作就是持续带球\n\n使用循环结构可以轻松控制某些事情（操作）重复，重复在重复性操作\n\nJava中提供循环结构有哪些？\n\n&ensp;&ensp;&ensp;&ensp;“while循环、do-while循环 和 for循环”，利用这三个结构中某一种就可以完成某些代码重复性操作\n\n所以在编写循环的时候主要提供要素【必要条件】\n\n```java\n1. 要执行重复性操作的代码时什么\n2. 执行重复操作的次数\n```\n\n就要可以在代码结构中添加循环操作，让代码执行重复性操作\n\n## <center>1、for循环</center>\n\n### 1）语法\n\n```java\nfor(循环变量赋初值;循环条件;循环变量自增或自减){\n    重复执行操作【执行语句】；\n}\n```\n\n详细说明：\n\n1. 循环变量赋初值：这个变量主要作用是组成循环条件，可以参与到循环体计算与打印\n2. 循环条件： 使用循环变量与某个值构建一个循环的范围，这个范围也就是循环次数因为是范围的存在，所以循环条件多使用的“关系表达式 即 常用关系运算符 > 、>= 、< 、<=” 来组成循环范围，偶尔可见使用逻辑运算符与关系运算符共同组成表达式作为循环范围 或者使用 == 或 != 来组建这个循环范围既然循环条件使用关系或逻辑运算符的表达式，所以条件得到结果值只有true 或 false\n3. 执行语句：就是你要让循环重复什么代码，这个代码时泛指【打印语句、逻辑计算、分支语句或者循环语句】\n4. 循环变量控制：因为使用循环变量与某个值构建循环范围，所有需要对循环变量加以控制【自增或自减】，以让循环条件可以达到我们需要的循环次数\n\n常见的自增或自检操作使用“++ 或 -- 运算符”，偶尔可见使用运算符“+=、-=、*= 、\\= 运算符“\n\nPS: for循环在书写过程中需要在小括号内使用【;】分隔不同的循环条件\n\n### 2）for循环的执行顺序：\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271918473.jpg\" alt=\"for循环的执行顺序\" style=\"zoom: 50%;\" />\n\n案例：打印 1~100 之间所有是 9 的倍数的整数，统计个数 及 总和[化繁为简,先死后活]】\n\n```java\npublic class ForExercise { \n\n    //编写一个main方法\n    public static void main(String[] args) {\n        //打印1~100之间所有是9的倍数的整数，统计个数  及 总和.[化繁为简,先死后活]\n        //老韩的两个编程思想(技巧)\n        //1. 化繁为简 : 即将复杂的需求，拆解成简单的需求，逐步完成\n        //2. 先死后活 : 先考虑固定的值，然后转成可以灵活变化的值\n        //\n        //思路分析\n        //打印1~100之间所有是9的倍数的整数，统计个数  及 总和\n        //化繁为简\n        //(1) 完成 输出 1-100的值\n        //(2) 在输出的过程中，进行过滤，只输出9的倍数  i % 9 ==0\n        //(3) 统计个数 定义一个变量 int count = 0; 当 条件满足时 count++;\n        //(4) 总和 , 定义一个变量 int sum = 0; 当条件满足时累积 sum += i;\n        //先死后活\n        //(1) 为了适应更好的需求，把范围的开始的值和结束的值，做出变量\n        //(2) 还可以更进一步 9 倍数也做成变量 int t = 9;\n        \n        int count = 0; \t//统计9的倍数个数 变量\n        int sum = 0; \t//总和\n        int start = 10;\n        int end = 200;\n        int t = 5; \t\t// 倍数\n        for(int i = start; i <= end; i++) {\n            if( i % t == 0) {\n                System.out.println(\"i=\" + i);\n                count++;\n                sum += i;\t//累积\n            }\n        }\n\n        System.out.println(\"count=\" + count);\n        System.out.println(\"sum=\" + sum);\n\n    }\n}\n```\n\n注意事项和细节说明\n\n1) 循环条件是返回一个布尔值的表达式\n2) for(;循环判断条件;) 中的初始化和变量迭代可以写到其它地方， 但是两边的分号不能省略。\n3) 循环初始值可以有多条初始化语句，但要求类型一样，并且中间用逗号隔开，循环变量迭代也可以有多条变量迭代语句，中间用逗号隔开\n\n## <center>2、while循环</center>\n\n注意：\n\n&ensp;&ensp;&ensp;&ensp;1）一般用于不知道循环次数\n\n&ensp;&ensp;&ensp;&ensp;2）循环初始化一般不能定义在循环里面\n\nwhile循环在以后开发中占比0.9%左右【书写while循环比例也就是在0.9%】,但是是一个经典的循环结构，利用这循环结构完成某些代码重复执行\n\n### 1）语法：\n\n```java\n循环变量初值;\nwhile(循环条件)【使用循环变量与某个值组成】{\n    执行语句【让循环重复执行的操作】;\n    循环变量控制【循环变量的自增或自减】;\n}\n```\n\n详细说明：\n\n1. 循环变量赋初值：这个变量主要作用是组成循环条件，可以参与到循环体计算与打印\n2. 循环条件： 使用循环变量与某个值构建一个循环的范围，这个范围也就是循环次数因为是范围的存在，所以循环条件多使用的“关系表达式 即 常用关系运算符 > 、>= 、< 、<=” 来组成循环范围，偶尔可见使用逻辑运算符与关系运算符共同组成表达式作为循环范围 或者使用 == 或 != 来组建这个循环范围既然循环条件使用关系或逻辑运算符的表达式，所以条件得到结果值只有true 或 false\n3. 执行语句：就是你要让循环重复什么代码，这个代码时泛指【打印语句、逻辑计算、分支语句或者循环语句】\n4. 循环变量控制：因为使用循环变量与某个值构建循环范围，所有需要对循环变量加以控制【自增或自减】，以让循环条件可以达到我们需要的循环次数\n\n常见的自增或自检操作使用“++ 或 -- 运算符”，偶尔可见使用运算符“+=、-=、*= 、\\= 运算符“\n\n### 2、while执行顺序：\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271918653.jpg\" alt=\"while执行顺序\" style=\"zoom:50%;\" />\n\n案例：利用while循环计算100以内（包括100）所有的奇数、偶数和3的倍数\n\n```java\np\nublic class WhileDemo2\n{\n    public static void main(String[] args)\n    {\n        //利用while循环计算100以内（包括100），所有的奇数、偶数和3的倍数\n        /*\n            分析:\n            1.重复操作的事情 ---》 需要提供判断数据是否是奇数、偶数和3的倍数\n            如果需要提供所有的奇数、偶数和3的倍数都要打印出来，此时应该提供一个什么样if判断是合理？\n            三个条件 ---》 if-else if ---》不可以，因为if-else if原则 只要有一个条件\n            判断为true，剩余条件皆不判断就会出现少一个打印结果情况 --》 那么应该选用谁？\n            2.重复的次数 --》 从1~100之间的所有数据 ---》 100次\n        */\n        //循环变量赋初值\n        int i = 1;\n        while(i<=100)    //循环条件\n        { \n            //重复操作的事情\n            //先提供if-else if分支判断 --》无法完成具体需求\n            //修改为 if 单分支\n            if(i %2 == 0)\n            {\n                System.out.println(\"偶数：\"+i);\n            } \n            if(i%2 == 1)\n            {\n                System.out.println(\"奇数：\"+i);\n            }\n            if(i%3 ==0)\n            {\n                System.out.println(\"3的倍数：\"+i);\n            }\n            //循环变量控制\n            i++;\n        }\n    }\n}\n```\n\n## <center>3、do while循环</center>\n\n注意：\n\n&ensp;&ensp;&ensp;&ensp;1、先执行后判断，无论什么情况至少执行一次\n\n&ensp;&ensp;&ensp;&ensp;2、循环初始化一般不能定义在循环里面\n\n### 语法\n\n```java\n循环变量初值;\ndo{\n    执行语句【重复操作的代码】;\n    循环变量自增或自减【循环变量控制】;\n}while(循环条件);\n```\n\n详细说明：\n\n1. 循环变量赋初值：这个变量主要作用是组成循环条件，可以参与到循环体计算与打印\n2. 循环条件： 使用循环变量与某个值构建一个循环的范围，这个范围也就是循环次数因为是范围的存在，所以循环条件多使用的“关系表达式 即 常用关系运算符 > 、>= 、< 、<=” 来组成循环范围，偶尔可见使用逻辑运算符与关系运算符共同组成表达式作为循环范围 或者使用 == 或 != 来组建这个循环范围既然循环条件使用关系或逻辑运算符的表达式，所以条件得到结果值只有true 或 false\n3. 执行语句：就是你要让循环重复什么代码，这个代码时泛指【打印语句、逻辑计算、分支语句或者循环语句】\n4. 循环变量控制：因为使用循环变量与某个值构建循环范围，所有需要对循环变量加以控制【自增或自减】，以让循环条件可以达到我们需要的循环次数\n\n常见的自增或自检操作使用“++ 或 -- 运算符”，偶尔可见使用运算符“+=、-=、*= 、\\= 运算符“\n\nPS：在书写do-while循环的时候一定要注意循环末尾的【;】一要添加\n\n### do..while 执行顺序 ：\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271918158.jpg\" alt=\"do..while执行顺序\" style=\"zoom:50%;\" />\n\n案例：学生根据老师的评语，是否继续敲代码，直到测评为ok，就结束 \n\n```java\ni\nmport java.awt.image.Kernel;\npublic class DoWhileDemo2\n{\n    public static void main(String[] args)\n    {\n        //在同等条件下使用while循环和do-while进行数据打印操作\n        System.out.println(\"-----------while循环的打印----------------\");\n        //将正常案例操作注释，提供特条件，无论是while还是do-while都设置条件为 <= 0\n        /* int i = 1;\n        while(i <= 5)\n        {\n            System.out.println(i);\n            i++;\n        }*/\n        int i = 1;\n        while(i <= 0){\n        System.out.println(i);\n        i++;\n        }\n        System.out.println(\"---------do-while循环的打印--------------\");\n        /* \n        int j = 1;    //此变量不能定义在do while语句里，因为在do while语句是局部变量while判断实在do while语句外，不在同一个范围内\n        do\n        {\n            System.out.println(j);\n            j++;\n        }while(j<=5);\n        */\n        int j = 1;\n        do\n        {\n            System.out.println(j);\n            j++;\n        }while(j <= 0);\n    }\n}\n```\n\n## <center>4、嵌套循环</center>\n\n将一个循环放在另一个循环体内， 就形成了嵌套循环。 其中， for ,while ,do…while 均可以作为外层循环和内层循环。【建议一般使用两层， 最多不要超过 3 层, 否则， 代码的可读性很差】\n\n循环嵌套中有一个经典的理论：**外层循环执行一次内层循环执行多次**\t\n\n&ensp;&ensp;&ensp;&ensp;设外层循环次数为 m 次， 内层为 n 次， 则内层循环体实际上需要执行 m*n 次\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271919595.jpg\" alt=\"嵌套循环\" style=\"zoom:50%;\" />\n\n某些操作中提供一层循环是无法满足所有循环逻辑，所以在这样前提下，我们就需要提供嵌套循环了\n\n需求：打印下面样式\n\n&ensp;&ensp;&ensp;&ensp;1 2  3   4   5\n\n&ensp;&ensp;&ensp;&ensp;2 4  6   8  10\n\n&ensp;&ensp;&ensp;&ensp;3 6  9  12 15\n\n&ensp;&ensp;&ensp;&ensp;4 8 12 16 20\n\n```java\np\nublic class NestingForDemo\n{\n    public static void main(String[] args)\n    {\n        /*\n            1 2 3 4 5\n            2 4 6 8 10\n            3 6 9 12 15\n            4 8 12 16 20\n        */\n        //外层循环中 变量是可以参与到 内层循环计算中\n        // 参与到 内层循环中 j的赋值、 j的循环条件和参与到内层循环的重复执行操作中\n        for(int i = 1 ; i<=4;i++)\n        {\n            for (int j = 1; j <= 5; j++)\n            {\n                /**\n                Java中打印语句有两个方式一个是带有 ln方法【println】 一个是不带有 ln方法\n                【print】\n                区别在于带有ln的打印语句输出结果时，会在打印结束的位置添加换行【添加回车-\n                -》\"\\n\"】\n                不带有ln的打印语句输出结果时，不会有添加换行的，将打印内容在一行显示\n                可以在打印语句中添加 “\\t” 代表4个空格 也是键盘上tab键\n                */\n                System.out.print(j*i + \"\\t\");\n            }\n            //调用一个带有ln方法进行打印，添加换行操作\n            System.out.println();\n        }\n    }\n}\n```\n\n&ensp;&ensp;&ensp;&ensp;可以将当前代码中这种循环形式理解为在看书，外层第一层循环【i层】相当于是书中页数，内层（第二层）循环【j层】相当于书页作用内一行内容，只有当书中每一行内容都看完之后，才可以翻页即只有内层循环执行完毕之后，外层循环才会开启下一次\n\n&ensp;&ensp;&ensp;&ensp;执行流程：当前代码执行到嵌套循环时，首先先执行外层循环的循环变量赋初值【执行1次】，判断外层循环循环条件是否成立，如果成立就执行大括号中的，内层循环，先执行循环变量赋初值【随外层循环的次数而进行初始化】，然后判断内层循环的循环条件，如果为true，就执行内层循环中大括号内执行语句，然后内层循环变量自增或自减，再次执行内层循环条件判断，直到循环条件为false，内层循环停止，此时外层循环开始循环变量自增或自减，然后再判断外层循环条件，如果为true，就会再次开启内层循环，否则循环完全结束\n\nPS:外层循环变量是可以参与到内层循环操作的，可以影响内层循环条件，参与到内存循环计算\n\n# <center>知识点四：break和continue关键字</center>\n\n含义：\n\n&ensp;&ensp;&ensp;&ensp;break：表示结束当前循环\n\n&ensp;&ensp;&ensp;&ensp;continue：表示结束本次循环,继续下一次循环\n\n注意：紧跟着break和continue后面不能写任何代码 \n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271919940.jpg\" alt=\"break和continue\" style=\"zoom: 67%;\" />\n\n实现登录验证，有 3 次机会， 如果用户名为\"丁真\" ,密码\"666\"提示登录成功，否则提示还有几次机会，请使用 for+break\n\n```java\nimport java.util.Scanner;\npublic class BreakExercise02 {\n    //编写一个 main 方法\n    public static void main(String[] args) {\n        //实现登录验证， 有 3 次机会， 如果用户名为\"丁真\" ,密码\"666\"提示登录成功，\n        //否则提示还有几次机会， 请使用 for+break 完成\n        //\n        // 思路分析\n        // 1. 创建 Scanner 对象接收用户输入\n        // 2. 定义 String name ; String passwd; 保存用户名和密码\n        // 3. 最多循环 3 次[登录 3 次]， 如果 满足条件就提前退出\n        // 4. 定义一般变量 int chance 记录还有几次登录机会\n        //\n        // 代码实现\n        Scanner myScanner = new Scanner(System.in);\n        String name = \"\";\n        String passwd = \"\";\n        int chance = 3; //登录一次 ， 就减少一次\n        for( int i = 1; i <= 3; i++) {//3 次登录机会\n        System.out.println(\"请输入名字\");\n        name = myScanner.next();\n        System.out.println(\"请输入密码\");\n        passwd = myScanner.next();\n        //比较输入的名字和密码是否正确\n        //补充说明字符串 的内容 比较 使用的 方法 equals\n        if(\"丁真\".equals(name) && \"666\".equals(passwd)) {\n        System.out.println(\"恭喜你， 登录成功~\");\n        break;\n    } \n    //登录的机会就减少一次\n    chance--;\n    System.out.println(\"你还有\" + chance + \"次登录机会\");\n}\n\ncontinue 语句出现在多层嵌套的循环语句体中时， 可以通过标签指明要跳过的是哪一层循环 , 这个和前面的标签的\n使用的规则一样\nlabel1:\nfor(int j = 0; j < 4; j++){\n    label2:\n    for(int i = 0; i < 10; i++){\n        if(i == 2){\n            //看看分别输出什么值， 并分析\n            //continue ;\n            //continue label2;\n            continue label1;\n        } \n        System.out.println(\"i = \" + i);\n    }\n}\n```\n\n**跳转控制语句-return**\n\n&ensp;&ensp;&ensp;&ensp;return 使用在方法，表示**跳出所在的方法**，在讲解方法的时候，会详细的介绍，这里我们简单的提一下。注意：如果 return 写在 **main 方法，退出程序** \n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271919833.jpg\" alt=\"return作用\" style=\"zoom:50%;\" />\n","tags":["Java"],"categories":["编程语言","Java"]},{"title":"13.运算符","url":"/post/ded373.html","content":"\n# <center>知识点一：算术运算符</center>\n\n算数运算符遵守就是数学四则运算\n\n| 符号 |      含义       |\n| :--: | :-------------: |\n|  +   |       加        |\n|  -   |       减        |\n|  *   |       乘        |\n|  /   |       除        |\n|  %   |      取余       |\n|  ++  | 自增（自身加1） |\n|  --  | 自减（自身减1） |\n\n+号在java中有两个作用：\n\n&ensp;&ensp;&ensp;&ensp;1、字符串的拼接（字符串拼接的时候，任何类型与字符串拼接最终的结果是字符串类型 ）\n\n&ensp;&ensp;&ensp;&ensp;2、加法运算 \n\n**&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;++、--在前：先加+1、-1再使用**\n\n&ensp;&ensp;&ensp;&ensp;**&ensp;&ensp;&ensp;&ensp;++、--在后：先使用再加+1 、-1**\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271915907.jpg\" alt=\"面试题\" style=\"zoom: 50%;\" />\n\n```java\npublic class ArithmeticOperatorExercise01 {\n    //编写一个 main 方法\n    public static void main(String[] args) {\n        // int i = 1;//i->1\n        // i = i++; //规则使用临时变量: (1) temp=i;(2) i=i+1;(3)i=temp;\n        // System.out.println(i); // 1\n        // int i=1;\n        // i=++i; //规则使用临时变量: (1) i=i+1;(2) temp=i;(3)i=temp;\n        // System.out.println(i); //2\n        \n        // 测试输出\n        int i1 = 10;\n        int i2 = 20;\n        int i = i1++;\n        System.out.print(\"i=\"+i);//10\n        System.out.println(\"i2=\"+i2);//20\n        i = --i2;\n        System.out.print(\"i=\"+i);//19\n        System.out.println(\"i2=\"+i2);//19\n    }\n}\n```\n\n详细说明\n\n&ensp;&ensp;&ensp;&ensp;1）加号运算符（+）：加号运算符不仅可以对数值类型（整数或小数）数据进行计算，而且还可以提供给字符类型进行计算，并且还可以对字符串类型提供操作\n\n```java\npublic class AddOperator\n{\n    public static void main(String[] args)\n    {\n        \n        //提供给 char类型【字符类型】进行计算\n        /*\n            字符类型char 默认存储范围是0~65535结束，在这个范围内都可以存正整数\n            如果char类型中存储的字符 也是可以通过 +号 进行计算的\n            将char类型中存储字符转换为对应十进制数据，转换原则是Unicode【万国码】\n            有一个存储字符的集合--》ASCII码【美国信息标准交换代码】\n            美国人将字符和字符定义到这个码中，并且提供字符对应十进制数据\n            所以使用字符类型在计算时，会将字符转换为对应十进制参与计算\n            在ASCII码表中大家需要记录一个范围\n            'a' -- 97 a~z之间是一个连续存储范围，所以b对应的数值就是98 ，依次类推 递增+1\n            'A' -- 65 A~Z之间是一个连续存储范围，所以B对应的数值就是66，依次类推，递增+1\n            '0'(字符零) -- 48 '0'~'9'之间是一个连续存储范围，所以'1'对应的数值就是49，依次类\n推，递增+1\n        */\n        char ch = 'A';\n        char ch2 = 32;\n        System.out.println(ch+ch2);\n        /*\n            在使用byte、short、char类型变量发生计算时，他们会被默认提升为为int类型参与到计算中\n            所以要存储会原有数据类型中必须进行强制类型转换操作\n        */\n        char ch3 = (char)(ch+ch2); //这个计算等式就等于 ---> char ch3 = 65+32;\n        System.out.println(ch3);\n        \n        //如果小数据数据类型范围数据变量与大数据类型范围数据变量发生计算，最终结果数据类型一定是大范围数据类型\n        int i1 = 10;\n        double d3 = 3.14;\n        double sum = i1 + d3;\n        //+号运算符是可以参与到 字符串计算的，但是是拼接效果\n        String str = \"hello\";\n        String str1 = \"world\";\n        int num1 = 1\n        int num2 = 2\n        System.out.println(str+str1);\n        //字符串类型与任何类型数据使用【+】进行拼接得到结果都是 拼接效果，所以利用这个原则就可以定义打印语句\n\n        //在执行和字符串拼接计算时遵守的是从左向右执行所以最先开始执行效果就是\n        //\"num1+num2的和是：\"+num1 --> \"num1+num2的和是：1\"\n        //然后在利用\"num1+num2的和是：1\"+num2 --> num1+num2的和是：12\n        System.out.println(\"num1+num2的和是：\"+(num1+num2));\n        \n        //++的使用\n\n        int i = 10;\n        i++;//自增 等价于 i = i + 1; => i = 11\n        ++i;//自增 等价于 i = i + 1; => i = 12\n        System.out.println(\"i=\" + i);//12\n        /*\n            作为表达式使用\n            前++： ++i 先自增后赋值\n            后++： i++先赋值后自增\n        */\n        int j = 8;\n        //int k = ++j; //等价 j=j+1;k=j;\n        int k = j++; // 等价 k =j;j=j+1;\n        System.out.println(\"k=\" + k + \"j=\" + j);//8 9\n        \n        //笔试题：short s1 = 1; short s2 = 1; s2 = s1 + s2? s2 += s1;?\n        short s1 = 1;\n        short s2 = 1;\n        // s2 = s1 + s2; //错误\n        s2 += s1; //正确\n    }\n}\n```\n\n&ensp;&ensp;&ensp;&ensp;2）除号运算符（/）：Java中整数除以整数只能得到整数，如果需要得到小数，需要使用小数数据类型计算\n\n在使用除号进行计算时，不允许除数为0即不能除以0，会已发Java程序异常导致后学代码无法执行\n\n小数允许这个操作，但是得到结果不是我们想要的0\n\n```p\np\nublic class DivOperator\n{\n    public static void main(String[] args)\n    {\n        //演示除法\n        //Java中整数除以整数只能得到整数\n        int num1 = 1;\n        int num2 = 10;\n        System.out.println(\"计算1/10等于：\"+(num1/num2));//0\n        \n        //小数\n        System.out.println(10 / 4); //从数学来看是 2.5, java 中 2\n        System.out.println(10.0 / 4); //java 是 2.5\n\n        double d = 10 / 4;//java 中 10 / 4 = 2, 2=>2.0\n        System.out.println(d);// 是 2.0\n        \n        //使用除法的时候是不可以除以0的\n        //java.lang.ArithmeticException 在java中叫做异常【程序出现了错误】\n        int i1 = 0;\n        int i2 = 1;\n        System.out.println(\"计算1/0等于：\"+(i2/i1));\n        //小数是可以除以0,但是这样做是没有意义\n    }\n}\n```\n\n&ensp;&ensp;&ensp;&ensp;3）求余操作（%），求余操作与除法计算时有本质上区别除法主要是计算求商，求余计算计算得到是余数，因为整数除以整数得到结果只能是整数，所以在Java要进行某些判断时候，除法操作是无法完成通用性判断，所以建议使用（%）求余的形式来记性一些辅助型的计算\n\n例如：判断某个数是否整数此时就不能使用除法来进行计算，可需要使用求余方式\n\n```java\n// % 取模，取余\n// 在 % 的本质 看一个公式!!!! a % b = a - a / b * b\n// -10 % 3 => -10 - (-10) / 3 * 3 = -10 + 9 = -1\n// 10 % -3 = 10 - 10 / (-3) * (-3) = 10 - 9 = 1\n// -10 % -3 = (-10) - (-10) / (-3) * (-3) = -10 + 9 = -1\nSystem.out.println(10 % 3); \t//1\nSystem.out.println(-10 % 3); \t//-1\nSystem.out.println(10 % -3); \t//1\nSystem.out.println(-10 % -3);\t//-1\n```\n\n剩余运算符就可以按照四则运算计算即可\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271916027.jpg\" alt=\"结果\" style=\"zoom:33%;\" />\n\n# <center>知识点二：赋值运算符</center>\n\n| 符号 |             作用             |\n| :--: | :--------------------------: |\n|  =   |             赋值             |\n|  +=  |   先计算加法然后再赋值操作   |\n|  -=  |   先计算减法然后再赋值操作   |\n|  *=  | 先计算乘法然后再赋值操作等于 |\n|  /=  |   先计算除法然后再赋值操作   |\n|  %=  |   先计算求余然后再赋值操作   |\n\n复合赋值运算符会进行类型转换。byte b = 2; b+=3; b++;\n\n```java\npublic class AssignmentOperator\n{\n    public static void main(String[] args)\n    {\n        int n1 = 10;\n        n1 += 4;// n1 = n1 + 4;\n        System.out.println(n1); // 14\n        n1 /= 3;// n1 = n1 / 3;//4\n        System.out.println(n1); // 4\n        \n        //复合运算符还可以减少强制类型转换的用法操作\n        byte num1 = 1;\n        //byte、short和char类型在变量计算时，会默提升为int类型\n        int sum2 = (byte)(num1+1);\n        //加入将计算记过存储到num1中 --》 修改后为\n        num1 = (byte)(num1+1);\n       \n        //复合赋值运算符会进行类型转换\n        byte b = 3;\n        b += 2; // 等价 b = (byte)(b + 2);\n        b++; // b = (byte)(b+1);\n    }\n}\n```\n\n# <center>知识点三：++ --运算符</center>\n\n无论 ++ 和 -- 运算符出现在变量任何一个位置，当前的变量都需要进行需要进行一次+1和-1操作\n\n```java\np\nublic class AddOperator2\n{\n    public static void main(String[] args)\n    {\n        //提供++ -- 运算符操作\n        //单独使用\n        int i = 1;\n        //执行 i++ 操作\n        /*\n            单独使用++运算符对变量进行计算即【没有参与到其它运算中和赋值运算符】\n            i++ 和 ++i的效果是一样的 i这边量 会进行+1操作\n        */\n        i++; // 等价于执行 i = i+1;\n        System.out.println(i);\n        ++i; // 等价于执行 i = i+1;\n        System.out.println(i);\n        // -- 也是同样的道理， 在单独使用前提下 i-- 和 --i效果都是一样 都是变量i进行-1操作\n    }\n}\n```\n\n&ensp;&ensp;&ensp;&ensp;如果使用自增或自减变量参与到运算符中时，此时++ 或 -- 运算符出现的位置 得到计算结果就是完全不一样的\n\n&ensp;&ensp;&ensp;&ensp;如果参与计算中 ++ 运算符出现在变量之前即 ++i，此时当前i变量要先执行+1自增操作，然后再参与到其它运算中\n\n&ensp;&ensp;&ensp;&ensp;如果参与计算中 ++ 运算符出现在变量之后即 i++，此时当前i变量要先参与到其他运算中，然后再执行+1自增操作\n\n&ensp;&ensp;&ensp;&ensp;-- 是同理的，只要将+1为-1即可\n\n```java\np\nublic class AddOperator3\n{\n    public static void main(String[] args)\n    {\n        int a = 1;\n        int b = 1;\n        int aplus;\n        int bplus;\n        /*\n            无论++和--运算符出现在变量任何一个位置，当前的变量都需要进行需要进行一次+1和-1操作\n            区分运算符使用方式【单独使用】或【参与运算符】\n            参与运算计算 ，此时就要区分运算符出现在变量位置，变量之前还是变量之后\n            如果参与计算中 ++ 运算符出现在变量之前即 ++i，此时当前i变量要先执行+1自增操作，然后再\n参与到其它运算中\n            如果参与计算中 ++ 运算符出现在变量之后即 i++，此时当前i变量要先参与到其他运算中，然后\n再执行+1自增操作\n        */\n        /*\n            a++ ++运算符出现在变量之后 满足了\n            如果参与计算中 ++ 运算符出现在变量之后即 i++，此时当前i变量要先参与到其他运算中，然\n后再执行+1自增操作\n            先执行 aplus = a 的操作 此时a的值是1 所以 aplus中赋值为1\n            然后执行 a++ 即 a = a+1 此时 a = 2\n        */\n        aplus = a++;\n        /*\n            ++b ++运算符出现在变量之前 满足了\n            如果参与计算中 ++ 运算符出现在变量之前即 ++i，此时当前i变量要先执行+1自增操作，然\n后再参与到其它运算中\n            先执行 bplus = b= b+1 即先执行 b= b+1操作 b= 2\n            然后执行 bplus = b操作 bplus 存储2这个值\n        */\n        bplus = ++b;\n        System.out.println(\"a的值是：\"+a);//2\n        System.out.println(\"b的值是：\"+b); //2\n        System.out.println(\"aplus的值是：\"+aplus);//1\n        System.out.println(\"bplus的值是：\"+bplus);//2\n    }\n}\n```\n\n# <center>知识点四：关系运算符</center>\n\n1）关系运算符的结果都是 boolean 型， 也就是要么是 true， 要么是 false\n\n2）关系表达式 经常用在 if 结构的条件中或循环结构的条件中\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271916838.jpg\" alt=\"关系运算符\" style=\"zoom:50%;\" />\n\n细节说明\n\n&ensp;&ensp;&ensp;&ensp;1）关系运算符的结果都是 boolean 型， 也就是要么是 true， 要么是 false\n\n&ensp;&ensp;&ensp;&ensp;2）关系运算符组成的表达式， 我们称为关系表达式。 a > b\n\n&ensp;&ensp;&ensp;&ensp;3）比较运算符 \"==\" 不能误写成 \"=\"\n\n```java\npublic class RelationalOperator\n{\n    public static void main(String[] args)\n    {\n        //演示关系运算符\n        //提供两个变量\n        int a = 10;\n        int b = 20;\n        //判断a和b变量之间的关系 --> 得到结果只有true 和 false\n        //在代码中看到是a和b两个变量在比较，其实在执行的是10和20这个两个数据在比较\n        System.out.println(a == b); //10等于20吗？ false\n        System.out.println(a != b); //10不等于20吗？ true\n        System.out.println(a > b); // 10大于20吗？ false\n        System.out.println(a >= b);//10大于等于20吗？即10大于20 或 10等于20 吗？false\n        System.out.println(a < b);//10小于20吗？ true\n        System.out.println(a <= b);//10小于等于20吗？即10小于20 或 10等于20 吗？ true\n        //又因为关系表达式计算结果得到true或false，所以可以存储在boolean变量中\n        boolean res = a>b;\n        System.out.println(res);\n    }\n}\n```\n\n# <center>知识点五：逻辑运算符</center>\n\n逻辑运算符的作用就是将多个关系表达式连接在一起，形成一个复杂的逻辑表达式，来进行逻辑判断操作\n\n结果：boolean类型 \n\n分为两组学习\n\n1) 短路与 && ， 短路或 ||+， 取反 !\n2) 逻辑与 &， 逻辑或 |， ^ 逻辑异或\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271916832.jpg\" alt=\"逻辑运算符\" style=\"zoom:50%;\" />\n\n**&& 和 & 基本规则**\n\n|   名称   |      语法      |                    特点                    |\n| :------: | :------------: | :----------------------------------------: |\n| 短路与&& | 条件1 && 条件2 | 两个条件都为 true， 结果为 true,否则 false |\n| 逻辑与&  | 条件1 & 条件2  | 两个条件都为 true， 结果为 true,否则 false |\n\n**&& 和 & 使用区别**\n\n&ensp;&ensp;&ensp;&ensp;1）&&短路与： 如果第一个条件为 false，则第二个条件不会判断，最终结果为 false，效率高\n\n&ensp;&ensp;&ensp;&ensp;2）& 逻辑与：不管第一个条件是否为 false，第二个条件都要判断， 效率低\n\n&ensp;&ensp;&ensp;&ensp;3）开发中，我们使用的基本是使用短路与&&，效率高\n\n```java\n/**\n* 演示逻辑运算符的使用\n*/\npublic class LogicOperator01 {\n    //编写一个 main 方法\n    public static void main(String[] args) {\n        //&&短路与 和 & 案例演示\n        int age = 50;\n        if(age > 20 && age < 90) {\n            System.out.println(\"ok100\");\n        } \n        //&逻辑与使用\n        if(age > 20 & age < 90) {\n            System.out.println(\"ok200\");\n        } \n        //区别\n        int a = 4;\n        int b = 9;\n        //对于&&短路与而言， 如果第一个条件为 false ,后面的条件不再判断\n        //对于&逻辑与而言， 如果第一个条件为 false ,后面的条件仍然会判断\n        if(a < 1 & ++b < 50) {\n            System.out.println(\"ok300\");\n        } \n        System.out.println(\"a=\" + a + \" b=\" + b);// 4 10\n    }\n}\n```\n\n**|| 和 | 基本规则**\n\n|    名称     |       语法       |                     特点                      |\n| :---------: | :--------------: | :-------------------------------------------: |\n| \\|\\| 短路或 | 条件1 \\|\\| 条件2 |  只要有一个条件成立,结果为 true,否则为 false  |\n|  \\| 逻辑或  |  条件1 \\| 条件2  | 只要有一个条件成立，结果为 true，否则为 false |\n\n**|| 和 | 使用区别**\n\n&ensp;&ensp;&ensp;&ensp;1）||短路或：如果第一个条件为 true，则第二个条件不会判断，最终结果为 true，效率高\n\n&ensp;&ensp;&ensp;&ensp;2）| 逻辑或：不管第一个条件是否为 true，第二个条件都要判断，效率低\n\n&ensp;&ensp;&ensp;&ensp;3）开发中，我们基本使用 ||\n\n```java\n//演示| || 使用\npublic class LogicOperator02 {\n    //编写一个 main 方法\n    public static void main(String[] args) {\n        //||短路或 和 |逻辑或 案例演示\n        //|| 规则: 两个条件中只要有一个成立， 结果为 true,否则为 false\n        //| 规则: 两个条件中只要有一个成立， 结果为 true,否则为 false\n        int age = 50;\n        if(age > 20 || age < 30) {\n            System.out.println(\"ok100\");\n        } \n        //&逻辑与使用\n        if(age > 20 | age < 30) {\n            System.out.println(\"ok200\");\n        } //\n        看看区别\n        //(1)||短路或： 如果第一个条件为 true，\n        //则第二个条件不会判断， 最终结果为 true， 效率高\n        //(2)| 逻辑或： 不管第一个条件是否为 true， 第二个条件都要判断， 效率低\n        int a = 4;\n        int b = 9;\n        if( a > 1 || ++b > 4) { // 可以换成 | 测试\n            System.out.println(\"ok300\");\n        } \n        System.out.println(\"a=\" + a + \" b=\" + b); //4 10\n    }\n}\n```\n\n**! 取反 基本规则**\n\n|     名称     |  语法  |                    特点                     |\n| :----------: | :----: | :-----------------------------------------: |\n| ! 非（取反） | ! 条件 | 如果条件本身成立，结果为 false，否则为 true |\n\n```java\n//!和^案例演示\npublic class InverseOperator {\n    //编写一个 main 方法\n    public static void main(String[] args) {\n        //! 操作是取反 T->F , F -> T\n        System.out.println(60 > 20); //T\n        System.out.println(!(60 > 20)); //F\n        //a^b: 叫逻辑异或， 当 a 和 b 不同时， 则结果为 true, 否则为 false\n        boolean b = (10 > 1) ^ ( 3 > 5);\n        System.out.println(\"b=\" + b);//T\n    }\n}\n```\n\n**PS：根据逻辑与和短路与 还有逻辑或和短路或的特点【不同】，建议在实际开中使用短路与和短路或作为开发操作的原则**\n\n# <center>知识点六：位运算符</center>\n\njava 中有7个位运算(&、 |、 ^、 ~、 >>、 <<和 >>>)\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271916692.jpg\" alt=\"位运算符\" style=\"zoom:50%;\" />\n\n\\>>、 << 和 >>> ，运算规则:\n\n1) 算术右移 >>： 低位溢出,符号位不变,并用符号位补溢出的高位\n2) 算术左移 <<: 符号位不变,低位补 0\n3) 逻辑右移也叫无符号右移,运算规则是: 低位溢出， 高位补 0\n4) 特别说明： 没有 <<< 符号\n\n```java\n//位运算\n\n\npublic class BitOperator { \n\n    //编写一个main方法\n    public static void main(String[] args) {\n\n        //看老师的推导过程\n        //1. 先得到 2的补码 => 2的原码 00000000 00000000 00000000 00000010\n        //   2的补码 00000000 00000000 00000000 00000010\n        //2. 3的补码 3的原码 00000000 00000000 00000000 00000011\n        //   3的补码 00000000 00000000 00000000 00000011\n        //3. 按位&\n        //   00000000 00000000 00000000 00000010\n        //   00000000 00000000 00000000 00000011 \n        //   00000000 00000000 00000000 00000010 & 运算后的补码\n        //   运算后的原码 也是  00000000 00000000 00000000 00000010\n        //   结果就是  2\n        System.out.println(2&3);//2\n        \n        //推导\n        //1. 先得到 -2的原码 10000000 00000000 00000000 00000010\n        //2. -2的 反码         11111111 11111111 11111111 11111101\n        //3. -2的 补码       11111111 11111111 11111111 11111110\n        //4. ~-2操作        00000000 00000000 00000000 00000001运算后的补码\n        //5. 运算后的原码 就是 00000000 00000000 00000000 00000001 => 1\n        System.out.println(~-2);//1\n        \n        //推导\n        //1. 得到2的补码 00000000 00000000 00000000 00000010\n        //2. ~2操作     11111111 11111111 11111111 11111101  运算后的补码\n        //3. 运算后的反码  11111111 11111111 11111111 11111100\n        //4. 运算后的原码  10000000 00000000 00000000 00000011=>-3\n        System.out.println(~2); //-3\n        \n        System.out.println(1 >> 2); //0\n        System.out.println(1 << 2); //4\n        System.out.println(4 << 3); // 4 * 2 * 2 * 2 = 32\n        System.out.println(15 >> 2); // 15 / 2 / 2 = 3               \n    }\n}\n```\n\n# <center>知识点七：三目运算符</center>\n\n形式：\n\n&ensp;&ensp;&ensp;&ensp;**条件表达式 ? 结果1 : 结果2;** \n\n嵌套使用：\n\n&ensp;&ensp;&ensp;&ensp;条件表达式 ? 条件表达式 ? 结果1 : 结果2 : 结果3;\n\n例：//判断年龄如果大于18岁，输出成年人,但是如果大于60岁，输出老年人，否则输出未成年人\n\n```java\npublic class TernaryOperator {\n    //编写一个 main 方法\n    public static void main(String[] args) {\n        int a = 10;\n        int b = 99;\n        // 解读\n        // 1. a > b 为 false\n        // 2. 返回 b--, 先返回 b 的值,然后在 b-1\n        // 3. 返回的结果是 99\n        int result = a < b ? a++ : b--;\n        System.out.println(\"result=\" + result);    //10\n        System.out.println(\"a=\" + a);\t//11\n        System.out.println(\"b=\" + b);\t//99\n    }\n}\n```\n\n**使用细节**\n\n&ensp;&ensp;&ensp;&ensp;1）表达式 1 和表达式 2 要为可以赋给接收变量的类型(或可以自动转换)\n\n&ensp;&ensp;&ensp;&ensp;2）三元运算符可以转成 if--else 语句\n\n```java\nint res = a > b ? a++ : --b;\nif ( a > b) res = a++;    //等同\nelse res = --b;\npublic class TernaryOperatorDetail {\n    //编写一个 main 方法\n    public static void main(String[] args) {\n        //表达式 1 和表达式 2 要为可以赋给接收变量的类型\n        //(或可以自动转换/或者强制转换)\n        int a = 3;\n        int b = 8;\n        int c = a > b ? (int)1.1 : (int)3.4;//可以的\n        double d = a > b ? a : b + 3;//可以的， 满足 int -> double\n    }\n}\n```\n\n```java\npublic class TernaryOperatorExercise {\n    //编写一个 main 方法\n    public static void main(String[] args) {\n        //案例： 实现三个数的最大值\n        int n1 = 553;\n        int n2 = 33;\n        int n3 = 123;\n        //思路\n        //1. 先得到 n1 和 n2 中最大数 , 保存到 max1\n        //2. 然后再 求出 max1 和 n3 中的最大数， 保存到 max2\n        int max1 = n1 > n2 ? n1 : n2;\n        int max2 = max1 > n3 ? max1 : n3;\n        System.out.println(\"最大数=\" + max2);\n        //使用一条语句实现, 推荐使用上面方法\n        //老师提示: 后面我们可以使用更好方法,比如排序\n        // int max = (n1 > n2 ? n1 : n2) > n3 ?\n        // (n1 > n2 ? n1 : n2) : n3;\n        // System.out.println(\"最大数=\" + max);\n    }\n}\n```\n\n","tags":["Java"],"categories":["编程语言","Java"]},{"title":"12.表达式","url":"/post/74955f2f.html","content":"\n&ensp;&ensp;&ensp;&ensp;在Java代码中需要对某些数据执行操作，就需要使用数据组成一个计算等式，这个计算等式在Java中叫做表达式，利用表达式这个概念就可以使用运算符与变量或常量组成一个计算等式，让程序帮组我们进行计算以得到结果\n\n&ensp;&ensp;&ensp;&ensp;什么表达式？ ---》 表达式就是在Java中编写代码使用“变量、常量与运算符组成式子”就称之为表达式，根据使用不同运算符进行组合可以得到不同表达式，从而就可以得到不同计算结果以满足我们编程需求\n\n&ensp;&ensp;&ensp;&ensp;除了这种基本表达式之外，还可以利用一些特殊运算符将表达式在于表达式之间组合起来形成一个更加还复杂表达式来进行计算结果\n\n```java\n//例如：常见的表达式：\nint a = 1;\nint b = 2;\n求1+2等于几 --》 a+b ---》就是表达式\n求1+2/3等于几 --》 (a+b)/3 --》就是表达式\n比价1 > 2吗？ --》 a > b ---》就是表达式\n```\n\n","tags":["Java"],"categories":["编程语言","Java"]},{"title":"11.数据类型转换","url":"/post/75e75572.html","content":"\n8种基本数据类型中只有boolean类型时不参与到数据类型转换操作\n\n# <center>知识点一：数据类型转换的原因</center>\n\n在Java中要求等号左边和等号右边的类型要一致。如果出现不一致，就需要进行数据类型转换\n\n# <center>知识点二：自动类型转换</center>\n\n在数据类型兼容的情况下， 小转大就是自动类型转换\n\n自动类型转换也称之为隐式类型转换，即不需要做任何操作\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271914474.jpg\" alt=\"自动类型转换介绍\" style=\"zoom:50%;\" />\n\n**自动类型转换注意和细节**\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271914915.jpg\" alt=\"自动类型转换细节\" style=\"zoom:50%;\" />\n\n```java\n//自动类型转换细节\npublic class AutoConvertDetail {\n    //编写一个 main 方法\n    public static void main(String[] args) {\n        //细节 1： 有多种类型的数据混合运算时，\n        //系统首先自动将所有数据转换成容量最大的那种数据类型， 然后再进行计算\n        int n1 = 10; //ok\n        //float d1 = n1 + 1.1;//错误 n1 + 1.1 => 结果类型是 double\n        //double d1 = n1 + 1.1;//对 n1 + 1.1 => 结果类型是 double\n        float d1 = n1 + 1.1F;//对 n1 + 1.1 => 结果类型是 float\n        \n        //细节 2: 当我们把精度(容量)大 的数据类型赋值给精度(容量)小 的数据类型时，\n        //就会报错， 反之就会进行自动类型转换。\n\n        //int n2 = 1.1;//错误 double -> int\n        \n        //细节 3: (byte, short) 和 char 之间不会相互自动转换\n        //当把具体数赋给 byte 时， (1)先判断该数是否在 byte 范围内， 如果是就可以\n        byte b1 = 10; //对 , -128-127\n        // int n2 = 1; //n2 是 int\n        // byte b2 = n2; //错误， 原因： 如果是变量赋值， 判断类型\n\n        // char c1 = b1; //错误， 原因 byte 不能自动转成 char\n        \n        //细节 4: byte， short， char 他们三者可以计算， 在计算时首先转换为 int 类型\n        byte b2 = 1;\n        byte b3 = 2;\n        short s1 = 1;\n        //short s2 = b2 + s1;//错, b2 + s1 => int\n        int s2 = b2 + s1;//对, b2 + s1 => int\n        //byte b4 = b2 + b3; //错误: b2 + b3 => int\n\n        //boolean 不参与转换\n        boolean pass = true;\n        //int num100 = pass;// boolean 不参与类型的自动转换\n        //自动提升原则： 表达式结果的类型自动提升为 操作数中最大的类型\n        //看一道题\n        byte b4 = 1;\n        short s3 = 100;\n        int num200 = 1;\n        float num300 = 1.1F;\n        double num500 = b4 + s3 + num200 + num300; //float -> double\n    }\n}\n```\n\n# <center>知识点三：强制类型转换</center>\n\n在数据类型兼容的情况下， 大转小就是强制类型转换，但是可能会造成“精度缺失的风险”\n\n强制类型转换也称之为显式类型转换，需要添加对应语法\n\n## <center>1、语法</center>\n\n小数据类型 变量名字 = (小数据类型)大数据类型存储的数据；\n\n例：\n\n```java\np\nublic class VarDemo2\n{\n    public static void main(String[] args)\n    {\n        //提供一个long类型变量存储数据1000\n        long l1 = 1000l;\n        //提供一个int类型变量i1 存储 l1中变量值\n        /*\n        IDEA提供错误信息\n        Required type: int\n        Provided: long\n        i1这个变量实际的数据类型是int类型 提供的数据类型l1的变量类型long\n        无法进行赋值操作， long类型在内存中存储数据范围是8个字节\n        而int类型在内存存储是4个字节 long存储范围大于int类型存范围\n，所以在Java中这样语法是不支持的\n        */\n        //int i1 = l1;\n        //此时可以提供强制类型转换语法\n        // 小数据类型 变量名 = (小数据类型)存大数据类型数据的变量;\n        int i1 = (int)l1;\n        //演示精度缺失问题\n        //提供一个int类型变量存储数据130\n        int num1 = 130;\n        //将num1变量中存储数据赋值给byte类型变量\n        /*\n        byte类型存储范围是从-128~127之间，所以存储130超出当前范围\n        舍弃部分数据【即存储在内存二进制就会出现舍弃问题】\n        */\n        byte num2 = (byte)num1;\n        System.out.println(num2);\n    }\n}\n```\n\n## <center>2、强制类型转换细节说明</center>\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271915957.jpg\" alt=\"强制类型转换细节\" style=\"zoom:50%;\" />\n\n# <center>知识点四：数据类型转换注意点</center>\n\n1、boolean不能参与任何数据类型转换\n\n2、基本类型中范围(数据大小)\n\n &ensp;&ensp;&ensp;&ensp;byte  short/char int  long  float  double\n\n3、强制类型转换可能会造成数据丢失\n\n4、数据类型提升（结果：按范围大的）\n\n&ensp;&ensp;&ensp;&ensp;表达式中有double结果double\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;有float\t结果float\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;有long\t结果long\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;有int\t结果int\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;有char、byte、short  结果为int\n\n# <center>知识点五：基本数据类型和 String 类型的转换</center>\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271915245.jpg\" alt=\"基本数据类型和String类型的转换\" style=\"zoom:50%;\" />\n\n```java\npublic class StringToBasic {\n    //编写一个 main 方法\n    public static void main(String[] args) {\n        //基本数据类型->String\n        int n1 = 100;\n        float f1 = 1.1F;\n        double d1 = 4.5;\n        boolean b1 = true;\n        String s1 = n1 + \"\";\n        String s2 = f1 + \"\";\n        String s3 = d1 + \"\";\n        String s4 = b1 + \"\";\n        System.out.println(s1 + \" \" + s2 + \" \" + s3 + \" \" + s4);\n        //String->对应的基本数据类型\n        String s5 = \"123\";\n        //会在 OOP 讲对象和方法的时候回详细\n        //解读 使用 基本数据类型对应的包装类， 的相应方法， 得到基本数据类型\n        int num1 = Integer.parseInt(s5);\n        double num2 = Double.parseDouble(s5);\n        float num3 = Float.parseFloat(s5);\n        long num4 = Long.parseLong(s5);\n        byte num5 = Byte.parseByte(s5);\n        boolean b = Boolean.parseBoolean(\"true\");\n        short num6 = Short.parseShort(s5);\n        System.out.println(\"===================\");\n        System.out.println(num1);//123\n        System.out.println(num2);//123.0\n        System.out.println(num3);//123.0\n        System.out.println(num4);//123\n        System.out.println(num5);//123\n        System.out.println(num6);//123\n        System.out.println(b);//true\n        \n        //怎么把字符串转成字符 char -> 含义是指 把字符串的第一个字符得到\n        //解读 s5.charAt(0) 得到 s5 字符串的第一个字符 '1'\n        System.out.println(s5.charAt(0));\n    }\n}\n```\n\n**注意事项**\n\n&ensp;&ensp;&ensp;&ensp;1）在将 String 类型转成 基本数据类型时，比如 我们可以把 \"123\" , 转成一个整数，但是不能把 \"hello\" 转成一个整数\n\n&ensp;&ensp;&ensp;&ensp;2）如果格式不正确， 就会抛出异常， 程序就会终止，这个问题在异常处理章节中，会处理\n\n```java\n/**\n* 演示字符串转基本数据类型的细节\n*/\npublic class StringToBasicDetail {\n    //编写一个 main 方法\n    public static void main(String[] args) {\n        String str = \"hello\";\n        //转成 int\n        int n1 = Integer.parseInt(str);\n        System.out.println(n1);\n    }\n}\n```\n\n","tags":["Java"],"categories":["编程语言","Java"]},{"title":"10.转义字符和访问修饰符","url":"/post/6a2c2bbd.html","content":"\n# <center>知识点一、转义字符</center>\n\n常见转义字符\n\n| 符号 |    含义    |\n| :--: | :--------: |\n|  \\n  |  表示换行  |\n|  \\t  | 表示制表位 |\n|  \\\\  |   一个\\    |\n|  \\\"  |   一个\"    |\n|  \\'  |   一个'    |\n|  \\r  |  一个回车  |\n\n注意：\n\n&ensp;&ensp;&ensp;&ensp;1、反斜杠不能单独使用\n\n&ensp;&ensp;&ensp;&ensp;2、在代码注释中不能出现 \\\n\n&ensp;&ensp;&ensp;&ensp;3、\" \"不能重复包含，除非用转义字符\n\n```java\nSystem.out.println(\"你\\\"真棒\\\"\");\n//演示转义字符的使用\npublic class ChangeChar {\n    //编写一个 main 方法\n    public static void main(String[] args) {\n        //\\t ： 一个制表位， 实现对齐的功能\n        System.out.println(\"北京\\t 天津\\t 上海\");\n        // \\n ： 换行符\n        System.out.println(\"jack\\nsmith\\nmary\");\n        // \\\\ ： 一个\\ \\\\\n        System.out.println(\"C:\\\\Windows\\\\System32\\\\cmd.exe\");\n        // \\\" :一个\"\n        System.out.println(\"老韩说:\\\"要好好学习 java,有前途\\\"\");\n        // \\' ： 一个'\n        System.out.println(\"老韩说:\\'要好好学习 java,有前途\\'\");\n        // \\r :一个回车 System.out.println(\"韩顺平教育\\r 北京\");\n        // 解读\n        // 1. 输出 韩顺平教育\n        // 2. \\r 表示回车\n        System.out.println(\"韩顺平教育\\r 北京\"); // 北京平教育\n    }\n}\n```\n\n# <center>知识点二、访问修饰符</center>\n\n访问修饰符：可以修饰属性、方法、内部类\n\n修饰符修饰类\n\n&ensp;&ensp;&ensp;&ensp;**修饰的访问权限修饰符**一共有两个 一个public 和 一个default/package【默认不写】\n\n&ensp;&ensp;&ensp;&ensp;public是最大权限在工程中任意一个位置都可以访问\n\n&ensp;&ensp;&ensp;&ensp;default/package【默认不写】包权限，当前包内部可以访问\n\n| private |       default/package        | protected | public |\n| :-----: | :--------------------------: | :-------: | :----: |\n| 私有的  | 默认的或包权限->默认不用定义 | 受保护的  | 公开的 |\n\n|                        修饰符                        | 本类 | 同包 |        子类【本包子类和跨包子 类】         | 不同包 |\n| :--------------------------------------------------: | :--: | :--: | :----------------------------------------: | :----: |\n|                  private【私有的】                   |  √   |      |                                            |        |\n| default/package【默认权限或包权限 --》默认不用定义】 |  √   |  √   | 【本包子类可以访问】【跨包子类不可以访问】 |        |\n|                 protected【保护的】                  |  √   |  √   |                     √                      |        |\n|                   public【公有的】                   |  √   |  √   |                     √                      |   √    |\n\n&ensp;&ensp;&ensp;&ensp;对于现在Java开发而言，访问权限修饰符修饰属性和行为时，只有两个权限【private 或 public】，要么就是大家都可以访问，要么就是大家谁也别访问\n","tags":["Java"],"categories":["编程语言","Java"]},{"title":"9.数据类型","url":"/post/5c2f197a.html","content":"\n# <center>知识点一：整数类</center>\n\n| 类型  | 所占字节 | 所占位数 |    取值范围    |\n| :---: | :------: | :------: | :------------: |\n| byte  |  1字节   |   8位    |  -2^7 ~ 2^7-1  |\n| short |  2字节   |    16    | -2^15 ~2^15-1  |\n|  int  |  4字节   |    32    | -2^31 ~ 2^31-1 |\n| long  |  8字节   |    64    | -2^63 ~ 2^63-1 |\n\n# <center>知识点二：浮点类型</center>\n\n|  类型  | 所占字节 | 所占位数 | 取值范围  | 有效数位 |\n| :----: | :------: | :------: | :-------: | :------: |\n| float  |  4字节   |   32位   | ±3.4E+38  |   7位    |\n| double |  8字节   |   64位   | ±1.7E+308 |   16位   |\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271912047.jpg\" alt=\"浮点类型\" style=\"zoom: 50%;\" />\n\n# <center>知识点三：布尔类型</center>\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271912251.jpg\" alt=\"布尔类型\" style=\"zoom:50%;\" />\n\n|  类型   | 所占字节 | 所占位数 |  取值范围  |\n| :-----: | :------: | :------: | :--------: |\n| boolean |  1字节   |   8位    | true\\false |\n\n# <center>知识点四：字符类型</center>\n\n| 类型 | 所占字节 | 所占位数 | 取值范围 |\n| :--: | :------: | :------: | :------: |\n| char |  2字节   |   16位   | 0~65535  |\n\n```java\npublic class CharDetail {\n    //编写一个 main 方法\n    public static void main(String[] args) {\n        //在 java 中， char 的本质是一个整数， 在默认输出时， 是 unicode 码对应的字符\n        //要输出对应的数字， 可以(int)字符\n        char c1 = 97;\n        System.out.println(c1); // a\n        char c2 = 'a'; //输出'a' 对应的 数字\n        System.out.println((int)c2);\n        char c3 = '韩';\n        System.out.println((int)c3);//38889\n        char c4 = 38889;\n        System.out.println(c4);//韩\n        //char 类型是可以进行运算的， 相当于一个整数， 因为它都对应有 Unicode 码.\n        System.out.println('a' + 10);//107\n        //课堂小测试\n        char c5 = 'b' + 1;//98+1==> 99\n        System.out.println((int)c5); //99\n        System.out.println(c5); //99->对应的字符->编码表 ASCII(规定好的)=>c\n    }\n}\n```\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271912602.jpg\" alt=\"字符类型\" style=\"zoom: 67%;\" />\n\n# <center>知识点五：引用数据类型</center>\n\nString 表示：引用数据类型 \n\n在一切用 \" \" 包裹起来的类型都是String类型 （也就是表示字符串）\n\n例：String name = \"张三\";\n\n# <center>知识点六：注意细节</center>\n\nlong类型数据需要在最后添加  L、l\n\nfloat类型数据需要在最后添加  F、f\n\n字符必须使用 ' ' 表示，字符串必须要使用 \" \" \n\n在java中整数默认是int类型，浮点数默认是double类型\n\n因为小数使用是科学计数法存储数据的，所以在某些要求小数精度的存储的行业中是不允许使用float和double类型，因为这个类型在计算时会出现精度不精准问题【日常开发开发计算还是可以】，所以为了解决这个问题提供BigDecimal类型作为精度小数计算\n\n# <center>知识点七：字节码介绍</center>\n\n**ASCII 码介绍(了解)**\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271913393.jpg\" alt=\"ASCII码介绍\" style=\"zoom:67%;\" />\n\n**Unicode 编码介绍**\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271913840.jpg\" alt=\"Unicode编码介绍\" style=\"zoom:67%;\" />\n\n**UTF-8 编码介绍**\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271913917.jpg\" alt=\"UTF-8编码介绍\" style=\"zoom:67%;\" />\n","tags":["Java"],"categories":["编程语言","Java"]},{"title":"8.关键字和保留字","url":"/post/4a789563.html","content":"\n# <center>知识点一：特点</center>\n\n定义：被 Java 语言赋予了特殊含义， 用做专门用途的字符串（单词）\n\n特点：关键字中所有字母都为小写\n\n# <center>知识点二：所有关键字及保留字</center>\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271911616.jpg\" alt=\"关键字及保留字\" style=\"zoom: 67%;\" />\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271911029.jpg\" alt=\"关键字及保留字1\" style=\"zoom:67%;\" />\n\n## <center>保留字</center>\n\n**介绍**\n\n&ensp;&ensp;&ensp;&ensp;Java 保留字：现有 Java 版本尚未使用，但以后版本可能会作为关键字使用。自己命名标识符时要避免使用这些保留字 \n\n&ensp;&ensp;&ensp;&ensp;byValue、cast、future、generic、inner、operator、outer、rest、var 、goto 、const\n","tags":["Java"],"categories":["编程语言","Java"]},{"title":"7.标识符","url":"/post/c46a5cd3.html","content":"\n# <center>知识点一：含义</center>\n\n标识符是用户编程时使用的名字，用于给类、方法、变量、常量等命名。\n\n在写代码的时候为了增强代码的阅读性会自定义很多名字，比如：类名，方法名，变量名等。\n\n在编程的里我们把这种为了增强程序阅读性而自定义的名称，称为标识符。\n\n标识符（变量名，类名，包名，方法名.....）\n\n# <center>知识点二：标识符命名规则</center>\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271911800.jpg\" alt=\"标识符命名规则\" style=\"zoom:67%;\" />\n\n**形式**\n\n1) 包名： 多单词组成时所有字母都小写：aaa.bbb.ccc //比如 com.hsp.crm\n2) 类名、 接口名： 多单词组成时， 所有单词的首字母大写：XxxYyyZzz [大驼峰]\n\n&ensp;&ensp;&ensp;&ensp;比如：TankShotGame\n\n3) 变量名、 方法名： 多单词组成时\n\n&ensp;&ensp;&ensp;&ensp;第一个单词首字母小写， 第二个单词开始每个单词首字母大写： xxxYyyZzz [小驼峰，简称 驼峰法]\n\n&ensp;&ensp;&ensp;&ensp;比如：tankShotGame\n\n4) 常量名：所有字母都大写。 多单词时每个单词用下划线连接：XXX_YYY_ZZZ\n\n&ensp;&ensp;&ensp;&ensp;比如：定义一个所得税率 TAX_RATE\n\n5) 后面我们学习到 类， 包， 接口， 等时， 我们的命名规范要这样遵守,更加详细的看文档\n","tags":["Java"],"categories":["编程语言","Java"]},{"title":"6.变量","url":"/post/1b3fd879.html","content":"\n# <center>知识点一：定义</center>\n\n&ensp;&ensp;&ensp;&ensp;对比常量而言变量其实就是一个可以存储数据量，既然常量可以完成打印和计算等编程操作，那为什么要有变量提供，如果在代码中大量使用常量形式参与计算或打印，一旦代码发生了修改，就要面临大量代码重复性修改的操作\n\n&ensp;&ensp;&ensp;&ensp;为了解决这样问题，所以Java提供一种数据存储形式，这个形式就是变量，将数据存储到一个变量中，在操作时候操作这个变量就就间接的等于操作数据，如果出现了数据的修改，只需要修改变量中存储的数据，可以在使用变量的位置修改数据\n\n&ensp;&ensp;&ensp;&ensp;变量：表示存储空间，可用来存放某一类型的常量，没有固定值，并可以重复使用，也可以用来存储某种类型的数据\n\n# <center>知识点二：特点</center>\n\n- 占据着内存中的某一块存储区域；\n- 该区域有自己的名称（变量名）和类型(数据类型)；\n- 可以被重复使用;\n- 该区域的数据可以在同一类型范围内不断变化；\n- 在同一个{}大括号中，变量名必须是唯一，不允许重复\n\n# <center>知识点三：语法</center>\n\n1、\n\n```java\n数据类型 变量名;\n变量名 = 值;\n```\n\n这种定义变量方式，先定义在赋值\n\n2、\n\n```java\n数据类型 变量名 = 值;\n```\n\n这种定义变量方式，在定义变量同时对变量进行赋值操作\n\n3、\n\n除了上述2中定义变量的方式之外，还支持以下语法（了解即可）\n\n同时定义多个变量 \n\n&ensp;&ensp;&ensp;&ensp;数据类型 变量1，变量2，变量3...;\n\n同时定义多个变量并分别赋值\n\n&ensp;&ensp;&ensp;&ensp;数据类型 变量名1 = 值，变量名2 = 值， 变量名3 = 值...;\n\n```java\npublic class Demo01{\n    public static void main(String[] args)\n    {\n        /*\n            //方式1：\n            //1、申明变量\n            int a;\n            //2、变量赋值\n            a = 10;\n            //3、使用变量\n            System.out.println(a);\n        */\n        \n        /*\n            //方式2：\n            //1、申明变量申明变量和变量初始化\n            int a = 10;\n            //2、使用变量\n            System.out.println(\"a的值为：\"+a);\n        */\n        \n        //方式3：\n        //连续定义多个变量 int a; int b; int c = 10;\n        int a,b,c = 10;\n        b = 20;             \n        // System.out.println(\"a的值为：\"+a); 错误代码（没有初始化）\n        System.out.println(\"c的值为：\"+c);\n        //注意：在java中变量一定要初始化才能使用\n    }\n}\n```\n\n# <center>知识点四：变量定义说明</center>\n\n1. 什么数据类型？\n\n&ensp;&ensp;&ensp;&ensp;理解为当前这个变量可以存储什么样数据\n\n2. 变量名？\n\n&ensp;&ensp;&ensp;&ensp;理解为变量名相当于是一个代号，使用变量名就相当于使用数据\n\n&ensp;&ensp;&ensp;&ensp;变量的在定义的时候必须满足标识符的规则\n\n3. =（等号）\n\n&ensp;&ensp;&ensp;&ensp;等号在Java中与在数学中是不一样的，在数学中等号代表的是相等\n\n&ensp;&ensp;&ensp;&ensp;在Java中等号代表的就是赋值操作， 将等号右边值存储到等号左边\n\n4. 值？\n\n&ensp;&ensp;&ensp;&ensp;值是根据 前面的数据类型决定的，不能随意的赋值，数据类型时什么就可以赋值对应范围内容的值\n","tags":["Java"],"categories":["编程语言","Java"]},{"title":"5.常量","url":"/post/26831432.html","content":"\n# <center>知识点一：定义</center>\n\n常量：在程序运行过程中，其值不可以发生改变的量\n\nJava中常量存在方式一共有两种形态：字面常量和定义常量\n\n# <center>知识点二：什么是字面常量</center>\n\n字面常量指的是：通过观察就可以得知数据的大小\n\n字面常量是可以直接在Java代码中使用，既可以打印数据也可以作为计算操作\n\n# <center>知识点三：Java中的常量分类</center>\n\n字符串常量\n\n&ensp;&ensp;&ensp;&ensp;用双引号括起来的多个字符（可以包含0个、一个或多个）例如\"a\"、\"abc\"、\"中国\"等\n\n整数常量\n\n&ensp;&ensp;&ensp;&ensp;整数，例如：-10、0、88等\n\n小数常量\n\n&ensp;&ensp;&ensp;&ensp;小数，例如：-5.5、1.0、88.88等\n\n字符常量\n\n&ensp;&ensp;&ensp;&ensp;用单引号括起来的一个字符，例如：'a'、'5'、'B'、'中'等\n\n布尔常量\n\n&ensp;&ensp;&ensp;&ensp;布尔值，表示真假，只有两个值true和false\n\n空常量\n\n&ensp;&ensp;&ensp;&ensp;一个特殊的值，空值，值为null\n\n除空常量外，其他常量均可使用输出语句直接输出\n\n```java\n/*\n    常量演示\n*/\npublic class FinalDemo\n{\n    public static void main(String[] args)\n    {\n        //打印数据10到控制台\n        System.out.println(10);\n        //打印数据1.2到控制台\n        System.out.println(1.2);\n        //打印字符串到控制台\n        System.out.println(\"欢迎各位同学来到千锋学习\");\n        //利用常量进行计算\n        //求10+10等于几\n        System.out.println(10+10);\n    }\n}\n```\n\n","tags":["Java"],"categories":["编程语言","Java"]},{"title":"4.编程规范","url":"/post/3cc3da73.html","content":"\n# <center>知识点一：注释</center>\n\n## <center>1、单行注释</center>\n\n形式：\n\n```java\n// 注释内容\n```\n\n应用场景：对一行代码的解释\n\n## <center>2、多行注释</center>\n\n形式： \n\n```java\n/*\n    注释内容 \n*/\n```\n\n应用场景：对一段代码的解释\n\n## <center>3、文档注释</center>\n\n形式：\n\n```java\n/** \n    注释内容 \n*/\n```\n\n应用场景：对整个类/方法的解释\n\n![文档注释](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271751002.jpg)\n\n# <center>知识点二：Javadoc标签</center>\n\njavadoc 工具软件识别以下标签：\n\n|     **标签**      |                          **描述**                          |                           **示例**                           |\n| :---------------: | :--------------------------------------------------------: | :----------------------------------------------------------: |\n|    **@author**    |                    **标识一个类的作者**                    |                   **@author  description**                   |\n|  **@deprecated**  |                 **指名一个过期的类或成员**                 |                 **@deprecated  description**                 |\n|  **{@docRoot}**   |                **指明当前文档根目录的路径**                |                     **Directory  Path**                      |\n|  **@exception**   |                  **标志一个类抛出的异常**                  |          **@exception  exception-name explanation**          |\n| **{@inheritDoc}** |                  **从直接父类继承的注释**                  |   **Inherits a  comment from the immediate surperclass.**    |\n|    **{@link}**    |               **插入一个到另一个主题的链接**               |                    **{@link  name text}**                    |\n| **{@linkplain}**  |  **插入一个到另一个主题的链接，但是该链接显示纯文本字体**  |        **Inserts an  in-line link to another topic.**        |\n|    **@param**     |                   **说明一个方法的参数**                   |            **@param  parameter-name explanation**            |\n|    **@return**    |                     **说明返回值类型**                     |                   **@return  explanation**                   |\n|     **@see**      |               **指定一个到另一个主题的链接**               |                       **@see  anchor**                       |\n|    **@serial**    |                   **说明一个序列化属性**                   |                   **@serial  description**                   |\n|  **@serialData**  | **说明通过writeObject( ) 和 writeExternal( )方法写的数据** |                 **@serialData  description**                 |\n| **@serialField**  |             **说明一个ObjectStreamField组件**              |           **@serialField  name type description**            |\n|    **@since**     |               **标记当引入一个特定的变化时**               |                     **@since  release**                      |\n|    **@throws**    |                **和  @exception标签一样.**                 | **The  @throws tag has the same meaning as the @exception tag.** |\n|   **{@value}**    |         **显示常量的值，该常量必须是static属性。**         | **Displays  the value of a constant, which must be a static field.** |\n|   **@version**    |                      **指定类的版本**                      |                      **@version  info**                      |\n\n# <center>知识点三：类的阐述</center>\n\n1、同一个源文件中可以定义多个类\n\n2、编译后，每个类都会生成独立的 .class文件\n\n3、一个类中，只能有一个主方法，每个类都可以有自己的主方法\n\n4、public修饰的类称为公开类，要求 类名 必须与 文件名称 完全相同，包括大小写\n\n5、一个源文件中，只能有一个公开类(public)\n\n# <center>知识点四：包的阐述</center>\n\n作用：类似于文件夹，用于管理字节码（.class）文件\n\n语法：package 包名\n\n位置：必须写在源文件的第一行\n\n包如何定义\n\n&ensp;&ensp;&ensp;&ensp;1、包名不允许以java开头，因为java有安全检查机制【Java提供系统API都是以java开头】\n\n&ensp;&ensp;&ensp;&ensp;2、包名建议全小写，包名要遵守标识符的命名规则，不建议使用关键字作为包名\n\n&ensp;&ensp;&ensp;&ensp;3、在开发中包名是有同一个固定写法的，首先就是包名的开头【一般就是你公司域名倒写，不包括www】\n\n采用域名倒置的规则：www.baidu.com -> com.baidu.xxx\n\n&ensp;&ensp;&ensp;&ensp;例如：com.qfedu.xxx\n\n可能你的公司域名是数字 ---》 www.360.com ---》com._360 ---》在数字之前添加下划线这样就合法了\n\nps：在项目中我们看到包名是以com.qfedu.encaps.homework这种方式分层的\n\n&ensp;&ensp;&ensp;&ensp;在实际系统中 C:\\IdeaProjects\\Encapsulation\\src\\com\\qfedu\\encaps\\homework\n\n&ensp;&ensp;&ensp;&ensp;是以路径形式划分的，所以在项目中【.】其实在路径中是以[\\]\n\n&ensp;&ensp;&ensp;&ensp;在项目中创建包其实就是在间接创建文件夹\n\n# <center>知识点五：编写Java代码的规则</center>\n\n1、在Java中最小程序单元是“类”，换句话说需要编写Java代码就需要创建一个类文件，只有在类文件中才可以编写Java代码\n\n2、在创建类文件名称的会将类文件名称作为当前创建类的名字\n\n![编写Java代码的规则1](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271752471.jpg)\n\n3、如果这个类使用 public 这个关键字 那么类名字必须和文件名字一致\n\n![编写Java代码的规则2](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271752733.jpg)\n\n4、如果程序中出现了 红色波浪线 或 红色的字体，证明编写代码出现了错误，这个错误IDEA使用红色波浪险 或 红色的字体来进行提示，你必须进行修改代码\n\n![编写Java代码的规则3](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271752661.jpg)\n\n5、代码中括号必须成对出现，在Java编写代码时，代表一个语句结束需要使用【;】，但是不是所有位置都要添加【;】\n\n![编写Java代码的规则4](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271752784.jpg)\n\n6、在Java程序开发过程中，一共会得到两个文件夹，一个是以.java作为文件结尾的，称之为Java源文件【就是创建在src文件中的文件，主要提供代码编写】，另外一个是以.class作为文件结尾的，称之为字节码文件【就是在out目录中的文件，主要提供是对.java文件编译之后形成字节码文件，主要提供是执行操作】\n\n![编写Java代码的规则5](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271910037.jpg)\n\n7、对第一个Java程序进行进行一个简单的说明\n\n![编写Java代码的规则6](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271910073.jpg)\n","tags":["Java"],"categories":["编程语言","Java"]},{"title":"3.Java的概述","url":"/post/fbc82303.html","content":"\n# <center>知识点一：Java语言背景介绍</center>\n\n操作系统：是管理和控制计算机硬件与软件资源的计算机程序，是直接运行在“裸机”上的最基本的\n\n系统软件，任何其他软件都必须在操作系统的支持下才能运行。\n\n&ensp;&ensp;&ensp;&ensp;Windows: Windows95、98、2000、XP、vista、7、8、10\n\n&ensp;&ensp;&ensp;&ensp;Unix 服务器端\n\n&ensp;&ensp;&ensp;&ensp;Linux 开源的 Ubuntu、CentOS、Debian\n\n语言：人与人交流沟通的表达方式\n\n计算机语言：人与计算机之间进行信息交流沟通的一种特殊语言\n\nJava语言是美国Sun公司（Stanford University Network）在1995年推出的计算机语言\n\nJava之父：詹姆斯·高斯林（James Gosling）\n\n2009年，Sun公司被甲骨文公司收购，所以我们现在访问oracle官网即可：\n\n&ensp;&ensp;&ensp;&ensp;https://www.oracle.com\n\n2011年，甲骨文公司举行了全球性的活动，以庆祝Java7的推出，随后Java7正式发布。\n\n2014年，甲骨文公司发布了Java8正式版\n\n2017年，甲骨文发布Java9\n\n从Java9之后Oracle近日宣布，他们将Java的发布频率改为每六个月一次。最新的是Java17\n\nJava语言的三个版本：\n\n&ensp;&ensp;&ensp;&ensp;JavaSE: Java 语言的（标准版），用于桌面应用的开发，是其他两个版本的基础\n\n&ensp;&ensp;&ensp;&ensp;JavaME: Java 语言的（小型版），用于嵌入式消费类电子设备\n\n&ensp;&ensp;&ensp;&ensp;JavaEE: Java 语言的（企业版），用于 Web 方向的网站开发\n\nJava是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征\n\nJava语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程 \n\nJava具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点\n\n# <center>知识点二：Java语言跨平台原理</center>\n\n&ensp;&ensp;&ensp;&ensp;Java程序并非是直接运行的，Java编译器将Java源程序编译成与平台无关的字节码文件(class文件)，然后由Java虚拟机（JVM）对字节码文件解释执行。所以在不同的操作系统下，只需安装不同的Java虚拟机即可实现java程序的跨平台\n\n# <center>知识点三：JRE和JDK</center>\n\nJDK：JRE +java开发工具\n\nJRE： JVM + 核心类库\n\nJVM：Java虚拟机，虚拟计算机，通过虚拟计算机运行Java程序\n\n总结：我们只需安装JDK即可，它包含了java的运行环境和虚拟机\n\n# <center>知识点四：JDK的安装目录介绍</center>\n\n| 目录名称 |                            说明                            |\n| :------: | :--------------------------------------------------------: |\n|   bin    | 该路径下存放了JDK的各种工具命令。javac和java就放在这个目录 |\n|   conf   |              该路径下存放了JDK的相关配置文件               |\n| include  |             该路径下存放了一些平台特定的头文件             |\n|  jmods   |                该路径下存放了JDK的各种模块                 |\n|  legal   |             该路径下存放了JDK各模块的授权文档              |\n|   lib    |            该路径下存放了JDK工具的一些补充JAR包            |\n\n# <center>知识点五：类对象和类的对象</center>\n\n类的对象：指的是通过new关键字产生的对象称类的对象\n\n类对象：指的是类加载的时候产生的类对象（只会加载再一次）\n","tags":["Java"],"categories":["编程语言","Java"]},{"title":"2.计算机基础","url":"/post/3ccb602.html","content":"\n# <center>知识点一：计算机单位</center>\n\n8 Bit(位) ----- 1024 Byte(字节) ----1024 KB(千字节) ---- 1024 MB(兆) ---- 1024 GB ---- 1024TB\n\nPB \tEB  ZB\tYB\tBB\tNB\tDB\tCB\tXB\n\n口诀：别苦闷国土配额资源不能动次序 \n\n# <center>知识点二：常用的DOS命令</center>\n\n打开DOS窗口：WIN+R 再输入cmd \n\n1）查看当前目录是有什么内容 dir\n\n&ensp;&ensp;&ensp;&ensp;dir dir d:\\abc2\\test200\n\n2）切换到其他盘下： 盘符号 cd : change directory\n\n&ensp;&ensp;&ensp;&ensp;案例演示：切换到 c 盘   cd /D c:\n\n3）切换到当前盘的其他目录下 (使用相对路径和绝对路径演示), ..\\表示上一级目录\n\n&ensp;&ensp;&ensp;&ensp;案例演示：cd d:\\abc2\\test200 cd ..\\..\\abc2\\test200\n\n4）切换到上一级：\n\n&ensp;&ensp;&ensp;&ensp;案例演示：cd ..\n\n5）切换到根目录： cd \\\n\n&ensp;&ensp;&ensp;&ensp;案例演示：cd \\\n\n6）查看指定的目录下所有的子级目录 tree\n\n7）清屏 cls [苍老师]\n\n8）退出 DOS exit\n\n9）说明: 因为小伙伴后面使用 DOS 非常少， 所以对下面的几个指令， 老韩给大家演示下, 大家了解即可 (md[创建目录],rd[删除目录],copy[拷贝文件],del[删除文件],echo[输入内容到文件],type,move[剪切]) => Linux\n\n|    命令     |           含意           |\n| :---------: | :----------------------: |\n| cd 目录路径 |         目录切换         |\n|    cd .     |       表示当前目录       |\n|     tab     |         自动补全         |\n|   上下键    | 快速查看之前输入过的命令 |\n|  ipconfig   |   查看当前电脑的ip地址   |\n|   ctrl+C    |     强制停止当前命令     |\n|    calc     |        打开计算器        |\n|   notepad   |        打开记事本        |\n|  ping 网站  |      查看是否有网络      |\n\n# <center>知识点三：进制</center>\n\n需要分组的只有八进制和十六进制，八进制3个数字为一组，十六进制4个数字为一组\n\n对于整数， 有四种表示方式：\n\n&ensp;&ensp;&ensp;&ensp;二进制：0,1 ，满 2 进 1，以 0b 或 0B 开头\n\n&ensp;&ensp;&ensp;&ensp;十进制：0-9 ，满 10 进 1\n\n&ensp;&ensp;&ensp;&ensp;八进制：0-7 ，满 8 进 1，以数字 0 开头表示\n\n&ensp;&ensp;&ensp;&ensp;十六进制：0-9 及 A(10) - F(15)，满 16 进 1，以 0x 或 0X 开头表示。此处的 A-F 不区分大小写\n\n方法：8421法\n\n### <center>二进制转八进制</center>\n\n三位为一组，一组按1，2，4分\n\n0 0 1 1  0 1 0 0\n\n​      4 2  1 4 2 1\n\n————————————\n\n从左往右，三位一组，第一组三位中二进制为1的相加得八进制的个位，第二组三位中二进制为1的相加得八进制的十位，如果有第三组三位数则为1相加则为八进制的百位，以此类推\n\n第一个三位二进制，1 0 0 则 421，为1的只有4，则八进制个位数为4\n\n第二个三位二进制，1 1 0 则 421，为1的有4 和 2，则八进制十位数为4 + 2 = 6\n\n则八进制为：(0)64\n\n### <center>八进制转二进制</center>\n\n八进制拆开单独数字，一个数字对应三位 再按1，2，4分解\n\n64 --》分为两组(三位一组)，从左到右，第一组为4，第二组为6，6又分为4 + 2，有对应数字的二进制为1，没有为0\n\n4 2 1 4 2 1\n\n1 1 0 1 0 0\n\n位数不足补零\t0011 0100\n\n### <center>二进制转十进制</center>\n\n直接按1、2、4、8.....分，二进制为1的数字相加\n\n0 0 0 1  0 1 0 1\n\n​         16 8 4 2 1\n\n————————————\n\n16+4+1 = 21\n\n### <center>十进制转二进制</center>\n\n十进制拆分，1，2，4，8........组合的数，无需分组\n\n21 = 16 + 4 + 1\n\n16 8 4 2 1\n\n——————\n\n1   0 1 0 1\t位数不足补零，0001 0101\n\n### <center>二进制转十六进制</center>\n\n四位为一组，一组按1，2，4，8分\n\n0 0 1 1  0 1 0 0\n\n8 4 2 1  8 4 2 1\n\n————————\n\n从左往右，四位一组，第一组四位中二进制为1的相加得十六进制的个位，第二组四位中二进制为1的相加得十六进制的十位，第三组四位中二进制为1的相加得十六进制的百位，以此类推\n\n第一个四位二进制，0 1 0 0 则 8421，为1的只有4，则八进制个位数为4\n\n第二个四位二进制，0 0 1 1 则 8421，为1的有1 和 2，则八进制十位数为1 + 2 = 3\n\n则十六进制为：0x34\n\n### <center>十六进制转二进制</center>\n\n十六进制数分开单个数字，一个数字对应四位，并拆分 1，2，4，8....数组成\n\n0x2A =》分为两组(四位一组)，从左到右，第一组为A，A又分为8 + 2，第二组为2，有对应数字的二进制为1，没有为0\n\n8 4 2 1  8 4 2 1\n\n————————————————\n\n0 0 1 0  1 0 1 0\n\n### <center>八进制转十进制</center>\n\n八转二，二转十\n\n### <center>十进制转八进制</center>\n\n十转二，二转八\n\n### <center>八进制转十六进制</center>\n\n八转二，二转十六\n\n### <center>十六进制转八进制</center>\n\n十六转二，二转八\n\n### <center>十进制转十六进制</center>\n\n十转二，二转十六\n\n### <center>十六进制转十进制</center>\n\n十六转二，二转十\n\n# <center>知识点四：原码、反码和补码</center>\n\n![原码 反码 补码](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271750019.png)\n\n计算中存储数据都是以二进制形式继续进行存储了，存储数据在内存值是需要开辟空间的，这个空间是存在一个大小\n\n```java\n8bit（位） = 1byte（字节 K） ---》8位是指8个二进制\n1024 byte(k) = 1KB\n1024 Kb = 1MB\n1024 MB = 1GB\n1024 GB = 1TB\n1024 TB = 1PB\n```\n\n计算机存储数据是要开辟空间，计算中最小开辟空间单位是 “**字节**”\n\n## <center>1、原码</center>\n\n原码是可以直观的观察出数据的大小，数据在内存那种如何表示原码\n\n即使用二进制的形式表示数据的存储原码，最高位即左侧第一位使用【0】表示正数，【1】表示负数，其余位数表示数据的大小\n\n1字节 等于 8位 即 0000 0000（8 位二进制）\n\n例如：正数7 和 负数 7 使用原码进行展示\n\n```java\n正数7 ----》 使用 8位进行表示数据 0000 0000\n```\n\n步骤：\n\n&ensp;&ensp;&ensp;&ensp;正数原码的规则就是，左侧最高位符号位使用0表示正数 ---》 0 000 0000\n\n&ensp;&ensp;&ensp;&ensp;剩余的位数表示7这个数值的大小， 使用剩余的7个0表示7的数值 ---》 0 000 0111（7的原码）\n\n&ensp;&ensp;&ensp;&ensp;负数7 ----》 使用 8位进行表示数据 0000 0000\n\n&ensp;&ensp;&ensp;&ensp;负数原码的规则就是，左侧最高位符号位使用1表示负数 ---》 1 000 0000\n\n&ensp;&ensp;&ensp;&ensp;剩余的位数表示7这个数值的大小，使用剩余的7个0表示7的数值 ---》 1000 0111（-7的原码）\n\n思考：\n\n&ensp;&ensp;&ensp;&ensp;计算机是否是以原码的形式进行数据存储的？\n\n&ensp;&ensp;&ensp;&ensp;使用原码存储 1 和 -1 的，并进行计算，查看结果\n\n原码分析：\n\n&ensp;&ensp;&ensp;&ensp;正数1的原码\t 0 000 0001\n\n&ensp;&ensp;&ensp;&ensp;负数1的原码 \t1 000 0001\n\n&ensp;&ensp;&ensp;&ensp;+\n\n\\-----------------------------------------------\n\n &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1 000 0010\t---》 结果出来 是 -2\n\n计算中是不可以使用原码的形式进行数据存储的是，会出现数据计算错误\n\n## <center>2、反码</center>\n\n正数的反码和原码是一样的，负数的反码是在原码的基础之上进行计算得来的\n\n负数的反码原则：符号位不动（不改变），其他位进行取反操作（1变0，0变1）\n\n思考：\n\n&ensp;&ensp;&ensp;&ensp;计算机是否是以反码的形式进行数据存储的？\n\n&ensp;&ensp;&ensp;&ensp;使用原码存储 1 和 -1 的，并进行计算，查看结果\n\n反码分析：\n\n&ensp;&ensp;&ensp;&ensp;正数1的原码和反码\t0 000 0001\n\n&ensp;&ensp;&ensp;&ensp;负数1的原码\t\t&ensp;&ensp;1 000 0001 ---》在这个基础上计算反码\n\n&ensp;&ensp;&ensp;&ensp;负数1的反码 \t\t&ensp;1 111 1110\n\n&ensp;&ensp;&ensp;&ensp;+\n\n\\---------------------------------------------------------------------\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1 111 1111 ---》 结果出来 是 -255（不看符号位）/ -127（看符号位）\n\n计算中是不可以使用原码和反码的形式进行数据存储的是，会出现数据计算错误\n\n## <center>3、补码</center>\n\n正数的补码和原码、反码都是一样的【名词：三位一体】\n\n负数的补码是在反码基础上进行+1操作\n\n思考：\n\n&ensp;&ensp;&ensp;&ensp;计算机是否是以补码的形式进行数据存储的？\n\n&ensp;&ensp;&ensp;&ensp;使用原码存储1和-1的，并进行计算，查看结果\n\n补码分析：\n\n&ensp;&ensp;&ensp;&ensp;正数1的原码和反码、补码 \t0 000 0001\n\n&ensp;&ensp;&ensp;&ensp;负数1的原码 \t\t\t1 000 0001 ---》在这个基础上计算反码\n\n&ensp;&ensp;&ensp;&ensp;负数1的反码 \t\t\t1 111 1110 ----》在反码的基础上+1操作\n\n&ensp;&ensp;&ensp;&ensp;负数1的补码 \t\t\t1 111 1111\n\n&ensp;&ensp;&ensp;&ensp;+\n\n\\----------------------------------------------------------------------------------\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1 0000 0000 ---》这个结果是0 ，1这个值会发生溢出操作（丢失不存储）\n\n当前这个计算结果叫做理论值，理论值中1是存在的，但是在真实内存中存储是1会被舍去得到结果就是\n\n0000 0000 即0 这个数据\n\n总结：计算中是以补码的形式进行数据的存储操作的\n","tags":["Java"],"categories":["编程语言","Java"]},{"title":"1.IDEA快捷键","url":"/post/ca0fcd03.html","content":"\n1、类名写错 ：alt+回车键\n\n2、选中全部：ctrl+shift + 选中范围最后一个\n\n3、面向对象创建：alt + INS  或  右键选 Generate（一键三连）(JavaBean)\n\n&ensp;&ensp;&ensp;&ensp;进入后：选Constructor  + 选全部 + ok ==> 生成全参构造方法\n\n&ensp;&ensp;&ensp;&ensp;进入后：选Constructor  + 不用选 + Select None ==> 生成无参构造\n\n&ensp;&ensp;&ensp;&ensp;进入后：选Getter and Setter  + 选全部 + ok ==> 生成公共访问\n\n&ensp;&ensp;&ensp;&ensp;进入后：选toString + 选全部 + ok ==>生成重写父类的toString方法\n\n4、打开计算器：win + R  输入  calc\n\n5、若子类继承父类，在子类中可以直接打父类里面有的方法名，会直接生成重写方法格式 \n\n6、快速生成main方法 有两个快捷输入 psvm 或者 main\n\n7、多行批量编辑\n\n&ensp;&ensp;&ensp;&ensp;shift+alt 快捷键组合加上鼠标点击每行需要修改的起始位置（这个适合数据量比较少的情况）\n\n&ensp;&ensp;&ensp;&ensp;鼠标中键可以拉选多行，然后就可以做批量的编辑和修改了（数据量大的情况下真的很实用）\n\n8、替换\n\n&ensp;&ensp;&ensp;&ensp;ctrl+R\t上面是要替换掉的数据\t下面是要替换的数据\n\n9、Java命令窗口编译及运行\n\n&ensp;&ensp;&ensp;&ensp;进入Java文件目录 --》javac 文件名.java(源文件) --》生成class文件(字节码文件) --》java 文件名\n","tags":["Java"],"categories":["编程语言","Java"]},{"title":"0.C语言概述","url":"/post/6ac19130.html","content":"\n# <center>一、写代码过程</center>\n\n编辑器：程序员写代码的过程\n\n编译器：查看代码的语法错误，生成汇编语言\n\n汇编语言：将生成好汇编语言生成二进制语言（目标文件）\n\n连接器：将生成好的二进制语言+用到的库+启动代码==>可执行代码\n\n# <center>二、完整代码分析</center>\n\n符号：//       意思：行注释。\n\n符号：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;/*\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;内容             意思：块注释（不能嵌套）  \n\n&ensp;&ensp;&ensp;&ensp;&ensp;*/\n\n符号： <mark>; </mark>        意思：C语言语句结束标志\n\n```c\n//头文件 \n#include<stdio.h>      //std：标准  i：输入   o：输出（标准输入输出头文件） \n//main函数是程序的入口，有且只有一个 \n//mian左边的int是代表着函数返回值的类型，右边的()里面的是函数的形参（将函数外部的数据传递到函数内部桥梁） \nint main(int argc，char *argv[]) \n{\n    printf(\"hello iot\\n\");\n    //printf：将\"\"中的字符串输出到终端上 \n    return 0; \n}\n```\n\n","tags":["C语言"],"categories":["编程语言","C语言"]},{"title":"知识点","url":"/post/8c9aed93.html","content":"\n党的几大 ==》可以修改党章\n\n几届全国人大几次会议 ==》可以修改宪法\n\n党的几届几中全会 ==》决议、公报\n\n根本力量、==》人民\n\n按劳分配以外的多种分配方式，其实质就是 ==》按对生产要素的占有状况进行分配\n\n按生产要素分配包括有\n\n1. 按资本分配得到的收入\n2. 按劳动力价值分配获得的收入\n3. 提供技术、信息等获得的收入\n\n非公有制经济包括\n\n1. 个体经济\n2. 私营经济\n3. 混合所有制经济中的非公有制经济成分\n4. 外商独资经济\n\n无产阶级及其政党要实现自己对同盟者的领导，必须具备两个条件：\n\n一是率领被领导者向着共同敌人作坚决斗争并取得胜利\n\n二是对被领导者给以物质利益，至少不损害其利益，同时给以政治教育\n\n中国共产党提出“马克思主义中国化“命题和任务的会议：六届六中全会\n\n抗日战争时期，中国共产党同国民党顽固势力斗争时所遵循的原则：有理、有利、有节\n\n民主革命遗留任务完成的时间：1952年\n\n中华人民共和国成立初期，建立社会主义国营经济的主要途径：没收官僚资本\n\n土地改革完成后，毛泽东分析我国农民的两大积极性：个体经济积极性、互助合作积极性\n\n1961年，中共八届九中全会决定对国民经济进行调整，其基本方针：调整、巩固、充实、提高\n\n党的十二届三中全会 通过了 《中共中央关于经济体制改革的决定》\n\n《在武昌、深圳、珠海、上海等地的谈话要点》是对全面改革进程中思想解放的科学总结\n\n“坚持四项基本原则”回答了解放和发展生产力的政治保证问题，体现了社会主义基本制度的要求\n\n解决中国所有问题的关键：靠自己的发展\n\n邓小平反复强调 稳定 是中国实现社会主义现代化发展战略的必要前提，也是中国的最高利益\n\n社会发展的根本动力：社会基本矛盾\n\n社会发展的决定力量：物质资料的生产方式\n\n社会形态更替的根本标志：生产力水平的提高和生产关系的改变\n\n民族区域自治的核心：保障少数名族当家作主，管理本民族、本地方事务的权利\n\n第一次提出“中国特色社会主义理论体系”科学概念是：党的十七大\n\n提出到2020年全面建成小康社会奋斗目标的是：党的十八大\n\n全面依法治国，总目标是：建设中国特色社会主义法制体系、建设社会主义法治国家\n\n新型国际关系，“新”在：相互尊重、公平正义、合作共赢\n\n中国社会主义政治中独特的、独有的、独到的民主形式是：协商民主\n\n首次把党的政治建设纳入党的建设总体布局的是：党的十七大\n\n首次提出“中国特色社会主义理论体系”科学概念的会议是：党的十七大\n\n作出全面深化改革决定的会议是：党的十八届三中全会\n\n江泽民同志首次比较全面地阐述“三个代表”重要思想是在：广东考察工作时\n\n\n\n\n\n","tags":["政治"],"categories":["升学"]},{"title":"大题","url":"/post/66861d4a.html","content":"\n# <center>一、绪论</center>\n\n## <center>1、简答马克思主义的科学内涵</center>\n\n马克思主义是关于自然界、人类社会、人类思维发展的一般规律的理论体系、揭示了事务的本质、内在联系及发展规律，是“伟大的认识工具”，是人们观察世界，分析问题的有利思想武器。\n\n## <center>2、简答马克思主义中国化的必然性</center>\n\n（1）实现马克思主义中国化，是解决中国实际问题的客观需要。历史和现实反复证明，马克思主义只有中国化才能在中国大地上闪耀真理光芒，也只有实现中国化才能救中国，发展中国，发展社会主义\n\n（2）实现马克思主义中国化，是马克思主义理论发展的内在要求。马克思主义只有在同各国具体实际相结合的过程中，才能开辟自身的发展道路，这是马克思主义的应有之义\n\n## <center>3、简答马克思主义中国化的科学内涵</center>\n\n具体化：马克思主义中国化就是把马克思主义基本原理同中国具体实际和时代特征结合起来，运用马克思主义的立场、观点、方法 研究和解决中国革命、建设、改革中的实际问题。\n\n理论化：马克思主义中国化就是总结和提炼中国革命、建设、改革的实践经验，从而认识和掌握客观规律，为马克思主义理论宝库增添新的内容\n\n民族化：马克思主义中国化就是运用中国人命喜闻乐见的民族语言来阐述马克思主义理论，使之成为具有中国特色，中国风格，中国气派的马克思主义\n\n## <center>4、简答马克思主义中国化的两次历史性飞跃</center>\n\n在中国革命、建设、改革的历史进程中，马克思主义中国化实现了两次历史性飞跃\n\n（1）第一次飞跃发生在新民主主义革命时期，形成了毛泽东思想\n\n（2）第二次历史性飞跃发生在社会主义进入改革开放的新时期，形成了包括邓小平理论、“三个代表”重要思想、科学发展观、习近平新时代中国特色社会主义思想在内的这个特色社会主义理论体系\n\n马克思主义中国化的两大理论成果极大地丰富和发展了马克思主义，不断开辟了马克思主义在中国发展的新境界。\n\n## <center>5、简答中国化马克思主义理论的历史地位</center>\n\n毛泽东思想和中国特色社会主义理论体系，都是马克思主义中国化的理论成果，都是中国化的马克思主义，它们同马克思主义列宁主义一起，是中国共产党长期坚持的指导思想和全国人民团结奋斗的共同思想基础\n\n2018年，十三届全国人民一次会议通过的宪法修正案把马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观、习近平新时代中国特色社会主义思想共同确立为国家指导思想。\n\n# <center>二、毛泽东思想及其历史地位</center>\n\n## <center>辨析题</center>\n\n### 1、毛泽东思想是中国革命实践自发的产物\n\n&ensp;&ensp;&ensp;&ensp;&ensp;观点错误\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（1）毛泽东思想产生于20世纪二三十年代的中国绝不是偶然的。它的产生是近现代中国社会和革命运动发展的客观需要和历史发展的必然产物。\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（2）毛泽东思想的产生和形成的社会历史条件有：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;20世纪前中期世界和中国政局的变动，是毛泽东思想产生和形成的历史背景。\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;近代中国社会和民族民主革命的实践，为毛泽东思想的产生提供了肥沃的土壤和丰富的源泉。\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;新的社会生产力的增长和工人运动的发展，为毛泽东思想的产生和形成，提供了物质基础。\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;新文化运动的兴起和马克思主义的引进与传播，为毛泽东思想的产生和形成准备了思想理论条件\n\n&ensp;&ensp;&ensp;&ensp;&ensp;由此可见，毛泽东思想的产生和形成并不是中国革命自发的产物，而是马克思列宁主义和中国革命具体实践相结合的产物\n\n### 2、毛泽东思想成熟于土地革命战争时期\n\n&ensp;&ensp;&ensp;&ensp;&ensp;观点错误\n\n&ensp;&ensp;&ensp;&ensp;&ensp;遵义会议以后，毛泽东系统地总结了当领导中国革命特别是全民族抗日战争以来的历史经验，深入分析中国革命具体实际，科学阐述了新民主主义革命的对象、动力、领导力量、性质和前途等基本问题，提出了新民主主义革命的总路线，并制定相应的经济、政治、文化纲领，指明了新民主主义革命的具体目标。毛泽东还详细论述了统一战线、武装斗争和党的建设的基本规律和内在联系，为新民主主义革命的胜利找到了正确的方法。这一时期，新民主主义革命理论的系统阐述，实现了马克思主义与中国革命实践相结合的历史性飞跃，标志着毛泽东思想得到多方面展开而趋于成熟。1945年党的七大将毛泽东思想写入党章，确定为党必须长期坚持的指导思想\n\n### 3、毛泽东思想就是毛泽东个人的思想\n\n&ensp;&ensp;&ensp;&ensp;&ensp;观点错误\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（1）毛泽东思想是毛泽东同志个人的杰出贡献和党的集体智慧的相得益彰、交相辉映共同构筑的理论大厦\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（2）在马克思主义中国化这一伟大工程的建设中，毛泽东的贡献是最大、创造最多、水平最高，因此，以他名字来命名的中国化的马克思主义是天经地义的。毛泽东思想主要是毛泽东同志的思想，毛泽东的科学著作是它的集中概括\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（3）毛泽东思想不是毛泽东同志个人的独创，党的许多卓越的领导人都对它形成和发展作出了重要贡献，党的许多重要会议和文献都丰富了毛泽东思想的理论宝库。因此，毛泽东思想是中国共产党人集体智慧的结晶，而不是毛泽东同志个人的独创\n\n### 4、毛泽东思想以独创性的理论丰富和发展了马克思列宁主义\n\n&ensp;&ensp;&ensp;&ensp;&ensp;观点正确\n\n&ensp;&ensp;&ensp;&ensp;&ensp;毛泽东思想在以下几个方面，以独创性的理论丰富和发展了马克思列宁主义：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;新民主主义革命理论\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;社会主义革命和社会主义建设理论\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;革命军队建设和军事战略的理论\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;政策和策略的理论\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;思想政治工作和文化工作的理论\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;党的建设理论\n\n### 5、李大钊是中国第一个提出“马克思主义中国化”的人\n\n&ensp;&ensp;&ensp;&ensp;&ensp;观点错误\n\n&ensp;&ensp;&ensp;&ensp;&ensp;在中国共产党历史上，毛泽东第一个明确提出了“马克思主义中国化”的科学命题和重大任务，深刻论证了马克思主义中国化的必要性和极端重要性，系统阐述了马克思主义中国化的科学内涵和实现马克思主义中国化的正确途径，开辟了马克思主义在中国发展的宽广道路，为党领导的革命和建设事业的发展奠定了坚实的思想理论基础。\n\n## <center>简答题</center>\n\n### 1、简答毛泽东思想形成发展过程中各个阶段的代表性著作及内容\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（1）毛泽东思想的形成：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第一次国内革命战争时期，毛泽东对马克思列宁主义为指导，深入实际调查研究，在《中国社会各阶段的分析》《湖南农民运动考察报告》等著作中，分析了中国社会各阶级在革命中的的地位和作用，提出了新民主主义革命的基本思想\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;土地革命战争时期，毛泽东在《中国红色政权为什么能够存在？》《井冈山的斗争》《星星之火，可以燎原》《反对本本主义》等著作中，提出并阐述了农村包围城市、武装夺取政权的思想\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（2）毛泽东思想的成熟：遵义会议以后，毛泽东在《实践论》和《矛盾论》两篇著作中，运用马克思主义的认识论和辩证法，系统分析了党内“左”的和“右”的错误思想根源。在《<共产党人>发刊词》《中国革命和中国共产党》《新民主主义论》《论联合政府》等理论著作中，科学阐述了新民主主义革命的对象、动力、领导力量、性质和前途等基本问题，提出了新民主主义的总路线，并制定了相应的经济、政治、文化纲领，指明了新民主主义革命的具体目标\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（3）毛泽东思想的继续发展：解放战争时期和中华人民共和国成立以后，形成了毛泽东关于社会主义革命和社会主义建设的重要思想，集中体现于《在中国共产党第七届中央委员会第二次全体会议上的报告》《论人民民主专政》《论十大关系》》《关于正确处理人民内部矛盾的问题》等著作中\n\n### 2、简答新民主主义革命理论的主要内容\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（1）中国资产阶级有两个部分：依附于帝国主义的大资产阶级和既有革命要求又有动摇性的民主资产阶级。无产阶级领导的统一战线要争取民族资产阶级参加，并且在面对外敌侵略的特殊条件下可以把一部分大地主大资产阶级也包括在内，以求最大限度地孤立最主要的敌人。在同资产阶级结成统一战线时，要保持无产阶级的独立性，实行又团结又斗争、以斗争求团结的政策，在被迫同资产阶级、主要时同大资产阶级分裂时，要敢于并善于同大资产阶级进行坚决的武装斗争，同时要继续争取民族资产阶级的同情或中立。\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（2）由于帝国主义的侵略，加之中国没有资产阶级民主，因此中国革命只能以长期的武装斗争为主要形式\n\n### 3、简答社会主义革命和建设理论的主要内容\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（1）关于社会主义社会仍然存在着矛盾，基本的矛盾仍然是生产关系和生产力之间的矛盾、上层建筑和经济基础之间的矛盾，必须严格区分和正确处理敌我矛盾的思想\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（2）关于人民内部要在政治上实行“团结—批评—团结”，在党与民主党派的关系上实行“长期共存、互相监督”，在科学文化工作中实行“百花齐放、百家争鸣”，在经济工作以及其它各项工作中实行“统筹兼顾、适当安排”等一系列正确方针\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（3）关于不要机械搬用外国的经验，而要从中国是一个农业大国这种情况出发，以工业为主导，以农业为基础，正确处理重工业同农业、轻工业的关系，充分重视农业和轻工业，走出一条适合我国国情的中国工业化道路的思想\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（4）关于社会主义建设中要处理好各种关系，处理好积累和消费的关系，注意综合平衡等思想\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（5）关于调动一切积极因素，化消极因素为积极因素，团结全国各族人民建设社会注意强大国家的思想\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（6）关于要造成一个又有集中又有民主，又有纪律又有自由，又有同一意志，又有个人心情舒畅、生动活泼，那样一种政治局面的主张\n\n### 4、简答革命军队建设和军事战略理论的主要内容\n\n&ensp;&ensp;&ensp;&ensp;&ensp;毛泽东系统解决了如何把农民为主要成分的革命军队建设成为一支无产阶级性质的、具有严格纪律的、同人民群众保持亲密关系的新型人民军队的问题\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（1）他规定了全心全意为人民服务是人民军队的唯一宗旨，规定了党指挥枪的原则\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（2）他总结了中国长期革命战争的经验，系统地提出了建设人民军队的思想，提出了以人民军队为骨干，依靠广大人民群众，建立农村根据地，进行人民战争的思想\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（3）他把游击战争提到了战略的地位，认为中国革命战争在长期内的主要作战形式是游击战和带游击性的运动战。他论述了要随着敌我力量对比的变化和战争发展的进程，正确地实行军事战略的转变\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（4）在中华人民共和国成立以后。他提出必须加强国防，建设现代化革命武装力量和发展现代化国防技术的重要指导思想\n\n### 5、简答政策和策略理论的主要内容\n\n&ensp;&ensp;&ensp;&ensp;&ensp;毛泽东指出政策和策略是党的生命，必须根据政治形式、阶级关系和实际情况及其变化制定党的政策，把原则性和灵活性结合起来\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（1）弱小的革命力量在变化着的主客观条件下能够最终战胜强大的反动力量\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（2）战略上要藐视敌人、战术上要重视敌人\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（3）要掌握斗争的主要方向，不要四面出击\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（4）对敌人要区别对待、分化瓦解，实行利用矛盾，争取多数，反对少数、各个击破的策略，并做到有理、有利、有节\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（5）在反动统治地区，把公开斗争和秘密斗争结合起来，在组织上采取隐蔽精干的方针\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（6）对被打到的反动统治阶级成员和反动分子，之哟啊他们不造反、不捣乱，都给予生活出路，让他们在劳动中改造成为自食其力的劳动者\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（7）无产阶级及其政党要实现自己对同盟者的领导，必须具备两个条件：一是率领被领导者向着共同敌人做坚决斗争，二是对被领导者给以物质利益，至少不损坏其利益，同时给以政治教育等等。\n\n### 6、简答思想政治工作和文化工作理论的主要内容\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（1）思想政治工作是经济工作和其他一切工作的生命线，要实行政治和经济的统一、政治和技术的统一、又红又专的方针\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（2）发展民族的、科学的、大众的文化，实行百花齐放、百家争鸣和古为今用、洋为中用、推陈出新的方针\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（3）关于知识分子在革命和建设中具有重要作用，知识分子要同工农相结合，通过学习马克思列宁主义、学习社会和工作实践，树立无产阶级思想\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（4）强调要全心全意为人民服务，对革命工作要极端负责，要艰苦奋斗和不怕牺牲。\n\n### 7、简答党的建设理论的主要内容\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（1）毛泽东特别注意从思想上建党，提出党员不但要在组织上入党，而且要在思想上入党，经常注意以无产阶级思想改造和克服各种非无产阶级思想\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（2）毛泽东指出，理论和实践相结合的作风，和人民群众紧密地联系在一起的作风，以及自我批评的作风，是中国共产党区别于其他任何政党的显著标志。针对历史上党内斗争中存在过的“残酷斗争、无情打击”的“左”的错误，他强调在党内斗争中要达到及弄清思想又团结同志的目的\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（3）中华人民共和国成立前后，他多次提出务必使同志们继续地保持谦虚、谨慎、不骄、不躁的作风，务必使同志们继续保持艰苦奋斗的作风，要求全党警惕资产阶级思想的侵蚀，反对脱离群众的官僚主义。\n\n### 8、简答实事求是的内涵\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（1）实事求是，就是一切从实际出发，理论联系实际，坚持在实践中检验真理和发展真理。“实事”就是客观存在着的一切事务，“是”就是客观事务的内部联系，即规律性，“求”就是我们去研究\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（2）\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;坚持实事求是，就要深入实际了解事物的本来面貌，把握事物内在联系，按照客观规律办事\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;坚持实事求是，就要清醒认识和正确把握我国基本国情\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;坚持实事求是，就要不断推进实践基础上的理论创新\n\n### 9、简答群众路线的内涵\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（1）群众路线，就是一切为了群众，一切依靠群众，从群众中来，到群众中去，把党的正确主张变为群众的自觉行动。群众路线本质上体现的是马克思主义关于人民群众是历史的创造者这一基本原理，是我们党的生命线和根本工作路线，是我们党永葆青春活力和战斗力的重要传家宝\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（2）坚持群众路线，就要坚持人民是推动历史发展的根本力量\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（3）坚持群众路线，就要坚持全心全意为人民服务的根本宗旨\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（4）坚持群众路线，就要保持党同人民群众的血肉联系。党风问题、党同人民群众的脸问题关系党的生死存亡\n\n### 10、简答独立自主的内涵\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（1）独立自主，就要坚持独立思考，走自己的路，就是坚定不移地维护民族独立、捍卫国家主权，把立足点放在依靠自己力量的基础上，同时积极争取外援，开展国际经济文化交流，学习外国一切对我们有益的先进事物。\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（2）坚持独立自主，就要坚持中国事情必须有中国人民自己处理\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（3）坚持独立自主，就要坚持独立自主的和平外交政策，坚定不移走和平发展道路。恪守维护世界和平、促进共同发展的外交宗旨，坚持在和平共处五项原则基础上同各国友好相处，在平等互利基础上积极开展同各国的交流合作。\n\n### 11、《历史决议》对毛泽东的历史地位作出了怎样实事求是的评价？\n\n&ensp;&ensp;&ensp;&ensp;&ensp;毛泽东是伟大的马克思主义者、伟大的无产阶级革命家、战略家和理论家。他为中国共产党和中国人民解放军的创立和发展，为中国各族人民解放事业的胜利，为中国各族人民解放战争事业的胜利，为中华人民共和国的缔造和社会主义事业的发展，建立了不可磨灭的功勋，为世界被压迫民族的解放和人类进步事业做出了重大贡献。毛泽东的功绩是第一位的，错误是第二位。\n\n## <center>论述题</center>\n\n### 1、论述毛泽东思想形成和发展的历史进程\n\n&ensp;&ensp;&ensp;&ensp;&ensp;毛泽东思想是中国共产党领导的中国革命与建设的实践中逐步形成和发展起来的。这一过程大体上可分为开始萌芽、初步形成、走向成熟、继续发展和曲折发展等多个阶段\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（1）在第一次国内革命战争时期，毛泽东初步提出了新民主主义革命的基本思想，标志着毛泽东思想开始萌芽\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（2）在土地革命战争前中期，毛泽东提出阐述了农村包围城市、武装夺取政权的革命道路理论，标志着毛泽东思想初步形成\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（3）在土地革命战争后期和抗日战争时期，毛泽东写了大量著作，对新民主主义理论作了系统而完整的阐述，标志着毛泽东思想达到成熟\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（4）在解放战争时期和从新民主主义向社会主义的过渡时期，毛泽东思想在军事原则、战略策略和政策、国家政权理论、革命转变理论等方面，均有新的重大发展\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（5）在社会主义建设时期，在探索中国社会主义建设道路的曲折历程中，毛泽东在工作重心转移、社会主义现代化目标、中国工业化道路、经济体制改革、民主政治建设、思想文化建设、执政党建设等方面，提出了许多重要思想观点，特别是创立了社会主义社会矛盾学说。但毛泽东晚年也有失误，毛泽东思想在曲折中得到发展\n\n### 2、论述如何坚持和发展毛泽东思想\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（1）要完整准确地理解和掌握毛泽东思想的科学体系。绝不能用毛泽东的个别观点、个别词句来理解毛泽东思想，要着重掌握毛泽东思想科学体系的主要内容和贯穿其中的立场、观点和方法\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（2）要把毛泽东晚年的错误思想与毛泽东思想严格区分开来。毛泽东晚年的错误思想，不属于毛泽东思想科学体系的范畴\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（3）要在实践中丰富和发展毛泽东思想。毛泽东思想的基本思想的基本原理及立场、观点和方法必须坚持。但是，毛泽东思想必须要随着时代、实践和科学的发展而不断发展。邓小平理论是毛泽东思想的继承和发展。在当代中国，马克思主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观、习近平新时代中国特色社会主义思想是一脉相承的统一的科学体系。坚持习近平新时代中国特色社会主义思想，就是坚持和发展毛泽东思想。\n\n## <center>思考题</center>\n\n### 1、毛泽东思想形成和发展的社会历史条件是什么？\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（1）19世纪末20世纪初，世界进入帝国主义和无产阶级革命时代\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（2）1917年俄国十月革命的胜利开辟了世界无产阶级社会主义革命的新时代。它使中国反帝反封建的民主革命从旧的世界资产阶级民主革命的一部分，转变为新的世界无产阶级社会主义革命的一部分。十月革命给中国送来了马克思列宁主义，帮助中国的先进分子开始用无产阶级的世界观作为观察国家命运的工具，中国革命从此有了科学的指导思想\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（3）中国在革命取得胜利后，又经历了第二次世界大战后两大阵营的斗争，西方国家不仅对我国实行持续的封锁禁运，还极力推行和平演变战略。毛泽东思想正是在这样的时代条件下形成和发展起来的。\n\n### 2、如何把握毛泽东思想的主要内容和活的灵魂？\n\n&ensp;&ensp;&ensp;&ensp;&ensp;毛泽东思想的主要内容有新民主主义革命理论、社会主义革命和社会主义建设理论、革命军队建设和军事战略的理论、政策和策略的理论、思想政治工作和文化工作的理论，党的建设理论等内容\n\n&ensp;&ensp;&ensp;&ensp;&ensp;毛泽东思想活的灵魂使实事求是，群众路线，独立自主。实事求是，就是一切从实际出发，理论联系实际，坚持在实践中检验真理和发展真理。群众路线，就是一切为了群众，一切依靠群众，从群众中来，到群众中去，把党的正确主张变为群众的自觉行动。独立自主，就是坚持独立思考，走自己的路，就是坚定不移地维护民族独立，捍卫国家主权，把立足点放在依靠自己力量的基础上，同时积极争取外援，开展国际经济文化交流，学习外国一切对我们有益的先进事物\n\n### 3、如何科学认识毛泽东思想的历史地位？\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（1）马克思主义中国化的第一个重大理论成果\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（2）中国革命和建设的科学指南\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（3）中国共产党和中国人民宝贵的精神财富\n\n# <center>三、新民主主义革命理论</center>\n\n## <center>辨析题</center>\n\n### 1、新民主主义革命是新式的资产阶级民主革命\n\n观点正确\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（1）新民主主义革命是无产阶级领导的，新旧民主革命的根本区别是领导阶级不同\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（2）新民主主义革命发生在俄国十月革命后，属于世界无产阶级革命的范畴\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（3）新民主主义的指导思想是马克思列宁主义\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（4）新民主主义革命的前途不是资本主义社会，而是经过新民主主义逐渐过渡到社会主义\n\n### 2、中国革命实质上是无产阶级领导下的社会主义革命\n\n观点错误\n\n&ensp;&ensp;&ensp;&ensp;&ensp;中国革命战争实质上是无产阶级领导的农民战争。这是因为：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（1）要完成反帝反封建任务，就必须发动和依靠农民，解决农民的土地问题。中国民主革命的中心问题是农民问题，农民问题的中心问题是土地问题\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（2）广大农民具有强烈的反帝反封建的革命性，是中国民主革命的主力军\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（3）只有与广大农民结成联盟，才能完成反帝反封建的革命任务\n\n### 3、在新民主主义革命时期，只有当民族资产阶级拥护革命时，才需要保护民族资本主义\n\n观点错误\n\n&ensp;&ensp;&ensp;&ensp;&ensp;中国共产党在新民主主义革命时期对民族资本主义的政策，是基于对中国社会性质和革命性质的正确认识，并不取决于民族资产阶级的政治态度及其变化。近代中国是半殖民地半封建社会，中国革命是以反帝国主义和封建主义为基本内容的资产阶级民主革命。民族资本主义的存在与发展具有历史进步性。中国共产党在新民主主义革命过程中，对民族资本主义必须始终采取保护政策。民族资产阶级是一个具有两面性的阶级，既有革命要求又有动摇性。但是，无论民族资产阶级拥护革命，还是脱离革命阵营，中国共产党都不应改变对民族资本主义的保护政策。\n\n### 4、民主革命时期，中国共产党的党员绝大多数来自农民，因而它不是工人阶级先锋队\n\n观点错误\n\n&ensp;&ensp;&ensp;&ensp;&ensp;党的理论和纲领决定党的性质。民族革命时期，农民党员占绝大多数，大量非无产阶级思想入侵党内，给党保持工人阶级先锋队的性质带来严峻的挑战。但是，党的理论和纲领是马克思主义，代表了中国社会发展的正确方向，党高度重视在思想上建党，坚持用马克思主义理论教育和武装全体党员，不仅要求党员在组织上入党，而且要求党员首先在思想上入党，指导他们为实现党的纲领和任务而奋斗，因而保持了党的工人阶级先锋队性质。\n\n### 5、封建主义是新民主主义革命的首要对象\n\n观点错误\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（1）中国新民主主义革命的对象是帝国主义、封建主义和官僚资本主义，其中帝国主义是首要对象\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（2）帝国主义通过发动一次次侵略战争，操纵了中国的经济、政治和军事，使中国沦为半殖民地半封建社会\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（3）帝国主义同中国封建势力相勾结，残酷地镇压革命，阻碍了中国的民族独立和政治进步，是近代中国贫困落后的总根源。推翻了帝国主义压迫是中国走向独立和富强的前提\n\n### 6、我国社会是一个两头大中间小的社会\n\n观点错误\n\n&ensp;&ensp;&ensp;&ensp;&ensp;中国社会是一个两头小中间大的社会，无产阶级和地主大资产阶级都只占少数，最广大的人民是农民、城市小资产阶级以及其他的中间阶级。\n\n## <center>简答题</center>\n\n### 1、简答近代中国社会的主要矛盾\n\n&ensp;&ensp;&ensp;&ensp;&ensp;在近代中国社会中，占支配地位的主要矛盾是帝国主义和中华民族的矛盾、封建主义和人民大众的矛盾，而帝国主义和中华民族的矛盾，又是各种矛盾中最主要的矛盾。这决定了近代中国革命的根本任务是推翻帝国主义、封建主义和官僚资本主义的统治，从根本上推翻了反动腐朽的政治上层建筑，变革阻碍了生产力发展的生产关系。\n\n### 2、简答新民主主义革命的对象\n\n&ensp;&ensp;&ensp;&ensp;&ensp;近代中国社会的性质和主要矛盾，决定了中国革命的主要敌人是帝国主义、封建主义和官僚资本主义\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（1）帝国主义是中国革命的首要对象。帝国主义是中国社会进步和发展的最大障碍，是近代中国贫困落后和一切灾难祸害的总根源。推翻帝国主义的压迫是中国走向独立和富强的前提\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（2）封建地主阶级是帝国主义统治中国和封建军阀实行专制统治的社会基础。地主阶级是用封建制度剥削和压迫农民阶级，是在政治上、经济上、文化上阻碍了中国社会前进而没有丝毫进步作用的阶级，是中国经济现代化和政治民主化的主要障碍\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（3）官僚资本主义是依靠帝国主义、勾结封建势力、利用国家政权力量而发展起来的买办的封建的国家垄断资本主义。官僚资本主义对广大劳动人民的残酷剥削和对民族工商业的巧取豪夺，严重束缚了中国社会生产力的发展，因此也是中国革命的对象\n\n### 3、简答新民主主义革命的动力\n\n&ensp;&ensp;&ensp;&ensp;&ensp;新民主主义革命的动力包括无产阶级、农民阶级、城市小资产阶级和民族资产阶级\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（1）无产阶级是中国革命最基本的动力。无产阶级是中国沦为半殖民地半封建社会过程中最早出现的一个新的社会阶级。中国无产阶级是新的社会生产力的代表，是近代中国最进步的阶级，是中国革命的领导力量\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（2）农民是中国革命的主力军，其中的贫雇农是无产阶级最可靠的同盟军，中农是无产阶级可靠的同盟军\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（3）城市小资产阶级是无产阶级的可靠同盟者。城市小资产阶级，包括广大的知识分子、小商人、手工业者和自由职业者\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（4）民族资产阶级也是中国革命的动力之一。半殖民地半封建社会的民族资产阶级是一个带有两面性的阶级(表现为革命性和动摇性)\n\n### 4、简答新民主主义革命的性质和前途\n\n&ensp;&ensp;&ensp;&ensp;&ensp;近代中国半殖民地半封建社会的性质和中国革命的历史任务，决定了中国革命的性质不是无产阶级社会主义革命，而是资产阶级民主主义革命\n\n&ensp;&ensp;&ensp;&ensp;&ensp;中国革命处于世界无产阶级社会主义革命的时代，是世界无产阶级社会主义革命的一部分；革命的领导力量是中国无产阶级及其先锋队---中国共产党；革命的指导思想是马克思列宁主义；革命的前途是社会主义而不是资本主义，它要建立的是无产阶级领导的各革命阶级的联合专政，而不是无产阶级专政。\n\n## <center>论述题</center>\n\n### 1、论述新民主主义革命理论的实践基础\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（1）旧民主主义革命的失败呼唤新的革命理论。旧民主主义革命的失败，近代中国革命形式的发展，以及世界形势的新变化，呼唤着新的革命理论的诞生。新民主主义革命理论在近代中国革命的实践中应运而生，它的形成包含了对旧民主主义革命失败教训的深刻总结\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（2）新民主主义革命的艰辛探索奠定了革命理论形成的实践基础。没有中国革命的实践，没有党对革命实践经验的概括和总结，新民主主义革命理论就无法形成和发展。新民主主义革命实践是新民主主义理论得以形成的实践基础和智慧源泉\n\n### 2、论述中国民族资产阶级的两面性\n\n&ensp;&ensp;&ensp;&ensp;&ensp;半殖民地半封建社会的民族资产阶级是一个带有两面性的阶级\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（1）民族资产阶级既受帝国主义的压迫，又受封建主义的束缚，它同帝国主义和封建主义有矛盾，是革命的力量之一\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（2）由于它在经济上和政治上与帝国主义和封建主义有着千丝万缕的联系，没有彻底的反帝反封建的勇气，在革命的关键时刻表现出明显的动摇性。民族资产阶级的这种两重性，决定了它在一定时期内和一定程度上能够参加反帝反封建的革命，而在另一时期，又有跟在官僚资产阶级后面反对革命的危险\n\n&ensp;&ensp;&ensp;&ensp;&ensp;它既不可能充当革命的主要力量，更不可能革命的领导力量。中国共产党对民族资产阶级在政治上争取它，又斗争又联合，是合乎实际的，是争取革命胜利的需要\n\n### 3、与中国旧民主主义革命相比，新民主主义革命有哪些特点？\n\n&ensp;&ensp;&ensp;&ensp;&ensp;与中国旧民主主义革命相比，新民主主义革命的特点有：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（1）革命领导权不同。旧民主主义革命的领导着是资产阶级，工人阶级只是追随资产阶级参加革命；新民主主义革命的领导者是工人阶级及其政党----中国共产党\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（2）革命指导思想不同。旧民主主义革命的思想是从西方资产阶级革命思想武器库中学来的，而新民主主义革命则是以马克思列宁主义为指导思想\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（3）革命目标和革命前途不同。旧民主主义革命是要在中国建立资产阶级专政的国家，以建立资本主义社会制度为目的；新民主主义革命则要在中国建立以工人阶级领导的、以工农联盟为基础的人民民主专政的国家，然后建立社会主义制度，最终目标是在中国实现共产主义\n\n### 4、如何理解中国革命实践与新民主主义革命理论之间的联系？\n\n&ensp;&ensp;&ensp;&ensp;&ensp;新民主主义革命理论来源于新民主主义革命的实践，如两次国共合作的实践形成了统一战线的理论\n\n&ensp;&ensp;&ensp;&ensp;&ensp;建立和巩固农村革命根据地的实践形成了中国革命道路的理论\n\n&ensp;&ensp;&ensp;&ensp;&ensp;革命战争的实践形成了人民军队建设和军事战略的理论\n\n&ensp;&ensp;&ensp;&ensp;&ensp;党在革命中由小到大、由弱到强的实践形成了党的建设的理论。同时理论又指导实践。总之，没有中国革命的实践，没有对实践经验的概括和总结，也就不会有新民主主义革命理论的形成和发展\n\n### 5、如何认识新民主主义革命理论的重大意义？\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（1）新民主主义革命理论，是以毛泽东为主要代表的中国共产党人，把马克思列宁主义基本原理同中国革命具体实践相结合，在认真总结中国革命实践经验的基础上形成了具有独创性的革命理论\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（2）新民主主义革命理论，揭示了近代中国革命发展的客观规律，解决了在一个以农民为主体的、落后的半殖民地半封建社会的东方大国里进行革命的一系列理论问题\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（3）新民主主义革命理论是马克思主义中国化的重要理论成果，开辟了马克思主义中国化的发展道路，从中国革命的具体实际出发，不拘泥于已有的结论，运用马克思主义的立场、观点和方法，独立自主地对中国革命实际问题做出分析和研究，是对中国革命实践经验的概括和总结，是中国共产党集体智慧的结晶\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（4）新民主主义革命的理论是夺取中国革命胜利的理论武器；新民主主义革命理论是新中国立国建国的思想政治基础；新民主主义革命理论是对马克思列宁主义的丰富和发展，是建设中国特色社会主义理论的思想渊源和理论先导；新民主主义革命理论是中华民族团结奋斗的宝贵财富\n\n### 6、论述在新民主主义革命过程中党的建设工作积累的经验\n\n&ensp;&ensp;&ensp;&ensp;&ensp;中国共产党在加强自身建设中积累了丰富的经验，归纳起来主要有：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（1）必须把思想建设始终放在党的建设的首位。加强党的思想建设，关键是要以无产阶级思想克服和改造各种非无产阶级思想\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（2）必须在任何时候都重视党的组织建设。加强党的组织建设，根本的是要贯彻民主集中制这一党的根本组织原则，坚持在民主基础上的集中和在集中指导下的民主相结合，个人服从组织，少数服从多数，下级服从上级，全党服从中央\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（3）必须重视党的作风建设。党在领导新民主主义革命的过程中，把党的建设作为一项“伟大工程”，逐步形成了理论联系实际、密切联系群众、批评与自我批评相结合的三大优良作风，这是中国共产党区别于其他任何政党的显著标志\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（4）必须联系党的政治路线加强党的建设。党的政治路线是党的纲领在一定历史时期的具体表现，是完成党在一定历史阶段的政治任务的总政策，为全党的团结统一奠定政治基础。\n\n## <center>思考题</center>\n\n### 1、什么是新民主主义革命的总路线？如何理解新民主主义革命的领导权问题？\n\n总路线的内容：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;无产阶级领导的，人民大众的，反帝国主义、封建主义和官僚资本主义的革命\n\n领导权问题：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（1）无产阶级的领导权是中国革命的中心问题，也是新民主主义革命理论的核心问题。区别新旧两种不同范畴的民主主义革命的根本标志是，革命的领导权是掌握在无产阶级手中还是掌握在资产阶级手中\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（2）无产阶级及其政党对中国革命的领导权是在与资产暨欸争夺领导权的斗争中实现的\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（3）无产阶级及其政党实现领导权的关键是，必须建立以工农联盟为基础的广泛的统一战线。中国的新民主主义革命实质上就是无产阶级领导下的农民革命\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（4）无产阶级在同资产阶级建立统一战线时，必须坚持独立自主的原则，保持党在思想上、政治上和组织上的独立性，实行又联合又斗争的方针，这是坚持领导权的基本策略\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（5）无产阶级要保持在民主革命中的领导权，就必须建立和人民的革命武装力量。建立一支无产阶级领导的以农民为主体的强大的革命武装，是保证领导权的坚强支柱\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（6）加强无产阶级政党的建设，是实现领导权的根本保证\n\n### 2、新民主主义基本纲领的主要内容是什么？\n\n&ensp;&ensp;&ensp;&ensp;&ensp;新民主主义基本纲领包括政治、经济、文化纲领\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（1）政治纲领：推翻帝国主义和封建主义的统治，建立一个无产阶级领导的、以工农联盟为基础的、各革命阶级联合专政的新民主主义的共和国\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（2）经济纲领：没收封建地主阶级的土地归农民所有，没收官僚资产阶级的垄断资本归新民主主义国家所有，保护民族工商业\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（3）文化纲领：无产阶级领导的人民大众的反帝反封建的文化，即民族的科学的大众文化\n\n### 3、如何认识中国革命走农村包围城市、武装夺取政权道路的必要性及重大意义？\n\n必要性：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（1）中国所处的时代特点但和具体国情因素\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;在半殖民地半封建的中国社会，内无民主制度而受封建主义的压迫，外无民族独立而受帝国主义的压迫。中国革命的主要斗争形式只能是武装斗争\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;农名是无产阶级可靠同盟军和革命的主力军。在中国开展革命斗争，必须充分地发动农民，凝聚农民阶级的革命力量，否则就无法摧毁帝国主义和封建地主阶级反动统治的基础\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（2）中国所处的时代特点和特殊的国情因素\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;近代中国是多个帝国主义间接统治的经济落后的半殖民地国家，社会政治经济发展极端不平衡\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;近代中国的广大农村深受反动统治阶级的多重压迫和剥削，人民革命愿望强烈，加之经历过大革命的洗礼，革命的群众基础好\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;全国革命形势继续向前发展，为在农村建设革命根据地提供了客观条件\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;相当力量正式红军的存在，为农村革命根据地的创立、巩固和发展提供了坚强后盾\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;党的领导的有力量及其政策的不错误，为农村革命根据地建设和发展提供了重要的主观条件\n\n重要性：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（1）中国革命道路的理论，反映了中国半殖民地半封建社会民主革命发展的客观规律\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（2）党在探索中国革命道路的过程中，不是照抄照搬俄国十月革命的经验，而是从中国的实际出发，开辟了引导中国革命走向胜利的正确道路，独创性地发展了马克思列宁主义\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（3）中国革命道路理论，是党运用马克思主义的立场、观点和方法，分析、研究和解决中国革命具体问题的光辉典范，对于推进马克思主义中国化具有重要的方法论意义\n\n### 4、如何理解新民主主义革命的三大法宝及其相互关系？\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（1）统一战线、武装斗争、党的建设，是中国共产党在中国革命中战胜敌人的三个法宝\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;统一战线是无产阶级政党策略思想的重要内容\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;武装斗争是中国革命的主要形式，是中国革命的特点和优点之一\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;中国共产党要领导革命取得胜利，必须不断加强党的思想建设、组织艰涩和和作风建设。要建设一个广大群众性的、马克思主义的无产阶级政党，是一项艰巨的任务，也是一项伟大的工程\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（2）三个法宝是相互联系、辩证统一的。统一战线和武装斗争是中国革命的两个基本特点，是战胜敌人的两个基本武器。统一战线是实行武装斗争的统一战线，武装斗争是统一战线的中心支柱，党的组织则是掌握统一战线和武装斗争这两个武器以实行对敌冲锋陷阵的英勇战士\n\n# <center>四、社会主义改造理论</center>\n\n## <center>辨析题</center>\n\n### 1、因为新民主主义革命是资产阶级性质的革命，所以新民主主义社会也是资本主义性质的社会\n\n&ensp;&ensp;&ensp;&ensp;&ensp;观点错误\n\n&ensp;&ensp;&ensp;&ensp;&ensp;近代中国是半殖民地半封建社会，主要矛盾是帝国主义和中华民族的矛盾、封建主义和人民大众的矛盾。这些决定了近代中国革命的根本任务是推翻帝国主义、封建主义和官僚资本主义的统治，决定了中国革命仍是资产阶级民主革命。所以，新民主主义革命是资产阶级性质的革命\n\n&ensp;&ensp;&ensp;&ensp;&ensp;而在新民主主义社会，无论是政治上、经济上还是文化上，既有社会主义因素，又有非社会主义因素，但社会主义的因素占主导地位，而且将不再增长并获得最终胜利，非社会主义因素将不断受到限制和改造。因此，新民主主义社会是属于社会主义体系，是逐步过渡到社会主义的过渡性质的社会\n\n### 2、中华人民共和国成立初期，我国社会主义的主要矛盾是资产阶级和无产阶级的矛盾\n\n&ensp;&ensp;&ensp;&ensp;&ensp;观点错误\n\n&ensp;&ensp;&ensp;&ensp;&ensp;中华人民共和国成立之初，我国社会的主要矛盾是广大人民群众同帝国主义、封建主义、国民党反动派残余之间的矛盾。1952年底土地改革完成，地主阶级已被消灭，无产阶级与资产阶级的矛盾上升为主要矛盾。1956年社会主义改造基本完成，资产阶级作为一个阶级已不复存在，人民日益增长的物质文化需要同落后的社会生产之间的矛盾成为主要矛盾\n\n### 3、我国对资本主义工商业采取了暴力的方法进行改造\n\n&ensp;&ensp;&ensp;&ensp;&ensp;观点错误\n\n&ensp;&ensp;&ensp;&ensp;&ensp;中国共产党根据马克思、恩格斯和列宁关于采用和平方式变革所有制的设想，结合中国的具体情况，提出了对资本主义工商业实行和平赎买的方针。所谓赎买，就是国家有偿地将私营企业改变为国营企业，将资本主义私有制改变为公有制。赎买的具体方式不是由国家支付一笔巨额补偿金，而是让资本家在一定年限内从企业经营所得中获取一部分利润\n\n### 4、中华人民共和国成立初期，我国的国家资本主义是一种传统的资本主义经济\n\n&ensp;&ensp;&ensp;&ensp;&ensp;观点错误\n\n&ensp;&ensp;&ensp;&ensp;&ensp;所谓的国家资本主义，就是在国家直接控制和支配下的资本主义经济。我国社会主义改造中出现的国家资本主义经济，“是在人民政府管理之下的，用各种形式和国营社会主义经济联系着的，并受工人监督的资本主义经济。这种资本主义经济已经不是普通的资本主义经济，而是一种特殊的资本主义经济，即新式的国家资本主义经济。它主要地不是为了资本家的利润存在，而是为了供应人民和国家的需要而存在”。“因此，这种新式国家资本主义经济是带着很大的社会主义性质的，是对工人和国家有利的”\n\n### 5、在社会主义改造时期，生产资料公有化程度越高越好\n\n&ensp;&ensp;&ensp;&ensp;&ensp;观点错误\n\n&ensp;&ensp;&ensp;&ensp;&ensp;生产力决定生产关系，生产关系要适应生产力的发展。生产资料的所有制形式是由生产力的性质和发展水平决定的。我国在社会主义改造时期存在着低水平、不平衡、多层次的生产力，所以必然要求有多种所有制形式与之适应。如果认为生产资料公有化程度越高越好，就会违背生产关系一定要适应生产力的状况的规律，结果只能阻碍生产力的发展\n\n## <center>简答题</center>\n\n### 1、我国由新民主主义社会过渡到社会主义为什么需要一个相当长的时间？\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（1）我国经济和文化落后，要求一个相当常的时期来创造为保证社会主义完全胜利所必要的经济上和文化上的前提\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（2）我国有极其广大的个体的农业和手工业及在国民经济中占很大一部分比重的资本主义工商业，要求一个相当长的时期来改造他们\n\n### 2、简答新民主主义社会的特点\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（1）新民主主义社会不是一个独立的社会形态，而是由新民主主义向社会主义转变的过渡性社会形态，是属于社会主义体系的\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（2）在新民主主义社会中，存在着五种经济成分，即社会主义性质的国营经济、半社会主义性质的合作社经济、农民和手工业者的个体经济、私人资本主义经济和国家资本主义经济\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（3）在新民主主义社会中，中国社会的阶级构成主要是工人阶级、农民阶级和其他小资产阶级、民族资产阶级等基本的阶级力量\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（4）在新民主主义社会中，社会主义的因素不论在经济上还是政治上都已经居于领导地位，非社会主义因素不断受到限制和改造。社会主义因素居于领导地位，加上当时有利于发展社会主义的国际条件，决定了社会主义因素将不断增长并获得最终胜利\n\n### 3、简答我国农业、手工业的社会主义改造的经验\n\n&ensp;&ensp;&ensp;&ensp;&ensp;农业的社会主义改造：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;（1）积极引导农民组织起来，走互助合作道路\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;（2）遵循自愿互利、典型示范和国家帮助的原则，以互助合作的优越性吸引农民走互助合作道路\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;（3）正确分析农村的阶级和阶层状况，指定正确的阶级政策\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;（4）坚持积极领导、稳步前进的方针，采取循序渐进的步骤\n\n&ensp;&ensp;&ensp;&ensp;&ensp;手工业的社会主义改造：采取了积极领导、稳步前进的方针。在方法步骤上由小到大、由低级到高级，从供销合作入手，逐步发展到生产合作的道路。\n\n### 4、简答我国资本主义工商业实行和平赎买的意义\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（1）有利于发挥私营工商业在国计民生方面的积极作用，促进国民经济发展\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（2）有利于争取和团结民族资产阶级，有利于团结各民主党派和各界爱国人士，巩固和发展统一战线\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（3）有利于发挥民族资产阶级中大多数人的知识、才能、技术专长和管理经验，也有利于争取和团结那些原来同资产阶级相联系的知识分子为社会主义建设服务\n\n### 5、简答对资本主义工商业的社会主义改造经历了的步骤\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（1）第一步主要实行初级形式的国家资本主义。国家在私营工业中实行委托加工、计划订货、统购包销，在私营商业中采取委托经销、代销等形式，既帮助私营企业克服困难，也使其生产和经营开始纳入国家计划的轨道\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（2）第二步主要实行个别企业的公私合营。资本家的剥削进一步受到限制。企业的经营管理以发展生产、满足人民需要和完成国家计划为目标，因而已经属于半社会主义性质的企业\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（3）第三步是实行全行业的公私合营。全行业公私合营后，企业的生产关系已经发生了根本的变化，基本上成为社会主义国营性质的企业\n\n### 6、如何正确认识改革开放前后的两个历史阶段的相互关系？\n\n&ensp;&ensp;&ensp;&ensp;&ensp;我国的社会主义建设，有改革开放前和改革开放后两个历史时期，这是两个相互联系又有重大区别的时期，但本质上都是我们党领导人民进行社会主义建设的实践探索，两个时期都不能否定\n\n&ensp;&ensp;&ensp;&ensp;&ensp;如果没有1978年以来我党实行改革开放并坚定不移地推进改革开放，坚定不移把握改革开放的方向，社会主义中国就不可能有今天的大好局面；同时如果没有1949年建立中华人民共和国并进行社会主义改革和建设，积累了重要的思想、物质、制度条件，积累了正反两方面的经验，改革开放也很难顺利推进\n\n&ensp;&ensp;&ensp;&ensp;&ensp;尽管两个历史时期在进行社会主义建设的思想指导、方针政策、实际工作有很大差别，但两者绝不是彼此割裂，更不是根本对立的。改革开放前的社会主义实践探索为改革开放后的社会主义探索积累了条件；改革开放后的社会主义实践探索是对前一个时期的坚持、改革、发展\n\n### 7、如何正确认识社会主义改造中出现的失误和偏差？\n\n&ensp;&ensp;&ensp;&ensp;&ensp;我国的社会主义改造中出现失误和偏差的原因主要是：在社会主义经济模式的选择和理解上过于单一，最求纯碎的单一的社会主义经济成分；在公有制实现形式的选择和理解上过于简单化，只注意到集体所有制和全民所有制这两种基本形式，而对社会主义改造完成以后公有制经济可以和非公有制经济共同发展缺乏认识。但是，不能因为出现这些失误和偏差而否定社会主义改造的伟大意义\n\n## <center>论述题</center>\n\n### 1、论述新民主主义时期民族资产阶级的特点\n\n&ensp;&ensp;&ensp;&ensp;&ensp;新民主主义时期的民族资产阶级仍然是一个具有两面性的阶级：既有剥削工人的一面，又有接受工人阶级及其政党领导的一面。因此，民族资产阶级与工人阶级的矛盾也具有两重性，既有剥削者与被剥削者的阶级利益相互对立的对抗性，又有相互合作、具有相同利益的非对抗性的一面。对于工人阶级和社会主义革命来说，民族资产阶级作为一个剥削阶级，是被消灭的对象；作为一个可以接受工人阶级及其政党领导的社会力量，又是团结和改造的对象\n\n### 2、如何认识具有中国特点的社会主义改造道路\n\n&ensp;&ensp;&ensp;&ensp;&ensp;改造取得的成就：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;在一个几亿人口的大国比较顺利地实现了如此复杂、困难和深刻的社会变革，不仅没有造成生产力的破坏，反而促进了工农业和整个国民经济的发展\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;这样的变革没有引起巨大的社会动荡，反而极大地加强了人民的团结，并且是在人民基本上普遍拥护的情况下完成的。这说明，我国社会主义改造的基本完成的确是一个伟大的历史性胜利\n\n&ensp;&ensp;&ensp;&ensp;&ensp;改造的失误和偏差：主要是“在一九五五年夏季以后，农业合作化以及对手工业和个体商业的改造要求过急，工作过粗，改变过快，形式过于简单划一”\n\n&ensp;&ensp;&ensp;&ensp;&ensp;正确认识：成就第一，失误和偏差第二，不能因为出现一些失误而否定社会主义改造的伟大意义。社会主义制度是中国历史最深刻最伟大的社会变革，也是20世纪中国又一次划时代的历史巨变。\n\n### 3、论述我国对资本主义工商业采取和平赎买的方式进行改造的原因\n\n&ensp;&ensp;&ensp;&ensp;&ensp;民族资产阶级具有两面性。在社会主义改革时期，民族资产阶级既有剥削工人取得利润的一面，又有拥护宪法、愿意接受社会主义改造的一面\n\n&ensp;&ensp;&ensp;&ensp;&ensp;中国共产党与民族资产阶级长期保持着统一战线的关系，这就为将工人阶级和民族资产阶级之间存在着的对抗性矛盾转化为非对抗性矛盾并按照人民内部矛盾来处理提供了前提\n\n&ensp;&ensp;&ensp;&ensp;&ensp;我国已经有了以工人阶级为领导、工农联盟为基础的人民民主专政的国家政权，建立了强大的社会主义国营经济并掌握了国家的经济命脉，这就造成了私人资本主义在政治上、经济上对社会主义的依赖\n\n&ensp;&ensp;&ensp;&ensp;&ensp;当时国家对粮食和工业原料的统购统销，以及资本主义企业中工人群众对资本主义的监督等因素，就使私人资本主义企业只能接受社会主义改造\n\n### 4、论述我国社会主义基本制度确立后，我国社会的阶级关系发生了哪些变化？\n\n&ensp;&ensp;&ensp;&ensp;&ensp;伴随着社会主义制度和社会经济结构的根本变化，我国社会的阶级关系也发生了根本变化：\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;帝国主义侵略势力已经被清除中国大陆\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;官僚资产阶级已经在中国内地被消灭\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;原来的地主和富农正在被改造成自食其力的劳动者\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;民族资产阶级分子被改造成自食其力的社会主义劳动者\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;工人阶级已经成为国家的领导阶级，工人阶级队伍进一步壮大\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;亿万农民和其他个体劳动者已经成为社会主义的集体劳动者\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;知识界已经成为一支为社会主义服务的队伍。广大劳动人民从此摆脱了被剥削被奴役的地位，成为掌握生产资料的国家和社会的主义以及掌握自己命运的主人。\n\n## <center>思考题</center>\n\n### 1、为什么说新民主主义社会是一个过渡性社会？\n\n&ensp;&ensp;&ensp;&ensp;&ensp;在新民主主义社会中，存在着五种经济成分，在这些经济成分中，通过没收官僚资本主义而形成的社会主义的国营经济，掌握了主要经济命脉，居于领导地位\n\n&ensp;&ensp;&ensp;&ensp;&ensp;在我国新民主主义社会中，社会主义的因素无论在经济上还是政治上都已经居于领导地位，加上当时有利于发展社会主义的国际条件，决定了社会主义因素将不断增长并获得最终胜利，非社会主义因素将不断受到限制和改造\n\n&ensp;&ensp;&ensp;&ensp;&ensp;为了促进社会主义生产力的进一步发展，实现了国家富强、民族振兴，我国新民主主义社会必须适时地逐步过渡到社会主义社会\n\n&ensp;&ensp;&ensp;&ensp;&ensp;我国新民主主义社会是属于社会主义体系的，是逐步过渡到社会主义的过渡性质的社会\n\n### 2、怎样理解党的过渡时期的总路线？\n\n&ensp;&ensp;&ensp;&ensp;&ensp;党在过渡时期总路线的主要内容被概括为“一化三改”。“一化”即社会主义工业化，“三改”即个体农业、手工业和资本主义工商业的社会主义改造。它们之间相互联系，不可分离，可以比喻为鸟的“主体”和“两翼”。其中，“一化”是“主体”，“三改”是“两翼”，两者相辅相成、相互促进\n\n&ensp;&ensp;&ensp;&ensp;&ensp;这是一条社会主义建设和社会主义改造同时并举的路线，体现了社会主义工业化和社会主义改造的紧密结合，体现了解放生产力与发展生产力、变革生产关系与生产力的有机统一\n\n### 3、如何认识我国社会主义改造的基本经验？\n\n&ensp;&ensp;&ensp;&ensp;&ensp;坚持社会主义工业化建设与社会主义改造同时并举\n\n&ensp;&ensp;&ensp;&ensp;&ensp;采取积极引导、逐步过渡的方式\n\n&ensp;&ensp;&ensp;&ensp;&ensp;用和平方法进行改造\n\n### 4、如何理解中国确立社会主义基本制度的重大意义？\n\n&ensp;&ensp;&ensp;&ensp;&ensp;中华人民共和国的成立和社会主义基本制度的确立，是20世纪中国一次划时代的历史巨变，也是20世纪社会主义发展史的历史巨变，也是世界社会主义发展史上又一个历史性的伟大胜利，为当代中国一切发展进步奠定了根本的政治前提和制度基础，实现了中华民族由近代不断衰落到根本扭转命运、持续走向繁荣富强的伟大飞跃\n\n&ensp;&ensp;&ensp;&ensp;&ensp;社会主义基本制度的确立，极大地提高了工人阶级和广大劳动者的积极性、创造性\n\n&ensp;&ensp;&ensp;&ensp;&ensp;社会主义基本制度的确立，促进了我国社会生产力突飞猛进的发展，初步显示了社会主义的优越性\n\n&ensp;&ensp;&ensp;&ensp;&ensp;社会主义基本制度的确立，是广大劳动人民真正成为国家的主人。这是中国几千年阶级关系的最根本变革，极大地巩固和扩大工人阶级的领导、以工农联盟为基础的人民民主专政国家政权的阶级基础和经济基础\n\n&ensp;&ensp;&ensp;&ensp;&ensp;社会主义基本制度的确立，进一步改变了世界政治经济格局，增强了社会主义的力量，对维护世界和平产生了积极影响\n\n&ensp;&ensp;&ensp;&ensp;&ensp;社会主义基本制度的确立，是以毛泽东为主要代表的中国共产党人对一个脱胎于半殖民地半封建的东方大国如何进行社会主义革命问题的系统回答和正确解决，是马克思列宁主义关于社会主义革命理论在中国正确运用和创造性发展的结果\n\n# <center>五、社会主义建设道路初步探索的理论成果</center>\n\n## <center>辨析题</center>\n\n### 1、我国社会主义初级阶段的主要矛盾是生产力和生产关系的矛盾\n\n&ensp;&ensp;&ensp;&ensp;&ensp;观点错误\n\n&ensp;&ensp;&ensp;&ensp;&ensp;生产力和生产关系的矛盾是我国社会的基本矛盾，但不是主要矛盾，这种说法混淆了基本矛盾和主要矛盾\n\n&ensp;&ensp;&ensp;&ensp;&ensp;我国社会主义改造基本完成以后，我国的主要矛盾，已经是人民对于建立先进的工业国的要求同落后的农业国的现实之间的矛盾，已经是人民对于经济文化迅速发展的需要同当前经济文化不能满足人民需要的状况之间的矛盾\n\n### 2、毛泽东在《论十大关系》中，提出了优先发展重工业的中国工业化道路的思想\n\n&ensp;&ensp;&ensp;&ensp;&ensp;观点错误\n\n&ensp;&ensp;&ensp;&ensp;&ensp;毛泽哦对那个提出了以农业为基础，以工业为主导，以农轻重为序发展国民经济的总方针，以及一整套“两条腿走路”的工业化发展思路，即重工业和轻工业同时并举，中央工业和地方工业同时并举，沿海工业和内地工业同时并举，大型企业和中小型企业同时并举，等等\n\n### 3、党的八大二次会议仍然坚持了我国对社会主要矛盾的正确判断\n\n&ensp;&ensp;&ensp;&ensp;&ensp;观点错误\n\n&ensp;&ensp;&ensp;&ensp;&ensp;党的八大二次会议改变了党的八大关于我国社会主要矛盾的正确判断，错误地认为在社会主义社会建成以前，无产阶级与资产阶级的矛盾，社会主义道路和资本主义道路的矛盾，始终是我国社会的主要矛盾。这是导致后来阶级斗争扩大化的重要原因。实践证明，在社会主义初级阶段，要科学把握我国社会主要矛盾，以经济建设为中心，不断提高人民物质文化生活水平，不断满足人民对美好生活的向往。对于社会主义社会一定范围内长期存在的阶级斗争，不能将其简单地等同于全国范围内的阶级斗争，也不能搞大规模的政治活动，更不能搞阶级斗争扩大化\n\n## 简答题\n\n### 1、简答社会主义制度确立后我国社会的主要矛盾\n\n&ensp;&ensp;&ensp;&ensp;&ensp;党的八大正确分析了社会主义改造完成后我国社会主要矛盾的变化，指出社会主义制度在我国已经基本上建立起来了，我国国内的主要矛盾，是人民对于建立先进的工业国的要求同落后的农业国的现实之间的矛盾，是人民对于经济文化迅速发展的需要同当前经济文化不能满足人民需要的状况之间的矛盾。\n\n### 2、简答走中国工业化道路的思想\n\n&ensp;&ensp;&ensp;&ensp;&ensp;走中国工业化道路，必须明确战略目标和战略步骤\n\n&ensp;&ensp;&ensp;&ensp;&ensp;走中国工业化道路，必须采取正确的经济建设方针。党的八大提出了既反保守又反冒进、在综合平衡中稳步前进的方针\n\n&ensp;&ensp;&ensp;&ensp;&ensp;走中国工业化道路，必须发展科学技术和文化教育\n\n&ensp;&ensp;&ensp;&ensp;&ensp;走中国工业化道路，必须重视知识分子工作\n\n&ensp;&ensp;&ensp;&ensp;&ensp;走中国工业化道路，必调整和完善所有制结构\n\n&ensp;&ensp;&ensp;&ensp;&ensp;走中国工业化道路，必须积极探索适合我国情况的经济体制和运行机制\n\n### 3、简答正确处理人民内部矛盾的具体方针和原则\n\n&ensp;&ensp;&ensp;&ensp;&ensp;对于政治思想领域的人民内部矛盾，实行 “团结—批评—团结” 的方针，坚持说服教育、讨论的方法\n\n&ensp;&ensp;&ensp;&ensp;&ensp;对于物质利益、分配方面的人民内部矛盾，实行 “统筹兼顾、适当安排” 的方针，兼顾国家、集体和个人三方面的利益\n\n&ensp;&ensp;&ensp;&ensp;&ensp;对于人民群众和政府机关的矛盾，要坚持民主集中制原则，努力克服政府机关的官僚主义，也要加强对群众的思想教育\n\n&ensp;&ensp;&ensp;&ensp;&ensp;对于科学文化领域里的矛盾，实行 “百花齐放、百家争鸣” 的方针，通过自由讨论和科学实践、艺术实践去解决\n\n&ensp;&ensp;&ensp;&ensp;&ensp;对于共产党和民主党派的矛盾，实行在坚持社会主义道路和共产党领导的前提下 “长期共存、互相监督” 的方针\n\n&ensp;&ensp;&ensp;&ensp;&ensp;对于民族之间的矛盾，实行民族平等、团结互助的方针，着重反对大汉族主义，也要反对地方民族主义，等等\n\n### 4、简答关于正确处理两类不同性质社会矛盾的基本方法\n\n&ensp;&ensp;&ensp;&ensp;&ensp;毛泽东指出：敌我之间和人民内部这两类矛盾的性质不同，解决的方法也不同。前者是分清敌我的问题，后者是分清是非的问题\n\n&ensp;&ensp;&ensp;&ensp;&ensp;采用专政的方法解决敌我矛盾，所谓专政方法，就是运用人民民主专政的国家机器，对于国家内部那些反抗社会主义改造、破坏社会主义建设的敌对分子和严重犯罪分子依法治罪，剥夺他们政治权利，强迫他们从事劳动，并在劳动中尽量使他们改造成为新人\n\n&ensp;&ensp;&ensp;&ensp;&ensp;采用民主的方法解决人民内部矛盾。所谓民主方法，就是讨论的方法、批评的方法、说服教育的方法\n\n### 5、简答《论十大关系》中十大关系的内容\n\n&ensp;&ensp;&ensp;&ensp;&ensp;《论十大关系》内容涉及生产力和生产关系、经济基础和上层建筑各方面\n\n&ensp;&ensp;&ensp;&ensp;&ensp;前五条主要讨论经济问题，着眼于调动经济领域各个方面的积极因素。其中前三条讲重工业和轻工业、农业的关系，沿海工业和内地工业的关系，经济建设和国防建设的关系。这实际上是在论述如何开辟一条和苏联有所不同的中国工业道路问题。第四、第五条讲国家、生产单位和生产者个人的关系，中央和地方的关系，开始涉及经济体制改革。这样就初步提出了中国社会主义经济建设的若干新方针、新思路\n\n&ensp;&ensp;&ensp;&ensp;&ensp;“十大关系”的后五条，讲汉族与少数民族的关系，党与非党的关系、革命和反革命的关系、是非关系、中国和外国关系，论述的是政治生活和思想文化领域如何调动各种积极因素的问题\n\n## 论述题\n\n### 1、论述社会主义建设中积极因素和消极因素的关系\n\n&ensp;&ensp;&ensp;&ensp;&ensp;社会主义建设中的积极因素与消极因素是一对矛盾，这一矛盾呈现出既统一又斗争的关系\n\n&ensp;&ensp;&ensp;&ensp;&ensp;充分调用一切积极因素，尽可能地克服消极因素，并且努力化消极因素为积极因素，是社会主义事业前进的现实需要\n\n&ensp;&ensp;&ensp;&ensp;&ensp;积极因素与消极因素，既包括党内因素，也包括党外因素；既包括国内的因素，也包括国外因素；既包括直接的因素，也包括间接的因素\n\n&ensp;&ensp;&ensp;&ensp;&ensp;在社会主义事业的发展中，一般来说，积极因素是处于主导地位、统领地位的，占有压倒的优势，这是社会主义事业不断前进的可靠保证。社会主义建设的积极因素与消极因素在一定条件下是可以相互转化的。我们的任务是创造条件，大力促使消极因素比较多、比较快地向积极因素转化，并同时尽力防止积极因素向消极因素逆转\n\n### 2、论述怎样调动一切积极因素发展社会主义事业\n\n&ensp;&ensp;&ensp;&ensp;&ensp;调动一切积极因素为社会主义事业服务，必须坚持中国共产党的领导\n\n&ensp;&ensp;&ensp;&ensp;&ensp;调动一切积极因素为社会主义事业服务，必须发展社会主义民主政治\n\n&ensp;&ensp;&ensp;&ensp;&ensp;调动一切积极因素为社会主义事业服务，有一个如何认识社会主义发展阶段和社会主义建设规律的问题。在探索中国社会主义建设道路过程中，毛泽东指出，社会主义又可分为两个阶段，第一个阶段是不发达的社会主义，第二个阶段是比较发达的社会主义。后一个阶段可能比前一个阶段需要更长的时间\n\n&ensp;&ensp;&ensp;&ensp;&ensp;总之，调动一切积极因素为社会主义事业服务，是党关于社会主义建设的一条极为重要的方针，对于最大限度地团结全国各族人民，为建设社会主义现代化国家而奋斗，具有长远的指导意义\n\n### 3、论述毛泽东《关于正确处理人民内部矛盾的问题》的报告中对社会主义社会矛盾的系统分析\n\n&ensp;&ensp;&ensp;&ensp;&ensp;关于社会主义社会的基本矛盾。在社会主义社会中，基本矛盾仍然是生产关系和生产力之间的矛盾，上层建筑和经济基础的矛盾\n\n&ensp;&ensp;&ensp;&ensp;&ensp;关于我国社会的主要矛盾和根本任务。党的八大提出：社会主义制度在我国已经基本上建立起来了。我们国内的主要矛盾，已经是人民对于建立先进工业国的要求同落后的农业国的现实之间的矛盾，已经是人民对于经济文化迅速发展同当前经济文化不能满足人民需要的状况之间的矛盾\n\n&ensp;&ensp;&ensp;&ensp;&ensp;关于社会主义社会在两类不同性质矛盾的理论。敌我矛盾和人民内部矛盾，这是两类性质完全不同的矛盾\n\n&ensp;&ensp;&ensp;&ensp;&ensp;关于正确处理两类不同性质的矛盾的基本方法。解决敌我之间的和人民内部的这两类不同性质的矛盾，采用专政和民主这样两种不同的方法\n\n&ensp;&ensp;&ensp;&ensp;&ensp;关于正确处理人民内部矛盾的方针。用民主的方法解决人民内部矛盾，这是一个总方针\n\n&ensp;&ensp;&ensp;&ensp;&ensp;关于区分两类不同性质矛盾和正确处理人民内部矛盾的目的和意义\n\n&ensp;&ensp;&ensp;&ensp;&ensp;毛泽东关于社会主义社会矛盾的学说，科学揭示了社会主义社会发展的动力，以独创性的内容丰富了马克思主义的理论宝库，为正确处理社会主义社会各种矛盾、创造良好的社会环境，提供了基本的理论依据，也为后来的社会主义改革奠定了理论基础\n\n## 思考题\n\n### 1、党在社会主义建设道路的初步探索中取得了哪些重要的理论成果？\n\n&ensp;&ensp;&ensp;&ensp;&ensp;党在中国社会主义建设道路的初步探索中取得的重要理论成果：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;调动一切积极因素为社会主义事业服务\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;正确认识和处理社会主义社会矛盾的思想\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;走中国工业化道路\n\n&ensp;&ensp;&ensp;&ensp;&ensp;在探索社会主义建设道路的过程中，毛泽东以及党的其他领导人，还提出了一些重要的思想理论观点，其中涉及国防建设和军队建设、实现祖国统一、外交和国际战略、执政党建设等方面，当在探索社会主义建设道路过程中取得的重要理论成果，是毛泽东思想的重要组成部分，丰富和发展了科学社会主义理论，成为中国特色社会主义理论体系的重要思想来源\n\n### 2、如何认识党对社会主义建设道路初步探索的重大意义\n\n&ensp;&ensp;&ensp;&ensp;&ensp;党领导人民探索社会主义建设道路，经历了艰辛和曲折，在理论和实践上取得了一系列重要成果。这些成果对于巩固我国社会主义制度，开创和发展中国特色社会主义，对于促进世界社会主义发展，具有重要意义：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;巩固和发展了我国的社会主义制度\n\n&ensp;&ensp;&ensp;&ensp;&ensp;为开创中国特色社会主义提供了宝贵经验、理论准备、物质基础\n\n&ensp;&ensp;&ensp;&ensp;&ensp;丰富了科学社会主义的理论和实践\n\n### 3、党对社会主义道路的初步探索有哪些经验教训？\n\n&ensp;&ensp;&ensp;&ensp;&ensp;党对社会主义建设道路的初步探索，取得了巨大成就，积累了丰富的经验，同时也遭遇过严重挫折，造成了严重后果，留下了深刻教训\n\n&ensp;&ensp;&ensp;&ensp;&ensp;必须把马克思主义与中国实际相结合，探索符合中国特点的社会主义建设的道路\n\n&ensp;&ensp;&ensp;&ensp;&ensp;必须正确认识社会主义社会的主要矛盾和根本任务，集中力量发展生产力\n\n&ensp;&ensp;&ensp;&ensp;&ensp;必须从实际出发进行社会主义建设，建设规模和速度要和国力相适应，不能急于求成\n\n&ensp;&ensp;&ensp;&ensp;&ensp;必须发展社会主义民主，健全社会主义法制\n\n&ensp;&ensp;&ensp;&ensp;&ensp;必须坚持党的民主集中制和集体领导制度，加强执政党建设\n\n&ensp;&ensp;&ensp;&ensp;&ensp;必须坚持对外开放，借鉴和吸收人类文明的共同成果建设社会主义，不能关起门来搞建设\n\n# <center>六、邓小平理论</center>\n\n## <center>辨析题</center>\n\n### 1、中国共产党领导人民进行革命和建设的实践是邓小平理论形成的现实依据\n\n&ensp;&ensp;&ensp;&ensp;&ensp;观点错误\n\n&ensp;&ensp;&ensp;&ensp;&ensp;改革开放和现代化建设的实践是邓小平理论形成的现实依据。邓小平理论是以邓小平为主要代表的中国共产党人立足中国又面向世界，总结历史又正视现实、放眼未来，把马克思主义基本原理同中国国情和时代特征结合起来，在研究新情况、解决新问题的过程中形成发展起来的\n\n### 2、邓小平理论的主题是和平与发展\n\n&ensp;&ensp;&ensp;&ensp;&ensp;观点错误\n\n&ensp;&ensp;&ensp;&ensp;&ensp;题干混淆了邓小平理论的主题与当今世界的时代主题。和平与发展是当今的世界的时代主题，是邓小平理论形成和发展的时代背景。邓小平理论的主题是“建设中国特色社会主义”，主线是“什么是社会主义和怎样建设社会主义”。邓小平理论的全部内容都是围绕这一主题而展开的。只有正确把握邓小平理论的主题，才能更好地建设中国特色社会主义\n\n### 3、社会主义初级阶段是每一个社会主义国家必然经历的阶段\n\n&ensp;&ensp;&ensp;&ensp;&ensp;观点错误\n\n&ensp;&ensp;&ensp;&ensp;&ensp;社会主义初级阶段不是泛指任何国家进入社会主义都会经历的起始阶段，而是特指我国生产力落后、商品经济不发达条件下建设社会主义必然要经历的特定阶段。它包括两层含义：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;（1）我国社会已经是社会主义社会\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;（2）我国的社会主义社会还处在初级阶段。它是建设中国特色社会主义的总依据\n\n### 4、建设中国特色社会主义，总依据是社会主义初级阶段\n\n&ensp;&ensp;&ensp;&ensp;&ensp;观点正确\n\n&ensp;&ensp;&ensp;&ensp;&ensp;建设中国特色社会主义，总依据是社会主义初级阶段。正确认识我国当今社会所处的历史阶段，是建设中国特色社会主义的首要问题，是我们制定和执行正确的路线方针的总依据。认清国情，是认清一切革命问题的基本依据。认清中国国情的首要任务是搞清楚社会的性质和发展阶段，认识社会主要矛盾及其变化\n\n&ensp;&ensp;&ensp;&ensp;&ensp;我国社会主义事业取得了举世瞩目的巨大成就，但人口多、底子薄，发展不平衡，仍然是我国的基本国情。社会主义初级阶段是我国最大的实际，我们想问题、办事情、定政策，推进任何领域任何方面的改革发展，都要牢牢立足于这一实际\n\n### 5、社会主义的根本任务是深化改革、扩大开放\n\n&ensp;&ensp;&ensp;&ensp;&ensp;观点错误\n\n&ensp;&ensp;&ensp;&ensp;&ensp;社会主义的根本任务是发展生产力。把发展生产力作为社会主义的根本任务是符合马克思主义基本原理的，是巩固和发展社会主义制度的必然要求。把发展生产力作为社会主义根本任务根据我国的国情和总结我国社会主义实践经验教训得出的必然结果。社会主义在同资本主义的较量中，能否不断地巩固和发展自己，能否体现出其优越性，最根本的是生产力能否比资本主义发展得更快更好。深化改革，扩大开放只是发展社会主义生产力的手段之一，不是社会主义的根本任务\n\n### 6、改革的实质，就是改变我国社会的发展方向\n\n&ensp;&ensp;&ensp;&ensp;&ensp;观点错误\n\n&ensp;&ensp;&ensp;&ensp;&ensp;改革是社会主义制度的自我完善，是在坚持社会主义方向的前提下，改变生产关系中不适应生产力发展的方面，是在中国共产党的领导下，有计划、有步骤、有秩序的改革。改革决不是改变党的领导，决不是改变社会主义方向\n\n### 7、改革是中国的第二次革命\n\n&ensp;&ensp;&ensp;&ensp;&ensp;观点正确\n\n&ensp;&ensp;&ensp;&ensp;&ensp;改革的实质就是要从根本上改变束缚我国生产力发展和社会发展的经济体制、政治体制、科技体制、教育体制、文化体制等各种具体制度，以适应中国社会主义现代化建设的需要\n\n&ensp;&ensp;&ensp;&ensp;&ensp;改革是中国的第二次革命，是相对与新民主主义革命而言的。改革不是对旧体制细枝末节的、修修补补的改变，而是为了扫除发展社会生产力的障碍\n\n&ensp;&ensp;&ensp;&ensp;&ensp;中国的改革是“全方位”的改革，不仅改变了同生产力发展不相适应的生产关系，而且引起上层建筑的变革，并带来生产方式和价值等一系列重大变化。改革已辐射到社会生活的一切领域、促使社会生活发生整体转型\n\n&ensp;&ensp;&ensp;&ensp;&ensp;所以，无论从改革在解放和发展生产力方面所引起的巨大作用看，还是从其引起我国社会关系和社会生活改革的深度和广度看，都可以说是一场新的革命\n\n### 8、实行对外开放要正确对待资本主义社会创造的现代文明成果\n\n&ensp;&ensp;&ensp;&ensp;&ensp;观点正确\n\n&ensp;&ensp;&ensp;&ensp;&ensp;实行对外开放要正确对待资本主义创造的现代文明成果。资本主义社会经过几百年发展，特别是一些发达国家，在经济、科技、教育、文化和社会管理等方面，积累了丰富经验，取得了许多历史性的文化成果。社会主义作为后起的崭新的社会制度，必须大胆借鉴、吸收人类社会包括资本主义社会创造出来的全部文明成果，结合新的实践进行新的创造，为我所用，才能加快发展，赢得同资本主义相比较的优势\n","tags":["政治"],"categories":["升学"]},{"title":"高数","url":"/post/374a26ee.html","content":"\n第一章\n\n> https://maifile.cn/est/a2717024567063/pdf\n\n> https://maifile.cn/est/a2607026959444/pdf\n\n第二章\n\n> https://maifile.cn/est/a3247024573378/pdf\n\n> https://maifile.cn/est/a2577026959811/pdf\n\n第三章\n\n> https://maifile.cn/est/a2687024676086/pdf\n\n> https://maifile.cn/est/a3157026960210/pdf\n\n第四章\n\n> https://maifile.cn/est/a3287024676507/pdf\n\n> https://maifile.cn/est/a2397026960625/pdf\n\n第五章\n\n> https://maifile.cn/est/a2397024676890/pdf\n\n> https://maifile.cn/est/a2327026961032/pdf\n\n第六章\n\n> https://maifile.cn/est/a2737024677280/pdf\n\n> https://maifile.cn/est/a2887026961429/pdf\n\n第七章\n\n> https://maifile.cn/est/a2317024677719/pdf\n\n&ensp;&ensp;&ensp;&ensp;&ensp;https://maifile.cn/est/a3017026961908/pdf\n\n第八章\n\n> https://maifile.cn/est/a2837024678072/pdf\n\n> https://maifile.cn/est/a3197026962285/pdf\n\n第九章\n\n> https://maifile.cn/est/a2907024678413/pdf\n\n> https://maifile.cn/est/a2317026962687/pdf\n\n第十章\n\n> https://maifile.cn/est/a2537024678750/pdf\n\n> https://maifile.cn/est/a2677026963126/pdf\n\n第十一章\n\n> https://maifile.cn/est/a3127024679105/pdf\n\n> https://maifile.cn/est/a2687026963493/pdf\n\n","tags":["高数"],"categories":["升学"]},{"title":"第十二章 实现中华民族伟大复兴的重要保障","url":"/post/de801b7c.html","content":"\n# <center>第一节 坚持总体国家安全观</center>\n\n## <center>1、国家安全是安邦定国的重要基石</center>\n\n**内涵**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;关键在“总体”，突出的是“大安全”理念，涵盖诸多领域\n\n**重要性**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;人民幸福安康的基本要求，安邦定国的重要基石，\n\n&ensp;&ensp;&ensp;&ensp;&ensp;维护国家安全是全国各族人民的根本利益所在\n\n**意义**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;①适应了进行具有许多新的历史特点的伟大斗争的新要求\n\n&ensp;&ensp;&ensp;&ensp;&ensp;②回应了人民对国家安全的新期待\n\n&ensp;&ensp;&ensp;&ensp;&ensp;③顺应了世界发展变化的新趋势\n\n## <center>2、坚持走中国特色国家安全道路</center>\n\n**含义**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;①总体国家安全观是指坚持国家利益至上\n\n&ensp;&ensp;&ensp;&ensp;&ensp;②以人民安全为宗旨，以政治安全为根本\n\n&ensp;&ensp;&ensp;&ensp;&ensp;③ 以经济安全为基础\n\n&ensp;&ensp;&ensp;&ensp;&ensp;④以军事、文化、社会安全为保障\n\n&ensp;&ensp;&ensp;&ensp;&ensp;⑤ 以促进国际安全为依托\n\n内容\n\n&ensp;&ensp;&ensp;&ensp;&ensp;既重视发展问题又重视安全问题，既重视外部安全又重视内部安全，\n\n&ensp;&ensp;&ensp;&ensp;&ensp;既重视国土安全又重视国民安全，既重视传统安全又重视非传统安，\n\n&ensp;&ensp;&ensp;&ensp;&ensp;既重视自身安全又重视共同安全\n\n要求\n\n&ensp;&ensp;&ensp;&ensp;&ensp;①坚持统筹发展和安全两件大事\n\n&ensp;&ensp;&ensp;&ensp;&ensp;②坚持人民安全、政治安全、国家利益至上有机统一\n\n&ensp;&ensp;&ensp;&ensp;&ensp;③ 坚持维护和塑造国家安全\n\n&ensp;&ensp;&ensp;&ensp;&ensp;④坚持科学统筹的根本方法\n\n## <center>3、着力防范化重大风险</center>\n\n重大风险包括国内的经济、政治、意识形态、社会风险以及自然界风险等等\n\n预判风险所在是防范风险的前提，把握风险走向是谋求战略主动的关键\n\n坚持立足于防，又有效处置风险\n\n# <center>第二节 加快国防和军队现代化</center>\n\n## <center>1、坚持习近平强军思想</center>\n\n**回答问题**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;新时代建设一支什么样的强大人民军队，怎样建设强大人民军队\n\n**主要内容**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;明确强国必须强军\n\n&ensp;&ensp;&ensp;&ensp;&ensp;明确强军目标：听党指挥，能打胜战，作风优良\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;2020：军队基本机械化\t\t2035：军队基本现代化\t本世纪中叶：世界一流军队\n\n&ensp;&ensp;&ensp;&ensp;&ensp;明确党对人民军队的绝对领导是建军之本，强军之魂\n\n&ensp;&ensp;&ensp;&ensp;&ensp;明确军队聚焦能打仗，打胜仗\n\n&ensp;&ensp;&ensp;&ensp;&ensp;明确作风优良是我军鲜明特色和政治优势\n\n&ensp;&ensp;&ensp;&ensp;&ensp;明确推进强军事业\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;必须坚持政治建军(立军之本)、改革强军(关键一招)、科技强军(核心战斗力)、人才强军(第一资源)、依法治军(基本方略)\n\n&ensp;&ensp;&ensp;&ensp;&ensp;明确改革是强军的必由之路\n\n&ensp;&ensp;&ensp;&ensp;&ensp;明确创新是引领发展的第一动力\n\n&ensp;&ensp;&ensp;&ensp;&ensp;明确现代化军队必须构建中国特色军事法治体系\n\n&ensp;&ensp;&ensp;&ensp;&ensp;明确军民融合发展是兴国之举，强军之策\n\n## <center>2、实现党在新时代的强军目标</center>\n\n强军目标：建设一支听党指挥(灵魂)、能打胜仗(核心)、作风优良(保证)的人民军队\n\n听党指挥\n\n&ensp;&ensp;&ensp;&ensp;&ensp;决定军队建设的政治方向；发端于南昌起义，奠基于三湾改编，定型于古田会议\n\n能打胜战\n\n&ensp;&ensp;&ensp;&ensp;&ensp;反映军队的根本职能和军队建设的根本，牢固树立战斗力这个唯一根本标准\n\n作风优良\n\n&ensp;&ensp;&ensp;&ensp;&ensp;关系军队的性质、宗旨、本色\n\n## <center>3、构建一体化的国家战略体系和能力</center>\n\n**意义**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;实现发展和安全兼顾，富国和强军相统一的必然选择\n\n**军政军民团结**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;实现富国和强军相统一的重要政治保障，是我党我军特有的政治优势\n\n**要求**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;① 坚持人民战争的战略思想\n\n&ensp;&ensp;&ensp;&ensp;&ensp;② 建立健全国防动员体制机制\n\n&ensp;&ensp;&ensp;&ensp;&ensp;③ 坚持军民合力共建边海防\n\n&ensp;&ensp;&ensp;&ensp;&ensp;④ 加强国防教育，增强全民国防观念\n\n&ensp;&ensp;&ensp;&ensp;&ensp;⑤ 大力弘扬军爱民、民拥军的光荣传统\n\n# <center>第三节 坚持“一国两制”推进祖国统一</center>\n\n## <center>1、全面精准贯彻“一国两制”方针</center>\n\n**基本国策**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;计划生育，保护环境，对外开放，节约资源，合理利用土地和保护耕地，\n\n&ensp;&ensp;&ensp;&ensp;&ensp;男女平等、水土保持、一国两制、科教兴国、耕地保护\n\n**一国两制**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;含义：国家主体社会主义制度，个别地区依法实行资本主义制度\n\n&ensp;&ensp;&ensp;&ensp;&ensp;关系：一国是两制的前提和基础，两制从属和派生于一国\n\n&ensp;&ensp;&ensp;&ensp;&ensp;提出：1961年最早针对台湾提出\n\n&ensp;&ensp;&ensp;&ensp;&ensp;应用：首先在香港、澳门得到应用\n\n意义\n\n&ensp;&ensp;&ensp;&ensp;&ensp;① 解决历史遗留问题最佳方案，香港澳门长期繁荣最佳制度\n\n&ensp;&ensp;&ensp;&ensp;&ensp;② 中华民族为世界和平与发展做出的新贡献\n\n要求\n\n&ensp;&ensp;&ensp;&ensp;&ensp;①必须始终准确把握“一国”和“两制”关系\n\n&ensp;&ensp;&ensp;&ensp;&ensp;②必须落实中央对特别行政区全面管治权，维护国家主权、安全、发展利益\n\n&ensp;&ensp;&ensp;&ensp;&ensp;③必须聚焦发展这个第一要务\n\n&ensp;&ensp;&ensp;&ensp;&ensp;④必须坚持爱国者治港治澳原则\n\n## <center>2、确保“一国两制”实践行稳致远</center>\n\n2016\t\t通过香港特别行政区基本法第104条解释\n\n2020.5\t《全国人民代表大会关于建立健全香港特别行政区维护国家安全的法律制度和执行机制的决定》\n\n2020.6\t《中华人民共和国香港特别行政区维护国家安全法》\n\n2021.3\t《全国人民代表大会关于完善香港特别行政区选举制度的决定》\n\n## <center>3、实现祖国完全统一</center>\n\n（1）一个中国原则是两岸关系的政治基础，体现一个中国原则的“九二共识” ，明确界定了两岸关系的根本性质，是确保两岸关系和平发展的关键。\n\n（2）“和平统一、一国两制”是解决台湾问题的基本方针，也是实现国家统一的最佳方式\n\n（3）坚决反对和遏制任何形式的“台独”。\"台独”分裂势力及其活动损害国家主权和领土完整，是两岸关系和平发展的最大障碍，是当前对两岸关系和平发展的最大现实威胁。秉持“两岸一家亲”理念，尊重台湾现有的社会制度和台湾同胞生活方式，继续率先同台湾同胞分享大陆发展机遇\n","tags":["政治"],"categories":["升学"]},{"title":"第十一章 “四个全面”战略布局","url":"/post/ee96f7a4.html","content":"\n# <center>第一节 全面建设社会主义现代化国家</center>\n\n## <center>1、从全面建成小康社会到全面建设社会主义现代化国家</center>\n\n“小康”讲的是发展水平，“全面”讲的是发展的平衡性、协调性、可持续性\n\n覆盖的领域要全面，是“五位一体”全面进步的小康\n\n覆盖的人口要全面，是惠及全体人民的小康\n\n覆盖的区域要全面，是城乡区域共同发展的小康\n\n三大攻坚战：1、防范化解重大风险、2、精准脱贫、3、污染防治\n\n解决区域整体贫困，消除绝对贫困\n\n全面建设社会主义现代化国家\n\n&ensp;&ensp;&ensp;&ensp;&ensp;第一，人口规模巨大的现代化\n\n&ensp;&ensp;&ensp;&ensp;&ensp;第二，全体人民共同富裕的现代化\n\n&ensp;&ensp;&ensp;&ensp;&ensp;第三，物质文明和精神文明相协调的现代化\n\n&ensp;&ensp;&ensp;&ensp;&ensp;第四，人与自然和谐共生的现代化\n\n&ensp;&ensp;&ensp;&ensp;&ensp;第五，走和平发展道路的现代化\n\n# <center>第二节 全面深化改革</center>\n\n## <center>1、坚定不移地全面深化改革</center>\n\n**必要性**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;1、全面深化改革，是顺应当今世界发展大势的必然选择\n\n&ensp;&ensp;&ensp;&ensp;&ensp;2、全面深化改革，是解决中国现实问题的根本途径\n\n&ensp;&ensp;&ensp;&ensp;&ensp;3、全面深化改革，关系党和人民事业的前途命运，关系党的执政基础和执政地位\n\n**目标**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;时间：党的十八届三中全会\n\n&ensp;&ensp;&ensp;&ensp;&ensp;完善和发展中国特色社会主义制度、推进国家治理体系和治理能力现代化\n\n**地位**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;实践证明，改革开放是决定当代中国革命的关键一招，也是决定实现“两个一百年”奋斗目标，实行中华民族伟大复兴的关键一招\n\n**战略安排**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;2035 国家治理体系和治理能力现代化基本实现\n\n&ensp;&ensp;&ensp;&ensp;&ensp;本世纪中叶 实现国家治理体系和治理能力现代化\n\n## <center>2、坚持全面深化改革的方向、立场和原则</center>\n\n必须坚持和完善中国特色社会主义制度和国家治理体系\n\n&ensp;&ensp;&ensp;&ensp;&ensp;历史：制度优势是最大优势，站起来、富起来、强起来\n\n&ensp;&ensp;&ensp;&ensp;&ensp;内容：马克思主义、中华优秀传统文化等结合\n\n必须始终站稳人民立场，坚持以人民为中心的改革价值取向\n\n&ensp;&ensp;&ensp;&ensp;&ensp;仅仅依靠人民，保持党同人民群众的血肉联系\n\n必须坚持党对改革的集中统一领导\n\n&ensp;&ensp;&ensp;&ensp;&ensp;指南针、定盘星、压舱石；党的领导制度具有统领地位\n\n## <center>3、坚持和完善中国特色社会主义制度，推进国家治理体系现代化</center>\n\n突出坚持和完善中国特色社会主义制度的根本制度、基本制度、重要制度\n\n推进国家治理体系和治理能力，就是使各方面制度更加科学，更加完善\n\n## <center>4、正确处理全面深化改革中的重大关系</center>\n\n第一，处理好解放思想和实事求是(党的思想路线)的关系\n\n第二，处理好顶层设计和摸着石头过河的关系\n\n第三，处理好整体推进和重点突破的关系\n\n第四，处理好胆子要大、步子要稳的关系\n\n第五，处理好改革、发展、稳定的关系\n\n一是改革、发展、稳定是我国社会主义现代化建设的三个重要支点，改革是经济社会发展的强大动力，发展是解决一切经济社会问题的关键，稳定是改革发展的前提。把改善人民生活作为正确处理改革、发展、稳定关系的结合点。\n\n全面深化改革的出发点和落脚点：促进社会公平正义、增进人民福祉\n\n# <center>第三节 全面依法治国</center>\n\n![全面依法治国](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271748781.png)\n\n## <center>1、坚持习近平法治思想</center>\n\n全面依法治国地位：中国特色社会主义的本质要求和重要保障\n\n1、坚持党对全面依法治国的领导\n\n2、坚持以人民为中心\n\n3、坚持中国特色社会主义法治道路\n\n4、坚持依宪治国、依宪执政\t\t\t\t依法治国首先要依宪治国\n\n5、坚持在法治轨道上推进国家治理体系和治理能力现代化\n\n6、坚持建设中国特色社会主义法治体系\n\n&ensp;&ensp;&ensp;&ensp;&ensp;中国特色社会主义法治体系是推进全面依法治国的总抓手\n\n&ensp;&ensp;&ensp;&ensp;&ensp;依法治国和以德治国相结合\n\n&ensp;&ensp;&ensp;&ensp;&ensp;党纪严于法律，法律地位高于法纪\n\n7、坚持依法治国(人民)、依法执政(党)、依法行政(政府)共同推进，法治国家、法治政府(主体工程)、法治社会一体建设\n\n8、坚持全面推进科学立法、严格执法、公正司法、全民守法\n\n&ensp;&ensp;&ensp;&ensp;&ensp;司法机关：检察院和法院\n\n&ensp;&ensp;&ensp;&ensp;&ensp;法制最后一道防线：公正司法\n\n&ensp;&ensp;&ensp;&ensp;&ensp;司法的灵魂和生命：公平正义\n\n9、坚持统筹推进国内法治和涉外法治\n\n10、坚持建设德才兼备的高素质法制工作队伍\n\n11、坚持抓住领导干部这个“关键少数”\n\n## <center>2、中国特色社会主义法治道路</center>\n\n**原因**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;走中国特色社会主义法治道路，是历史的必然结论\n\n&ensp;&ensp;&ensp;&ensp;&ensp;走中国特色社会主义法治道路，是由我国社会主义国家性质所决定的\n\n&ensp;&ensp;&ensp;&ensp;&ensp;走中国特色社会主义法治道路，是立足我国基本国情的必然选择\n\n**核心要义**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;坚持党的领导，坚持中国特色社会主义制度，贯彻中国特色社会主义法治理论\n\n## <center>3、深化依法治国实践</center>\n\n全面依法治国总目标：建设中国特色社会主义法治体系，建设社会主义法治国家   提出时间：十八届四中全会\n\n做法\n\n&ensp;&ensp;&ensp;&ensp;&ensp;1、紧紧围绕全面推进依法治国总目标，加快建设中国特色社会主义法治体系\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;(1)加快形成完备的法律规范体系\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;(2)加快形成高效的法治实施体系\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;(3)加快形成严密的法律监督体系\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;(4)加快形成有力的法律保障体系\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;(5)加快形成完善的党内法规体系\n\n&ensp;&ensp;&ensp;&ensp;&ensp;2、准确把握全面推进依法治国工作布局，坚持依法治国、依法执政、依法行政共同推进法治国家、法治政府、法治社会一体建设\n\n&ensp;&ensp;&ensp;&ensp;&ensp;3、准确把握全面推进依法治国重点任务，着力推进科学立法、严格执法、公正司法、全民守法\n\n&ensp;&ensp;&ensp;&ensp;&ensp;4、法治不仅要求完备的法律体系、完善的执法机制、普遍的法律遵守，更要求公平正义得到维护和实现\n\n# <center>第四节 全面从严治党</center>\n\n## <center>1、全面从严治党是伟大的自我革命</center>\n\n我党区别于其他政党最显著的标志：全面从严治党\n\n中国共产党区别于其他任何政党的显著标志：三大作风\n\n中国共产党区别于其他一切政党的根本标志：全心全意为人民服务\n\n全面从严治党\n\n&ensp;&ensp;&ensp;&ensp;&ensp;核心：加强党的领导\n\n&ensp;&ensp;&ensp;&ensp;&ensp;基础：在全面\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;全面：管全党，各领域\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;各方面，各部门\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;重点：“关键少数”\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;关键：在严\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;从严：真管真严，敢管敢言，长管长严\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;要害：在治\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;治：各级党委部门并肩主体负责\n\n全面从严治党，，要求增强系统性、预见性、创造性、时效性，使全面从严治党的一切努力都集中到党自我净化、自我完善、自我革新、自我提高能力上来\n\n## <center>2、新时代党的建设总要求</center>\n\n**原则**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;坚持和加强党的全面领导\n\n**方针**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;坚持党要管党、全面从严治党\n\n**统领**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;党的政治建设\n\n**主线**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;加强党的长期执政能力建设、先进性和纯洁性建设\n\n**根基**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;坚定理想信念宗旨\n\n**着力点**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;调动全党积极性、主动性、创造性\n\n**总体布局**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;政治、思想、组织、作风、纪律建设，把制度建设贯穿其中，深入推进反腐败斗争\n\n**目标**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;始终走在时代前列、人民衷心拥护、勇于自我革命、经得起各种风浪考验、朝气蓬勃的马克思主义执政党\n\n## <center>3、全面从严治党永远在路上</center>\n\n**加强党的政治建设**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;重要性\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;地位：政治建设摆在首位\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;（1）旗帜鲜明讲政治——马克思主义政党根本要求\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;（2）党的根本性建设\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;（3）政治建设为统领\n\n基本内容\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（1）首要任务：保证全党服从中央，坚持党中央权威和集中统一领导\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（2）政治方向：远大理想，共同理想，两个“百年目标”等\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（3）政治立场：马克思主义立场、党性立场和人民立场\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（4）政治生态：政治生活（增强“四个性”、反对不良作风）\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（5）政治担当：对党忠诚、为党分忧、为党尽职、为民造福\n\n**加强党的思想建设**\n\n重要性\n\n&ensp;&ensp;&ensp;&ensp;&ensp;地位：党的基础性建设\n\n基本内容\n\n&ensp;&ensp;&ensp;&ensp;&ensp;首要任务：坚定理想信念\n\n&ensp;&ensp;&ensp;&ensp;&ensp;含义：真理信仰、远大理想、共同理想\n\n&ensp;&ensp;&ensp;&ensp;&ensp;地位：共产党人精神上的“钙”；精神支柱和政治灵魂\n\n&ensp;&ensp;&ensp;&ensp;&ensp;要求：解决好世界观、人生观、价值观这个“总开关”问题\n\n**加强组织建设**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;含义\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;新时代党的组织路线:全面贯彻“习思想”，组织体系建设(重点)，培养忠诚干净担当的高素质干部，坚持德才兼备、以德为先、任人唯贤\n\n&ensp;&ensp;&ensp;&ensp;&ensp;贯彻\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;基层党组织建设：提升组织力为重点，突出政治功能原因:战斗堡垒)\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;关键：建设高素质干部队伍。坚持选人原则，好干部标准、培养四铁干部\n\n**加强作风建设**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;核心\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;保持党同人民群众的血肉联系\n\n&ensp;&ensp;&ensp;&ensp;&ensp;最大政治优势\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;密切联系群众\n\n&ensp;&ensp;&ensp;&ensp;&ensp;反对形式主义、官僚主义、享乐主义和奢靡之风\n\n&ensp;&ensp;&ensp;&ensp;&ensp;主题教育\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;永恒课题、终身课题：“不忘初心，牢记使命”——初心和使命：为人民谋幸福，为民族谋复兴\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;对象：县处级以上领导干部\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;总要求：守初心、担使命，找差距、抓落实\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;根本任务:深入学习贯彻习近平新时代中国特色社会主义思想、锤炼忠诚干净担当的政治品格、团结带领全国各族人民为实现伟大梦想共同奋斗\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;具体目标:理论学习有收获、思想政治受洗礼、干事创业敢担当、为民服务解难题、清正廉洁作表率\n\n**加强纪律建设**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;重要性：全面从严治党的治本之策\n\n&ensp;&ensp;&ensp;&ensp;&ensp;要求：纪严于法、纪在法前\n\n&ensp;&ensp;&ensp;&ensp;&ensp;内容\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;首要：严格遵守党章（党的根本大法）\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;最根本、最重要：政治纪律——“两个维护”（首要政治纪律）\n\n**加强制度建设**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;地位：重要制度保障，是全面从严治党的长远之策、根本之策\n\n&ensp;&ensp;&ensp;&ensp;&ensp;要求\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;健全监督体系\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;增强严肃性、协同性、有效性\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;形成决策科学、执行坚决、监督有力的权力运行机制\n\n&ensp;&ensp;&ensp;&ensp;&ensp;措施\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;健全党和国家监督制度\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;完善权力配置和运行制约机制\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;构建一体推进不敢腐、不能腐、不想腐机制\n\n**巩固发展反腐败斗争**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;压倒性胜利\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;“打虎” “拍蝇” “猎狐”\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;不敢腐的目标初步实现\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;不能腐的笼子越扎越牢\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;不想腐的堤坝正在构筑\n\n深度推进\n\n&ensp;&ensp;&ensp;&ensp;&ensp;原因：腐败是我们党面临的最大威胁\n\n&ensp;&ensp;&ensp;&ensp;&ensp;坚持无禁区、全覆盖、零容忍\n\n&ensp;&ensp;&ensp;&ensp;&ensp;坚持重遏制、强高压、长震慑\n\n&ensp;&ensp;&ensp;&ensp;&ensp;有力削减存量、有效遏制增量\n","tags":["政治"],"categories":["升学"]},{"title":"第十章 “五位一体”总体布局","url":"/post/a8259cf6.html","content":"\n# <center>第一节 实现经济高质量发展</center>\n\n高质量发展是经济发展的主题\n\n## <center>1、坚持习近平经济思想</center>\n\n坚持加强党对经济工作的集中统一领导\n\n&ensp;&ensp;&ensp;&ensp;&ensp;经济工作是党治国理政的中心工作\n\n坚持人民为中心的发展思想\n\n&ensp;&ensp;&ensp;&ensp;&ensp;把人民对美好生活的向往明确为党的奋斗目标\n\n坚持适应把握引领经济发展新常态\n\n&ensp;&ensp;&ensp;&ensp;&ensp;三期叠加：增长速度换挡期、结构调整阵痛期、前期刺激政策消化期\n\n坚持市场在资源的配置中起决定作用\n\n&ensp;&ensp;&ensp;&ensp;&ensp;经济体制改革关键：处理好政府和市场关系\n\n坚持适应我国经济发展主要矛盾变化完善宏观调控\n\n&ensp;&ensp;&ensp;&ensp;&ensp;现阶段我国经济发展主要矛盾已转化成结构性问题\n\n坚持问题导向部署经济发展新战略\n\n&ensp;&ensp;&ensp;&ensp;&ensp;京津翼协同发展、长江经济带发展战略、一带一路建设等\n\n## <center>2、深化供给侧结构性改革</center>\n\n供给侧结构性改革作为经济发展的主线\n\n供给侧结构性改革的必要性\n\n&ensp;&ensp;&ensp;&ensp;&ensp;八字方针：巩固、增强、提升、畅通\n\n供给侧结构性改革的主要任务\n\n&ensp;&ensp;&ensp;&ensp;&ensp;坚持质量第一、效益优先，以供给侧结构性改革为主线，推动经济发展质量变革、效率变革、动力变革，提高全要素生产率\n\n&ensp;&ensp;&ensp;&ensp;&ensp;第一，推进增长动能转换，以加快发展先进制造业为重点全面提升实体经济\n\n&ensp;&ensp;&ensp;&ensp;&ensp;第二，深化要素市场化配置改革，实现由以价取胜向以质取胜的转变\n\n&ensp;&ensp;&ensp;&ensp;&ensp;第三，加大人力资本培育力度，更加注重调动和保护人的积极性\n\n&ensp;&ensp;&ensp;&ensp;&ensp;第四，持续推进“三去一降一补”，优化市场供求结构。坚持“去产能、去库存、去杠杆、降成本、补短板\"，优化存量资源配置，扩大优质增量供给\n\n&ensp;&ensp;&ensp;&ensp;&ensp;第五，激发各类市场主体活力，加快建设世界一流企业。毫不动摇巩固和发展公有制经济，毫不动摇鼓励、支持、引导非公有制经济发展\n\n## <center>3、建设现代化经济体系的主要任务</center>\n\n我国经济已由高速增长阶段转向高质量发展阶段，正处于转变发展方式、优化经济结构、转换增长动力的攻关期\n\n必要性\n\n&ensp;&ensp;&ensp;&ensp;&ensp;既是重大理论命题，也是重大实践课题\n\n&ensp;&ensp;&ensp;&ensp;&ensp;我国发展的战略目标，也是三大攻关期的迫切要求\n\n内涵\n\n&ensp;&ensp;&ensp;&ensp;&ensp;建设创新引领、协同发展的产业体系\n\n&ensp;&ensp;&ensp;&ensp;&ensp;建设统一开放、竞争有序的市场体系\n\n&ensp;&ensp;&ensp;&ensp;&ensp;建设体现效率、促进公平的收入分配体系\n\n&ensp;&ensp;&ensp;&ensp;&ensp;建设彰显优势、协调联动的城乡区域发展体系\n\n&ensp;&ensp;&ensp;&ensp;&ensp;建设资源节约、环境友好的绿色发展体系\n\n&ensp;&ensp;&ensp;&ensp;&ensp;建设多元平衡、安全高效的全面开放体系\n\n举措\n\n&ensp;&ensp;&ensp;&ensp;&ensp;第一，大力发展实体经济\n\n&ensp;&ensp;&ensp;&ensp;&ensp;第二，加快实施创新驱动发展战略\n\n&ensp;&ensp;&ensp;&ensp;&ensp;第三，激发各类市场主体活力\n\n&ensp;&ensp;&ensp;&ensp;&ensp;第四，积极推动城乡区域协调发展\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;乡村振兴是“三农”问题的总抓手\n\n&ensp;&ensp;&ensp;&ensp;&ensp;第五，着力发展开放型经济\n\n&ensp;&ensp;&ensp;&ensp;&ensp;第六，加快完善社会主义市场经济体制\n\n# <center>第二节 发展社会主义民主政治</center>\n\n## <center>1、坚持中国特色社会主义政治发展道路</center>\n\n中国特色社会主义政治发展道路是近代以来中国人民长期奋斗历史逻辑、理论逻辑、实践逻辑的必然结果，是坚持党的本质属性、践行党的根本宗旨的必然要求\n\n走中国特色社会主义政治发展道路，必须坚持党的领导、人民当家作主、依法治国有机统一\n\n&ensp;&ensp;&ensp;&ensp;&ensp;党的领导（根本保证）+ 人民当家作主（本质特征）+ 依法治国（基本方式）\n\n走中国特色社会主义政治发展道路，必须坚持正确政治方向\n\n走中国特色社会主义政治发展道路，必须积极稳妥推进政治体制改革\n\n## <center>2、健全人民当家作主制度体系</center>\n\n坚持人民民主专政（国体）\n\n我国根本政治制度（政体）：人民代表大会制度\n\n关系：国体决定政体，政体体现国体\n\n我国社会主义民主政治特有形式和独特优势：协商民主\n\n基本政治制度\n\n&ensp;&ensp;&ensp;&ensp;&ensp;中国共产党领导的多党合作和政治协商制度\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;中国共产党是执政党，各民族党派是参政党\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;中国共产党与各民主党派的基本方针\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;中国人民政治协商会议\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;性质：社会主义协商民主的重要渠道和专门协商机构\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;主题：团结和民主\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;职能：政治协商、民主监督、参政议政\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;议事原则：民主协商\n\n&ensp;&ensp;&ensp;&ensp;&ensp;民族区域自治制度\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;含义：统一的国家领导下，在各少数民族聚居的地方设立自治机关行使自治权，实行区域自治\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;原因：由我国的历史特点和现实情况决定\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;核心：保障少数民族当家作主，管理本民族、本地方事务的权利\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;处理民族关系的基本原则：民族平等、民族团结、各民族共同繁荣(民族工作的出发点和归宿)\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;社会主义新型民族关系：平等，团结，互助，和谐\n\n&ensp;&ensp;&ensp;&ensp;&ensp;基层群众自治制度\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;地位：社会主义民主政治建设的基础\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;形式：村民委员会、居民委员会、职工代表大会\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;内容：自我管理、自我服务、自我教育、自我监督\n\n## <center>3、巩固和发展最广泛的爱国统一战线</center>\n\n**含义**：全体社会主义劳动者、社会主义事业的建设者、拥护社会主义的爱国者、拥护祖国统一和致力于中华民族伟大复兴的爱国者\n\n**要求**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;本质要求是大团结大联合\n\n&ensp;&ensp;&ensp;&ensp;&ensp;中华民族共同体意识（民族工作主线）\n\n&ensp;&ensp;&ensp;&ensp;&ensp;构建亲清新型政商关系\n\n&ensp;&ensp;&ensp;&ensp;&ensp;坚持独立自主自办的原则，引导宗教与社会主义社会相适应\n\n**做法**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;坚持长期共存、互相监督、肝胆相照、荣辱与共，支持民主党派参政\n\n&ensp;&ensp;&ensp;&ensp;&ensp;深化民族团结进步教育，铸牢中华民族共同体意识\n\n&ensp;&ensp;&ensp;&ensp;&ensp;贯彻党的宗教工作基本方针，坚持我国宗教的中国化，积极引导宗教与社会主义社会相适应。\n\n&ensp;&ensp;&ensp;&ensp;&ensp;牢牢把握大团结大联合的主题，做好统战工作\n\n# <center>第三节 推动社会文化繁荣复兴</center>\n\n## <center>1、坚持马克思主义在意识形态领域指导地位的根本制度</center>\n\n意识形态决定文化的性质和方向，是文化的核心和灵魂，对一个政党、一个国家、一个民族的生存发展至关重要\n\n意识形态关乎旗帜，关乎道路，关乎国家政治安全\n\n&ensp;&ensp;&ensp;&ensp;&ensp;把马克思主义指导地位贯穿到文化建设各方面\n\n&ensp;&ensp;&ensp;&ensp;&ensp;加强和改进学校思想政治教育\n\n&ensp;&ensp;&ensp;&ensp;&ensp;落实意识形态工作责任制\n\n## <center>2、培育和践行社会主义核心价值观</center>\n\n**含义**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;核心价值观是一个民族赖以维系的精神纽带，是一个国家共同的思想道德基础\n\n**重要性**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;历史与现实表明，核心价值观是国家重要的稳定器，关系社会和谐稳定，关系国家长治久安\n\n**社会主义核心价值观**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（国家层面）富强、民主、文明、和谐\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（社会层面）自由、平等、公正、法治\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（公民层面）爱国、敬业、诚信、友善\n\n**社会主义核心价值体系**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;马克思主义指导思想【灵魂】\n\n&ensp;&ensp;&ensp;&ensp;&ensp;中国特色社会主义共同理想【主题】\n\n&ensp;&ensp;&ensp;&ensp;&ensp;以爱国主义为核心的民族精神和以改革创新为核心的时代精神【精髓】\n\n&ensp;&ensp;&ensp;&ensp;&ensp;社会主义荣辱观【基础】\n\n**关系**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;社会主义核心价值观是社会主义核心价值体系的内核凝练和集中表达\n\n**培育和践行社会主义核心价值观**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;要把社会主义核心价值观融入社会生活各个方面\n\n&ensp;&ensp;&ensp;&ensp;&ensp;要坚持全民行动、干部带头，从家庭做起、从娃娃抓起\n\n&ensp;&ensp;&ensp;&ensp;&ensp;必须立足中华优秀传统文化和革命文化\n\n&ensp;&ensp;&ensp;&ensp;&ensp;必须发扬伟大的民族精神\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（即伟大创造精神、伟大奋斗精神、伟大团结精神和伟大梦想精神）\n\n## <center>3、坚定文化自信，繁荣发展社会主义文化</center>\n\n建设社会主义文化强国的重要性\n\n&ensp;&ensp;&ensp;&ensp;&ensp;文化是一个国家、一个民族的灵魂，是人民的精神家园，也是政党的精神旗帜\n\n含义\n\n&ensp;&ensp;&ensp;&ensp;&ensp;文化强国是指一个国家具有较强大的文化力量\n\n&ensp;&ensp;&ensp;&ensp;&ensp;这种力量既表现为具有高度文化素养的国民，也表现为发达的文化产业，还表现为强大的文化软实力\n\n如何建设文化强国\n\n&ensp;&ensp;&ensp;&ensp;&ensp;必须培养高度的文化自信\n\n&ensp;&ensp;&ensp;&ensp;&ensp;提升公共文化服务水平\n\n&ensp;&ensp;&ensp;&ensp;&ensp;健全现代文化产业体系\n\n&ensp;&ensp;&ensp;&ensp;&ensp;必须提高国家文化软实力。首先要努力弘扬中华文化，其次要讲好中国故事，最后要加强当代中国价值观念的提炼与阐释\n\n# <center>第四节 坚持在发展中保障和改善民生</center>\n\n## <center>1、在发展中保障和改善民生</center>\n\n民生是人民幸福之基、社会和谐之本\n\n在发展经济的基础上不断提高人民生活水平，实现人民群众对美好生活的向往，是党和国家一切工作的根本目的\n\n我们的发展是以人民为中心的发展，始终坚持发展为了人民、发展依靠人民、发展成果由人民共享\n\n检验我们一切工作的成效，最终要看人民是否真正得到实惠，人民生活是否得到真正改善\n\n要求\n\n&ensp;&ensp;&ensp;&ensp;&ensp;要把握好发展经济与改善民生的关系。经济发展是改善民生的前提，要紧紧抓住经济建设这个中心。同时，抓民生就是在抓发展\n\n&ensp;&ensp;&ensp;&ensp;&ensp;改善民生要坚持尽力而为与量力而行的统一\n\n1、建设高质量教育体系\n\n&ensp;&ensp;&ensp;&ensp;&ensp;百年大计、教育为本。建设教育强国是民族复兴的基础工程\n\n&ensp;&ensp;&ensp;&ensp;&ensp;落实立德树人的根本任务，培养德智体美劳全面发展的社会主义建设者和接班人\n\n2、实施就业优先战略\n\n&ensp;&ensp;&ensp;&ensp;&ensp;就业是人民生存的经济基础和基本保障，是最大的民生工程，民心工程，根基工程\n\n3、优化收入分配结构\n\n&ensp;&ensp;&ensp;&ensp;&ensp;收入分配是民生之源，是改善民生，实现发展成果由人民共享最重要最直接的方式\n\n&ensp;&ensp;&ensp;&ensp;&ensp;保护合法收入、增加低收入者收入、扩大中等收入、调节过高收入、清理规范、隐性收入、取缔非法收入，形成橄榄型分配格局\n\n4、健全多层次社会保障体系\n\n&ensp;&ensp;&ensp;&ensp;&ensp;社会保障发挥着社会稳定器作用\n\n&ensp;&ensp;&ensp;&ensp;&ensp;社会保障制度：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;社会保险（基本纲领）\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;社会福利（最高层次）\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;社会救济（最低层次）\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;社会优抚与安置（有特定对象）\n\n5、全面推进健康中国建设\n\n&ensp;&ensp;&ensp;&ensp;&ensp;人民健康是国家富强和民族昌盛的重要标志\n\n## <center>2、加强和创新社会治理</center>\n\n含义\n\n&ensp;&ensp;&ensp;&ensp;&ensp;社会治理是社会建设的重大任务，是国家治理的重要内容，社会治理地位日益重要\n\n如何加强和创新社会治理\n\n&ensp;&ensp;&ensp;&ensp;&ensp;1、创新社会治理体系\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;坚持完善党委领导、政府负责、社会协同、公众参与、法治保障的社会治理体制\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;提高社会治理社会化、法治化、智能化、专业化水平，推进社会治理精细化\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;打造共建共治共享的社会治理格局\n\n&ensp;&ensp;&ensp;&ensp;&ensp;2、完善正确处理新形势下人民内部矛盾有效机制\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;新时代枫桥经验\n\n&ensp;&ensp;&ensp;&ensp;&ensp;3、完善社会治安防控体系\n\n&ensp;&ensp;&ensp;&ensp;&ensp;4、加强社会心理服务体系建设\n\n&ensp;&ensp;&ensp;&ensp;&ensp;5、构建基层社会治理新格局\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;城乡社区是党和政府联系群众的“最后一公里”\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;社会治理的重心向基层下移，落实到城乡社区\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;健全党组织领导的自治、法治、德治相结合的城乡基层治理体系\n\n# <center>第五节 建设美丽中国</center>\n\n## <center>1、坚持习近平生态文明思想</center>\n\n生态文明理念：尊重自然（首要态度）、顺应自然（基本原则）、保护自然（重要责任）\n\n国策：坚持节约资源和保护环境\n\n第一，坚持人与自然和谐共生（生态文明的核心）\n\n&ensp;&ensp;&ensp;&ensp;&ensp;方针：节约优先、保护优先、自然恢复为主\n\n第二，绿水青山就是金山银山（理念）\n\n&ensp;&ensp;&ensp;&ensp;&ensp;三条红线：生态保护红线、环境质量底线、资源利用上线\n\n&ensp;&ensp;&ensp;&ensp;&ensp;三条控制线：生态保护红线、永久基本农田、城镇开发边界\n\n第三，良好生态环境是最普惠的民生福祉\n\n第四，统筹山水林田湖草沙系统治理\n\n第五，用最严格制度最严密法治保护生态环境\n\n第六，共谋全球生态文明建设\n\n## <center>2、推动绿色发展，促进人与自然和谐共生</center>\n\n建设生态文明是关系人民福祉、关乎中华民族永续发展的千年大计，是实现中华民族伟大复兴的重要战略任务\n\n建设人与自然和谐共生的现代化，建设美丽中国，必须坚定不移的走生产发展、生活富裕、生态良好的文明发展道路\n&ensp;&ensp;&ensp;&ensp;&ensp;加快构建生态文明体系\n\n&ensp;&ensp;&ensp;&ensp;&ensp;全面推动绿色转型\n\n&ensp;&ensp;&ensp;&ensp;&ensp;深入推进生态文明体制改革\n\n&ensp;&ensp;&ensp;&ensp;&ensp;有效防范生态环境风险\n\n&ensp;&ensp;&ensp;&ensp;&ensp;提高环境治理水平\n","tags":["政治"],"categories":["升学"]},{"title":"第九章 坚持和发展中国特色社会主义的总任务","url":"/post/2d17b932.html","content":"\n# <center>第一节 实现中华民族伟大复兴的中国梦</center>\n\n## <center>1、中华民族近代以来最伟大的梦想</center>\n\n**坚持和发展中国特色社会主义的总任务**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;实现社会主义现代化和中华民族伟大复兴，在全面建成小康社会的基础上，分两步走在本世纪中叶建成富强民主文明和谐美丽的社会主义现代化强国\n\n&ensp;&ensp;&ensp;&ensp;&ensp;中国梦是中华民族伟大复兴的形象表达\n\n&ensp;&ensp;&ensp;&ensp;&ensp;2012年11月(中国梦提出时间)，习近平参观复兴之路的展览\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;中华民族的昨天，“雄关漫道真如铁”\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;中华民族的今天，“人间正道是沧桑”\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;中华民族的明天，“长风破浪会有时”\n\n&ensp;&ensp;&ensp;&ensp;&ensp;**永恒课题**：不忘初心，牢记使命\n\n&ensp;&ensp;&ensp;&ensp;&ensp;中国共产党的初心使命\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;为中华人民谋幸福、为中华民族谋复兴\n\n&ensp;&ensp;&ensp;&ensp;&ensp;**主题**：实现中华民族伟大复兴\n\n## <center>2、中国梦的科学内涵</center>\n\n**中国梦的本质**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;国家富强、民族振兴、人民幸福<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271746417.png\" alt=\"中国梦的本质关系\" style=\"zoom:33%;\" />\n\n&ensp;&ensp;&ensp;&ensp;&ensp;国家富强，是指我国综合国力进一步增强，中国特色社会主义事业进一步发展和完善\n\n&ensp;&ensp;&ensp;&ensp;&ensp;民族振兴，就是通过自身的不断发展与强大，继承并创造中华民族的优秀文化以及先进的文明成果，进而使中华民族再次处于世界领先的地位，再次以高昂的姿态屹立于世界民族之林\n\n&ensp;&ensp;&ensp;&ensp;&ensp;人民幸福，就是人民权利保障更加充分、人人得享共同发展，生活在伟大祖国和伟大时代的中国人民，共同享有人生出彩的机会，共同享有梦想成真的机会，共同享有同祖国和时代一起成长与进步的机会\n\n**中国梦的特点**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;中国梦是国家情怀、民族情怀、人民情怀相统一的梦\n\n&ensp;&ensp;&ensp;&ensp;&ensp;中国梦归根到底是人民的梦\n\n&ensp;&ensp;&ensp;&ensp;&ensp;中国梦是国家的梦、民族的梦，也是每一个中国人的梦\n\n&ensp;&ensp;&ensp;&ensp;&ensp;中国梦是和平、发展、合作、共赢的梦，与世界各国人民的美好梦想息息相通\n\n## <center>3、奋力实现中国梦</center>\n\n三个“必须”四个“实现”\n\n&ensp;&ensp;&ensp;&ensp;&ensp;必须走中国道路，这就是中国特色社会主义道路\t\t必由之路\n\n&ensp;&ensp;&ensp;&ensp;&ensp;必须弘扬中国精神，这就是以爱国主义为核心的民族精神和以改革创新为核心的时代精神\n\n&ensp;&ensp;&ensp;&ensp;&ensp;必须凝聚中国力量，这就是全国各族人民大团结的力量\n\n&ensp;&ensp;&ensp;&ensp;&ensp;实现中华民族伟大复兴是海内外中华儿女的共同梦想\n\n&ensp;&ensp;&ensp;&ensp;&ensp;实干才能梦想成真。实现中华民族伟大复兴，是一项光荣而艰巨的事业，需要每一个人付出艰苦努力，用实干托起中国梦\n\n&ensp;&ensp;&ensp;&ensp;&ensp;实现中国梦任重而道远，需要锲而不舍、驰而不息的艰苦努力\n\n&ensp;&ensp;&ensp;&ensp;&ensp;实现中国梦需要和平，只有和平才能实现梦想\n\n# <center>第二节 建成社会主义现代化强国的战略安排</center>\n\n## <center>1、开启全面建设社会主义现代化强国的战略安排</center>\n\n两个一百年\n\n&ensp;&ensp;&ensp;&ensp;&ensp;建党一百年\t1921-2020\t\t全面建成小康社会\n\n&ensp;&ensp;&ensp;&ensp;&ensp;建国一百年\t1949-本世纪中叶\t\t建成富强民主文明和谐美丽的社会主义现代化强国\n\n两步走\n\n&ensp;&ensp;&ensp;&ensp;&ensp;2020\t\t\t\t   \t2035\t\t\t\t\t\t本世纪中叶\n\n&ensp;&ensp;&ensp;&ensp;&ensp;全面建成小康社会\t  \t  基本实现社会主义现代化国家\t建成社会主义现代化强国\n\n&ensp;&ensp;&ensp;&ensp;&ensp;进入创新型国家行列\t\t跻身于创新型国家前列\n\n&ensp;&ensp;&ensp;&ensp;&ensp;军队基本机械化\t\t\t军队基本现代化\t\t\t\t世界一流军队\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;共同富裕取得实质性进展\t\t共同富裕基本实现\n\n## <center>2、实现社会主义现代化强国“两步走”战略的目标要求</center>\n\n从2020到2035年，基本实现社会主义现代化的目标\n\n&ensp;&ensp;&ensp;&ensp;&ensp;经济建设方面：我国经济实力、科技实力将大幅跃升，跻身创新型国家前列\n\n&ensp;&ensp;&ensp;&ensp;&ensp;政治建设方面：人民平等参与、平等发展权利得到充分保障，法治国家、法治政府、法治社会基本建成，各方面制度更加完善，国家治理体系和治理能力现代化基本实现\n\n&ensp;&ensp;&ensp;&ensp;&ensp;文化建设方面：社会文明程度达到新的高度，国家文化软实力显著增强，中华文化影响更加广泛深入\n\n&ensp;&ensp;&ensp;&ensp;&ensp;社会建设方面：人民生活更为宽裕，中等收入 群体比例明显提高，城乡区域发展差距和居民生活水平差距显著缩小，基本公共服务均等化基本实现，全体人民共同富裕迈出坚实步伐\n\n&ensp;&ensp;&ensp;&ensp;&ensp;生态文明建设方面：生态环境根本好转，美丽中国目标基本实现。清洁低碳、安全高效的能源体系和绿色低碳循环发展的经济体系基本建立，生态文明制度更加健全\n\n&ensp;&ensp;&ensp;&ensp;&ensp;对外开放方面：形成对外开放新格局，参与国际经济合作和竞争新优势明显增强\n\n&ensp;&ensp;&ensp;&ensp;&ensp;国防建设方面:平安中国建设达到更高水平，基本实现国防和军队现代化\n\n从2035到本世纪中叶，建成社会主义现代化强国的目标要求\n\n&ensp;&ensp;&ensp;&ensp;&ensp;我国将拥有高度的物质文明，社会生产力水平大幅提高，核心竞争力名列世界前茅，经济总量和市场规模超越其他国家，建成富强的社会主义现代化强国\n\n&ensp;&ensp;&ensp;&ensp;&ensp;我国将拥有高度的政治文明，形成又有集中又有民主、又有纪律又有自由、又有统一意志又有个人心情舒畅生动活泼的政治局面，依法治国和以德治国有机结合，建成民主的社会主义现代化强国\n\n&ensp;&ensp;&ensp;&ensp;&ensp;我国将拥有高度的精神文明，践行社会主义核心价值观成为全社会自觉行动，国民素质显著提高，中国精神、中国价值、中国力量成为中国发展的重要影响力和推动力，建成文明的社会主义现代化强国\n\n&ensp;&ensp;&ensp;&ensp;&ensp;我国将拥有高度的社会文明，城乡居民将普遍拥有较高的收入、富裕的生活、健全的基本公共服务，享有更加幸福安康的生活，全体人民共同富裕基本实现，公平正义普遍彰显，社会充满活力而又规范有序，建成和谐的社会主义现代化强国\n\n&ensp;&ensp;&ensp;&ensp;&ensp;我国将拥有高度的生态文明，天蓝、地绿、水清的优美生态环境成为普遍常态，开创人与自然和谐共生新境界，建成美丽的社会主义现代化强国\n\n# <center>第三节 建设社会主义现代化国家的战略导向</center>\n\n## <center>1、立足新发展阶段</center>\n\n理论依据：社会主义本身是共产主义的初级阶段，中国又处在社会主义的初级阶段，新发展阶段是社会主义初级阶段中的一个阶段\n\n历史依据：新发展阶段是我们党带领人民迎来从站起来、富起来到强起来的历史性跨越的新阶段\n\n现实依据：我们已经拥有开启新征程、实现新的更高目标的雄厚物质基础\n\n## <center>2、贯彻新发展理念</center>\n\n提出时间：党的十八届五中全会\n\n口诀：创协绿开共\n\n五大发展理念\n\n|                **创新**（引领发展的第一动力）                |   解决发展动力问题   |\n| :----------------------------------------------------------: | :------------------: |\n|              **协调**（持续健康发展的内在要求）              |  解决发展不平衡问题  |\n| **&ensp;&ensp;&ensp;&ensp;&ensp;绿色**（永续发展的必要条件） | 解决人与自然和谐问题 |\n|                开放（国家繁荣发展的必由之路）                | 解决发展内外联动问题 |\n|            **共享**（中国特色社会主义的本质要求）            | 解决社会公平正义问题 |\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;必须坚持全民共享、全面共享、共建共享、渐进共享\n\n如何贯彻\n\n&ensp;&ensp;&ensp;&ensp;&ensp;从根本宗旨把握新发展理念\n\n&ensp;&ensp;&ensp;&ensp;&ensp;从问题导向把握新发展理念\n\n&ensp;&ensp;&ensp;&ensp;&ensp;从忧患意识把握新发展理念\n\n## <center>3、构建新发展格局</center>\n\n国内大循环为主体，国内国际双循环相互促进\n\n一、从发展进程看:融入国际大循环，市场、资源”两头“在外\n\n二、从世界比较看：大国经济特征以内需为主导、内部可循环\n\n三、从国际形势看:全球政治经济环境发生深刻变化，逆全球化趋势加剧\n\n## <center>4、立足新发展阶段、贯彻新发展理念、构建新发展格局关系</center>\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271746749.png\" alt=\"三大关系\" style=\"zoom: 50%;\" />\n\n&ensp;&ensp;&ensp;&ensp;&ensp;进入新发展阶段、贯彻新发展理念、构建新发展格局，是由我国经济社会发展的理论逻辑、历史逻辑、现实逻辑决定的，三者紧密关联。\n\n&ensp;&ensp;&ensp;&ensp;&ensp;进入新发展阶段明确了我国发展的历史方位，贯彻新发展理念明确了我国现代化建设的指导原则，构建新发展格局明确了我国经济现代化的路径选择。\n\n&ensp;&ensp;&ensp;&ensp;&ensp;把握新发展阶段是贯彻新发展理念、构建新发展格局的现实依据，贯彻新发展理念为把握新发展阶段、构建新发展格局提供了行动指南，构建新发展格局则是应对新发展阶段机遇和挑战、贯彻新发展理念的战略选择\n","tags":["政治"],"categories":["升学"]},{"title":"第八章 习近平新时代中国特色社会主义思想及其历史地位","url":"/post/57da986d.html","content":"\n# <center>第一节 新思想创立的社会历史条件</center>\n\n## <center>1、中国特色社会主义进入新时代</center>\n\n**历史性成就和历史性变革**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;历史性成就\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第一，经济建设取得重大成就。\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第二，全面深化改革取得重大突破。\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第三，民主法治建设迈出重大步伐。\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第四，思想文化建设取得重大进展。\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第五，人民生活不断改善。\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第六，生态文明建设成效显著。\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第七，强军兴军开创新局面。\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第八，港澳台工作取得新进展。\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第九，全方位外交布局深入展开。\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第十，全面从严治党成效卓著。\n\n&ensp;&ensp;&ensp;&ensp;&ensp;历史性变革\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第一，党的领导得到全面加强，党的领导被忽视、淡化、削弱的状况得到明显改变\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第二，坚定不移贯彻新发展理念，发展观念不正确、发展方式粗放的状况得到明显改变\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第三，坚定不移全面深化改革，各方面体制机制弊端阻碍发展活力和社会活力的状况得到明显改变\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第四，坚定不移全面推进依法治国，有法不依、执法不严、司法不公问题严重的状况得到明显改变\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第五，加强党对意识形态工作的领导，社会思想舆论环境的混乱状况得到明显改变\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第六，坚定不移推进生态文明建设，忽视生态环境保护、生态环境恶化的状况得到明显改变\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第七，坚定不移推进国防和军队现代化，人民军队中一度存在的不良政治状况得到明显改变\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第八，坚定不移推进中国特色大国外交，我国在国际力量对比中面临的不利状况得到明显改变\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第九，坚定不移推进全面从严治党，管党治党宽松软状况得到明显改变\n\n**社会主要矛盾的最新变化**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;一变(社会主要矛盾)\n\n![社会主要矛盾一变](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271745563.png)\n\n&ensp;&ensp;&ensp;&ensp;&ensp;两不变\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;我国社会主要矛盾的变化，没有改变我们对我国社会主义所处历史阶段的判断，我国仍处于并将长期处于社会主义初级阶段的基本国情没有变，我国是世界最大发展中国家的国际地位没有变。\n\n**新时代的内涵和意义**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;内涵\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第一，这个新时代是承前启后、继往开来，在新的历史条件下继续夺取中国特色社会主义伟大胜利的时代\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第二，这个新时代是决胜全面建成小康社会、进而全面建设社会主义现代化强国的时代\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第三，这个新时代是全国各族人民团结奋斗、不断创造美好生活、逐步实现全体人民共同富裕的时代\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第四，这个新时代是全体中华儿女勠力同心、奋力实现中华民族伟大复兴中国梦的时代\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第五，这个新时代是我国日益走近世界舞台中央、不断为人类作出更大贡献的时代\n\n&ensp;&ensp;&ensp;&ensp;&ensp;意义\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第一，从中华民族复兴的历史进程看，中国特色社会主义进入新时代，意味着近代以来久经磨难的中华民族迎来了从站起来(1949)、富起来(1978)到强起来(2017)的伟大飞跃，迎来了实现中华民族伟大复兴的光明前景\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第二，从科学社会主义发展进程看，中国特色社会主义进入新时代，意味着科学社会主义在21世纪的中国焕发出强大生机活力，在世界上高高举起了中国特色社会主义伟大旗帜。\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第三，从人类文明进程看，中国特色社会主义进入新时代，意味着中国特色社会主义道路、理论、制度、文化不断发展，拓展了发展中国家走向现代化的途径，给世界上那些既希望加快发展又希望保持自身独立性的国家和民族提供了全新选择，为解决人类问题贡献了中国智慧和中国方案。\n\n## <center>2、世界正经历百年之未有大变局</center>\n\n&ensp;&ensp;&ensp;&ensp;&ensp;一是 世界经济版图发生的深刻变化前所未有，新兴经济体和发展中国家在世界经济中占据越来越大的份额，世界经济重心加快“自西向东”位移\n\n&ensp;&ensp;&ensp;&ensp;&ensp;二是 新一轮技革命和产业变革带来的新陈代谢和激烈竞争前所未有，深刻改变人类社会生产生活方式和思维方式，推动生产关系变革，给国际格局和国际体系带来广泛深远影响\n\n&ensp;&ensp;&ensp;&ensp;&ensp;三是 国际力量对比发生的革命性变化前所未有，发达国家内部矛盾重重、实力相对下降，大批发展中国家群体性崛起，成为影响国际政治经济格局的重要力量\n\n&ensp;&ensp;&ensp;&ensp;&ensp;四是 全球治理体系的不适应、不对称前所未有，西方发达国家主导的国际政治经济秩序越来越难以为继，发展中国家在国际事务中的代表性和发言权不断扩大，全球治理越来越向着更加公平合理的方向发展\n\n&ensp;&ensp;&ensp;&ensp;&ensp;五是 人类前途命运的休戚与共前所未有，各国相互联系和彼此依存比过去任何时候都更频繁、更紧密，整个世界日益成为你中有我、我中有你的人类命运共同体\n\n## <center>3、中华民族伟大复兴正处于关键时期</center>\n\n&ensp;&ensp;&ensp;&ensp;&ensp;我国社会生产力、综合国力、人民生活水平实现历史性跨越，经济实力、科技实力、国防实力进入世界前列\n\n&ensp;&ensp;&ensp;&ensp;&ensp;形势变化快、改革发展稳定任务重、矛盾风险挑战多，对党的治国理政考验之大前所未有。改革需要“涉深水”、“闯险滩”，防范化解\"黑天鹅\"、\"灰犀牛“等\n\n&ensp;&ensp;&ensp;&ensp;&ensp;中国共产党是实现中华民族伟大复兴的根本保证。面对“四大危险”、“四大考验”、坚定走在时代前列，空前力度推进全面从严治党，为建设坚强有力的马克思主义执政党，确保党长期执政和国家长治久安提供了根本保证。\n\n&ensp;&ensp;&ensp;&ensp;&ensp;中华优秀传统文化是中华民族的根和魂，是中国特色社会主义植根的沃土。重视优秀传统文化，不断推进中华优秀传统文化的创造性转化、创新性发展，以新的时代内涵增强其生命力，使之成为治国理政的重要思想文化资源。\n\n&ensp;&ensp;&ensp;&ensp;&ensp;习近平新时代中国特色社会主义思想，是党和人民实践经验和集体智慧的结晶，主要创立者是作为党中央的核心、全党核心的习近平同志\n\n# <center>第二节 习近平新时代中国特色社会主义思想的科学体系</center>\n\n## <center>1、习近平新时代中国特色社会主义思想的核心要义</center>\n\n坚持和发展中国特色社会主义是改革开放以来我们党全部理论和实践的鲜明主题，也是习近平新时代中国特色社会主义思想的核心要义。\n\n即新时代坚持和发展什么样的中国特色社会主义(十个明确)怎样坚持和发展中国特色社会主义(十四个坚持) \n\n习近平思想 十九大写进党章并确立为指导思想\t2018年载入宪法\n\n## <center>2、习近平新时代中国特色社会主义思想的主要内容</center>\n\n“十个明确”\t最重要、最核心的内容，起支撑作用的“四梁八柱”\t\t思想层面\n\n&ensp;&ensp;&ensp;&ensp;&ensp;第一，明确坚持和发展中国特色社会主义，总任务是实现社会主义现代化和中华民族伟大复兴，在全面建成小康社会的基础上，分两步走在本世纪中叶建成富强民主文明和谐美丽的社会主义现代化强国\n\n&ensp;&ensp;&ensp;&ensp;&ensp;第二，明确新时代我国社会主要矛盾是人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾，必须坚持以人民为中心的发展思想，不断促进人的全面发展、全体人民共同富裕\n\n发展思想中心\\==》人民\t\t工作中心==》经济建设\n\n&ensp;&ensp;&ensp;&ensp;&ensp;第三，明确中国特色社会主义事业总体布局是“五位一体”、战略布局是“四个全面”，强调坚定道路自信、理论自信、制度自信、文化自信(最重要)\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;四个全面：全面建设社会主义现代化国家、全面深化改革(车之两轮、鸟之两翼)、全面依法治国(车之两轮、鸟之两翼)、全面从严治党(根本保证)\t\t\t第一个是目标，剩下三个是战略举措\n\n&ensp;&ensp;&ensp;&ensp;&ensp;第四，明确全面深化改革(十八届三中全会)总目标是完善和发展中国特色社会主义制度、推进国家治理体系和治理能力现代化\n\n&ensp;&ensp;&ensp;&ensp;&ensp;第五，明确全面推进依法治国总目标(十八届四中全会)是建设中国特色社会主义法治体系(总抓手)、建设社会主义法治国家\n\n&ensp;&ensp;&ensp;&ensp;&ensp;第六，明确党在新时代的强军目标是建设一支听党指挥(灵魂)、能打胜仗(核心)、作风优良(保证)的人民军队，把人民军队建设成为世界一流军队\t\t世界一流军队唯一标准：核心战斗力\n\n&ensp;&ensp;&ensp;&ensp;&ensp;第七，明确必须坚持和完善社会主义基本经济制度\n\n&ensp;&ensp;&ensp;&ensp;&ensp;第八，明确中国特色大国外交要推动构建新型国际关系，推动构建人类命运共同体\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;新型国际关系：相互尊重、公平正义、合作共赢\n\n&ensp;&ensp;&ensp;&ensp;&ensp;第九，明确中国特色社会主义最本质的特征是中国共产党的领导，中国特色社会主义制度的最大优势是中国共产党的领导，党是最高政治领导力量，提出新时代党的建设总要求，突出政治建设(首位、统领、根本性)在党的建设中的重要地位\n\n&ensp;&ensp;&ensp;&ensp;&ensp;第十，明确全面从严治党的战略方针\n\n“十四个坚持”\t\t行动纲领\n\n|      1、坚持党对一切工作的领导      |          2、坚持以人民为中心          |\n| :---------------------------------: | :-----------------------------------: |\n|         3、坚持全面深化改革         |       4、坚持新发展理念（经济）       |\n|     5、坚持人民当家作主（政治）     |          6、坚持全面依法治国          |\n| 7、坚持社会主义核心价值体系（文化） | 8、坚持在发展中保障和改善民生（社会） |\n|   9、坚持人与自然和谐共生（生态）   |        10、坚持总体国家安全观         |\n|   11、坚持党对人民军队的绝对领导    |   12、坚持\"一国两制”和推进祖国统一    |\n|   13、坚持推动构建人类命运共同体    |         14、坚持全面从严治党          |\n\n## <center>3、习近平新时代中国特色社会主义思想的理论特质</center>\n\n这一思想秉持人民至上\n\n这一思想彰显历史自觉\n\n这一思想坚持实事求是\n\n这一思想突出问题导向\n\n这一思想强化战略思维\n\n这一思想发扬斗争精神\n\n# <center>第三节 习近平新时代中国特色社会主义思想的历史地位</center>\n\n当代马克思主义，21世纪马克思主义\n\n&ensp;&ensp;&ensp;&ensp;&ensp;习近平新时代中国特色社会主义思想与马克思列宁主义、毛泽东思想、邓小平理论、三个代表”重要思想、科学发展观既一脉相承又与时俱进，是马克思主义中国化的新飞跃，是当代中国马克思主义、21世纪马克思主义。具体包括一下三个方面：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1、开辟了马克思主义新境界 2、开辟了中国特色社会主义新境界 3、对人类文明进步具有重要意义\n\n&ensp;&ensp;&ensp;&ensp;&ensp;习近平新时代中国特色社会主义思想是开放的理论体系，是我们推进马克思主义中国化的新的起点，必将随着党和国家事业的发展而不断发展。\n\n实现中华民族伟大复兴的行动指南\n\n&ensp;&ensp;&ensp;&ensp;&ensp;1、是党和国家必须长期坚持的指导思想，是全党全国各族人民团结奋斗的共同思想基础，是决胜全面建成小康社会、建设社会主义现代化强国、实现中华民族伟大复兴中国梦的行动纲领。\n\n&ensp;&ensp;&ensp;&ensp;&ensp;2、是党的意志、国家意志和人民意志的集中体现，为新时代坚持和发展中国特色社会主义提供根本指引\n\n&ensp;&ensp;&ensp;&ensp;&ensp;3、为新时代治国理政提供了基本遵循\n\n&ensp;&ensp;&ensp;&ensp;&ensp;4、为全面从严治党、把党建设成为中国特色社会主义事业的坚强领导核心提供了强大思想武器\n\n建设美好世界的中国智慧和中国方案\n","tags":["政治"],"categories":["升学"]},{"title":"第七章 科学发展观","url":"/post/a0b1b02e.html","content":"\n# <center>第一节 科学发展观的形成</center>\n\n**科学发展观的形成条件**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;在深刻把握我国基本国情和新的阶段性特征的基础上形成和发展\t（现实依据）\n\n&ensp;&ensp;&ensp;&ensp;&ensp;在深入总结改革开放以来特别是党的十六大以来实践经验的基础上形成和发展的\t（实践基础）\n\n&ensp;&ensp;&ensp;&ensp;&ensp;世界大发展大变革大调整，在深刻分析国际形势、顺应世界发展趋势、借鉴国外发展经验的基础上形成和发展\t（时代背景）\n\n![科学发展观的形成](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271746576.png)\n\n十七大：写进党章\t十八大：确立为指导思想\t2018：载入宪法\n\n# <center>第二节 科学发展观的科学内涵和主要内容</center>\n\n**科学发展观的科学内涵**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;第一要义：发展\t发展是解决一切问题的关键(总钥匙)、第一要务\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;坚持科学发展观，必须加快转变经济的发展方式\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;主攻方向：经济结构战略性调整\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;重要支撑：科技进步、创新\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;出发点、落脚点：保障和改善民生\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;重要着力点：资源节约型、环境友好型社会\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;强大动力：改革开放\n\n&ensp;&ensp;&ensp;&ensp;&ensp;核心立场：以人为本\t\t出发点和落脚点\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;坚持以人为本，就要以最广大人民根本利益为本\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;坚持以人为本，就要坚持发展为了人民\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;坚持以人为本，就要坚持发展依靠人民\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;坚持以人为本，就要坚持发展成果由人民共享\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;坚持以人为本，最终为了实现人的全面发展\n\n&ensp;&ensp;&ensp;&ensp;&ensp;基本要求：全面协调可持续\t总体布局、各领域协调\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;全面性：发展全面性、整体性   协调：发展协调性、均衡性   可持续：发展持久性、连续性\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;经济建设是中心和基础\t政治建设是方向和保障\t文化建设是灵魂和血脉\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;社会建设是支撑和归宿\t生态文明建设是根基和条件\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;坚持全面发展，就是要按照中国特色社会主义事业总体布局，正确认识和把握经济建设、政治建设、文化建设、社会建设、生态文明建设是相互联系、相互促进的有机统一体。\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;坚持协调发展，就是保证中国特色社会主义各个领域协调推进。\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;坚持可持续发展，必须走生产发展、生活富裕、生态良好的文明发展道路，还必须建设生态文明。\n\n&ensp;&ensp;&ensp;&ensp;&ensp;根本方法：统筹兼顾\t\t科学发展根本途径\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;正确认识、处理中国特色社会主义事业中的重大关系\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;认真考虑和对待各方面的发展需要\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;掌握统筹兼顾思想方法\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;兼顾各方、综合平衡\n\n**科学发展观的主要内容**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;前五个“五位一体”\n\n&ensp;&ensp;&ensp;&ensp;&ensp;1、加快转变经济发展方式\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;主题：科学发展\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;主线：加快转变经济发展方式\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;关键：全面深化经济体制改革\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;主攻方向：经济结构战略性调整\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;解决三农问题根本途径：城乡一体化发展\t\t三农：农业、农村、农民\n\n&ensp;&ensp;&ensp;&ensp;&ensp;2、发展社会主义民主政治\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;本质和核心是人民当家作主\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;坚持社会主义政治制度\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;人民代表大会制度是根本政治制度\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;多党合作和政治协商制度、民族区域自治制度以及基层群众自治制度等是基本政治制度\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;坚持社会主义协商民主\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;坚持依法治国基本方略\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;依法治国前提:有法可依\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;依法治国关键：依法执政、依法行政、依法办事、公正司法\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;坚持政治体制改革\n\n3、推进社会主义文化强国建设\n\n&ensp;&ensp;&ensp;&ensp;&ensp;(1)建设社会主义文化强国\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;①道路：中国特色社会主义道路\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;②方向：为人民服务，为社会主义服务\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;③方针：百花齐放，百家争鸣\n\n&ensp;&ensp;&ensp;&ensp;&ensp;(2)倡导社会主义核心价值观\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;（国家）富强 民主 文明 和谐\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;（社会）自由平等公正 法治\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;（公民)爱国 敬业 诚信 友善\n\n&ensp;&ensp;&ensp;&ensp;&ensp;(3)社会主义核心价值体系\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;地位：兴国之魂\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;内容：马克思主义指导思想（灵魂）\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;中特社义共同理想（主题）\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;以爱国主义为核心的民族精神和以改革创新为核心的时代精神（精髓)\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;社会主义荣辱观（基础）\n\n4、构建社会主义和谐社会\n\n&ensp;&ensp;&ensp;&ensp;&ensp;定位：中国特色社会主义本质属性\n\n&ensp;&ensp;&ensp;&ensp;&ensp;内涵:五位一体协调发展，人与人、人与社会、人与自然整体和谐\n\n&ensp;&ensp;&ensp;&ensp;&ensp;总要求：民主法治、公平正义、诚信有爱、充满活力、安定有序、人与自然和谐相处\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;民族法治：构建社会主义和谐社会的重要保证\n\n&ensp;&ensp;&ensp;&ensp;&ensp;措施: “大社会着眼”、\"小社会着手\n\n&ensp;&ensp;&ensp;&ensp;&ensp;出发点和落脚点：以人为本\n\n5、推进生态文明建设\n\n&ensp;&ensp;&ensp;&ensp;&ensp;理念：尊重自然、顺应自然、保护自然\n\n&ensp;&ensp;&ensp;&ensp;&ensp;地位：放在突出地位\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;良好生态环境是人与社会持续发展的根本基础\n\n&ensp;&ensp;&ensp;&ensp;&ensp;国策：节约资源、保护环境\n\n&ensp;&ensp;&ensp;&ensp;&ensp;方针：节约优先、保护优先、自然恢复为主\n\n6、全面提高党的建设科学化水平\n\n&ensp;&ensp;&ensp;&ensp;&ensp;背景: \"四大危险”、\"四大考验\"\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;四大危险：精神懈怠危险、能力不足危险、脱离群众危险、消极腐败危险\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;四大考验：执政考验、改革开放考验、市场经济考验、外部环境考验\n\n&ensp;&ensp;&ensp;&ensp;&ensp;地位：执政能力建设是党执政后的一项根本建设\n\n&ensp;&ensp;&ensp;&ensp;&ensp;要求：科学执政、民主执政、依法执政\n\n&ensp;&ensp;&ensp;&ensp;&ensp;重要性：保持和发展党的先进性是马克思主义政党自身建设的根本任务和永恒课题\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;先进性是马克思主义政党的本质属性，是马克思主义政党的生命所系、力量所在\n\n# <center>第三节 科学发展观的历史地位</center>\n\n中国特色社会主义理论体系的接续发展\n\n&ensp;&ensp;&ensp;&ensp;&ensp;科学发展观最鲜明的精神实质是解放思想、实事求是、与时俱进、求真务实\n\n&ensp;&ensp;&ensp;&ensp;&ensp;科学发展观进一步回答了什么是社会主义、怎样建设社会主义和建设什么样的党、怎样建设党的问题\n\n&ensp;&ensp;&ensp;&ensp;&ensp;创造性地回答了新形势下实现什么样的发展、怎样发展等重大问题。\n\n全面建成小康社会、加快推进社会主义现代化的根本指针\n","tags":["政治"],"categories":["升学"]},{"title":"第六章 “三个代表”重要思想","url":"/post/72b1c7b1.html","content":"\n# <center>第一节“三个代表”重要思想的形成</center>\n\n**“三个代表” 重要思想的形成条件**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;在对冷战结束后国际局势科学判断的基础上形成的（世情）\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;时代主题：和平与发展\n\n&ensp;&ensp;&ensp;&ensp;&ensp;在科学判断党的历史方位和总结历史经验的基础上提出来的（党情）\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;进一步提高党的领导水平和执政水平、提高拒腐防变和抵御风险的能力，是我们党必须解决好的两大历史性课题\n\n&ensp;&ensp;&ensp;&ensp;&ensp;在建设中国特色社会主义伟大实践基础上形成的（国情）\n\n**“三个代表”重要思想的形成过程**\n\n![“三个代表”重要思想的形成过程](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271746695.png)\n\n&ensp;&ensp;&ensp;&ensp;&ensp;2004年写入宪法\n\n&ensp;&ensp;&ensp;&ensp;&ensp;十四大 系统论述了加强党的建设和改善党的领导问题\n\n&ensp;&ensp;&ensp;&ensp;&ensp;十四届三中全会 通过了《中共中央关于加强党的建设几个重大问题》分析了党的建设面临的形势\n\n&ensp;&ensp;&ensp;&ensp;&ensp;十五大 高度概括了新时期党的建设新的伟大工程目标\n\n&ensp;&ensp;&ensp;&ensp;&ensp;2000年 江泽民在广东省考察工作时 首次对“三个代表”比较全面的阐述\n\n贯彻“三个代表”重要思想\n\n&ensp;&ensp;&ensp;&ensp;&ensp;关键在于坚持与时俱进\n\n&ensp;&ensp;&ensp;&ensp;&ensp;核心在保持党的先进性\n\n&ensp;&ensp;&ensp;&ensp;&ensp;本质在坚持执政为民\n\n# <center>第二节“三个代表”重要思想的核心观点和主要内容</center>\n\n**“三个代表”重要思想的核心观点**\n\n1、始终代表中国先进生产力的发展要求\t（基础）\n\n&ensp;&ensp;&ensp;&ensp;&ensp;社会主义的根本任务是发展生产力\n\n&ensp;&ensp;&ensp;&ensp;&ensp;广大工人、农民、知识分子始终是推动我国生产力发展和社会全面进步的根本力量\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;改革开放和社会主义现代化建设事业发展关键因素：依靠知识分子推动科技、经济发展和社会进步\n\n&ensp;&ensp;&ensp;&ensp;&ensp;人才资源是第一资源\n\n&ensp;&ensp;&ensp;&ensp;&ensp;科学技术是第一生产力（先进生产力的集中体现和主要标志）\n\n&ensp;&ensp;&ensp;&ensp;&ensp;科学的本质是创新\n\n&ensp;&ensp;&ensp;&ensp;&ensp;生产力中最活跃的因素：人\n\n&ensp;&ensp;&ensp;&ensp;&ensp;保持先进性的根本体现和根本要求：大力促进先进生产力的发展\n\n2、始终代表中国先进文化的前进方向\n\n&ensp;&ensp;&ensp;&ensp;&ensp;把握先进文化的前进方向\n\n&ensp;&ensp;&ensp;&ensp;&ensp;建设社会主义精神文明\n\n&ensp;&ensp;&ensp;&ensp;&ensp;发展面向现代化、面向世界、面向未来的，民族的科学的大众的社会主义\n\n&ensp;&ensp;&ensp;&ensp;&ensp;必须弘扬民族精神\n\n&ensp;&ensp;&ensp;&ensp;&ensp;必须加强社会主义思想道德建设（先进文化的重要内容和中心环节）\n\n&ensp;&ensp;&ensp;&ensp;&ensp;必须做好思想政治工作（思想政治工作是经济工作和其他一切工作的生命线，是我们党和社会主义国家的重要政治优势）\n\n3、始终代表中国最广大人民的根本利益\t（根本）\n\n&ensp;&ensp;&ensp;&ensp;&ensp;人民是国家的主人（人民民主专政）\n\n&ensp;&ensp;&ensp;&ensp;&ensp;人民是决定国家前途和命运的根本力量\n\n&ensp;&ensp;&ensp;&ensp;&ensp;人民是历史的创造者\n\n&ensp;&ensp;&ensp;&ensp;&ensp;人民是党工作价值的最高裁决者\n\n**“三个代表”重要思想的主要内容**\n\n1、发展是党执政兴国的第一要务\n\n&ensp;&ensp;&ensp;&ensp;&ensp;社会主义要强大，体现优越性，关键在发展\n\n2、建立社会主义市场经济体制\n\n&ensp;&ensp;&ensp;&ensp;&ensp;党的十四大\t建立社会主义市场经济体制确立为我国经济体制改革的目标\n\n&ensp;&ensp;&ensp;&ensp;&ensp;党的十四届三中全会\t通过《关于建立社会主义市场经济体制若干问题的决定》 勾画了建立社会主义市场经济体制的蓝图和基本框架\n\n&ensp;&ensp;&ensp;&ensp;&ensp;如何建立社会主义市场经济体制？\t\t\t制度(完善)包含体制(改革)\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;一是 必须坚持和完善公有制为主体、多种所有制经济共同发展的社会主义基本经济制度\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;二是 进一步探索公有制特别是国有制的多种有效实现形式\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;三是 发挥市场机制的作用和国家宏观调控\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;四是 理顺分配关系，调整和规范国家、企业和个人的分配关系\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;五是 建立和完善社会保障体系，是建立社会主义市场经济体制的重要内容\n\n3、全面建设小康社会\n\n4、建设社会主义政治文明\n\n&ensp;&ensp;&ensp;&ensp;&ensp;在十六大报告中，江泽民把社会主义**物质文明**、**政治文明**、**精神文明**一起确立为社会主义现代化全面发展的**三大基本目标**，从而使中国特色社会主义的理论和实践更加走向成熟和完善。\n\n&ensp;&ensp;&ensp;&ensp;&ensp;建立社会主义政治文明，最根本就是要坚持党的领导、人民当家作主和依法治国的有机统一，这是我国社会主义政治文明区别于资本主义政治文明的本质特征\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;党的领导是人民当家作主和依法治国的根本保证\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;人民当家作主是社会主义民主政治的本质要求\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;依法治国是党领导人民治理国家的基本方略\n\n&ensp;&ensp;&ensp;&ensp;&ensp;建设社会主义政治文明，必须坚持依法治国，建设社会主义法治国家\n\n&ensp;&ensp;&ensp;&ensp;&ensp;建设社会主义政治文明，必须进行政治体制改革\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;政治体制改革是社会主义政治制度的自我完善和发展\n\n5、推进党的建设新的伟大工程\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（1）坚持中国共产党的领导，就是要坚持党在建设中国特色社会主义事业中的领导核心地位，发挥党总揽全局、协调各方的作用。坚持党的领导，**核心**是坚持党的先进性。\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（2）推进党的建设新的伟大工程，重点是加强党的执政能力建设\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（3）领导干部一定要讲学习、讲政治、讲正气。讲学习是前提；讲政治是核心；讲正气就是要坚持和发扬共产党人的政治本色与革命气节。\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（4）坚持党要管党、从严治党的方针。从严治党必须全面贯穿到党的思想、政治、组织、作风和制度建设之中。加强和改进党的作风建设，核心问题是保持党同人民群的 血肉联系。党的最大政治优势是密切联系群众，党执政后的最大危险是脱离群众\n\n&ensp;&ensp;&ensp;&ensp;&ensp;（5）坚决反对和防止腐败是全党一项重大的政治任务，是关系党和国家生死存亡的严重政治斗争\n\n# <center>第三节“三个代表”重要思想的历史地位</center>\n\n一、中国特色社会主义理论体系的接续发展\n\n&ensp;&ensp;&ensp;&ensp;&ensp;“三个代表”重要思想是对马克思列宁主义、毛泽东思想和邓小平理论的继承和发展，是中国特色社会\t主义理论体系的重要组成部分\n\n&ensp;&ensp;&ensp;&ensp;&ensp;始终做到“三个代表”，是我们党的立党之本、执政之基、力量之源。\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;“三个代表”重要思想强调社会主义社会是全面发展、全面进步的社会\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;“三个代表”重要思想强调要努力促进人的全面发展\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;“三个代表”重要思想，科学揭示了执政党建设的规律\n\n二、加强和改进党的建设，推进中国特色社会主义事业的强大理论武器\n\n&ensp;&ensp;&ensp;&ensp;&ensp;“三个代表”重要思想进一步回答了什么是社会主义、怎么建设社会主义的问题，创造性地回答了建设什么样的党、怎样建设党的问题\n","tags":["政治"],"categories":["升学"]},{"title":"第五章 邓小平理论","url":"/post/17bf8c68.html","content":"\n# <center>第一节 邓小平理论的形成</center>\n\n**邓小平理论的形成条件**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;时代背景：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;和平与发展成为时代主题（国际）\n\n&ensp;&ensp;&ensp;&ensp;&ensp;历史依据：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;社会主义建设的经验教训（过去）\n\n&ensp;&ensp;&ensp;&ensp;&ensp;现实依据：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;改革开放和现代化建设的实践（现在）\n\n&ensp;&ensp;&ensp;&ensp;&ensp;邓小平：和平问题是东西问题，发展问题是南北问题（核心问题）\n\n**邓小平理论的形成过程**\n\n|          时间          |                           主义内容                           |                                                              |\n| :--------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |\n| 1978.12 十一届三中全会 | 重新确立了解放思想、实事求是的思想路线，确定把全党工作中心转移到社会主义现代化建设上来，作出实行改革开放的重大决策 |                                                              |\n|     1982.9 十二大      | 邓小平正式提出“**建设有中国特色社会主义”的命题**，从此，“中国特色社会主义”成为党的全部理论和实践的主题 |                                                              |\n|     1987.10 十三大     | 第一次比较系统地论述了我国社会主义初级阶段理论，第一次对中国特色社会主义理论进行系统概括，标志着邓小平理论轮廓形成，把邓小平理论“三步走”战略构想确定下来，明确概括和全面阐发了党的“一个中心、两个基本点”的基本路线 |         2017年 十七大 中国特色社会主义理论体系的提出         |\n|     1992 南方谈话      | 邓小平理论的**集大成之作**，推进改革开放和社会主义现代化建设进入新阶段，邓小平理论也逐步走向成熟 | 十四大 高度评价邓小平对创新中国特色社会主义理论的杰出贡献，系统阐述了邓小平理论的历史地位和指导意义 |\n|      1997 十五大       | 正式提出“邓小平理论”这一概念，深刻阐述了邓小平理论的历史地位和指导意义，并郑重地把邓小平理论同马克思列宁主义、毛泽东思想一起，确立为党的指导思想并写入党章 |                                                              |\n|          1999          |              宪法修正案正式将邓小平理论载入宪法              |                                                              |\n\n**三次工作中心转移**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;秋收起义后    城市转向农村\n\n&ensp;&ensp;&ensp;&ensp;&ensp;七届二中全会       农村转城市\n\n&ensp;&ensp;&ensp;&ensp;&ensp;十一届三中全会    阶级斗争转经济建设\n\n# <center>第二节 邓小平理论的基本问题和主要内容</center>\n\n## <center>邓小平理论回答的基本问题</center>\n\n&ensp;&ensp;&ensp;&ensp;&ensp;什么是社会主义、怎样建设社会主义，是邓小平在领导改革开放和现代化建设这一新的革命过程，不断提出和反复思考的首要的基本的理论问题\n\n&ensp;&ensp;&ensp;&ensp;&ensp;搞清楚什么是社会主义、怎样建设社会主义，关键是要在坚持社会主义基本制度的基础上进一步认清社会主义的本质\n\n&ensp;&ensp;&ensp;&ensp;&ensp;社会主义本质论。1992年初，邓小平在南方谈话中对社会主义本质作了总结性理论概括：“社会主义的本质，是解放生产力，发展生产力(社会主义根本任务)，消灭剥削，消除两极分化，最终达到共同富裕”\n\n&ensp;&ensp;&ensp;&ensp;&ensp;实现目标基础、根本要求、根本途径：解放生产力，发展生产力\n\n&ensp;&ensp;&ensp;&ensp;&ensp;社会主义和资本主义的根本区别、社会主义根本目的：消灭剥削，消除两极分化\n\n&ensp;&ensp;&ensp;&ensp;&ensp;社会主义要赢得与资本主义相比较的优势，就必须 吸收和借鉴国外文明成果\n\n&ensp;&ensp;&ensp;&ensp;&ensp;社会主义根本目标：共同富裕\t\n\n&ensp;&ensp;&ensp;&ensp;&ensp;社会主义最大优越性：共同富裕\n\n&ensp;&ensp;&ensp;&ensp;&ensp;两条根本原则：一是 以社会主义公有制经济为主体，一是 共同富裕\n\n## <center>邓小平理论的主要内容</center>\n\n**1、解放思想，实事求是的思想路线**（活的灵魂、精髓）\n\n&ensp;&ensp;&ensp;&ensp;&ensp;1978 十一届三中全会 《解放思想，实事求是，团结一致向前看》重新确立马克思主义的思想路线\t\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;解放思想是实事求是的基础和前提\t实事求是是解放思想的目的和归宿\n\n**2、社会主义初级阶段理论**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;社会主义初级阶段的提出\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;十三大：我们讲一切从实际出发，最大的实际就是中国处于并将长期处于社会主义初级阶段\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;社会主义初级阶段是最基本国情也是建设中国特色社会主义总依据\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第一次明确指出我国处于社会主义初级阶段的重要文件：《历史决议》\n\n&ensp;&ensp;&ensp;&ensp;&ensp;社会主义初级阶段的科学内涵\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;指我国生产力落后、商品经济不发达条件下建设社会主义必然要经历的特定阶段，即从我国进入社会主义到基本实现现代化的整个历史阶段\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;初级阶段时间：1956(进入社会主义社会) ~ 基本实现现代化\t初阶：我国特定阶段\n\n&ensp;&ensp;&ensp;&ensp;&ensp;社会主义初级阶段的两层含义\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第一，我国已经进入社会主义社会，必须坚持而不能离开社会主义\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第二，我国的社会主义社会还处在不发达阶段，必须正视而不能超越初级阶段\n\n&ensp;&ensp;&ensp;&ensp;&ensp;社会主义初级阶段的重要意义\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第一，我国处在社会主义初级阶段，是邓小平和我们党对当代中国基本国情的科学判断，它揭示了当代中国的历史方位，是建设中国特色社会主义的总依据\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第二，社会主义初级阶段理论是基于对中国国情的准确把握，是对马克思主义关于社会主义发展阶段理论的重大发展和重大突破\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第三，邓小平关于社会主义初级阶段的论断，使我们对社会主义建设的长期性、复杂性、艰巨性有了更加清醒的认识\n\n**3、党的基本路线**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;时间：十三大\t地位：党和国家生命线 人民的幸福线\n\n&ensp;&ensp;&ensp;&ensp;&ensp;领导和团结全国各族人民，以经济建设为中心(工作)，坚持四项基本原则、坚持改革开放，自力更生，艰苦创业，为把我国建成富强、民主、文明的社会主义现代化国家而奋斗\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;领导(党)、依靠(全国各族人民)力量\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;基本途径：一个中心，两个基本点\n\n&ensp;&ensp;&ensp;&ensp;&ensp;一个中心、两个基本点 集中体现了我国社会主义现代化建设的战略布局，揭示了中国特色社会主义的客观规律和发展道路\n\n&ensp;&ensp;&ensp;&ensp;&ensp;根本立足点：自力更生，艰苦创业\n\n&ensp;&ensp;&ensp;&ensp;&ensp;目标：把我国建成富强、民主、文明的社会主义现代化国家\n\n&ensp;&ensp;&ensp;&ensp;&ensp;经济建设为中心地位：兴国之要\n\n&ensp;&ensp;&ensp;&ensp;&ensp;四项基本原则地位：立国之本、政治基石\n\n&ensp;&ensp;&ensp;&ensp;&ensp;改革开放地位：强国之路、必由之路、关键一招\n\n&ensp;&ensp;&ensp;&ensp;&ensp;十三大：富强、民主、文明的社会主义现代化国家\n\n&ensp;&ensp;&ensp;&ensp;&ensp;十七大：富强、民主、文明、和谐的社会主义现代化国家\n\n&ensp;&ensp;&ensp;&ensp;&ensp;十九大：富强、民主、文明、和谐、美丽的社会主义现代化强国\n\n&ensp;&ensp;&ensp;&ensp;&ensp;如何坚持党的基本路线\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第一，坚持党的基本路线，必须紧紧围绕经济建设这一中心\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第二，坚持党的基本路线，必须把坚持四项基本原则同坚持改革开放结合起来，正确处理改革开放和四项基本原则的关系。坚持以经济建设为中心同四项基本原则、改革开放这两个基本的统一于发展中国特色社会主义的伟大实践\n\n**4、社会主义根本任务的理论**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;生产力是社会发展的最根本的决定性因素，社会主义根本任务是发展生产力\n\n&ensp;&ensp;&ensp;&ensp;&ensp;发展是硬道理\n\n&ensp;&ensp;&ensp;&ensp;&ensp;科学技术是第一生产力\n\n**5、“三步走” 战略**\n\n![三步走战略](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271749655.png)\n\n**6、改革开放理论**\t(新时代最鲜明特点、改革是直接动力)\n\n&ensp;&ensp;&ensp;&ensp;&ensp;改革开放 回答了社会主义的发展动力和外部条件问题，体现了解放生产力的本质要求\n\n&ensp;&ensp;&ensp;&ensp;&ensp;改革的性质\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;“改革是中国的第二次革命”\n\n&ensp;&ensp;&ensp;&ensp;&ensp;改革的衡量标准\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;“三个有利于”的标准\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;是否有利于发展社会主义的生产力\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;是否有利于增强社会主义国家的综合国力(经济力+科技力)\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;是否有利于提高人民的生活水平\n\n&ensp;&ensp;&ensp;&ensp;&ensp;开放也是改革\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;对外开放是建设中国特色社会主义的一项基本国策\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;坚持改革开放这一国策的基本立足点：独立自主，自力更生\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;十一届三中全会后，对外开放格局：全方位、多层次、宽领域\n\n&ensp;&ensp;&ensp;&ensp;&ensp;改革开放进程\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;对内改革\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1978年底——家庭联产承包责任制\t改革从农村开始\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;对外开放\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1980——深圳、珠海、汕头、厦门市设置经济特区\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1984——开放14个沿海港口城市\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1988——海南岛办全国最大的经济特区\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;2001——加入世界贸易组织\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;2013——设立中国（上海）自由贸易试验区\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;2018——海南全岛建设自由贸易试验区、自由贸易港\n\n**7、社会主义市场经济理论**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;社会主义市场经济体制的改革目标的提出\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;正确处理和认识计划(政府)与市场的关系是经济体制改革的核心问题\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;十二届三中全会 《中共中央关于经济体制改革的决定》提出社会主义经济是“公有制基础上有计划的商品经济”的论断\n\n&ensp;&ensp;&ensp;&ensp;&ensp;社会主义市场经济理论的要点\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;一是 计划经济和市场经济不是划分社会制度的标志\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;二是 计划和市场都是经济手段\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;三是 坚持社会主义制度与市场经济的结合，是社会主义市场经济的特色所在、优势所在\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;社会主义市场经济包含社会主义经济(只有计划经济)\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1981\t十一届六中全会\t\t“以计划经济为主，以市场经济为辅”\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1984\t十二届三中全会\t\t社会主义经济是“公有制基础上有计划的商品经济”\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1987\t十三大\t\t\t\t社会主义有计划商品经济的体制应是计划与市场内在统一的体制\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1992\t南方谈话\t\t\t    建立社会主义市场经济体制\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1992\t十四大\t\t\t\t确立建立社会主义市场经济体制作为我国经济体制改革目标\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1993\t十四届三中全会\t\t使市场在国家宏观调控下对资源的配置起基础性作用\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;2013\t十八届三中全会\t\t使市场在资源的配置中起决定性作用\n\n8、“两手抓”，两手都要硬\t\t辩证法的两面性\n\n&ensp;&ensp;&ensp;&ensp;&ensp;一手抓物质文明，一手抓精神文明，\"两手抓，两手都要硬”，这是我国社会主义现代化建设的一个根本指针，邓小平理论不仅强调物质文明和精神文明两手抓、两手都要硬，而且还提出了其他一系列两手抓思想。“一手抓建设，一手抓法制”；“一手抓改革开放，一手抓惩治腐败”；“一手抓改革开放，一手抓打击各种犯罪活动\"\n\n9、一国两制\n\n&ensp;&ensp;&ensp;&ensp;&ensp;提出从台湾问题开始的，首先运用于解决香港问题、澳门问题\n\n&ensp;&ensp;&ensp;&ensp;&ensp;台湾问题属于内政问题\n\n&ensp;&ensp;&ensp;&ensp;&ensp;代表中国政府第一次公开提出和平解决台湾问题主张的是：周恩来\n\n&ensp;&ensp;&ensp;&ensp;&ensp;将中国共产党提出的一系列和平解决台湾问题的思想、政策和主张归纳为“一纲四目”的国家领导人：周恩来\n\n&ensp;&ensp;&ensp;&ensp;&ensp;首次以“台湾回到祖国怀抱，实现统一大业”来代替“解放台湾”的提法：党的十一届三中全会公报\n\n&ensp;&ensp;&ensp;&ensp;&ensp;基本内容\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;坚持一个中国，这是“和平统一，一国两制”的核心，是发展两岸关系和实现和平统一的基础\n\n&ensp;&ensp;&ensp;&ensp;&ensp;两岸关系的主题：和平发展\n\n10、中国的问题关键在于党\t政治保证、党的建设\t\t（保证 ==》党）\n\n&ensp;&ensp;&ensp;&ensp;&ensp;建设中国特色社会主义，关键在于坚持、加强和改善党的领导\n\n&ensp;&ensp;&ensp;&ensp;&ensp;要加强党的思想建设、组织建设、作风建设\n\n&ensp;&ensp;&ensp;&ensp;&ensp;要坚持和健全民主集中制、加强和改进党的基层组织建设\n\n&ensp;&ensp;&ensp;&ensp;&ensp;按照“革命化、年轻化、知识化、专业化”的方针培养和选拔德才兼备的领导干部。\n\n&ensp;&ensp;&ensp;&ensp;&ensp;执政党的党风是关系党生死存亡的重大问题。一定要坚持党的宗旨，继承党的优良传统，发扬党的理论和实践相结合的作风、和人民群众紧密地联系在一起的作风以及自我批评的作风。\n\n# <center>第三节 邓小平理论的历史地位</center>\n\n邓小平理论是对马克思列宁主义、毛泽东思想的继承和发展\n\n邓小平理论是中国特色社会主义理论体系的开篇之作\n\n邓小平理论是改革开放和社会主义现代化建设的科学指南\n\n为什么说邓小平理论是改革开放和社会主义现代化建设的科学指南？\n\n&ensp;&ensp;&ensp;&ensp;&ensp;邓小平理论指导了改革开放的伟大实践。\n\n&ensp;&ensp;&ensp;&ensp;&ensp;邓小平理论的贡献，是历史性的，也是世界性的，不仅改变了中国人民的历史命运，而且改变了世界的历史进程\n\n&ensp;&ensp;&ensp;&ensp;&ensp;邓小平理论是邓小平留给我们的最重要的思想遗产。邓小平论经过改革开放和现代化建设实践的检验，已经被证明是指导中国人民建设中国特色社会主义、保证中国在改革开放实现国家繁荣富强和人民共同富裕的系统的科学理论。邓小平理论是中国共产党和中国人民宝贵的精神财富，是改革开放和社会主义现代化 建设的科学指南，是党和国家必须长期坚持的指导思想\n","tags":["政治"],"categories":["升学"]},{"title":"第四章 社会主义建设道路初步探索的理论成果","url":"/post/7821492f.html","content":"\n# <center>第一节 初步探索的重要理论成果</center>\n\n## <center>调动一切积极因素为社会主义事业服务的思想</center>\n\n**1、方针的提出**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;1956年 毛泽东 中央政治局扩大会议、最高国务会议 《论十大关系》\n\n&ensp;&ensp;&ensp;&ensp;&ensp;《论十大关系》建设社会主义的根本思想：必须根据本国的国情走自己的道路\n\n&ensp;&ensp;&ensp;&ensp;&ensp;观点：以苏为鉴，独立自主地探索适合中国情况的社会主义建设道路\n\n&ensp;&ensp;&ensp;&ensp;&ensp;提出：“向外国学习”的口号\n\n&ensp;&ensp;&ensp;&ensp;&ensp;《论十大关系》确定了一个基本方针：调用一切积极因素为社会主义事业服务\n\n&ensp;&ensp;&ensp;&ensp;&ensp;意义：《论十大关系》标志着党探索中国社会主义建设道路的良好开端\n\n|            |      |     两次结合     |                |          |            |\n| :--------: | :--: | :--------------: | :------------: | -------- | :--------: |\n|            |      |       会议       |      文献      | 成熟     |    成果    |\n| 第一次结合 | 1938 |   六届六中全会   |  《论新阶段》  | 中共七大 | 毛泽东思想 |\n| 第二次结合 | 1956 | 中央政治扩大会议 | 《论十大关系》 |          |            |\n\n**2、调用了一切积极因素为社会主义事业服务的要求**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;第一，调用一切积极因素为社会主义事业服务，必须坚持中国共产党的领导\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;领导事业的核心力量是中国共产党，党是领导一切\n\n&ensp;&ensp;&ensp;&ensp;&ensp;第二，调用一切积极因素为社会主义事业服务，必须发展社会主义民主政治\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;又有集中又有民主，又有纪律又有自由、又有统一意志又有个人心情舒畅、生动活泼\n\n&ensp;&ensp;&ensp;&ensp;&ensp;第三，调用一切积极因素为社会主义事业服务，必须正确认识社会主义发展阶段和社会主义建设规律的问题\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;社会主义又可分为两个阶段，第一个阶段是不发达的社会主义，第二个是比较发达的社会主义\n\n**3、十大关系的主要内容**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;农业、轻工业、重工业关系(第一大关系)\n\n&ensp;&ensp;&ensp;&ensp;&ensp;沿海工业、内地工业关系\n\n&ensp;&ensp;&ensp;&ensp;&ensp;经济建设和国防建设关系\n\n&ensp;&ensp;&ensp;&ensp;&ensp;国家、单位、个人生产关系\n\n&ensp;&ensp;&ensp;&ensp;&ensp;中央和地方关系\n\n&ensp;&ensp;&ensp;&ensp;&ensp;汉族和少数民族的关系\n\n&ensp;&ensp;&ensp;&ensp;&ensp;党与非党的关系\n\n&ensp;&ensp;&ensp;&ensp;&ensp;革命和反革命关系\n\n&ensp;&ensp;&ensp;&ensp;&ensp;是非关系\n\n&ensp;&ensp;&ensp;&ensp;&ensp;中国和外国关系\n\n## <center>正确认识和处理社会主义社会矛盾的思想</center>\n\n社会主义改造的任务完成后，国内的社会矛盾和阶级关系发生了重大变化无产阶级同资产阶级之间的矛盾基本解决\n\n现实：大量人民内部矛盾逐步成为国家政治生活中居于主导(主要矛盾)地位的矛盾\n\n毛泽东在1957年2月所作的《关于正确处理人民内部矛盾的问题》的报告，系统论述了社会主义社会矛盾的理论\n\n社会主义社会存在矛盾。毛泽东指出，矛盾是普遍存在的，社会主义社会同样充满着矛盾，正是这些矛盾推动着社会主义社会不断地向前发展。**用**对立统一规律**看问题**\n\n**关于社会主义社会的基本矛盾**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;关于社会主义社会的基本矛盾(不变)。在社会主义社会中，基本的矛盾仍然是生产关系和生产力之间的矛盾，上层建筑和经济基础之间的矛盾，社会主义社会的基本矛盾的特点是“非对抗性的”“又相适应又相矛盾”的特点。解决的办法：通过社会主义制度本身来解决\n\n**关于社会主义社会的主要矛盾和根本任务**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;关于我国社会的主要矛盾。“我们国内的主要矛盾，已经是人民对于建立先进的工业国的要求同落后的农业国的现实之间的矛盾，已经是人民对于经济文化迅速发展的需要同当前经济文化不能满足人民需要的状况之间的矛盾”\n\n&ensp;&ensp;&ensp;&ensp;&ensp;党中央提出把党和国家的重点转到技术革命和社会主义建设\n\n**关于社会主义社会的两类不同性质的矛盾**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;在我们面前有两类社会矛盾，这就是敌我矛盾和人民内部矛盾\n\n&ensp;&ensp;&ensp;&ensp;&ensp;敌我矛盾(对抗性)：人民和反抗社会主义革命，敌视和破坏社会主义建设的社会主义势力和社会主义集团\n\n&ensp;&ensp;&ensp;&ensp;&ensp;人民内部矛盾(非对抗性)：工人阶级内部、农民阶级内部、知识分子内部、工农阶级之间、工人阶级同民资产阶级等等\n\n&ensp;&ensp;&ensp;&ensp;&ensp;民族资产阶级有两面性，工人阶级同民族资产阶级的矛盾属于人民内部矛盾\n\n&ensp;&ensp;&ensp;&ensp;&ensp;**1.两类矛盾在一定条件下可以相互转换：**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;人民内部矛盾不是对抗性的，但处理不当，也可能会发生对抗\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;本来对抗的矛盾，如果处理得当，可以转化为非对抗性矛盾\n\n**&ensp;&ensp;&ensp;&ensp;&ensp;2.关于正确处理两类不同性质社会矛盾的基本方法**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;在人民民主专政(国体)下面，解决敌我矛盾和人民内部矛盾这两类不同性质的矛盾，采用专政和民主两种不同方法\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;专政(敌我矛盾)：对敌对分子、严重犯罪分子依法治罪，剥夺政治权利，强迫从事劳动，进行改造\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;民主(人民内部矛盾)：讨论、批评方法，说服教育的方法\n\n**3.关于正确处理人民内部矛盾的总方针**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;民主的办法是正确处理人民内部矛盾的总方针\n\n| 对于政治思想领域       | 实行“团结—批评—团结”的方针                                   |\n| ---------------------- | ------------------------------------------------------------ |\n| 对于物质利益、分配方面 | 实行统筹兼顾、适当安排的方针                                 |\n| 对于人民群众和政府机关 | 坚持民主集中制原则                                           |\n| 对于科学文化领域       | 实行“百花齐放、百家争鸣”的方针                               |\n| 对于共产党和民主党派   | 坚持社会主义道路和共产党领导的前提下“长期共存、互相监督”的方针 |\n| 对于民族之间           | 实行民族平等、团结互助的方针                                 |\n\n&ensp;&ensp;&ensp;&ensp;&ensp;民主党派：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;政党制度：中国共产党领导的多党合作和政治协商制度\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;职能：参政议政、政治协商、民主监督\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;方针：长期共存、互相监督、肝胆相照、荣辱与共\n\n**4.关于处理两类不同性质矛盾的意义**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;正确处理人民内部矛盾作为国家政治生活主题\n\n&ensp;&ensp;&ensp;&ensp;&ensp;关于社会主义矛盾的学说，科学揭示了社会主义社会发展的动力，以独创性的内容丰富了马克思主义的理论宝库，为正确处理社会主义社会各种矛盾、创造良好机会的社会和政治环境，提供了基本的理论依据，也为后来的社会主义改革奠定了理论基础\n\n## <center>走中国工业化道路的思想</center>\n\n**走中国工业化道路问题的提出**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;我国实现工业化的根本政治前提：中华人民共和国成立\n\n&ensp;&ensp;&ensp;&ensp;&ensp;《论十大关系》论述了第一大关系，重工业、轻工业和农业的关系\n\n&ensp;&ensp;&ensp;&ensp;&ensp;《关于正确处理人民内部矛盾的问题》 提出要走有别于苏联的中国工业化道路\n\n&ensp;&ensp;&ensp;&ensp;&ensp;提出以农业为基础，以工业为主导，以农轻重为序发展国民经济的总方针以及“两条腿走路”的方针\n\n**走中国工业化道路的要求**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;走中国工业化道路，必须明确战略目标和战略步骤\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;四个现代化：农业现代化、工业现代化、国防现代化、科学技术现代化(关键)\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;“两步走”：比较完整的工业体系和国民经济体系    全面实现工业、农业、国防和科学技术现代化\n\n&ensp;&ensp;&ensp;&ensp;&ensp;走中国工业化道路，必须采取正确的经济建设方针\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1956 八大：既反保守又反冒进(周恩来等人提出)，在综合平衡中稳步前进(正确的)\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;八大提出要扩大社会主义民主，开展反对官僚主义的斗争\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;保守 ==》右倾     冒进 ==》“左”倾\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;八大二次会议：多快好省建设社会主义(错误的)\n\n&ensp;&ensp;&ensp;&ensp;&ensp;走中国工业化道路，必须发展科学技术和文化教育\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;口号：(周恩来)“向科学进军”\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;战略：重点发展、迎头赶上，必须大力发展文化教育事业\n\n&ensp;&ensp;&ensp;&ensp;&ensp;走中国工业化道路，必须重视知识分子工作\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;周恩来：知识分子是工人阶级的一部分\n\n&ensp;&ensp;&ensp;&ensp;&ensp;走中国工业化道路，必须调整和完善所有制结构\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;毛、刘、周：把资本主义经济作为社会主义经济的补充\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;朱德：要注意发展手工业和农业多种经营\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;陈云：“三个主体、三个补充”\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;国家经济和集体经济为主体，以个体经济为补充\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;以计划生产为主体，以自由生产为补充\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;以国家市场为主体，以自由市场为补充\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;毛泽东：提出了“发展商品生产、利用价值规律”的观点\n\n&ensp;&ensp;&ensp;&ensp;&ensp;走中国工业化道路，必须积极探索适合我国情况的经济体制和运行机制\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;毛泽东：有计划地发展社会主义的商品生产，两参一改三结合\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;干部参加劳动，工人参加管理，改革不合理的规章制度，工人群众、领导干部和技术人员三结合\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;刘少奇：使社会主义经济既有计划又有多样性和灵活性\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;陈云：建立 “适合我国情况和人民需要的社会主义的市场”\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;刘少奇：提出了实现 “两种劳动制度、两种教育制度”\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;邓小平：提出了关于整顿工业企业，改善和加强企业管理，实行职工代表大会制的思想\n\n# <center>第二节 初步探索的意义和经验教训</center>\n\n**初步探索的意义**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;巩固和发展了我国的社会主义制度(对之前而言)\n\n&ensp;&ensp;&ensp;&ensp;&ensp;为开创中国特色社会主义提供了宝贵的经验、理论准备、物质基础（对之后而言）\n\n&ensp;&ensp;&ensp;&ensp;&ensp;丰富了科学社会主义的理论和实践（理论意义）\n\n**初步探索的经验教训**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;必须把马克思主义与中国实际相结合，探索符合中国特点的社会主义道路\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;造成失误的原因：马克思主义基本原理的理解不够深入，对中国国情缺乏深刻认识\n\n&ensp;&ensp;&ensp;&ensp;&ensp;必须正确认识社会主义的主要矛盾和根本任务，集中力量发展生产力\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;评价：正确认识了当时社会的主要矛盾和根本任务，但未能坚持下来\n\n&ensp;&ensp;&ensp;&ensp;&ensp;必须从实际出发进行社会主义建设，建设规模和速度要和国力相适应，不能急于求成\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;必须采取科学态度，深入了解和分析实际情况\n\n&ensp;&ensp;&ensp;&ensp;&ensp;必须发展社会主义民主，健全社会主义法制\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;确保人民当家作主，党必须在宪法和法律范围内活动\n\n&ensp;&ensp;&ensp;&ensp;&ensp;必须坚持党的民主集中制和集体领导制度，加强执政党建设\n\n&ensp;&ensp;&ensp;&ensp;&ensp;必须坚持对外开放，借鉴和吸引人类文明成果建设社会主义，不能关起门来搞建设\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;大胆吸收借鉴和吸收包括资本主义文明在内的一切人类文明成果\n\n**正确认识改革开放前和改革开放后两个历史时期**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;这是两个相互联系又有重大区别的时期，但本质上都是我们党领导人民进行社会主义建设的实践探索\n\n&ensp;&ensp;&ensp;&ensp;&ensp;**结论：**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;改革开放前为改革开放后积累了经验和准备了条件\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;改革开放后是对改革开放前探索的坚持、改革、发展\n\n&ensp;&ensp;&ensp;&ensp;&ensp;补充：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;中国特色社会主义是改革开放以来党的全部理论经验的主题\n","tags":["政治"],"categories":["升学"]},{"title":"第三章 社会主义改造理论","url":"/post/cf0c504a.html","content":"\n# <center>第一节 从新民主主义到社会主义的转变</center>\n\n## <center>新民主主义社会是一个过渡性社会</center>\n\n**1.**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;这一时期，我国社会的性质：新民主主义社会\n\n&ensp;&ensp;&ensp;&ensp;&ensp;社会形态：过渡性的社会\n\n![过度社会图](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271747645.png)\n\n**2.新民主主义社会的经济成分**\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271747032.png\" alt=\"新民主主义社会经济成分\" style=\"zoom:33%;\" />\n\n社会主义性质的国营经济(领导地位)\n\n半社会主义性质的国家资本主义经济和合作社经济\n\n&ensp;&ensp;&ensp;&ensp;合作社经济是个体经济向社会主义集体经济过渡的形式\n\n&ensp;&ensp;&ensp;&ensp;国家资本主义经济是私人资本主义经济向社会主义国营经济过渡的形式\n\n农民和手工业的个体经济、私人资本主义经济\n\n&ensp;&ensp;&ensp;&ensp;主要的经济成分：社会主义经济、个体经济(处在十字路口的经济成分)和资本主义经济\n\n&ensp;&ensp;&ensp;&ensp;过渡形式的经济成分：合作社经济、国家资本主义经济\n\n**3、新民主主义社会的阶级构成**\n\n阶级构成：\n\n&ensp;&ensp;&ensp;&ensp;主要是工人阶级、农民阶级和其他小资产阶级、民族资产阶级\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;民族资产阶级 (两面性==>为资本主义工商业进行和平改造的可能性)\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;既有剥削工人的一面，又有接受工人阶级及其政党领导的一面\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;民族资产阶级与工人阶级的矛盾的两面性\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;既有剥削者与被剥削者的阶级利益相互对立的对抗性的一面，又有相互合作、具有相同利益的非对抗性的一面\n\n**4.新民主主义社会的两个主要矛盾**\n\n主要矛盾：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;社会主义和资本主义两条道路、工人阶级和资产阶级（两个阶级的矛盾）\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;随着土地改革的完成，工人阶级和资产阶级的矛盾逐渐成为国内主要矛盾\n\n![新民主主义社会两个主要矛盾](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271747610.png)\n\n**4.新民主主义社会的前途和性质**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;社会主义因素不论在经济还是在政治上都已经居于领导地位\n\n&ensp;&ensp;&ensp;&ensp;&ensp;新民主主义社会是属于社会主义体系的，是逐步过渡到社会主义社会的过渡性社会\n\n## <center>党在过渡时期的总路线及其理论依据</center>\n\n**总路线的提出**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;提出：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1949年 党的七届二中全会 提出“两个转变”同时并举的思想，讨论了建设新民主主义社会的问题\n\n&ensp;&ensp;&ensp;&ensp;&ensp;两个转变：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;稳步地由农业国转变成工业国\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;由新民主主义社会转变为社会主义国家\n\n&ensp;&ensp;&ensp;&ensp;&ensp;内容：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1953年6月，毛泽东在中央政治局会议上正式提出过渡时期的总路线和总任务，同年12月形成了关于总路线的完整表述\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;“从中华人民共和国成立，到社会主义改造基本完成，这是一个过渡时期。党在这个过渡时期的总路线和总任务，是要在一个相当长的时期内(10到20年)，逐步实现国家的社会主义工业化，并逐步实现国家对农业、对手工业和对资本主义工商业（一化三改）的社会主义改造”\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271747013.png\" alt=\"一化三改\" style=\"zoom:50%;\" />\n\n&ensp;&ensp;&ensp;&ensp;&ensp;特点：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;社会主义建设和社会主义改造同时并举，体现了社会主义工业化和社会主义改造的紧密结合，体现了解放生产力与发展生产力、变革生产关系与发展生产力的有机统一\n\n**理论依据：**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;一是 马克思、恩格斯提出关于从资本主义社会向社会主义社会过渡的理论\n\n&ensp;&ensp;&ensp;&ensp;&ensp;二是 列宁在十月革命后提出必须经过一个相当长的从资本主义到社会主义的过渡时期，俄国才能过渡到社会主义的思想\n\n&ensp;&ensp;&ensp;&ensp;&ensp;过渡的必要性：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第一，我国经济和文化的落后，要求一个相当长的时期来创造为保证社会主义完全胜利所必要的经济上和文化上的前提\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第二，我国有极其广大的个体农业和手工业及在国民经济中占很大一部分比重的资本主义工商业，要求一个相当长的时期来改造她们\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第三，实现社会主义工业化，是国家独立和富强的必然要求和必要条件\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;推翻帝国主义的压迫是中国独立和富强的前提\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第四，社会主义改造围绕的中心任务是社会主义工业化建设\n\n# <center>第二节 社会主义改造道路和历史经验</center>\n\n**农业的社会主义改造**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;第一，积极引导农民组织起来，走互助合作道路\n\n&ensp;&ensp;&ensp;&ensp;&ensp;第二，遵循自愿互利，典型示范和国家帮助的原则，以互助合作的优越性吸引农民走互助合作道路\n\n&ensp;&ensp;&ensp;&ensp;&ensp;第三，正确分析农村的阶段和阶层状况，制定正确的阶级政策\n\n&ensp;&ensp;&ensp;&ensp;&ensp;第四，坚持积极领导、稳步前进的方针，采取循序渐进的步骤\n\n| 行业及特点 | 社会主义萌芽性质 |              半社会主义性质              |     完全社会主义性质     |\n| :--------: | :--------------: | :--------------------------------------: | :----------------------: |\n|    农业    | 互助组(互帮互助) | 初级农业生产合作社(集体劳动、按劳分配等) | 高级社(生产资料集体所有) |\n\n**手工业的社会主义改造**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;党和政府采取了积极领导、稳步前进的方针\n\n&ensp;&ensp;&ensp;&ensp;&ensp;第一步是办手工业供销小组，具有社会主义萌芽性质\n\n&ensp;&ensp;&ensp;&ensp;&ensp;第二步是办手工业供销合作社，具有半社会主义性质\n\n&ensp;&ensp;&ensp;&ensp;&ensp;第三步是建立手工业生产合作社，是社会主义性质的集体经济组织\n\n| 行业及特点 |         社会主义萌芽性质         |           半社会主义性质           |           完全社会主义性质           |\n| :--------: | :------------------------------: | :--------------------------------: | :----------------------------------: |\n|   手工业   | 供销小组(组织手工业者、包销产品) | 供销合作社(部分资料共有、干预生产) | 生产合作社(生产资料公有制、按劳分配) |\n\n**资本主义工商业的社会主义改造**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;第一，用和平赎买的方法改造资本主义工商业\n\n&ensp;&ensp;&ensp;&ensp;&ensp;第二，采取从低级到高级的国家资本主义的过渡形式\n\n&ensp;&ensp;&ensp;&ensp;&ensp;第三，把资本主义工商业改造成为自食其力的社会主义劳动者\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;采用“包下来”政策，做法：以企业为基地，根据“量才使用，适当照顾”的原则\n\n|   行业及特点   |               社会主义萌芽性质               |               半社会主义性质               |                完全社会主义性质                |\n| :------------: | :------------------------------------------: | :----------------------------------------: | :--------------------------------------------: |\n| 资本主义工商业 | 初级形式的国家资本主义(委托加工、计划订货等) | 个别企业的公私合营(国家资本家共有生产资料) | 全行业的公私合营(绝大部分纳入公司合营或合作社) |\n\n&ensp;&ensp;&ensp;&ensp;&ensp;初级形式国家资本主义：(私营工业)委托加工、计划订货、统购包销、经销代销\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;(私营商业)委托经销、代销\n\n&ensp;&ensp;&ensp;&ensp;&ensp;高级形式国家资本主义：公私合营 (个别企业、全行业公私合营)\n\n&ensp;&ensp;&ensp;&ensp;&ensp;和平赎买：国家有偿将私营企业变为国营企业，让资本家在一定年限内从企业经营所得中获取一部分利润\n\n**资本主义工商业改造的利润分配方式：**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;四马分肥：国家税收、职工福利、企业公积金、资本家红利\n\n|          |    社会主义萌芽性质    |   半社会主义性质   |  完全社会主义性质  |\n| :------: | :--------------------: | :----------------: | :----------------: |\n| 采取方式 | 初级形式的国家资本主义 | 个别企业的公私合营 |  全行业的公私合营  |\n| 利润分配 |        四马分肥        |      四马分肥      | 清产核资、定股定息 |\n\n**社会主义改造的历史经验**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;坚持社会主义工业化建设与社会主义改造同时并举的方针\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;对保持社会稳定、促进生产力的发展，逐步改善人民生活推动社会进步有重要意义\n\n&ensp;&ensp;&ensp;&ensp;&ensp;采取积极引导、逐步过渡的方式\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;我国对农业、手工业、资本主义工商业的改造，都采取了取别对象，积极引导，逐步过渡的方式\n\n&ensp;&ensp;&ensp;&ensp;&ensp;用和平赎买进行改造\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;我国对农业、手工业、资本主义工商业的改造，属于社会主义革命性质，坚持用和平的方式，不仅保证了社会主义改造的顺利进行，还维护了社会稳定，促进了社会主义事业的发展\n\n**正确评价历史变革**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;如此复杂、困难和深刻的社会变革不仅没有造成生产力的破坏，反而促进了工农业和整个国民经济的发展\n\n&ensp;&ensp;&ensp;&ensp;&ensp;这样的变革没有引起巨大的社会动荡，反而极大地加强人民的团结，并且是在人民普遍拥护的情况下完成的\n\n&ensp;&ensp;&ensp;&ensp;&ensp;我国社会主义改造的基本完成的确是一件伟大的历史性胜利，是中国共产党紧紧依靠人民所做出的伟大创造。我国的社会主义改造取得了历史性的胜利，也出现了一些失误和偏差。主要是农业、手工业、和个体商业的改造要求过急，改变过快，形式也过于简单划一，一直在长期间遗留了一些问题。但是，不能因为出现这些错误和偏差而否定社会主义改造的伟大意义\n\n# <center>第三节 社会主义制度在中国的确立</center>\n\n## <center>社会主义基本制度的确立及其理论依据</center>\n\n确立的标志性事件\n\n&ensp;&ensp;&ensp;&ensp;&ensp;1956年底，三大改造的基本完成，标志着中国历史上长达数千年的阶级剥削制度的结束和社会主义基本制度在我国确立\n\n确立依据：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;经济角度：社会主义经济成分已经占绝对优势，社会主义公有制已成为我国社会的经济基础\n\n&ensp;&ensp;&ensp;&ensp;&ensp;政治角度：随着社会主义改造的进行，我国的人民民主政治建设在有步骤地向前推进\n\n&ensp;&ensp;&ensp;&ensp;&ensp;阶级角度：我国社会的阶级关系也发生了根本的变化，广大劳动人民就此摆脱了被剥削被奴役的地位，成为掌握生产资料的国家和社会的主人以及掌握自己命运的主人\n\n&ensp;&ensp;&ensp;&ensp;&ensp;社会矛盾变化角度：我国社会的主要矛盾发生了变化，过渡时期存在的无产阶级同资产阶级之间的矛盾已经基本解决\n\n&ensp;&ensp;&ensp;&ensp;&ensp;国外角度：列宁关于经济文化比较落后的国家可以走向社会主义的理论，是在中国确立社会主义基本制度的理论依据\n\n## <center>确立社会主义基本制度的重大意义</center>\n\n&ensp;&ensp;&ensp;&ensp;&ensp;社会主义基本制度的确立是中国历史上最深刻最伟大的社会变革，为当代中国一切发展进步奠定了制度基础，也为中国特色社会主义制度的创新和发展提供了重要前提\n\n**经济意义：**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;极大地提高了工人阶级和广大劳动人民的积极性、创造性，极大地促进了我国社会生产力的发展，初步显示了社会主义的优越性\n\n**政治意义：**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;使劳动人民真正成为国家的主人，极大巩固和扩大了工人阶级领导的、以工农联盟为基础的人民民主专政国家政权的阶级基础和经济基础\n\n**世界意义：**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;进一步改变了世界政治经济格局，增强了社会主义的力量，对维护世界和平产生了积极影响\n\n**理论意义：**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;社会主义基本制度的确立，不仅再次证明了马克思列宁主义的真理性，而且以独创性的理论原则和经验总结丰富和发展了马克思列宁主义的科学社会主义理论\n","tags":["政治"],"categories":["升学"]},{"title":"12.文件","url":"/post/e2246be5.html","content":"\n# <center>知识点一：文件的存取过程</center>\n\n缓冲区的目的:提高存储效率磁盘使用寿命\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221521055.png\" alt=\"文件的存取过程\" style=\"zoom: 25%;\" />\n\n# <center>知识点二：磁盘文件分类</center>\n\n物理上所有的磁盘文件都是二进制存储，以字节为单位顺序存储\n\n逻辑上的文件分类:\n\n&ensp;&ensp;&ensp;&ensp;&ensp;文本文件：基于字符编码的文件，如ASCII、UNICODE等，可以文件编辑器直接打开\n\n&ensp;&ensp;&ensp;&ensp;&ensp;二进制文件：基于值编码的文件，数据在内存原样输出到磁盘，需要自己判断或使用特定软件分析数据格式\n\n总结:\n\n&ensp;&ensp;&ensp;&ensp;（1）译码：文件文件编码基于字符定长，译码容易些。二进制文件编码变长，译码难一些(不同二进制文件格式，有不同的译码方式)\n\n&ensp;&ensp;&ensp;&ensp;（2）空间利用率：二进制文件用一个比特来代表一个意思(位操作)。文本文件任何一个符号需要一个字节\n\n&ensp;&ensp;&ensp;&ensp;（3）可读性：文本文件用通用记事本根据几乎可以浏览所有文本文件。二进制文件需要一个具体的文件解码器\n\n# <center>知识点三：文件指针</center>\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221522710.png\" alt=\"文件指针1\" style=\"zoom:33%;\" />\n\n```\ntypedef struct\n{\n\tshort level;\t\t\t//缓冲区“满”或“空”的程度\n\tunsigned flags;\t\t\t//文件状态标志\n\tchar fd;\t\t\t//文件描述符\n\tunsigned char hold;\t\t//如无缓冲区不读取字符\n\tshort bsize;\t\t\t//缓冲区大小\n\tunsigned char *buffer;\t//数据缓冲区的位置\n\tunsigned char *curp;\t//指针，当前的指向\n\tunsigned istemp;\t\t//临时文件，指示器\n\tshort token;\t\t\t//用于有效性检查\n}FILE;\n```\n\n注意：不要关心FILE的细节只需要会用FILE定义指针变量就行：FILE *fp=NULL;\n\nC语言有三个特殊的文件指针无需定义，打开直接使用：\n\n（1）stdin：标准输入    默认为当前终端（键盘）\n\n&ensp;&ensp;&ensp;&ensp;使用的scanf、getchar函数默认从此终端获得数据\n\n（2）stdout：标准输出  默认为当前终端（屏幕）\n\n&ensp;&ensp;&ensp;&ensp;使用的printf、puts函数默认输出信息到此终端\n\n（3）stderr：标准出错   默认当前终端（屏幕）\n\n&ensp;&ensp;&ensp;&ensp;当我们程序出错或使用：perror函数时信息打印在此终端\n\n# <center>知识点四：打开一个文件</center>\n\n```\n形式：\n\tfile* fp = null;\t//定义一个FILE类型的指针接收返回值\n\tfp = fopen(文件名,文件使用方式);\n参数：\n\t文件名：要打开的文件名字，可以包含路径信息\n\t文件使用方式：“读”、“写”、“文本”或“二进制”等\n返回值：成功返回相应指针，失败返回NULL\n```\n\n# <center>知识点五：文件使用方式</center>\n\n1、r：以只读方式打开文件\n\n&ensp;&ensp;&ensp;&ensp;文件不存在：返回NULL\n\n&ensp;&ensp;&ensp;&ensp;文件存在：返回文件指针，进行后续读操作\n\n2、w：以只写方式打开文件\n\n&ensp;&ensp;&ensp;&ensp;文件不存在：以指定文件名创建此文件\n\n&ensp;&ensp;&ensp;&ensp;文件存在：清空文件内容，进行写操作\n\n&ensp;&ensp;&ensp;&ensp;若文件打不开(如文件只读)，返回NULL\n\n3、a：以追加的方式打开文件（往文件的末尾写入数据）\n\n&ensp;&ensp;&ensp;&ensp;文件不存在：以指定文件名创建此文件(同w)\n\n&ensp;&ensp;&ensp;&ensp;文件存在，从文件的结尾处进行写操作\n\n4、+：以可读可写的方式打开\n\n5、b：以二进制的方式打开文件\n\n6、t：以文本的方式打开文件(省略)\n\n# <center>知识点六：打开方式的组合形式</center>\n\n| 模式    | 功能                                                         |\n| ------- | ------------------------------------------------------------ |\n| r或rb   | 以只读方式打开一个文本文件(不创建文件)                       |\n| w或wb   | 以写方式打开文件(使文件长度截断为0字节，创建一个文件)        |\n| a或ab   | 以添加方式打开文件，即在末尾添加内容，当文件不存在时，创建文件用于写 |\n| r+或rb+ | 以可读、可写的方式打开文件(不创建新文件)                     |\n| w+或wb+ | 以可读、可写的方式打开文件(使文件长度为0字节，创建一个文件)  |\n| a+或ab+ | 以添加方式打开文件，打开文件并在未尾更改文件(如果文件不存在，则创建文件) |\n\n# <center>知识点七：关闭文件</center>\n\n```c\n形式：fclose(文件指针);\t//文件指针：指向要关闭的文件\n返回值：\n    关闭文件成功，返回值为0\n    关闭文件失败，返回值非零 \n```\n\n# <center>知识点八：文件的读写</center>\n\n## <center>1、字节读操作</center>\n\n```c\nch = fgetc(fp);\t\t//读一个字节\n说明：从指定文件读一个字节赋给ch（以“读”或“读写”方式打开）\n文件文件：读到结尾返回EOF\n二进制文件：读到文件结尾，使用feof判断结尾\n```\n\n事先本地创建a.text\n\n```c\nvoid test01()\n{\n    char buf[127]=\"\";\n    int i = 0;\n    FILE *fp = NULL;\n    //1、 使用fopen打开一个文件获得文件指针\n    fp = fopen(\"a.txt\", \"r\") ;\n    if(fp == NULL)\n    {\n        perror(\"fopen\") ;\n        return ;\n    }\n    //2、对文件的操作\n    while(1)\n    {\n        //fgetc调用一次  读取到一个字节 \n        buf[i] = fgetc(fp);\n        if(buf[i] == EOF)//EOF表已经对到文件末尾\n        {\n            break ;\n        }\n        i++;\n    }\n    printf(\"buf = %s\\n\",buf);\n    //3、 关闭文件\n    fclose(fp);\n}\n```\n\n## <center>2、字节写操作</center>\n\n```c\n形式：fputc(ch,fp);\t\t//写一个字符\n说明：把一个ch变量中的值(1个字节)写到指定文件\n\t如果输出成功，则返回输出的字节\n\t如果输出失败，则返回一个EOF\n注意：EOF是在stdio.h文件中定义的符号常量，值为-1\n```\n\n```c\nvoid test01()\n{\n    char buf[127] = \"\";\n    int i = 0;\n    FILE *fp = NULL;\n    //1、 使用fopen打开一个文件获得文件指针\n    fp = fopen(\"a.txt\", \"w\") ;\n    if(fp == NULL)\n    {\n        perror(\"fopen\") ;\n        return ;\n    }\n    //2、使用fputc进行文件的数据写入\n    printf(\"请输入要写入文件的字符串:\") ;\n    fgets(buf,sizeof(buf),stdin) ;//会获取换行符\n    buf[strlen(buf) - 1] = 0;//去掉键盘输入的换行符\n    //将字符串buf中的元素逐个写入文件中\n    while(buf[i] != '\\0')\n    {\n        fputc(buf[i],fp);\n        i++;\n    }\n    //3、 关闭文件\n    fclose(fp);\n}\n```\n\n## <center>3、字符串写操作</center>\n\n```c\nfputs(\"china\",fp);\t\t//写一个字符串\n说明：\n    向指定的文件写一个字符串\n\t第一个参数可以是字符串常量，字符串数组名或字符指针\n\t字符串末尾的'\\0'不会写到文件中\n```\n\n```c\nvoid test01()\n{\n    char *buf[] = {\"床前明月光\\n\",\"疑是地上霜\\n\"};\n    int n = sizeof(buf)/sizeof(buf[0]);\n    int i = 0;\n    FILE *fp = NULL;\n    //1、 使用fopen打开一个文件获得文件指针\n    fp = fopen(\"a.txt\", \"w\");\n    if(fp == NULL)\n    {\n        perror(\"fopen\");\n        return ;\n    }\n    for(i = 0;i<n;i++)\n    {\n\t\tfputs(buf[i],fp);\n    } \n    //3、 关闭文件\n    fclose(fp);\n}\n```\n\n## <center>4、字符串读操作</center>\n\n获取文件一行的数据\n\n```c\n形式：fgets(str,n,fp);\t\t//读取一个字符串\n说明：从fp指向的文件读入n-1个字符，在读入n-1个字符之前遇到换行符或EOF，读入提前结束，并读取换行符，在最后加一个'\\0'，str为存放数据的首地址\n返回值：\n\t成功：返回读到字符串的首元素地址\n\t失败：返回NULL\n```\n\n```c\nvoid test01()\n{\n    char buf[128] = \"\";\n    char *path = \"a.txt\";\n    //int i = 0;\n    FILE *fp = NULL;\n    //1、 使用fopen打开一个文件获得文件指针\n    fp = fopen(path,\"r\");        //fp = fopen(\"a.txt\",\"r\");\n    //fp = fopen(\"path\",\"r\");    //err打开一个文件名叫\"path\"而不是path指向的文件名\"c. txt\"\n    if(fp == NULL)\n    {\n        perror(\"fopen\");\n        return ;\n    }\n     while(1)\n     {\n         char *ret = NULL;         \n         //从文件中读取一行数据 \n         ret = fgets(buf,sizeof(buf),fp);\n         if(ret == NULL)\n         break;\n         printf(\"%s\\n\",buf);\n     }    \n    //3、 关闭文件\n    fclose(fp);\n}\n```\n\n## <center>5、块读写</center>\n\n### （1）fwrite数据块写操作\n\n使用 fwrite 将数据块写入到文件中\n\n```\n形式：fwrite(buffer,size,count,fp);\n参数说明：\n\tbuffer：指向存储数据空间的首地址的指针\n\tsize：一次写的数据块大小\n\tcount：要写的数据块个数\n\tfp：指向要进行写操作的文件指针\n返回值：实际写的数据块数（不是总数据大小）\n```\n\n```c\ntypedef struct\n{\n    char name[16];\t//姓名\n    int deff;\t\t//防御\n    int atk;\t\t//攻击\n}HERO;\nvoid test01()\n{\n    HERO hero[] = {{\"德玛西亚\",80,60},{\"盲僧\",90,80},{\"小法\", 40,85},{\"小炮\",50,90}};\n    char *path = \"a.txt\";\n    //int i = 0;\n    int n = sizeof(hero)/sizeof(hero[0]);\n    FILE *fp = NULL;\n    //1、 使用fopen打开一个文件获得文件指针\n    fp = fopen(path,\"w\");\n    if(fp == NULL)\n    {\n        perror(\"fopen\");\n        return ;\n    }\n    //fwrite将内存的数据原样的输出到文件中\n    //写入文件的数据不便于用户查看但是不会影响程序的读\n     fwrite(hero,sizeof(HERO),n,fp);    \n    //3、 关闭文件\n    fclose(fp);\n}\n```\n\n### （2）fread数据块读操作\n\n使用 fread 从文件中读取数据块\n\n```c\n形式：fread(buffer,size,count,fp);\n参数说明：\n\tbuffer：指向存储数据空间的首地址的指针\n\tsize：一次读的数据块大小\n\tcount：要读的数据块个数\n\tfp：指向要进行读操作的文件指针\n返回值：实际读的数据块数（不是总数据大小）\n```\n\n```c\ntypedef struct\n{\n    char name[16];\t//姓名\n    int deff;\t\t//防御\n    int atk;\t\t//攻击\n}HERO;\nvoid test01()\n{\n    HERO hero[4]= {\"\"};\n    char *path = \"a.txt\";\n    int i = 0;\n    FILE *fp = NULL;\n    //1、 使用fopen打开一个文件获得文件指针\n    fp = fopen(path,\"r\");\n    if(fp == NULL)\n    {\n        perror(\"fopen\");\n        return ;\n    }\n    fread(hero,sizeof(HERO),4,fp);\n    for(i=0;i<4; i++)\n    {\n        //printf(\" 英雄姓名:《%s》,防御:%d》, 伤害:《%d》\\n\",hero[i].name,hero[i].deff,hero[i].atk);\n        printf(\"英雄姓名:《%s》, 防御:《%d》,伤害:《%d》\\n\",(hero+i)->name,(hero+i)->deff,(hero+i)->atk);\n    }    \n    //3、 关闭文件\n    fclose(fp);\n}\n```\n\n## <center>6、格式化读操作</center>\n\n```c\n读：fprintf(文件指针,格式字符串,输出列表);\n```\n\n```c\ntypedef struct\n{\n    char name[16];//姓名\n    int deff;//防 御\n    int atk;//攻击\n}HERO;\nvoid test01()\n{\n    HERO hero[]= {{\"德玛西亚\",80,60},{\"盲僧\",90,80},{\"小法\", 40,85},{\"小炮\",50,90}};\n    char *path = \"a.txt\";\n    int i = 0;\n    int n = sizeof(hero)/sizeof(hero[0]);\n    FILE *fp = NULL;\n    //1、 使用fopen打开一个文件获得文件指针\n    fp = fopen(path,\"w\");\n    if(fp == NULL)\n    {\n        perror(\"fopen\");\n        return ;\n    }\n    for(i= 0;i<n;i++)\n    {\n        fprintf(fp,\"英雄:%s 防御:%d 攻击:%d\\n\",hero[i].name,hero[i].deff,hero[i].atk);\n    }        \n    //3、 关闭文件\n    fclose(fp);\n}\n```\n\n## <center>7、格式化写操作</center>\n\n```c\n写：fscanf(文件指针,格式字符串,输入列表);\n```\n\n```c\ntypedef struct\n{\n    char name[16];\t//姓名\n    int deff;\t\t//防御\n    int atk;\t\t//攻击\n}HERO;\nvoid test01()\n{\n    HERO hero[4]= {\"\"};\n    char *path = \"a.txt\";\n    int i = 0;\n    //int n = sizeof(hero)/sizeof(hero[0]);\n    FILE *fp = NULL;\n    //1、 使用fopen打开一个文件获得文件指针\n    fp = fopen(path,\"r\");\n    if(fp == NULL)\n    {\n        perror(\"fopen\");\n        return ;\n    }\n    for(i= 0;i<4;i++)\n    {\n        fscanf(fp,\"英雄:%s 防御:%d 攻击:%d\\n\", hero[i].name,&hero[i].deff,&hero[i].atk);\n    }\n    for(i=0; i<4; i ++)\n    {\n        printf(\"%s %d %d\\n\",hero[i].name,hero[i].deff,hero[i].atk);\n    }\n        \n    //3、 关闭文件\n    fclose(fp);\n}\n```\n\n注意：\n\n&ensp;&ensp;&ensp;&ensp;（1）用fprintf和fscanf函数对磁盘文件读写使用方便，但在输入时要将ASCII码转换成二进制形式，在输出时将二进制形式转换成字符，花费时间较多\n\n&ensp;&ensp;&ensp;&ensp;（2）在内存与磁盘频繁交换数据的情况下，最好不用fprintf和fscanf函数，而用fread和fwrite函数\n\n## <center>8、文件随机读写</center>\n\n```c\nvoid test01()\n{\n    char buf[128] =\"\";\n    char *path = \"a.txt\";\n    int i = 0;\n    //int n = sizeof(hero)/sizeof(hero[0]);\n    FILE *fp = NULL;\n    //1、 使用fopen打开一个文件获得文件指针\n    fp = fopen(path,\"w+\");\n    if(fp == NULL)\n    {\n        perror(\"fopen\");\n        return ;\n    }\n    //先往文件中写入一个字符串\"hello file\"\n    fputs(\"hello file\",fp);\n    fclose(fp);\n    \n    //重新打开文件让文件的流指针 回到文件首部\n    fp = fopen(path,\"r\");\n    //在从文件找那个读取该字符串    \n    fgets(buf,sizeof(buf),fp);\n    printf(\"buf = %s\\n\",buf);        \n    //3、关闭文件\n    fclose(fp);\n}\n```\n\n&ensp;&ensp;&ensp;&ensp;&ensp;如果在写的步骤中没有关闭后再打开文件则会读取到右边等的情况\n\n&ensp;&ensp;&ensp;&ensp;&ensp;所以需要文件写完后需要关闭文件然后重新打开文件，让文件流指针指向文件开始位置让变下次的文件读操作\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221525355.png\" alt=\"结果\" style=\"zoom:25%;\" />\n\n## <center>9、复位文件流指针</center>\n\n```c\n形式：rewind(文件指针);\n功能；把文件内部的位置指针移到文件开始位置\n```\n\n```c\nvoid test01()\n{\n    char buf[128] =\"\";\n    char *path = \"a.txt\";\n\n    FILE *fp = NULL;\n    //1、 使用fopen打开一个文件获得文件指针\n    fp = fopen(path,\"w+\");\n    if(fp == NULL)\n    {\n        perror(\"fopen\");\n        return;\n    }\n    //先往文件中写入一个字符串\"hello file\"\n    fputs(\"hello file\",fp);\n    //复位文件流指针\n    rewind(fp); \n    \n    //在从文件找那个读取该字符串    \n    fgets(buf,sizeof(buf),fp);\n    printf(\"buf = %s\\n\",buf);        \n    //3、 关闭文件\n    fclose(fp);\n}\n```\n\n## <center>10、获得文件流指针距离文件首部的字节数</center>\n\n```c\n形式：ftell(文件指针);\n返回值：返回当前位置(距离文件起始位置的字节数)，出错返回-1\n```\n\n```c\nvoid test01()\n{\n    char buf[128] = \"\";\n    char *path = \"a.txt\";\n\n    long file_len = 0;\n    FILE *fp = NULL;\n    //1、 使用fopen打开一个文件获得文件指针\n    fp = fopen(path,\"w+\");\n    if(fp == NULL)\n    {\n        perror(\"fopen\");\n        return;\n    }\n    //先往文件中写入一个字符串\"hello file\"\n    fputs(\"hello file\",fp);\n    //获取文件流指针距离文件首部的字节数\n    file_len = ftell(fp);\n    printf(\"file_len = %ld\\n\",file_len);            \n    //3、关闭文件\n    fclose(fp);\n}\n```\n\n## <center>11、定位文件的流指针 fseek函数</center>\n\n```c\n形式：fseek(文件类型指针,位移量,起始点);\t//一般用于二进制文件\n功能：移动文件中位置指针的位置\n参数说明：\n    位移量：相对 起始点 的偏移量，向前、向后移动的字节数(-10往左边移动10字节，+10往右边移动10字节)\n    起始点：开始添加偏移 位移量 的位置\n    位置指针的位置说明：\n        在文件开头：0\t\t(SEEK_SET)\n        在文件当前位置：1\t(SEEK_CUR)\n        在文件末尾：2\t\t(SEEK_END)\n```\n\n一次性读取文件总数\n\n```c\nvoid test01()\n{\n    char *file_data = NULL;\n    long file_len = 0;\n    char *path = \"a.txt\";\n\n    FILE *fp = NULL;\n    //1、 使用fopen打开一个文件获得文件指针\n    fp = fopen(path,\"r\");\n    if(fp == NULL)\n    {\n        perror(\"fopen\");\n        return ;\n    }\n    //需求:一次性的将文件数据读取到内存中\n    //1、得到文件的总大小\n    //a、 使用 fseek 将文件指针定位到文件尾部\n    fseek(fp,0,2);\n    //b、使用 ftell 计算文件的偏移量==文件的总大小\n    file_len = ftell(fp);\n    //c、使用rewind复位文件流指针\n    rewind(fp);\n    //2、根据文件的总大小合理申请内存空间\n    file_data = (char *)calloc(1,file_len+1);    //+1的目的 内存末尾存放'\\0' \n    if(file_data == NULL)\n    {\n        fclose(fp);\n        return;\n    }\n    //3、一次性将文件数据读入到内存空间\n    fread(file_data,file_len,1,fp);\n    //4、遍历读取到的文件内容\n    printf(\"file_len = %ld\\n\",file_len);\n    printf(\"%s\\n\",file_data);\n    //5、释放堆区空间\n    if(file_len != NULL)\n    {\n        free(file_len);\n        file_len = NULL;\n    }    \n    // 关闭文件\n    fclose(fp);\n}\n```\n\n# <center>知识点九：feof()函数判断文件是否到达文件末尾</center>\n\nEOF宏：只能用于文本文文件\n\nfeof函数：可以用于文本文文件 二进制文件\n\n判断文件是否结束：0：未结束，非0：表示结束\n\n```c\nvoid test01()\n{    \n    char *path = \"a.txt\";\n    int i = 0;\n    FILE *fp = NULL;\n    //1、 使用fopen打开一个文件获得文件指针\n    fp = fopen(path,\"r\");\n    if(fp == NULL)\n    {\n        perror(\"fopen\");\n        return ;\n    }\n    //feof(fp)判断文件是否结束 0:未结束，非 0:表示结束\n    //while(feof(fp) == 0)//文件未结束才循环\n    while( !feof(fp))\n    {\n        char ch = fgetc(fp);\n        printf(\"%c\",ch);\n    }\n    // 关闭文件\n    fclose(fp);\n}\n```\n\n# <center>知识点十：文件加密器</center>\n\n加密过程：\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221526276.png\" alt=\"加密过程\" style=\"zoom: 50%;\" />\n\n解密过程：\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221526917.png\" alt=\"解密过程\" style=\"zoom: 50%;\" />\n","tags":["C语言"],"categories":["编程语言","C语言"]},{"title":"11.链表","url":"/post/9b06d854.html","content":"\n数组的分类：便于遍历\n\n静态数组：int arr[10]数据过多造成空间溢出，数据过小空间浪费\n\n动态数组：malloc calloc realloc 合理利用空间不能快捷的插入或删除数据（会涉及到大量的数据移动）\n\n# <center>知识点一：链表的基本概念</center>\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221509848.png\" alt=\"链表的基本概念\" style=\"zoom: 50%;\" />\n\n链表是一种物理存储上非连续，数据元素的逻辑顺序通过链表中的指针链接次序，实现的一种线性存储结构\n\n链表由一系列节点( 链表中每一个元素称为节点)组成，节点在运行时动态生成(malloc) ，每个节点包括两个部分：\n\n&ensp;&ensp;&ensp;&ensp;1）存储数据元素的数据域&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;2）存储下一个节点地址的指针域\n\n# <center>知识点二：链表结点的定义（结构体实现）</center>\n\n```c\ntypedef struct stu\n{\n    //数据域(自定义)\n    int num;\n    char name[32];\n    float score;\n    //指针域\n    struct stu *next;\t//保存 下一个节点的地址:\n}STU;\n```\n\n# <center>知识点三：静态链表</center>\n\n```c\ntypedef struct stu\n{\n    int num;\n    char name[32];\n    float score;\n    struct stu *next;\t//保存 下一个节点的地址:\n}STU;\nvoid test1()\n{    \n    STU datal = {100, \"德玛\",59};\n    STU data2 = {101, \"小炮\",89};\n    STU data3 = {102, \"小法\",79};\n    STU data4 = {103,\"盲僧\",99};\n    STU data5 = {104, \"快乐风男\",39};\n    //链表头\n    STU *head = NULL;\n    head = &datal;\n    datal.next = &data2;\n    data2.next = &data3;\n    data3.next = &data4;\n    data4.next = &data5;\n    data5.next = NULL;\n    //遍历链表\n    STU *pb = head;\n    while(pb != NULL)\n    {\n        printf(\"%d %s %f\\n\", pb->num, pb->name, pb->score) ;\n        pb = pb->next;    //pb指向下一一个节点\n    }\n}\n```\n\n# <center>知识点四：动态链表</center>\n\n**1、布局整个框架（main.c）**\n\n```c\n#include<stdio.h>\n#include<string.h>\nvoid stu_help(void);\nint main(int argc,char *argv[])\n{\n    stu_help();\n    while(1)\n    {\n        printf(\"请输入操作指令:\");\n        char cmd[32] = \"\";\n        scanf( \"%s\",cmd);\n        if(strcmp(cmd,\"help\") == 0)\n        {\n            printf(\"-----help------\\n\");\n        }\n        else if(strcmp(cmd,\"insert\") == 0)\n        {\n            printf(\"-----insert------\\n\");\n        }\n        else if(strcmp(cmd,\"print\") == 0)\n        {\n            printf(\"-----print------\\n\");\n        }\n        else if(strcmp(cmd,\"search\") == 0)\n        {\n            printf(\"-----search------\\n\");\n        }\n        else if(strcmp(cmd,\"delete\") == 0)\n        {\n            printf(\"-----delete------\\n\");\n        }\n        else if(strcmp(cmd,\"free\") == 0)\n        {\n            printf(\"-----free------\\n\");\n        }\n        else if(strcmp(cmd,\"quit\") == 0)\n        {\n            break;\n        }\n     }        \n    return 0;\n}\nvoid stu_help(void)\n{\n    printf(\"############################\\n\");\n    printf(\"#help:打印帮助信息         #\\n\");\n    printf(\"#insert:插入链表节点       #\\n\");\n    printf(\"#print:遍历链表节点信息    #\\n\");\n    printf(\"#search:查询链表节点       #\\n\");\n    printf(\"#delete:删除链表节点       #\\n\");\n    printf(\"#free:释放链表             #\\n\");\n    printf(\"#quit:退出                 #\\n\");\n    printf(\"############################\\n\");\n    return;\n}\n```\n\n**2、链表插入节点之头部之前插入**\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221509161.png\" alt=\"链表插入节点之头部之前插入\" style=\"zoom: 50%;\" />\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221509088.png\" alt=\"头部之前插入原理分析图\" style=\"zoom: 50%;\" />\n\n**3、在链表尾部插入**\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221509111.png\" alt=\"链表尾部插入\" style=\"zoom: 50%;\" />\n\n**4、链表的有序插入**\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221509363.png\" alt=\"链表有序插入\" style=\"zoom: 33%;\" />\n\n# <center>知识点五：链表查询某个节点</center>\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221509605.png\" alt=\"链表查询某个节点\" style=\"zoom: 50%;\" />\n\n# <center>知识点六：删除链表指定节点</center>\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221510308.png\" alt=\"删除链表指定节点\" style=\"zoom: 33%;\" />\n\n# <center>知识点七：链表的释放</center>\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221510500.png\" alt=\"链表的释放\" style=\"zoom: 33%;\" />\n\n```c\nSTU* free_link(STU *head)\n{\n    //1、判断链表是否存在\n    if(head == NULL)//不存在 \n    {\n        printf(\"link not found\\n\");\n        retrun head;\n    } \n    else\t//存在 \n    {\n        STU *pb = head;\n        //逐个节点释放\n        while(pb != NULL)\n        {\n            //head保存下一个节点的位置\n            head = pb->next;\n            //释放pb指向的节点\n            free(pb);\n            //pb指向head\n            pb = head; \n        }\n        printf(\"链表已经释放完毕\\n\"); \n        return head;\n    }\n    return head;\n}\n```\n\n# <center>知识点八：链表逆序</center>\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221510180.png\" alt=\"链表逆序\" style=\"zoom: 33%;\" />\n\n```c\nSTU* reverse_link(STU *head)\n{\n    //1、判断链表是否存在\n    if(head == NULL)//不存在 \n    {\n        printf(\"link not found\\n\");\n        retrun head;\n    } \n    else//存在 \n    {\n        //int *p,num;     //p为int *, num为int\n        STU *pb,*pr;    //pb为STU *,pr 为STU *\n        //pb保存head->next ( 原因head->next会置NULL)\n        pb = head->next;\n        //将head->next置NULL(原因:头节点变尾节点)\n        head->next = NULL;\n        while(pb != NULL)\n        {\n            //pr 保存pb->next ( 原因:pb->next会指向head)\n            pr = pb -> next;\n            //pb->next指向head ( 原因:逆转方向)\n            pb->next = head ;\n            //保存逆转方向的代码可以重复执行\n            head = pb;\n            pb = pr;\n        }\n        return head;\n    }\n    return head;\n}\n```\n\n# <center>知识点九：链表排序</center>\n\n选择法排序：（以数组实现）\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221510809.png\" alt=\"链表排序\" style=\"zoom: 33%;\" />\n\n```c\n#include<stdio.h>\nint main()\n{\n    int arr[10] = {0};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    int i = 0,j = 0,min = 0;\n    printf(\"请输入%d个int数据\\n\", n);\n    for(i = 0; i<n; i++)\n    {\n        scanf(\"%d\",arr+i);\n    }\n    for(i = 0;i < n-1;i++)\n    {\n        for(min = i,j = min+1;j < n;j++)\n        {\n            if (arr[min] > arr[j])\n            min = j;\n        }\n        if (min != i)\n        {\n            int tmp = 0;\n            tmp = arr[i];\n            arr[i] = arr[min];\n            arr [min] = tmp;\n        }\n    }\n    for(i = 0;i < n;i++) \n    {\n        printf(\"%d \",arr[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\n\n选择法排序：（以链表实现）\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221510620.png\" alt=\"链表排序1\" style=\"zoom: 67%;\" />\n\n# <center>知识点十：认识双向链表</center>\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221511384.png\" alt=\"双向链表\" style=\"zoom: 67%;\" />\n\n# <center>知识点十一：双链表插入</center>\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221511166.png\" alt=\"双链表插入\" style=\"zoom: 67%;\" />\n\n# <center>知识点十二：双向链表删除指定节点</center>\n\n![双向链表删除指定节点1](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221511759.png)\n\n![双向链表删除指定节点2](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221511653.png)\n\n# <center>知识点十三：结构的浅拷贝和深拷贝</center>\n\n**1、指针变量作为结构体的成员**\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221521063.png\" alt=\"指针变量作为结构体的成员\" style=\"zoom: 33%;\" />\n\n```c\ntypedef struct\n{\n    int num;\n    char *name;//指针变量作为结构体的成员\n}DATA;\nvoid test01()\n{\n    DATA data = {100, \"hehehehaha\"};\n    printf(\"%d\\n\",sizeof(DATA));//8字节\n    printf(\"num = %d\\n\" ,data.num) ;\n    //指针变量作为结构体的成员保存的是空间的地址\n    printf(\"name = %s\\n\", data. name);\n}\n```\n\n**2、指针变量作为结构体的成员 操作前 必须有合法空间**\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221521824.png\" alt=\"指针变量作为结构体的成员1\" style=\"zoom: 50%;\" />\n\n```c\nvoid test02()\n{\n    DATA data;\n    printf( \"%d\\n\",sizeof(DATA));\n    printf(\"num = %d\\n\", data.num) ;\n    //指针变量作为结构体的成员操作前必须有合法的空间\n    //data.name = \"hehe\" ;\n    //给name事先申请一块堆区空间\n    data.name = (char *)calloc(1,10);\n    strcpy(data.name,\"hahaha\");\n    printf(\"name = %s\\n\", data.name ) ;\n    //如果name指向堆区空间一定要记得释放\n    if(data. name != NULL )\n    {\n        free(data. name) ;\n        data. name = NULL;\n    }\n}\n```\n\n**3、指针变量作为结构体成员，结构体变量间的赋值操作容易导致“浅拷贝”发生**\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221521074.png\" alt=\"指针变量作为结构体的成员2\" style=\"zoom: 50%;\" />\n\n运行结果：出现段错误\n\n两个结构体变量中的指针成员指向同-块堆区空间\n\n```c\nvoid test03()\n{\n    DATA data1;\n    DATA data2;\n    data1.num = 100;\n    data1.name = (char *)calloc(1,10);\n    strcpy(data1.name,\"my data\");\n    //指针变量作为结构体的成员结构体变量间的赋值操作容易导致\"浅拷贝”发生\n    data2 = data1;    //\"浅拷贝”\n    printf(\"data2: num = %d,name = %s\\n\", data2.num,data2.name); \n     if(datal.name != NULL)\n    {\n        free(data1.name);\n        data1.name = NULL;\n    }\n    if( data2.name != NULL)\n    {\n        free(data2.name);\n        data2.name = NULL;\n    }\n}\n```\n\n**4、深拷贝**\n\n前提：是指针变量作为结构体的成员\n\n两个结构体变量中的指针成员指向各自的堆区空间\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221521447.png\" alt=\"深拷贝\" style=\"zoom:33%;\" />\n\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\ntypedef struct\n{\n    int num;\n    char *name;\n} DATA;\nvoid test01()\n{\n    DATA datal ;\n    DATA data2 ;\n    datal.num = 100;\n    datal.name = (char *)calloc(1,12);\n    strcpy (datal.name,\"my data\");\n    data2. num = datal. num;\n    //为结构体变量 申请 独立空间 \n    data2.name = (char *)calloc(1,12);\n    strcpy(data2.name,datal.name) ;\n    printf(\"data1:num = %d,name = %s\\n\",datal.num,datal.name);\n    printf(\"data2:num = %d,name = %s\\n\",data2.num,data2.name);\n    if (datal.name!=NULL)\n    {\n        free(datal.name);\n        datal.name = NULL;\n    }\n    if (data2.name!=NULL)\n    {\n        free(data2.name);\n        data2.name = NULL;\n    }\n}\n```\n\n","tags":["C语言"],"categories":["编程语言","C语言"]},{"title":"10.结构体、共用体、枚举","url":"/post/5bdb5548.html","content":"\n# <center>知识点一：结构体的定义形式</center>\n\n头文件：<font color=\"red\">`#include<string.h>`</font>\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221505290.png\" alt=\"结构体定义\" style=\"zoom:50%;\" />\n\n```c\n//struct：结构体关键字\n//stu：结构体类型名，指定了一个结构体类型，它相当于一个模型，但其中并无具体数据，系统对之也不分配实际内存单元\n\n//使用结构体类型必须是struct stu\n//num name age叫做结构体中的成员\n//定义结构体类型的时候不要给成员赋值（重要）\n//定义结构体类型的时候 并没有分配空间 所以不能给成员赋值       \n\nstruct stu \n{\n    int num;\n    char name[32];\n    int age;\n};        //一定要记得有;号\n```\n\n结构体中的成员拥有独立的空间\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221505038.png\" alt=\"结构体独立空间\" style=\"zoom: 50%;\" />\n\n# <center>知识点二：结构体变量的定义</center>\n\n```c\nstruct stu\n{\n    int num;\t//4B\n    char name [32];//32B\n    int age;\t//4B\n};\n\nvoid test1(void)\n{\n    //就用结构体类型定义一个变量\n    struct stu lucy;\t//lucy 是局部变量 lucy的成员内容不确定\n    //通过结构体变量访问结构体中的成员(访问时一定要遵循成员自身的类型)\n    lucy.num = 100;\n    strcpy (lucy.name,\"德玛西亚\");\n    lucy.age = 18;\n\n    printf(\"num = %d\\n\",lucy.num);\n    printf(\"name = %s\\n\",lucy.name);\n    printf(\"age = %d\\n\",lucy.age);\n}\n```\n\n# <center>知识点三：结构体变量的初始化</center>\n\n```c\nstruct stu\n{\n    int num;\t\t//4B\n    char name [32];\t//32B\n    int age;\t\t//4B\n};\n\nvoid test1(void)\n{\n    //初始化的顺序必 须和 结构体成员的顺序一致\n    struct stu lucy = {100,\"德玛西亚\",18};\n    printf(\" num = %d,name = %s,age = %d\\n\", lucy.num,lucy.name,lucy.age);\n    //清空结构体变量\n    memset(&lucy,0,sizeof(lucy));\n}\n```\n\n# <center>知识点四：结构体变量获取键盘输入</center>\n\n```c\nstruct stu\n{\n    int num;\t\t//4B\n    char name [32];\t//32B\n    int age;\t\t//4B\n};\nvoid test1(void)\n{\n    struct stu lucy;\n    memset(&lucy,0,sizeof(lucy));\n    printf(\"请输入num name_age:\") ;\n    //&lucy.num取的是num成员地址\n    scanf(\"%d %s %d\",&lucy.num,&lucy.name,&lucy.age);\n    printf(\"num = %d,name = %s,age = %d\\n\",lucy.num,lucy.name,lucy.age);\n}\n```\n\n# <center>知识点五：结构体变量之间的赋值</center>\n\n## <center>内存拷贝</center>\n\nmemcpy：内存块中的数据从一个地方复制到另一个地方\n\n```c\nmemcpy(void *str1, const void *str2, size_t n);\n参数说明：\n    str1：指向用于存储复制内容的目标数组，类型强制转换为 void* 指针\n    str2：指向要复制的数据源，类型强制转换为 void* 指针\n    n：要被复制的字节数\n```\n\n```c\nstruct stu\n{\n    int num;\t\t//4B\n    char name [32];\t//32B\n    int age;\t\t//4B\n};\nvoid test1(void)\n{\n    struct stu lucy = {100,\"小法\",18} ;\n    struct stu bob;\n    //需求将lucy的值赋值bob\n    //方式一：逐个成员赋值\n    //bob.num = lucy.num;\n    //strcpy(bob.name,lucy.name);\n    //bob.age = lucy.age;\n    //方拾二：相同类型的结构体变量 可以直接赋值(推荐)\n    //bob = lucy;    \n    //方法三：方法二的底层实现\n    memcpy(&bob, &lucy,sizeof(struct stu));\n    printf(\"num = %d,name = %s,age = %d\\n\",bob.num,bob.name,bob.age);\n}\n```\n\n# <center>知识点六：结构体数值</center>\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221505727.png\" alt=\"结构体数值\" style=\"zoom:50%;\" />\n\n```c\nstruct stu\n{\n    int num;\t\t//4B\n    char name [32];\t//32B\n    int age;\t\t//4B\n};\nvoid test1(void)\n{\n    struct stu arr[5]={\n        {100,\"小法\",18},\n        {101,\"德玛西亚\",19},\n        {102,\"盲僧\",20},\n        {103,\"快乐风男\",30},{104,\"提莫\",8}};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    int i = 0;\n    for(i = 0;i < n;i++)\n    {\n        printf(\"num = %d,name = %s,age = %d\\n\",arr[i].num, arr[i].name,arr[i].age);\n    }\n}\n```\n\n# <center>知识点七：冒泡排序</center>\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221505344.png\" alt=\"冒泡排序\" style=\"zoom: 67%;\" />\n\n```c\n#include<stdio.h>\n#include<stdlib.h>\nvoid test1(void)\n{\n    int n = 0;\n    int i,j = 0;\n    int *arr = NULL;\n    printf(\"请输入数据的个数:\");\n    scanf (\"%d\",&n);\n    //根据元素的个数申请空间\n    arr = (int *)calloc(n,sizeof(int));\n    if(NULL == arr)\n    {\n        perror(\"calloc\");\n        return;\n    }\n     //键盘给动态数组获取输入\n    printf(\"请输入%d个int数据\\n\",n);\n    for(i = 0;i < n;i++)\n    {\n        scanf(\"%d\",arr+i);//arr+i 第i个元素的地址\n    }\n    //排序\n    for(i = 0;i < n-1;i++)\n    {\n        for(j = 0; j < n-i-1;j++)\n        {\n            if(arr[j] > arr[j+1])    //从小到大排列 \n            {\n                int tmp = 0;\n                tmp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = tmp;\n            }            \n        }        \n    }\n    //数组的遍历\n    for(i = 0;i < n; i++)\n    {\n        printf(\"%d \",arr[i]);        \n    }\n    printf(\"\\n\");\n    //释放空间\n    if(arr != NULL)\n    {\n        free(arr) ;\n        arr = NULL;\n    }\n}\n```\n\n升级版\n\n```c\n#include<stdio.h>\n#include<stdlib.h>\nvoid test1(void)\n{\n    int n = 0;\n    int i,j = 0;\n    int *arr = NULL;\n    printf(\"请输入数据的个数:\");\n    scanf (\"%d\",&n);\n    //根据元素的个数申请空间\n    arr = (int *)calloc(n,sizeof(int));\n    if(NULL == arr)\n    {\n        perror(\"calloc\");\n        return;\n    }\n     //键盘给动态数组获取输入\n    printf(\"请输入%d个int数据\\n\",n);\n    for(i = 0;i < n;i++)\n    {\n        scanf(\"%d\",arr+i);\t//arr+i 第i个元素的地址\n    }\n    //排序\n    for(i = 0;i < n-1;i++)\n    {\n        int flag = 0; \n        for(j = 0; j < n-i-1; j++)\n        {\n            if(arr[j] > arr[j+1])    //从小到大排列 \n            {\n                int tmp = 0;\n                tmp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = tmp;\n            }            \n        }\n        if(flag == 0)    //数组已经有序 \n        break;        \n    }\n    //数组的遍历\n    for(i = 0;i < n; i++)\n    {\n        printf(\"%d \",arr[i]);        \n    }\n    printf(\"\\n\");\n    //释放空间\n    if(arr != NULL)\n    {\n        free(arr);\n        arr = NULL;\n    }    \n}\n```\n\n结构体数组排序\n\n```c\n#include<stdio.h>\n#include<string.h>\nstruct stu\n{\n    int num;\t\t//4B\n    char name [32];\t//32B\n    int age;\t\t//4B\n};\n\nvoid test1(void)\n{\n    struct stu arr[5];\n    int i,j = 0;\n    int n = sizeof (arr)/sizeof(arr[0]);\n    memset (arr,0,sizeof(arr));\t\t//整个数组清0\n    //获取键盘输入\n    printf(\"请输入%d个学生信息\\n\",n) ;\n    for(i=0;i<n; i++)\n    {\n        scanf(\"%d %s %d\",&arr[i].num,arr[i].name,&arr[i].age);\n    }\n    //根据学号排序\n    for(i = 0;i < n-1;i++)\n    {\n        for(j = 0; j < n-i-1;j++)\n        {\n            if(arr[j].num < arr[ j+1].num) //按照num的从大到小排序\n            {\n                struct stu tmp;\n                tmp = arr[j] ;\n                arr[j] = arr[j+1];\n                arr[j+1] = tmp;\n            }\n        }        \n    }\n    //遍 历\n    printf(\"--------------\\n\") ;\n    for(i = 0;i < n;i++)\n    {\n        printf(\"%d %s %d\\n\",arr[i].num,arr[i].name,arr[i].age);\n    }\n}\n```\n\n# <center>知识点八：typedef 给已有的类型取个别名</center>\n\n## 1、给int取个别名INT32\n\n```c\n#include<stdio.h>\n// typedef使用步骤:\n//1、先用已有的类型_ 定义一个变量      int num;\n//2、用别名替换变量名            \tint INT32;\n//3、在整个表达式前添加typedef        typedef int INT32;\n//注意：不能创造新的类型\ntypedef int INT32;\nvoid test1()\n{\n    INT32 num = 10;\n    printf(\"num = %d\\n\",num);//10\n}\n```\n\n## 2、给数组取个别名\n\n```c\n//ARR_TYPE 就是数组类型,该数组必须有5个元素 每个元素为int\ntypedef int ARR_TYPE[5];\nvoid test1()\n{\n    ARR_TYPE arr = {10, 20, 30, 40, 50}; //arr就是一个拥有5个元素每个元素为int的数\n    int i = 0;\n    for(i = 0;i < 5;i++)\n    {\n        printf(\"%d \",arr[i]);\n    }\n    printf(\"\\n\") ;\n}\n```\n\n## 3、给指针取别名\n\n```c\ntypedef int *P_TYPE;\nvoid test1()\n{\n    int num = 10;\n    P_TYPE p = &num;    //P_TYPE p == int *p\n    printf(\"*p = %d\\n\", *p);\t//10 \n}\n```\n\n## 4、给函数指针取别名\n\n```c\nint my_add(int x,int y)\n{\n    return x+y;\n}\n//FUN_P是一个函数指针类型 该函数必须有两个int形参以及一个int返回值\ntypedef int (*FUN_P)(int x, int y);\nvoid test1()\n{\n    FUN_P p = my_add;\n    printf(\"%d\\n\",p(100,200));    //300;\n}\n```\n\n## 5、给结构体类型取个别名\n\n```c\ntypedef struct stu\n{\n    int num;\n    char name[32];\n    int age;\n}STU;    //STU == struct stu\nvoid test1()\n{\n    STU lucy = {100,\"lucy\",18};\n}\n```\n\n# <center>知识点九：结构体指针</center>\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221506563.png\" alt=\"结构体指针\" style=\"zoom: 67%;\" />\n\n```c\ntypedef struct stu\n{\n    int num;\n    char name[16];\n    int age;\n}STU;    //STU是结构体类型\nvoid test1()\n{\n    STU lucy = {100,\"lucy\",18};\n    STU *p = &lucy;\n    printf(\"num = %d,name = %s,age = %d\\n\",lucy.num,lucy.name,lucy.age);\n    //注意：如果是结构体指针需要用下面两种方式输出\n    printf(\"num = %d,name = %s,age = %d\\n\",(*p).num,(*p).name,(*p).age);\n    printf(\"num = %d,name = %s,age = %d\\n\",p->num,p->name,p->age);\n    printf(\"num = %d\\n\",(&lucy)->num);\n}\n```\n\n# <center>知识点十：结构体指针作为函数的参数</center>\n\n```c\n#include<stdio.h>\n#include<string.h>\n\ntypedef struct stu\n{\n    int num;\n    char name[16];\n    int age;\n}STU;    //STU是结构体类型\nvoid mySetSTUData(STU *p)\t//p=&lucy\n{\n    printf(\"请输入一个学生的信息num name age\\n\");\n    scanf(\"%d %s %d\",&p->num,p->name,&p->age);\n    return;\n}\nvoid myPrintSTUData(const STU *p)\t//tmp =lucy    *p只读 \n{\n    //constSTU*p不允许用户借助p修改 p所指向的空间内容\n    printf(\"num = %d,name = %s,age = %d\\n\",p->num,p->name,p->age);\n}\nvoid test1()\n{\n    STU lucy;\n    memset(&lucy,0,sizeof(lucy));\n    //定义一个函数给lucy的成员获取键盘输入\n    mySetSTUData(&lucy);\n    //定义一个函数 打印lucy的成员信息\n    myPrintSTUData(&lucy);    \n}\n```\n\n# <center>知识点十一：结构体内存对齐</center>\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221506002.png\" alt=\"结构体内存对齐\" style=\"zoom: 50%;\" />\n\n**对齐规则：**\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221507085.png\" alt=\"对齐规则\" style=\"zoom: 50%;\" />\n\n```c\nstruct data \n{\n    char c;\t// 1B\n    int i;\t//4B\n};\nvoid test1()\n{    \n    //结构体的大小>=成员大小之和\n    printf(\"%d\\n\",sizeof(struct data));\t//8\n    struct data d;\n    printf(\"&d.c = %u\\n\",&d.c);\n    printf(\"&d.i = %u\\n\",&d.i);\n}\n```\n\n# <center>知识点十二：结构体嵌套结构体</center>\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221507173.png\" alt=\"结构体嵌套结构体\" style=\"zoom: 50%;\" />\n\n```c\ntypedef struct\n{\n    int x;\n    int y;\n}DATA2;\ntypedef struct\n{\n    int a;\n    int b;\n    DATA2 c;\t//结构体变量c作为了DATA3的成员叫结构体嵌套结构体\n}DATA3;\nvoid test1()\n{    \n    //DATA3 data = {10, 20, 30, 40};\n    DATA3 data = {10,20, {30,40}};\t//推荐\n    printf(\"a = %d\\n\",data.a);\n    printf(\"b = %d\\n\",data.b);\n    printf(\"x = %d\\n\",data.c.x);    //访问最底层 \n    printf(\"y = %d\\n\",data.c.y);\n}\n```\n\n# <center>知识点十三：结构体嵌套结构体的内存对齐</center>\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221507721.png\" alt=\"内存对齐\" style=\"zoom: 67%;\" />\n\n```c\ntypedef struct\n{\n    short d;\n    char e;\n}DATA2;\ntypedef struct\n{\n    short a;\n    int b;\n    DATA2 c;\n    char f;\n}DATA;\nvoid test1()\n{    \n    printf(\"%d\\n\", sizeof(DATA));\n    DATA data;\n    printf (\"a：%u\\n\",&data.a);\n    printf(\"b：%u\\n\",&data.b);\n    printf(\"c中d: %u\\n\",&data.c.d);\n    printf(\"c中e: %u\\n\", &data.c.e);\n    printf(\"f：%u\\n\",&data.f);\n}\n```\n\n# <center>知识点十四：指定对齐原则</center>\n\n1、使用#pragmapack改变默认对其原则\n\n格式：#pragma pack (value) 时的指定对齐值value\n\n注意:\n\n&ensp;&ensp;&ensp;&ensp;&ensp;1）value只能是:1248等\n\n&ensp;&ensp;&ensp;&ensp;&ensp;2）指定对齐值与数据类型对齐值相比取较小值\n\n&ensp;&ensp;&ensp;&ensp;&ensp;如:如果指定对齐值:\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;设为1：则short、 int、 float等均为1\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;设为2：则char仍为1，short为2，int变为2\n\n步骤:\n\n&ensp;&ensp;&ensp;&ensp;&ensp;1）确定分单位:每一 -行应该分配的字节数,min(value，默认分配单位)\n\n&ensp;&ensp;&ensp;&ensp;&ensp;2）成员偏移量=成员自身类型的整数(0~n)倍\n\n&ensp;&ensp;&ensp;&ensp;&ensp;3）收尾工作=分配单位的整数(0~n) 倍\n\n```c\n//指定对齐规则\n#pragma pack(2)\ntypedef struct\n{\n    char a;\n    int b;\n    short C;\n}DATA1;\n\nvoid test1()\n{    \n    printf (\"%d\\n\",sizeof(DATA1));    //8\n    return;\n}\n```\n\n# <center>知识点十五：位段</center>\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221507229.png\" alt=\"位段\" style=\"zoom: 50%;\" />\n\n**位段的使用**\n\n```c\n//位段 一般只考虑unsigned int类型也可以考虑unsi gned char\ntypedef struct\n{\n    unsigned char a:2;\t//a只占一个字节中的两位二进制位\n    unsigned char b:2;\t//b只占一个字节中的两位二进制位\n    //相邻位域可以压缩( 压缩的位数 不能超过  成员自身大小)\n    unsigned char c:5;\n}DATA2;\nvoid test1()\n{    \n    printf (\"%d\\n\",sizeof(DATA2));\t//2\n    DATA2 data;\n    //位段不能取地址\n    //printf(\"%p\\n\",&data.a);\n    //位段的赋值不要操作位段的大小a:2\n    data.a = 6;    //0110\n    printf(\"%u\\n\",data.a);    //2\n    return;\n}\n```\n\n**无意义位段**\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221507256.png\" alt=\"无意义位段\" style=\"zoom: 50%;\" />\n\n```c\ntypedef struct\n{\n    unsigned char a:2;\t//00\n    unsigned char :4;\t//无意 义的位段( 占有两位)\n    unsigned char b:2;\t//1 1\n}DATA3;\n\nvoid test1()\n{    \n    DATA3 data;\n    memset (&data,0,1);\n    data.a = 0;    //00\n    data.b = 3;    //11\n    printf(\"%d\\n\", sizeof(DATA3));\n    printf(\"%#x\\n\",*(unsigned char *)&data);    //1100 0000/ /0xc0  a是高位，b是低位\n    return;\n}\n```\n\n**应用场景**\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221508444.png\" alt=\"应用场景\" style=\"zoom: 50%;\" />\n\n**另起一个位段**\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221508368.png\" alt=\"另起一个位段\" style=\"zoom: 50%;\" />\n\n```c\ntypedef struct\n{\n    unsigned char a:2;   //00\n    unsigned char :0;    //另起一个位段\n    unsigned char b:2;   //11\n}DATA4;\nvoid test1()\n{    \n    printf (\"%d\\n\",sizeof(DATA4));\n    return;\n}\n```\n\n# <center>知识点十六：共用体与结构体的区别</center>\n\n结构体：struct\n\n所有的成员拥有独立的空间\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221508963.png\" alt=\"共用体与结构体的区别\" style=\"zoom:33%;\" />\n\n```c\nstruct stu\n{\n    char a;\n    short b;\n    int C;\n};\t// a  b  c成员有用独立的空间\n```\n\n共用体（联合体）union\n\n所有的成员共享同一份空间\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221508031.png\" alt=\"共用体与结构体的区别1\" style=\"zoom: 50%;\" />\n\n```c\nstruct stu\n{\n    char a;\n    short b;\n    int c;\n};\t// a  b  c成员有用共享一份空间\n```\n\n# <center>知识点十七：共用体</center>\n\n```c\nunion data\n{\n    char a;\n    short b;\n    int c;\n};\nvoid test1()\n{    \n    printf(\"%d\\n\",sizeof(union data));\t//4\n    union data A;\n    A.a = 10;\n    A.b = 20;\n    A.c = 30;\n    printf(\"%d\\n\",A.a + A.b + A.c);    //90\n}\n```\n\n共用体虽然共有同一份空间但是从空间读取的字节数是有成员自身类型决定\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221508110.png\" alt=\"共用体1\" style=\"zoom:50%;\" />\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221508373.png\" alt=\"共用体2\" style=\"zoom: 50%;\" />\n\n```c\nunion data\n{\n    char a;\n    short b;\n    int c;\n};\nvoid test1()\n{    \n    printf(\"%d\\n\", sizeof(union data));\t//4\n    union data A;\n    A.c = 0x01020304;\n    A.b = 0x0102;\n    A.a = 0x01;\n    printf(\"%#x\\n\",A.a+A.b+A.c);    \n}\n```\n\n# <center>知识点十八：枚举</center>\n\n枚举\n\n&ensp;&ensp;&ensp;&ensp;&ensp;将变量的值一一列举出来，变量的值只限于列举出来的值的范围内\n\n枚举类型定义:\n\n```c\nenum 枚举名\n{\n    枚举值表\n};\n```\n\n在枚举值表中应列出所有可用值，也称为枚举元素，枚举变量仅能取枚举值所列元素\n\n```c\n//枚举列表的值:默认从0开始\nenum POKER {HONGTAO,HEITAO=30,MEIHUA=40,FANGKUAI};\nvoid test1()\n{    \n    //poker_ color的取值为HONGTAO，HEITAO， MEIHUA， FANGKUAI中某一个\n    enum POKER poker_color = HEITAO;\n    printf(\"poker_ olor = %d\\n\",poker_color);    //30\n    printf(\"HONGTAO = %d\\n\",HONGTAO);   //0\n    printf(\"HEITAO = %d\\n\",HEITAO);    \t//30\n    printf(\"MEIHUA = %d\\n\",MEIHUA);    \t//40\n    printf(\"FANGKUAI = %d\\n\",FANGKUAI); //41\n}\n```\n\n","tags":["C语言"],"categories":["编程语言","C语言"]},{"title":"9.字符串","url":"/post/bec635c1.html","content":"\n# <center>知识点一：指针保存字符串</center>\n\n```c\n#include<stdio.h>\nvoid main()\n{\n    char* a = \"hello111\";\t//指针变量a 指向 字符串首地址\n    printf(\"%s\",a);\n}\n```\n\n# <center>知识点二：一维<mark>字符</mark>数组</center>\n\n字符数组：本质是数组，只是数组的每个元素是字符\n\n## <center>1、字符数组的初始化</center>\n\n逐个<mark>字符</mark>初始化 \n\n```c\nchar str[6]={'h','e','1','1','o'};\n//str[0] == 'h'的ASCII值\n```\n\n以<mark>字符串</mark>的形式初始化  （推荐）\n\n```c\nchar str[6] = \"hel1o\";\n```\n\n## <center>2、逐个字符初始化和字符串初始化的区别</center>\n\n&ensp;&ensp;&ensp;&ensp;&ensp;1）在没有确定数组个数的前提下，逐个<mark>字符</mark>初始化系统<mark>不会</mark>添加<font color=\"red\"> '\\0' </font>，以<mark>字符串</mark>初始化系统<mark>会</mark>给字符串添加 <font color=\"red\"> ’\\0'</font>\n\n&ensp;&ensp;&ensp;&ensp;&ensp;2）<mark>%s</mark>：输出的内容从数组的第0个元素开始逐个元素输出直到<mark>遇到 '\\0' 结束</mark>，逐个<mark>字符</mark>初始化用 %s 输出由于<mark>没有 '\\0' </mark>所以后面会导致出现乱码等情况，而用<mark>字符串</mark>初始化输出则不会\n\n## <center>3、字符数组的遍历</center>\n\n```c\nvoid test02( )\n{\n    char str[6]=\"hello\";\n    //方法一：逐个字符遍历\n    int i=0;\n    for(i=0;i<6;i++)\n    {\n        printf(\"%c\",str[i]);\n    }\n    printf(\"\\n---------------\\n\");\n    //方法二：字符数组可以整体遍历推荐\n    printf(\"%s\\n\"，str);\n    //方法三：使用puts输出\n    puts(str);\n}\n```\n\n## <center>4、获取键盘的字符串</center>\n\n&ensp;&ensp;&ensp;&ensp;&ensp;定义一个字符数组有足够大的空间\n\n```c\nchar buf[128] = \"\";\nscanf(\"%s\",buf);    //第一种方式\ngets(buf);         //第二种方式\n```\n\nscanf 和 %s 使用的时候有个缺点：遇到<font color=\"red\">空格</font>会结束输入\n\n<mark>gets</mark>缺点：获取键盘输入的时候<mark>不会管buf的大小</mark>容易造成内存污染\n\n## <center>5、fgets函数</center>\n\n**既可以获取带空格的字符串也可以保证buf的不越界**\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221500336.png\" alt=\"fgets函数解析\" style=\"zoom: 50%;\" />\n\n```c\n#include<stdio. h> \nchar *fgets(char *S，int size, FILE *stream )\n//s：表示存放字符串的空间地址\n//size 能够提取字符中的最大长度 size-1\n//stream写成stdin（标准输入设备） 表示标准输入设备\n\n#include<stdio.h>\nvoid test9()\n{\n    char buf[10] = \"\";\n    printf(\"请输入一个字符串\\n\");\n    scanf(\"%s\",buf);\n    //gets(buf);\n    fgets(buf,sizeof(buf),stdin);\n    printf(\"buf = %s\\n\",buf);\n}\n\nint main(int argc,char *argv[])\n{\n    test9();\n    return 0;\n}\n```\n\n## 6、字符串大小写转换\n\n&ensp;&ensp;&ensp;&ensp;&ensp;说明<mark>小</mark>字母和<mark>大</mark>写字母的ASCII码差值是<font color=\"red\">32</font>\n\n```c\n#include<stdio.h> \nvoid test10 () \n{\n    //'a' 97'b'98'c'99~'z’122\n    //'A' 65 'B' 66 'C' 67'Z'90\n    //说明小字母和大写字母的差值是32\n    char ch='a';\n    //小写 变 大写  -32\n    ch = ch -32;            //ch = ch - ('a'-'A');\n    printf(\"ch =%c\\n\", ch);\t//ch = A\n    //大写 变 小写  +32\n    ch = ch+32;        \t\t//ch = ch < ('a'-'A') ;\n    printf(\"ch =%c\\n\", ch);\t//ch = a\n}\nint main(int argc,char *argv[])\n{\n    test10();\n    return 0;\n}\n```\n\n# <center>知识点三：二维字符数组</center>\n\n&ensp;&ensp;&ensp;&ensp;<mark>一维</mark>字符数组是存放 多个<font color=\"red\">字符</font> 的\n\n&ensp;&ensp;&ensp;&ensp;<mark>二维</mark>字符数组是存放 多个<font color=\"red\">字符串</font> 每个字符串占一行\n\n&ensp;&ensp;&ensp;&ensp;不管是数值还是字符的二维数组，在初始化的时候是可以省略行标的，行数由具体初始化元素个数和列数决定出所需要的行数\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221500917.png\" alt=\"二维数组解析\" style=\"zoom: 50%;\" />\n\n&ensp;&ensp;&ensp;&ensp;&ensp;如果要输出整个字符只需输出str[0]，则就是对应的整个字符，如果要输出字符串里面的某一个字符则需要str\\[0][3],与数值二维数组不同\n\n&ensp;&ensp;&ensp;&ensp;&ensp;str[0]就是第一行存放hehe的首地址\n\n```c\n#include<stdio.h>\nvoid test11()\n{\n    char arr [3][16] = {\"hehe\",\"haha\",\"heihei\"};\n    //输出一个字符串  仅仅使用行标\n    printf(\"%s\\n\",arr[0]);\t\t//hehe\n    printf(\"%s\\n\",arr[1]);\t\t//haha\n    printf(\"%s\\n\",arr[2]);\t\t//heihei\n    //输出的是 字符串中的某个字符 必须用行标和列标 \n    printf(\"%s\\n\",arr[1][3]);\n} \nint main(int argc,char *argv[])\n{\n    test11();\n    return 0;\n}\n```\n\n二维字符数组获取键盘输入的字符串\n\n&ensp;&ensp;&ensp;&ensp;应用场景：将键盘需要输入 多个独立的字符串 用户必须单独存储好\n\n&ensp;&ensp;&ensp;&ensp;输入的字符串个数决定了二维数组的行数输入 \n\n&ensp;&ensp;&ensp;&ensp;字符串中的最大长度决定了二维字符数组的列数\n\n```c\n#include<stdio.h>\nvoid test01()\n{\n    / /hehe haha xixi heihei\n    char buf[4][16] = {\"\"};\n    int i = 0;\n    //获取键盘字符串 \n    for(i=0;i<4;i++)\n    {\n        //scanf(\"%s\",buf[i]);         //buf[i]已经代表是第i行的首元素地址\n        scanf(\"%s\",&buf[i][0]);  \n        //&buf[i][O] == & *(buf[i]+0) == buf[i] + 0 == buf[i]\n    } \n    for(i=0;i<4;i++)\n    {\n        printf(\"buf[%d]=%s\\n\",i,buf[i]);\n    }\n}\nint main(int argc,char *agrv[])\n{\n    test01();\n}\n```\n\n只要是以<font color=\"red\"> str开头 </font>的函数都是遇到 <mark>'\\0'</mark> 结束\n\n头文件：<font color=\"red\">#include<string></font>\n\n# <center>知识点四：strlen测量字符换长度</center>\n\n```c\nsize_t strlen(const char *s)      //strlen(被测量的字符串首元素地址（一般是数组名）)\n//s:被测量的字符串首元素地址\n//返回值为字符串的长度不包含 '\\0'\n//const char *s strlen函数 不会通过s修改s指向的空间内容\n```\n\n# <center>知识点五：strcpy和strncpy字符串拷贝</center>\n\n## <center>1、strcpy</center>\n\n```c\n原型：char *strcpy(char *dest, const char *src)\n功能：把 src 所指向的字符串 复制 到dest 所指向的空间中\n返回值：返回dest字符串的首地址\n注意: 遇到'\\0'会结束，只是'\\0'也会拷贝过去\n```\n\n```c\nvoid test1()\n{\n    char src[] = {\"hello string\"};\n    //保证dst足够大\n    char dst[128] = \"\";\n    strcpy(dst,src);\n    printf(\"dst = %s\\n\",dst); \n}\n```\n\n## <center>2、strncpy</center>\n\n```c\n原型：char *strncpy( char *dest,const char *src,int num)\n功能：把 src 指向字符串的前 num 个复制到 dest 所指向的空间中\n```\n\n```c\nvoid test1()\n{\n    char src[] = {\"hello string\"};\n    //保证dst足够大\n    char dst[128] = \"\";\n    strncpy(dst,src,3);\n    printf(\"dst = %s\\n\",dst);     //\"hel\"\n}\n```\n\n# <center>知识点六：字符串的拼接</center>\n\n## <center>1、strcat</center>\n\n```c\nchar *strcat(char *dest, const char *src);\n//将 src 的字符串拼接到 dst 的末尾(dst第一个'\\0'的位置 )\n```\n\n```c\nvoid test1()\n{\n    char src[] = {\"world\"};\n    char dst[128]=\"hello\";\n    strcat(dst,src);\n    printf(\"dst = %s\\n\",dst);     //\"hellowoeld\"\n}\n```\n\n## <center>2、strncat</center>\n\n```c\n原型：char *strncat (char *str1, char *str2, int num)\n功能：将str2前num个字母连接到str1后面\n返回值：返回str1字符串的首地址\n注意：会'\\0'一起拷贝过去\n```\n\n```c\nvoid test1()\n{\n    char src[] = {\"world\"};\n    char dst[128]=\"hello\";\n    strncat(dst,src,2);\n    printf(\"dst = %s\\n\",dst); //hellowo\n}\n```\n\n# <center>知识点七：字符串比较</center>\n\n## <center>1、strcmp</center>\n\n<mark>整个</mark>字符串的比较\n\n```c\nint strcmp(const char *S1,const char *s2);\n功能：将s1和s2指向的字符串逐个字符比较\n返回值:\n    >0：表示s1 > s2\n    <0：表示s1 < s2\n    ==0：表示s1 == s2\n```\n\n```c\nvoid test1()\n{\n    char s1[] = \"hehe haha\";\n    char s2[] = \"hehe xixi\";\n    if(strcmp(s1,s2) > 0)\n    {\n        printf(\"s1 > s2\\n\");\n    }\n    else if(strcmp(s1,s2) < 0)        //<0\n    {\n        printf(\"s1 < s2\\n\");\n    }\n    else if(strcmp(s1,s2) == 0)\n    {\n        printf(\"s1 == s2\\n\");\n    }\n}\n```\n\n## <center>2、strncmp</center>\n\n&ensp;&ensp;&ensp;&ensp;<mark>局部</mark>字符串的比较，比较两个字符串的<mark>前</mark> n 个字节是否一样\n\n```c\nvoid test1()\n{\n    char s1[] = \"hehe haha\";\n    char s2[] = \"hehe xixi\";\n    if(strncmp(s1,s2,3) > 0)\n    {\n    \tprintf(\"s1 > s2\\n\");\n    }\n    else if(strncmp(s1,s2,3) < 0)        \n    {\n    \tprintf(\"s1 < s2\\n\");\n    }\n    else if(strncmp(s1,s2,3) == 0)    //== 0\n    {\n    \tprintf(\"s1 == s2\\n\");\n    }\n}\n```\n\n# <center>知识点八：strchr字符查找函数</center>\n\n```c\n原型：char* strchr (const char *str1,char ch)\n功能：在字符串 str1 中查找字母 ch 出现的位置\n返回值：返回 第一次 出现的 ch地址，如果找不到，返回NULL\n```\n\n```c\nvoid test1()\n{\n    char str[] = \"www.1000phone.com\";\n    char *ret = NULL;\n    ret = strchr(str,'o');\n    if(ret != NULL)\n    {\n    \tprintf(\"%s\\n\",ret);    //one.com\n    }\n}\n```\n\n# <center>知识点九：strstr字符串查找</center>\n\n```c\nchar *strstr(const char *s1,const char *s2); \n//从 s1 中查找字符串 s2，返回 第一次 s2 出现的地址\n//查找失败返回NULL\n```\n\n```c\nvoid test1()\n{\n    char s1[] = \"www.sex.777.sex.com\";\n    char s2[] = \"sex\";\n    char *ret = NULL;\n    ret = strstr(s1,s2);\n    if(ret == NULL)\n    {\n        return;\n    }\n    printf(\"%s\\n\",ret);\n}\n```\n\n# <center>知识点十：替换字符函数</center>\n\n```c\n原型: void* memset (void *str, char C, int n)  \n功能：将 str 所指向的内存区的 前n个 全部用 c 填充\n    常用于清除指定空间，比如 数组 或 malloc 的空间\n返回值：返回 str 的地址\n```\n\n# <center>知识点十一：atoi atol atof 将字符串转化为数值</center>\n\n头文件：\\#include<stdlib.h>\n\n功能：将 str 所指向的数字字符串转化为 int、long、double\n\n```c\nvoid test1()\n{\n    printf(\"%d\\n\",atoi(\"123\"));\n    printf(\"%ld\\n\",atol(\"12356\"));\n    printf(\"%f\\n\",atof(\"12.3\"));\n}\n```\n\n# <center>知识点十二：strtok 字符串切割函数</center>\n\n```c\nchar *strtok(char *str，const char *delim);\n\n第一次切割：str必须指向要切割的字符串首元素地址，delim指向要切割的符号\n第2~n次切割: str必须指向NULL  delim指向要切割的符号\n\n返回值：切割成功返回切割到字符换片段的首元素地址，失败: NULL\n注意: strtok 不能切割字符串常量\n\n\"hehe:haha:xixi:lala\"\n如果切制完成会产生 \"hehe\" \"haha\" \"xixi\" \"lala\"\n一般选择char *arr[] 指针数组来存放上面独立的字符串的首元素地址\n```\n\n```c\nvoid test1(void)\n{\n    char buf[] =\"hehehe:haha@xixi:::lala#heihei:henhen\";\n    char *arr [32]= {NULL} ;\n    int i=0;\n    //第1次切割\n    arr[i] = strtok(buf,\":@#\") ;\n    //第2~n切割\n    while(arr[i] != NULL)\t//保证上一次切割正常才有进行下一次切割的必要\n    {\n        i++ ;\n        arr[i] = strtok (NULL,\":\");\n    }\n    //遍历切割的内容\n    i=0;\n    while(arr[i] != NULL)\n    {\n        printf (\"%s\\n\",arr[i]);\n        i++;\n    }\n}\n```\n\n# <center>知识点十三：sprintf组包</center>\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221505928.png\" alt=\"sprintf组包\" style=\"zoom: 50%;\" />\n\n```c\nint sprintf(buf, \"格式\"，数据)\n    //buf :用来存放组好的报文\n    //\"格式\"：按照格式组包\n    //数据: 各个零散的数据\n返回值：返回值的是组好的报文的实际长度(不包含'\\0')\n```\n\n```c\nvoid test1(void)\n{\n    int year = 2020;\n    int mon = 2;\n    int day = 24;\n    int len = 0;\n    //需求：将2020 2 24组 成一个\"2020年2月24日\"\n    char buf[ 128] = \"\";\n    //%d 和 year 类型要一一对应\n    len = sprintf (buf, \"%d年%d月%d日\", year, mon, day);\n    printf(\"len = %d\\n\",len);\n    printf(\"buf=%s\\n\", buf);\n}\n```\n\n# <center>知识点十四：sscanf解包</center>\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221505695.png\" alt=\"sscanf解包\" style=\"zoom: 50%;\" />\n\n```c\nint sprintf(buf, \"格式\"，地址)\n//buf :用来存放组好的报文\n//\"格式\":按照格式解包\n//地址: 保存各零散数据的地址\n```\n\n```c\nvoid test1(void)\n{\n    char buf[]=\"2020年2月24日\";\n    int year=0;\n    int mon=0;\n    int day=0;\n    //%d 只能提取'0'~'9'\n    sscanf (buf, \"%d年%d月%d日\",&year, &mon, &day);\n    printf(\"year = %d\\n\",year);    //2020\n    printf(\"mon = %d\\n\",mon);    //2\n    printf(\"day = %d\\n\", day);    //24\n}\n```\n\n# <center>知识点十五：sscanf高级用法</center>\n\n1、使用%*s %*d 跳过提取的内容(不要提取的内容)\n\n```c\nvoid test1(void)\n{\n    int datal = 0;\n    //sscanf(\"1234 5678\", \"1234 %d\", &datal);    //5678\n    //sscanf(\"1234 5678\",\"%*d %d\", &datal);    //5678\n    sscanf(\"1234 5678\",\"%*s %d\", &datal);    //5678\n    printf(\"datal = %d\\n\", datal);\n}\n```\n\n2、使用%ns  %nd提取指定宽度n的字符串或数据\tn：需要的字节数\n\n```c\nvoid test1(void)\n{\n    int datal = 0;\n    int data2 = 0;\n    char buf[16]=\"\";\n    sscanf (\"12abc5678\",\"%*5s%d\",&datal) ;//5678\n    printf(\"datal=%d\\n\", datal);\n    sscanf (\"12345678\", \"%*2s%2d%*2d%s\",&data2,buf);    //data2=34 buf=\"78\";\n    printf(\"data2 = %d\\n\", data2);    //34\n    printf(\"buf=%s\\n\",buf);    //\"78'\n}\n```\n\n3、%[a-z]提取a-z的字符串\n\n```c\nvoid test1(void)\n{\n    char buf[128]=\"\";\n    //%[]都是按 字符串 提取\n    sscanf(\"abcDefABC\", \"%[a-z]\",buf);\n    printf(\"buf=%s\\n\",buf);    //\"abc\"\n}\n```\n\n4、%[aBc] 提取 a B c\n\n```c\nvoid test1(void)\n{\n    char buf[128]=\"\";\n    //%[]都是按 字符串 提取\n    sscanf(\"aaBBcEdef\", \"%[aBc]\",buf);\n    printf(\"buf=%s\\n\",buf);        //aaBBc\n}\n```\n\n5、%\\[^abc]只要不是a b c其中一个都要\n\n```\nvoid test1(void)\n{\n    char buf[128]=\"\";\n    //%[]都是按 字符串 提取\n    sscanf(\"ABCcABC\", \"%[^abc]\",buf);\n    printf(\"buf=%s\\n\",buf);        \n}\n```\n\n# <center>知识点十六：const关键字</center>\n\n1、const修饰 变量 为只读\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221505055.png\" alt=\"const关键字\" style=\"zoom: 50%;\" />\n\n```c\nvoid test1(void)\n{\n    //const修饰num为只读变量 num 只能取值 num不能被赋值\n    const int num = 10;\n    printf(\"num = %d\\n\",num) ;//ok\n    //num = 100;//err num不能被赋值\n    printf(\"&num = %p\\n\",&num) ;\n    //但是如果知道num的地址也可以间接的修改num的值(一般不这么做)\n    *(int *)(&num) = 1000;\n    printf(\"num = %d\\n\",num);\n}\n```\n\n2、const * int p\n\nconst在\\*的左边表示const修饰的是*而不是p\n\n效果:用户不能借助\\*p更改空间的内容,但是p可以指向其他空间(*p只读,p可读可写)\n\n```c\nvoid test1(void)\n{\n    int num1=10;\n    int num2 = 20;\n    //const在*的左边 *p只读 p可读可写\n    const int *p = &num1;\n    printf(\"*p = %d\\n\",*p);    //10 \n    //*p = 1000;    //err *p只读.\n    p=&num2;    //ok p可读可写\n    printf(\"*p = %d\\n\",*p);//20\n}\n```\n\n3、int * const p\n\nconst在\\*的右边const修饰的是p而不是*\n\n用户可以通过\\*p修改p所指向空间的内容，但是不能再更改p的指向(*p可读可写，p只读)\n\n```c\nvoid test1(void)\n{\n    int num1 = 10;\n    int num2 = 20;\n    //const在*的右边 *p可读可写  p只读\n    int * const p = &num1;    //p一旦初始化 就不能更改指向\n    printf(\"*p = %d\\n\",*p);    //10\n    *p = 1000;    //ok *p可读可写\n    printf(\"*p = %d\\n\",*p);    // 1000\n    //p=&num2;    //err p只读    \n}\n```\n\n4、const int * const p\t(*p只读p只读)\n\n```c\nvoid test1(void)\n{\n    int num1 = 10;\n    int num2 = 20;\n    const int * const p = &num1;    //*p和p都是只读\n    //*p = 1000;    //err *p只读\n    //p = &num2;    //err p只读\n\n}\n```\n\n","tags":["C语言"],"categories":["编程语言","C语言"]},{"title":"8.动态内存申请","url":"/post/3ec1fd44.html","content":"\n# <center>知识点一：malloc函数和free函数</center>\n\n**malloc函数**\n\n```c\n头文件：#include<stdlib.h>\n       #include<string.h>    // 用于memset函数的头文件\nvoid *malloc(unsigned int num_ size);\n形参: num_ size需要申请空间大小的字节数。\n返回值：\n\t成功:返回空间的起始地址\n\t失败: NULL\n特点:\n    1、对于malloc的返回值一般要强制类型转换再赋值保存（返回值就是开辟对应的空间）\n    2、malloc申请的空间内容不确定一般使用memset进行清空\n    3、多次调用malloc第1次malloc 和 第2次malloc的地址不一定连续\n```\n\n**free函数**\n\n```c\nvoid free(void *addr);        ()里面是保存malloc保存返回值的指针变量名\n//功能：释放堆区空间\n```\n\n```c\n#include<stdio.h>\nvoid test1()\n{\n    int *addr = NULL;\n    addr = (int *)malloc(sizeof(int));    // (强转类型 *)malloc(n * sizeof(类型))    n：无符号整数 ()里面的字节数是n乘类型的字节数\n    if(addr == NULL)\n    {\n        printf(\"malloc err\\n\");\n    }\n    printf(\"*addr = %d\\n\",addr);    //不确定值 \n    //对堆区空间清零\n    memset(addr,0,sizeof(int));\n    printf(\"*addr = %d\\n\",*addr);\n    //对addr的空间 进行读 写\n    *addr = 1000;     //写\n     //读\n     printf(\"*addr = %d\\n\",*addr);     //1000\n     //释放堆区空间 空间使用权限的回收是否对空间内容清0这是不确定的\n     free(addr); \n}\nint main(int argc,char *argv[])\n{\n     test1();\n}\n```\n\n# <center>知识点二：calloc函数</center>\n\n```c\n头文件：#include<stdlib.h>\nvoid * calloc(size_t nmemb,size_ t size);    // (强转类型 *)calloc(n,sizeof(类型))    n：无符号整数 ()里面的字节数是n乘类型的字节数\n参数:\n    1、nmemb中请的数据块数\n    2、size 每一块大小\n    3、申请总大小 = nmemb*size\n返回值:\n    成功:返回空问的起始地址\n    失败:返回NULL\n特点：申请的空间自动清零，不需要memset清零\n```\n\n# <center>知识点三：realloc动态追加或减少空间</center>\n\n```c\n#include<stdlib.h>\nvoid* realloc(void *S,unsigned int newsize);    //(强转类型 *)realloc(保存原先开辟内存的指针名,(原先空间+新增空间)sizeof(类型))\n参数: \n    s：原先开辟内存的首地址\n    newsize: 新申请的空间的总大小（原先+新增部分大小）（如果新申请的空间比原先大，则是追加，如果比原先小，则是减少）\n返回值：新申请的内存的首地址\nrealloc的返回值一般要强制类型转换再赋值保存（返回值就是开辟对应的空间）\n```\n\n功能：\n\n&ensp;&ensp;&ensp;&ensp;在原先s指向的内存基础.上重新申请内存，新的内存的大小为new_ size 个字节，如果原先内存后面有足够大的空间，就追加，如果后边的内存不够用，则relloc函数会在堆区找一个newsize个字节大小的内存申请，将原先内存中的内容拷贝过来，然后释放原先的内存，最后返回新内存的地址\n\n# <center>知识点四：堆区空间使用的注意事项</center>\n\n```c\nvoid test1()\n{\n    int *p2 = NULL;\n    int *p3 = NULL;\n    //1、指向堆区空间的指针变量不要随意的更改指向\n    int *p=(int *)calloc(1, sizeof(int)) ;\n    int num = 10;\n    p = &num;    //p指向num导致calloc申请的空间泄露\n    //2、不要操作已经释放的空间\n    p2 = (int *)calloc(1,sizeof(int));\n    *p2 = 1000;\n    //释放该空间\n    free(p2) ;\n    printf(\"*p2 = %d\\n,*p2);\t//不确定\n    //3、不要对堆区空间重复释放\n    p3 = (int *)calloc(1, sizeof(int));\n    free(p3);\n    free(p3);//多次释放\n}\n```\n\n# <center>知识点五：防止多次释放</center>\n\n```c\nvoid test09 ()\n{\n    int *p=(int *)calloc(1,sizeof(int));\n    if(p != NULL)    //防止多次释放\n    {\n        free(p);\n        p=NULL;\n    }\n    if(p != NULL)    \n    {\n        free(p);\n        p=NULL;\n    }\n}\n```\n\n","tags":["C语言"],"categories":["编程语言","C语言"]},{"title":"7.指针","url":"/post/b70ae4e7.html","content":"\n# <center>知识点一：内存地址的概述</center>\n\n系统会给变量、函数、数组、字符串等开辟空间，开辟空间也会给予一个起始地址(内存地址)\n\n指针可以指向这些起始地址，也就是一个标记，这个标记就是指针\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221502960.png\" alt=\"内存地址\" style=\"zoom: 33%;\" />\n\n# <center>知识点二：指针变量</center>\n\n指针变量：本质就是一个`变量`，也有指针变量的起始地址，在指针变量的内存中存放指向的地址，二级指针就可以保存一级指针，依次嵌套\n\n在32位平台，指针变量`任何类型`的地址编号都是 4 字节\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221502626.png\" alt=\"指针变量\" style=\"zoom: 33%;\" />\n\n# <center>知识点三：定义指针变量</center>\n\n`*`：在<mark>定义</mark>一个指针变量时，起到<font color=\"red\">标识作用</font>，标识定义是一个指针变量除此之外，<mark>其他地方</mark>都表示<font color=\"red\">获取一个指针变量保存的地址里面</font>的<mark>内容</mark>\n\n`&`：取一个<mark>对应变量</mark>的<font color=\"red\">地址</font>，若对指针变量取地址，则是指针变量的地址(而不是指针变量指向的地址)\n\n形式：`类型 *指针变量名`\n\n# <center>知识点四：指针变量的使用</center>\n\n通过过 p 对所保存的地址空间进行读写操作\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221502363.png\" alt=\"指针变量定义\" style=\"zoom: 50%;\" />\n\n```c\nvoid test01 ()\n{\n    //num拥有一一个合法的空间 \n    int num = 10;\n    //需求:请定义一个指针变量保存num的地址\n    //p就是指针变量变量名为p不是*p\n    //在定义的时候：*修饰p表示p为指针变量\n    int *p;\n    \n    p = &num;  //&num代表num变量起始地址(首地址)\n    //指针变量指向变量p的起始地址\n    printf(\"&num = %p\\n\",&num);    \n    printf(\"p = %p\\n\",p);\n    //*p 等价num\n    printf(\"*p = %d\\n\",*p);  //10==num\n    //*p = 100 == num\n    *p = 100;\n    printf(\"num = %d\\n\",num);\t//num = 100\n    scanf(\"%d\",p);    //如果此处为&p表示键盘给p赋值而不是给num赋值\n    printf(\"num = %d\\n\",num);\n}\n```\n\n# <center>知识点五：指针变量取值<mark>宽度</mark></center>\n\n输出时是宽度里面的内容\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221502704.png\" alt=\"指针变量取值宽度\" style=\"zoom: 50%;\" />\n\n```c\n#include<stdio.h>\nvoid test01 ()\n{\n    int  num = 0x01020304;\n    int *p;\n    short *p1;\n    char *p2;\n    p = &num;\n    p1 = &num;\n    p2 = &num; \n    \n    printf(\"*p = %#x\\n\",*p);\t//*p = 0x1020304\n    printf(\"*p1 = %#x\\n\",*p1);\t//*p1 = 0x304\n    printf(\"*p2 = %#x\\n\",*p2);\t//*p2 = 0x4\n}\n\nint main(int argc,char *argv[])\n{\n    test01();\n}\n```\n\n# <center>知识点六：指针变量的<mark>跨度</mark></center>\n\n输出时是不输出跨度里面的内容，而是输出除了跨度内剩下且在宽度范围内的内容\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221502714.png\" alt=\"指针变量跨度\" style=\"zoom: 50%;\" />\n\n```c\n#include<stdio.h>\n\nvoid test01 ()\n{\n    int  num = 0x01020304;\n    int *p;\n    short *p2;\n    char *p1;\n    p2 = &num;\n    p = &num;\n    p1 = &num;\n    printf(\"*p = %u\\n\",p);\t\t\t//*p = 6356608\n    printf(\"*p+1 = %u\\n\",p+1);\t\t//*p+1 = 635612\n    printf(\"*p1 = %u\\n\",p1);\t\t//*p1 = 6356608\n    printf(\"*p1+1 = %u\\n\",p1+1);\t//*p1+1 = 6356609\n    printf(\"*p2 = %u\\n\",p2);\t\t//*p2 = 6356608\n    printf(\"*p2+1 = %u\\n\",p2+1);\t//*p2+1 = 6356610\n}\n\nint main(int argc,char *argv[])\n{\n\ttest01();\n}\n```\n\n# <center>知识点七：指针和普通变量强制类型转换</center>\n\n形式：<font color=\"red\">(需要强转的类型 *)变量名</font>\n\n普通变量：<font color=\"red\">(需要强转的类型)变量名</font>\n\n强转后则变成强转的类型\n\n# <center>知识点八：指针变量初始化</center>\n\n```c\nvoid test01 ()\n{\n    int num = 10;\n    int data = 100;\n    //如果 局部指针变量 不初始化保存的是随机的地址编号(千万别取值)\n    int *p;\n    //不想让指针变量指向任何地方 应该初始化为NULL(千万别取值)\n    //#define NULL ((void *)0)\n    int *pl = NULL;\n    //将指针变量初始化为合法的地址(可以取值)\n    //*修饰p2为指针变量，p2=&num;\n    int *p2 = &num;\t\t//第一步: int *p2;   第二步: p2=&num;\n    printf(\"%d\\n\",*p2);\t//num==10\n    //指针变量p2本质是一个变量  可以更改指向\n    p2 = &data;\n    printf(\"%d\\n\",*p2);\t//data==200\n}\n```\n\n总结：\n\n&ensp;&ensp;&ensp;&ensp;1）指针变量初始化为NULL\n\n```c\nint *p = NULL;    //不要对p进行*p操作  容易出段错误\n```\n\n&ensp;&ensp;&ensp;&ensp;2）指针变量初始化为 合法空间\n\n```c\nint num = 10;\nint *p = &num;    //第一步定义指针变量int *p    第二步给指针变量赋值: p=&num \n```\n\n# <center>知识点九：&取地址符 和 \\*指针解引用符区别（使用中...）</center>\n\n```c\nvoid test01 ()\n{\n    int num = 10;\n    int *p;\n    //num的类型是int 类型\n    //&num的类型是int *类型\n    //如果对一个变量取地址 整个表达式的类型是 变量 的类型 +*\n    p=&num;\n    //p的类型是 int * 类型\n    //*p的类型是 int 类型\n    //如果对指针变量取 * 整个表达式的类型是 指针变量 的类型 -* \n    //高级总结：如果 & 和 * 同时存在可以相互抵消(从右往左)\n    //论证: *p ==num\n    //*p=*&num==num;\n}\n```\n\n# <center>知识点十：指针的注意事项</center>\n\n1、void 不能定义变量\n\n```c\nvoid num;    //错误的 系统不知道num的大小\n```\n\n2、void <mark>*</mark> 可以定义变量\n\n```c\nvoid *p;    //p的类型为 void * 而void *指针类型32为平台4字节，系统知道给p开辟4字节\n//p叫万能指针，p可以保存任意类型的一级指针\n```\n\n&ensp;&ensp;&ensp;&ensp;对于 p 不能直接使用 *p 操作，必须实现对 <mark>p</mark> 进行<font color=\"red\">强制类型转换</font>\n\n```c\nvoid test01 ()\n{\n    int num = 10;\n    void *p;\n    p = &num;\n    //printf(\"%d\\n\",*p);    //错误：因为p的指向类型为void 系统确定不了宽度\n    printf(\"%d\\n\",*(int *)p);    //p临时的指向类型为int 系统确定宽度4B\n}\n```\n\n3、不要对<mark>没有初始化</mark>的指针变量 取<font color=\"red\">*</font>\n\n```c\nint *p;\nprintf(\"*p = %d\\n\", *p);    //不能这样取*输出\n//因为p没有初始化 内容随机 也就足p指向了一个未知空间系统不允许用户 取值*p操作\n```\n\n4、不要对<mark>初始化</mark>为<font color=\"red\"> NULL </font>的指针变量 <mark>取*</mark>\n\n```c\n//NULL就是(void *) 0 地址，也是内存的起始地址受系统保护\nint *p = NULL;\nprintf(\"*p = %d\\n\",*p);    //也不能 *p\n```\n\n5、不要给指针变量赋<mark>普通的数值</mark>\n\n```c\nint *p = 1000;    // 此时的1000对于p来说是地址编号1000\n//*p表示在地址编号为1000的位置 取值，而地址编号1000不是合法的空间所以不能*p\nprintf(\"*p = %d\\n\",*p);    //也不能*p\n```\n\n6、指针变量不要操作<mark>越界</mark>的空间\n\n```c\nchar num=10;\nint *p = &num;\n//num只占1B空间，而p的指向类型为int 所以*p取值宽度为4B ，所以越界3B\nprintf(\"*p =%d\\n\", *p);    //操作非法空间\n```\n\n# <center>知识点十一：数组元素的指针</center>\n\n<mark>普通变量</mark>保存是在一个空间里，所以跨度之后是输出<font color=\"red\">除了跨度之外在宽度之内的内容</font>\n\n数组是里面分许多的小空间保存不同的内容，所以跨度之后是输出<font color=\"red\">对应小空间里面的内容</font>\n\n通过数组元素的指针变量 遍历  数组的元素\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221503931.png\" alt=\"数组元素指针\" style=\"zoom: 50%;\" />\n\n```c\nvoid test1()\n{\n    int i = 0;\n    int num[4] = {10,20,30,40};\n    int *p = &num[0];     //或int *p = num;\n    for(i = 0;i<4;i++)\n    {\n        printf(\"num = %d\\n\",*(p + i));\n    }\n}\n```\n\n通过数组元素的指针变量给数组的元素获取键盘输入\n\n```c\nvoid test2()\n{\n    int i = 0;\n    int num[5] = {0};\n    int n = sizeof(num)/sizeof(num[0]);\n\n    int *p = &num[0]; //或int *p = num;\n    for(i = 0;i<n;i++)\n    {\n        //scanf(\"%d\",&num[i]);\n        scanf(\"%d\",p + i);    //p + i == &num[i];\n    }\n}\n```\n\n# <center>知识点十二：数组的[]和*()的关系</center>\n\n数组名arr 作为<mark>类型</mark>，代表的是数组的总大小sizeof (arr)\n\n数组名arr 作为<mark>地址</mark>，代表的是首元素地址(第0个元素的地址)\n\n```c\n&arr[0] == &*(arr+0) == arr+0 == arr\n```\n\n在使用中本质：[] 是 *( ) 缩写\n\n缩写规则：+ 左边的值放在[]左边+右边的值放在[]里面\n\n```c\narr [1] \t*(arr + 1)\n```\n\n# <center>知识点十三：数组中 arr 和 &arr的区别</center>\n\narr：数组的<mark>首元素</mark>地址\n\n&arr：数组的<mark>首地址</mark>\n\n数组名arr是一个符号常量，不能被赋值\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221503390.png\" alt=\"区别\" style=\"zoom: 50%;\" />\n\n# <center>知识点十四：指向同一数组的两个元素的指针变量间关系</center>\n\n```c\nvoid testll()\n{\n    int arr[5]={10, 20, 30, 40,50} ;\n    int*p1 = arr;\n    int *p2 = arr+3;\n    //1、指向同一数组的两个指针变量相减，返回的是相差元素的个数\n    printf(\"%d\\n\",p2- p1);\t//3\n    \n    //2、指向同一数组的两个指针变量可以比较大小\n    if (p2>p1)\n    {\n        printf(\">\\n\");\n    }    \n    else\n    {\n        printf(\"<\\n\");\n    }\n    \n    //3、 指向同一数组的两个指针变量 可以赋值\n    p1=p2;    //p1 和 p2指向同一处地址\n    \n    //4、指问同一数组的两个指针变量尽量不要相加\n    printf(\"p2=%u\\n\",p2);\n    p1+p2;    //错误：越界很厉害了\n    \n    //5、[]里面在不越界的情况下 可以为负数\n    printf(\"%d\\n\",p2[-2]);\t//20\n}\n```\n\n# <center>知识点十五：指针数组</center>\n\n指针数组：本质是<mark>数组</mark>，只是数组的每个元素是指针\n\n形式：<font color=\"red\">类型 * 数组名 [元素个数]</font>\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221503575.png\" alt=\"指针数组分析1\" style=\"zoom: 50%;\" />\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221503535.png\" alt=\"指针数组分析2\" style=\"zoom: 50%;\" />\n\n```c\n#include <stdio.h>\nvoid test1()\n{\n    int num1 = 10;\n    int num2 = 20;\n    int num3 = 30;\n    //指针数组\n    int *arr[3]={&num1,&num2,&num3};\n    char *arr2[3] ;\n    //arr[0] = &num1， arr[1]=&num2， arr[2]=&num3\n    printf(\"%d\\n\",*arr[1]);\t\t\t//*arr[1]= * &num2=num2\n    printf(\"%d\\n\",sizeof(arr));\t\t//12\n    printf(\"%d\\n\",sizeof(arr2));\t//12\n    return;\n}\n\nint main(int argc,char *argv[])\n{\n    test1();\n    return 0;\n} \n```\n\n# <center>知识点十六：数组指针</center>\n\n形式：<font color=\"red\">指向的数组的类型（*指针变量名）[指向的数组的元素个数]</font>\n\n本质是：<mark>指针变量</mark>，只是保存的是数组的首地址\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221503119.png\" alt=\"数组指针\" style=\"zoom: 50%;\" />\n\n```c\nvoid test03( )\n{\n    int arr[5]={10,20,30, 40};\n    int (*p)[5];\t//数组指针: 本质是一个指针变量只是该变量保存的是数组的首地址\n    printf(\"%d\\n\",sizeof(p));\t//4 \n    printf(\"p=  %u\\n\",p);\t\t\t//p = 3612672\n    printf(\"p+1 = %u\\n\",p+1);\t\t//p+2 = 3612692\n    p = &arr;    //&arr 才代表数组的首地址\n    printf(\"%d\\n\",*(*p+3));\t\t//40\n    //*(*p+3) == *(*(p+0)+3)==*(p[0]+3)==p[0][3]      \n    printf(\"%d\\n\",p[0][3]);\t\t//40\n}\n```\n\n# <center>知识点十七：二维数组分析</center>\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221504546.png\" alt=\"二维数组分析\" style=\"zoom: 50%;\" />\n\n# <center>知识点十八：数组指针与二维数组的关系</center>\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221504127.png\" alt=\"数组指针与二维数组的关系\" style=\"zoom: 50%;\" />\n\n```c\nvoid test03( )\n{\n    int arr[3][4] = {{1,2,3,4},{5,6,7,8},{9,10,11,12}};\n    int i,j = 0;\n    int (*p)[4] = arr;\n    for(i = 0;i<3;i++)\n    {\n        for(j = 0;j<4;j++)\n        {\n            //printf(\"%d\\n\",*(*(p+i)+j));\n            printf(\"%d \",arr[i][j]);\t//1 2 3 4 5 6 7 8 9 10 11 12\n        }\n        printf(\"\\n\");\n    }\n}\n```\n\n# <center>知识点十九：任何维度的数组在物理存储上都是一维</center>\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221504411.png\" alt=\"数组分析\" style=\"zoom: 50%;\" />\n\n# <center>知识点二十：多级指针</center>\n\n指针变量存放的是地址，但指针变量本身还有对应的地址，如果对<mark>指针变量</mark>取地址，就是指针变量本身对应的地址\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221504884.png\" alt=\"多级指针\" style=\"zoom: 50%;\" />\n\n```c\nint *p;\nint a = 10;\np = &a;\n//*p：取p指向地址的值\n//p：为p指向的地址\n//&p：原本指针变量\n```\n\n# <center>知识点二十一：<mark>指针变量</mark>作为函数的参数</center>\n\n如果想在函数内部 修改 外部变量的值，需要将外部变量的 地址 传递给 函数(以指针变量作为函数的参数)\n\n&ensp;&ensp;&ensp;&ensp;由于p1和p2分别保存了data1和data2的地址，可以通过p1和p2间接的修改data1和data2的值\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221504133.png\" alt=\"指针变量作为函数参数\" style=\"zoom:33%;\" />\n\n```c\n#include <stdio.h>\nint my_swap2(int *a,int *b)        //a = &data1 b = &data2\n{\n    int tmp;\n    \n    tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\nvoid test03()\n{\n    int data1 = 10,data2 = 20;\n    printf(\"data1 = %d,data2 = %d\\n\",data1,data2);\n    //函数内部修改外部变量的值需传递外部变量的地址\n\n    my_swap2(&data1,&data2);\n    printf(\"data1 = %d,data2 = %d\\n\",data1,data2);\n}\nint main(int argc,char *argv[])\n{\n    test03();\n    return 0;\n}\n```\n\n```c\n//如果交换的是 *变量，所对应的赋值的地址对应的值都会随着改变\n//如果是指针变量相互赋值的话，只是地址转换，只能影响交换地址之间的值\nint main(void)\n{\n\tint a = 100;\n\tint b = 200;\n\tint *a1;\n\tint *b1;\n\tint *a2;\n\tint *b2;\n\ta1 = &a;\n\tb1 = &b;\n\ta2 = a1;\n\tb2 = b1;\n    //情况一\n\t//a2 = b2;\n\t//printf(\"a2 = %d,b2 = %d\\n\",*a2,*b2);\t//a2 = 200,b2 = 200\n\t//printf(\"a1 = %d,b1 = %d\\n\",*a1,*b1);\t//a1 = 100,b1 = 200\n    //情况二，使用情况一需要屏蔽情况二\n\t*a2 = *b2;\n \tprintf(\"a2 = %d,b2 = %d\\n\",*a2,*b2);\t//a2 = 200,b2 = 200\n\tprintf(\"a1 = %d,b1 = %d\\n\",*a1,*b1);\t//a1 = 200,b1 = 200\n\tprintf(\"a = %d,b = %d\\n\",a,b);\t\t\t//a = 200,b = 200\n}\n```\n\n总结：函数内部修改外部变量的值请传外部变量的地址.\n\n&ensp;&ensp;&ensp;&ensp;&ensp;外部变量为0级指针，函数的形参为1级指针\n\n&ensp;&ensp;&ensp;&ensp;&ensp;外部变量为1级指针，函数的形参为2级指针\n\n&ensp;&ensp;&ensp;&ensp;&ensp;外部变量为2级指针，函数的形参为3级指针\n\n--------------------------------------------------------------------------------------------------\n\n&ensp;&ensp;&ensp;&ensp;&ensp;<mark>外部变量</mark>为 <font color=\"red\">n-1</font> 级指针，函数的<mark>形参</mark>为 <font color=\"red\">n</font> 级指针\n\n# <center>知识点二十二：<mark>一维数组名</mark>作为函数的参数</center>\n\n1、如果函数内部想操作(读、写)外部数组的元素，请将外部数组的数组名传递函数\n\n2、一维数组作为函数的<mark>形参</mark>会被优化成<font color=\"red\">一级指针变量</font>\n\n```c\n#include <stdio.h>\n//int my_input_array(int arr[5],int n)\n//一维数组作为函数的形参会被优化成指针变量\nint my_input_array(int *arr,int n)\n{\n    printf(\"B:%d\\n\",sizeof(arr));    //4\n    int i = 0;\n    printf(\"请输入%d个int数据\\n\",n);\n    for(i = 0;i<n;i++)\n    {\n        scanf(\"%d\",arr+i);\n    }\n}\nint my_print_array(int *arr,int n)\n{\n    int i = 0;\n    for(i = 0;i<n;i++)\n    {\n        //printf(\"%d \",*(arr+i));\n        printf(\"%d \",arr[i]);\n    }\n    printf(\"\\n\");\n}\nvoid test03( )\n{\n    int arr[5] = {0};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    printf(\"A:%d\\n\",sizeof(arr));    //20\n    //定义一个函数给arr获取键盘输入\n    my_input_array(arr,n);\n    //定义一个函数遍历数组元素\n    my_print_array(arr,n);\n}\nint main(int argc,char *argv[])\n{\n    test03();\n    return 0;\n}\n```\n\n# <center>知识点二十三：<mark>二维数组名</mark>作为函数的参数</center>\n\n1、如果函数内部想操作(读、写)外部数组的元素，请将外部数组的数组名传递函数\n\n2、二维数组名作为函数的形参会被优化成数组指针\n\n&ensp;&ensp;&ensp;&ensp;&ensp;<font color=\"red\">int arr1[5] -----> int \\*p;</font>\n\n&ensp;&ensp;&ensp;&ensp;&ensp;<font color=\"red\">int arr2\\[3][4] ----> int (\\*p1)[4];</font>\n\n&ensp;&ensp;&ensp;&ensp;&ensp;<font color=\"red\">int arr3\\[3]\\[4][5] ---> int (*p2)\\[4][5];</font>\n\n```c\n#include <stdio.h>\n//void my_print_tow_array(int arr[3][4],int cow,int col)\n//当二维数组作为函数形参会被优化成数组指针\nvoid my_print_tow_array(int (*arr)[4],int cow,int col)    //数组指针每一个元素都是指针，数组每个元素都有对应的地址，刚好保存对应的地址\n{\n    int i,j = 0;\n    printf(\"A = %d\\n\",sizeof(arr));\n    for(i = 0;i<cow;i++)\n    {\n        for(j =0;j<col;j++)\n        {\n            printf(\"arr = %d \",arr[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\nvoid test03( )\n{\n    int arr[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12};\n    int cow = sizeof(arr)/sizeof(arr[0]);    //行数 \n    int col = sizeof(arr[0])/sizeof(arr[0][0]);//列数 \n    printf(\"A = %d\\n\",sizeof(arr));\n    my_print_tow_array(arr,cow,col);\n}\nint main(int argc,char *argv[])\n{\n    test03();\n    return 0;\n}\n```\n\n# <center>知识点二十四：指针作为函数的<font color=\"red\">返回值</font></center>\n\n1、函数<mark>不要</mark>返回<font color=\"red\">普通局部变量</font>的<mark>地址</mark>\n\n```c\n#include <stdio.h>\nint* get_addr(void)\n{\n    //int num = 1000;\n    static int num = 1000;    //静态变量 程序结束前不会被释放\n    return &num;    //不要返回普通局部变量地址（局部变量可能执行后会被释放而存放其他则返回的并不是原来的内容） \n}\nvoid test03( )\n{\n    int *p = NULL;\n     p = get_addr();\n     printf(\"*p = %d\\n\",*p);    \n}\nint main(int argc,char *argv[])\n{\n    test03();\n    return 0;\n}\n```\n\n# <center>知识点二十五：函数名代表的是函数的入口地址</center>\n\n函数指针形式：函数返回值类型 (*变量名) (形参类型 ,形参类型 .....)\n\n```c\n#include <stdio.h>\nint my_add(int a,int b)\n{\n    return a+b;\n}\nvoid test03( )\n{\n    //my_add代表的是函数的入口地址\n    printf(\"%p\\n\", my_add);\n    //定一个指针变量保存该函数的入口地址\n    //函数指针本质：指针变量保存的是函数的入口地址\n    int (*p)(int ,int ) = NULL;\t\t//函数指针\n    printf(\"%d\\n\",sizeof(p));\n    //将函数指针和函数名建立关系\n    p = my_add;\n    printf(\"%p\\n\",p);\n    //函数调用:函数入口地址+()\n    printf(\"%d\\n\",my_add(10,20));\n    printf(\"%d\\n\",p(100,200));\n    //对函数指针变量取*无意义\n}\nint main(int argc,char *argv[])\n{\n    test03();\n    return 0;\n}\n```\n\n# <center>知识点二十六：<mark>函数指针</mark>作为函数的形参</center>\n\n```c\n#include<stdio.h>\nint my_add(int a,int b)\n{\n    return a+b;\n}\nint my_sub(int a,int b)\n{\n    return a-b;\n}\nint my_mul(int a,int b)\n{\n    return a*b;\n}\n//定义一个函数实现，上述函数的功能\n\nint my_calc(int a,int b,int (*fun_pointer)(int ,int))    //将实参10，20传给形参a，b、函数地址（my_add）传给函数指针（fun_pointer）\n{\n    return fun_pointer(a,b);    //返回计算后的结果\n}\nvoid test1()\n{\n    printf(\"%d\\n\",my_calc(10,20,my_add));    //30\n    printf(\"%d\\n\",my_calc(10,20,my_sub));    //-10\n    printf(\"%d\\n\",my_calc(10,20,my_mul));    //200\n}\nint main(int argc,char *argv[])\n{\n     test1();\n}\n```\n\n","tags":["C语言"],"categories":["编程语言","C语言"]},{"title":"6.预处理","url":"/post/804ae251.html","content":"\n# <center>知识点一：gcc编译过程</center>\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221501789.png\" alt=\"预处理类型\" style=\"zoom: 33%;\" />\n\n预处理：头文件包含、宏替换、条件编译、删除注释  不做语法检查\n\n编译：将预处理后的文件生成汇编文件语法检查\n\n汇编：将汇编文件编译二进制文件\n\n链接：将众多的二进制文件+库+启动代码生成可执行文件\n\n# <center>知识点二：头文件包含</center>\n\n符号：\n\n&ensp;&ensp;&ensp;&ensp;<font color=\"red\"><></font>：用于包含<mark>系统</mark>的头文件\n\n&ensp;&ensp;&ensp;&ensp;<font color=\"red\">\" \"</font>：用于包含<mark>用户</mark>自定义的头文件\n\n#include <hehe.h>表示从系统的指定目录下寻找 hehe.h\n\n#include \"hehe.h\"表示先从源文件所在的目录寻找如果找不到再到系统指定的目录下找\n\n# <center>知识点三：宏定义</center>\n\n宏名 一般是大写\n\n## 1、不带参数宏\n\n&ensp;&ensp;&ensp;&ensp;形式：<font color=\"red\">#define 宏名 需要代替的内容</font>\n\n&ensp;&ensp;&ensp;&ensp;宏只在当前源文件有效，定义宏是后面不能加 <mark>;</mark> 号\n\n```c\n#define N \"hehe\"\nvoid test01()\n{\n    //在预处理阶段 \"hehe\"替换 代码中所有出现的N ( 宏展开)\n    printf(\"%s\\n\",N);\n    return;\n}\n```\n\n&ensp;&ensp;&ensp;&ensp;<mark>终止宏</mark>的作用范围：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;形式：<font color=\"red\">#undef 宏名</font>\n\n## 2、带参数的宏 （宏 函数）\n\n&ensp;&ensp;&ensp;&ensp;形式：<font color=\"red\">#define 宏名(参数1,参数2, ...) 需要代替的内容 </font>\n\n```c\n//宏的参数a b 不能写类型\n//#define MY_ ADD(int a, int b) a+b  //错误\n#define MY_ADD(a,b) a+b\n//调用宏名(参数)\nMY_ ADD(10,20);     // 10+20\n```\n\n&ensp;&ensp;&ensp;&ensp;加小括号\n\n```c\n#define MY_MUL1(a,b) a*b \n#define MY_MUL2(a,b) ((a)*(b)) \nvoid fun1(void)\n{\n    printf(\"MY_MUL1 = %d\\n\",MY_MUL1(10,20));    //200     //MY_ MULI (10,20)==10*20\n\n    //MY MUL1 ( 10+10 , 20+20 )==10+10*20+20\n    printf(\"MY_MUL1 = %d\\n\",MY_MUL1(10+10,20+20));    //230     //不能保证完整性 \n    //MY_MUL2(10+10, 20+20) ==((10+10)*(20+20))\n    printf(\"MY_MUL2 = %d\\n\",MY_MUL2(10+10,20+20));    //800     //保证完整性 \n}\n```\n\n## 3、带参数的宏(宏函数)和普通函数的区别\n\n&ensp;&ensp;&ensp;&ensp;带参数的宏(宏函数)：调用多少次就会展开多少次，执行代码的时候没有函数调用的过程，也不需要函数的出入栈，所以带参数的<font color=\"red\">宏浪费空间节省了时间</font>\n\n&ensp;&ensp;&ensp;&ensp;代参的函数：代码只有一份，存在代码段，调用的时候去代码段读取函数指令 ，调用的时候要压栈(保存调用函数前的相关信息)，调用完出栈(恢复调用函数前的相关信息)，所以<font color=\"red\">函数浪费了时间节省空间</font>\n\n# <center>知识点四：条件编译</center>\n\n&ensp;&ensp;&ensp;&ensp;如果xxx为真则运行语句1，为假运行语句2。\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221501525.png\" alt=\"条件编译解析\" style=\"zoom: 50%;\" />\n\n```c\n//通过条件编译控制大小写的转换\n#include<stdio.h>\n\nint main(int argc,char *argv[])\n{\n    char buf[128] = \"\";\n    printf(\"请输入字符串\");\n    // fgets 会获取换行符 \n    fgets(buf,sizeof(buf),stdin);\n    int i = 0;\n    //去掉换行符  strlen返回的是字符串是长度 不包含'\\0'\n    //strlen(buf)-1 这是换行符的下标位置\n    buf[strlen(buf)-1] = '\\0';\n    //buf[i]是取数组中的第i个元素的值。\n    //while(buf[i] != '\\0')\n    while(buf[i])   //最后一一个元素是'\\0' == 0==假循环进不去\n    {\n#if 1\n        if(buf[i]>= 'A' && buf[i]<='Z')\n         buf[i] = buf[i]+32;\n#else\n         if(buf[i]<= 'a' && buf[i]<='z')\n         buf[i] = buf[i]-32;\n#endif\n    i++;\n    }\n    printf(\"buf = %s\\n\",buf);\n}\n```\n\n# <center>知识点五、防止头文件重复包含</center>\n\n方式一：#pragma once 编译器决定\n\n```c\n#pragma once 放在头文件的最前方\n```\n\n方式二：c/c++的标准制定\n\n```c\n#ifndef __头文件名_H__     //大写\n#define\n    //头文件具体内容\n#endif\n```\n\n总结：\n\n&ensp;&ensp;&ensp;&ensp;#pragma once 编译器决定强调的文件名\n\n&ensp;&ensp;&ensp;&ensp;#ifndef c/c++标准制定强调的宏而不是文件\n\n# <center>知识点六：原码、补码、反码</center>\n\n负数在计算机中存储的是补码\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221501283.png\" alt=\"原码、反码、补码\" style=\"zoom: 67%;\" />\n\n注意：无符号数，正数，他们的原码 == 反码 ==  补码\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;负数：反码 = 原码的符号位不变其他位取反\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;补码 = 反+1\n\n计算机为啥要补码?\n\n如果没有补码：\n\n&ensp;&ensp;&ensp;&ensp;6-10 == -4\n\n&ensp;&ensp;&ensp;&ensp;6+(-10) == -4\n\n&ensp;&ensp;&ensp;&ensp;0000 0110\n\n&ensp;&ensp;&ensp;&ensp;1000 1010\n\n————————————————————————\n\n&ensp;&ensp;&ensp;&ensp;1001 0000 == -16 (错误)\n\n如果有补码：\n\n&ensp;&ensp;&ensp;&ensp;0000 0110\n\n&ensp;&ensp;&ensp;&ensp;1111 0110\n\n---------------------------------------&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;补码转原码：取反加一\n\n&ensp;&ensp;&ensp;&ensp;1111 1100----->1000 0011--->1000 0100 ==> -4\n\n总结：补码的意义.将减法运算变加法运算\n\n以1字节分析：\n\n&ensp;&ensp;&ensp;&ensp;有符号符: 1111 1111 ~ 1000 0000~0000 0000 ~ 0111 1111\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;-127  ~    -0\t    ~    +0  \t ~   +127\n\n计算机为了扩数据的表示范围:故意将 -0 看成-128\n\n&ensp;&ensp;&ensp;&ensp;&ensp;-128~127\n\n无符号数：0000 0000 ~ 1111 1111 == 0~255\n\n总结：补码统一 0 的编码\n\n&ensp;&ensp;&ensp;&ensp;+0 == 0000 0000==0000 0000 (反码) ==0000 0000 (补码)\n\n&ensp;&ensp;&ensp;&ensp;-0 == 1000 0000 ==1111 1111 (反码) ==0000 0000 (补码)\n\n# <center>知识点七：计算机对数据的 存储 与 读取</center>\n\n存储：\n\n```c\nvoid test01 ()//存储\n{\n    //负数 以补码存储\n    char data = -10;\n    //正数 以原码存储\n    char data2 = 10;\n    //十六进制以原码存储(\n    char data3 = 0xae;     //Oxae==1010 1110\n    //八进制 以原码存储\n    char data4 = 0256;    //0256==1010 1110\n    //每3位二进制代表一位八进制\n    //如果数据越界 以原码 存储\n    char data5 = 129;    // 1000 0001\n    unsigned char data6 = -10;    //0000 1010\n    //取%x %u %o都是输出内存的原样数据\n    //每4位二进制 代表一位十六进制 (记住)\n    printf(\"%x \\n\",data);    //0xf6==1111 0110\n    printf(\"%x\\n\",data2);    //0x0a ==0000 1010\n    printf(\"%x\\n\",data3);     //0xae\n    printf(\"%x\\n\",data4);    //0xae\n    printf(\"%x\\n\",data5);    //0x81\n    printf(\"%x\\n\",data6);    //0xfb\n}\n```\n\n读取：\n\n```c\nvoid test02 ()\n{\n    char data1 = -10;  //-10 == 1000 1010\n    char data2 = 10;\n    //取:%d %hd %ld有符号取%u %x %o %lu都是无符号取\n    //有符号取:%d %hd %ld\n    //首先看内存的最高位如果为1 将内存数据符号位不变取反+1到原码\n    //最高位如果为0将数据原样输出。\n    //无符号取:将内存数据原样输出\n    printf(\"%d\\n\", data1) ;//-10\n    //datal & 0x000000ff只取低8位\n    printf (\"%u\\n\", data1 & 0x000000ff) ;//246==1111 0110\n    printf(\"%d\\n\",data2);\n}\n```\n\n","tags":["C语言"],"categories":["编程语言","C语言"]},{"title":"5.内存","url":"/post/df718222.html","content":"\n# <center>知识点一：内存分区</center>\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221500413.png\" alt=\"内存分析\" style=\"zoom: 33%;\" />\n\n# <center>知识点二：普通局部变量、 普通全局变量、静态局部变量、静态全局变量</center>\n\n## 1、普通<mark>局部</mark>变量\n\n&ensp;&ensp;&ensp;&ensp;定义形式:在函数<mark>里</mark>面定义的普通变量就是普通局部变量。\n\n```c\nvoid test01 ( )\n{\n    int numl=10;//普通局部变量\n}\n```\n\n&ensp;&ensp;&ensp;&ensp;作用范围：离它<mark>最近</mark>的 <font color=\"red\">{}</font> 之间有效\n\n&ensp;&ensp;&ensp;&ensp;生命周期：离它最近的 <font color=\"red\">{}</font> 之间有效，离开 {} 的局部变量系统自动回收\n\n&ensp;&ensp;&ensp;&ensp;存储区域：<mark>栈区</mark>\n\n&ensp;&ensp;&ensp;&ensp;注意事项：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1）普通局部变量<mark>不</mark>初始化<font color=\"red\">内容不确定</font>\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;2）普通局部变量<mark>同名</mark> <font color=\"red\">就近原则</font>（同一个{}里的）\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221500597.png\" alt=\"局部变量注意事项\" style=\"zoom: 50%;\" />\n\n```c\nvoid test0l ()\n{\n    //局部变量同名就近原则\n    int data= 100;\n    {\n        int data = 200;\n        printf(\"A:data = %d\\n\", data) ;    //200\n    }    \n    printf(\"B:data = %d\\n\", data) ;        //100\n}\n```\n\n## 2、普通<mark>全局</mark>变量\n\n&ensp;&ensp;&ensp;&ensp;&ensp;定义形式：定义在<mark>函数外边</mark>的变量就是普通全局变量\n\n```c\nint data;//普通全局变量 在函数外边定义\nvoid test02()\n{\n}\n```\n\n&ensp;&ensp;&ensp;&ensp;&ensp;作用范围:\n\n&ensp;&ensp;&ensp;&ensp;&ensp;1）当前源文件都有效\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;全局变量声明的时候最好也加上extern（用于区别）\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;如果函数在全局变量定义的上方，如果没有变量声明则不可用，声明时注意不要赋值\n\n&ensp;&ensp;&ensp;&ensp;&ensp;2）<mark>其他源文件</mark>使用<font color=\"red\">全局变量</font>时，<mark>必须</mark>加 <font color=\"red\">extern</font> 声明\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;//extern本质：告诉编译器 变量、函数 来至其他源文件\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221501658.png\" alt=\"全局变量解析\" style=\"zoom: 50%;\" />\n\n&ensp;&ensp;&ensp;&ensp;&ensp;生命周期：整个 进程 都有效(程序结束的时候全局变量才被释放)\n\n&ensp;&ensp;&ensp;&ensp;&ensp;存储区域：<mark>全局区</mark>\n\n&ensp;&ensp;&ensp;&ensp;&ensp;注意事项：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1）全局变量<mark>不</mark>初始化内容为 <mark>0</mark>\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;2）如果全局变量要在其他源文件中使用必须在所使用的源文件中加extern声明\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;3）如果<mark>全局</mark>变量和<mark>局部</mark>变量同名 在 {} 中优先使用<font color=\"red\">局部</font>变量\n\n## 3、静态<mark>局部</mark>变量\n\n&ensp;&ensp;&ensp;&ensp;定义形式:在函数<mark>中</mark>定义前面必须加 static 修饰这样的变量叫静态局部变量\n\n```c\nvoid test01 ()\n{\n    static int num;//静态局部变量\n    return ;\n}\n```\n\n&ensp;&ensp;&ensp;&ensp;作用范围：离它<mark>最近</mark>的 <font color=\"red\">{}</font> 之间有效\n\n&ensp;&ensp;&ensp;&ensp;生命周期：整个进程（程序结束的时候静态局部变量才被释放）\n\n&ensp;&ensp;&ensp;&ensp;存储区域：<mark>全局区</mark>\n\n&ensp;&ensp;&ensp;&ensp;注意事项：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1）静态局部变量<mark>不</mark>初始化内容为<mark>0</mark> （全局区）\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;2）只能被初始化一次（重要）\n\n```c\n#include<stdio.h>\nvoid fun1(void)\n{\n    //静态局部变量只能被初始化一次\n    static int num = 10;    //静态局部变量 \n    num++;\n    printf(\"num = %d\\n\",num);\n    return;\n}\nint main(int argc,char *argv[])\n{\n    fun1();\n    fun1();\n    fun1();\n}\n```\n\n## 4、静态<mark>全局</mark>变量\n\n&ensp;&ensp;&ensp;&ensp;定义形式：在函数<mark>外</mark>边定义同时加 <font color=\"red\">static</font> 这样的变量就是静态全局变量\n\n```c\n#include<stdio. h>\nstatic int data = 10;//静态全局变量\nint main(int argc, char *argv[ ])\n{   \n\treturn 0;\n}\n```\n\n&ensp;&ensp;&ensp;&ensp;作用范围：当前源文件有效 不能在其他源文件 中使用\n\n&ensp;&ensp;&ensp;&ensp;生命周期：整个进程(程序结束 静态全局变量才被释放)\n\n&ensp;&ensp;&ensp;&ensp;存储区域：<mark>全局区</mark>\n\n&ensp;&ensp;&ensp;&ensp;注意事项：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1）静态全局变量<mark>不</mark>初始化内容为 <mark>0</mark>\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;2）静态全局变量只在当前源文件有效\n\n# <center>知识点三：全局函数(普通函数) 和 静态函数 (局部函数)</center>\n\n## 1、全局函数(普通函数)\n\n```c\nvoid my_ fun(void )\n{\n    printf(\"(全局函数)普通函数\\n\");\n    return;\n}\n```\n\n&ensp;&ensp;&ensp;&ensp;&ensp;特点：其他源文件可以使用全局函数，必须加 <font color=\"red\">extern</font> 声明\n\n## 2、静态函数 (局部函数)\n\n```c\nstatic void my_static_fun(void)\n{\n    printf(\"(静态丽数)局部函数\\n\");\n    return;\n}\n```\n\n&ensp;&ensp;&ensp;&ensp;&ensp;特点：只能在当前源文件使用，<mark>不</mark>能在其他源文件使用\n\n&ensp;&ensp;&ensp;&ensp;&ensp;注意：如果想在其他源文件调用静态函数，需要将<font color=\"red\">静态函数</font><mark>封装</mark>在<font color=\"red\">全局函数</font>中，同时全局函数和静态函数必须是同一个源文件\n","tags":["C语言"],"categories":["编程语言","C语言"]},{"title":"4.函数","url":"/post/3b48d11a.html","content":"\n1、函数的定义：实现函数功能、确定函数体、返回值类型、形参类型。让函数存在\n\n2、函数的声明：不是实现函数功能仅仅是说明改函数有返回值类型、形参类型、函数名\n\n3、函数的调用：函数的执行\n\n# <center>知识点一：函数的概述</center>\n\n## <center>1、函数的定义</center>\n\n```c\n//返回值类型:函数将来返回值的类型\n//函数名:函数的入口地址\n//形参:函数外部数据 传递到 函数内部的 桥梁\n//函数体:具体的函数功能带\n返回值类型 函数名(形参类型 形参)        //形参可以不止一个\n{\n    函数体;\n}\n```\n\n## <center>2、函数的声明</center>\n\n省略函数声明：函数的`调用`，在函数`定义的下方`可以省略函数声明\n\n```c\n返回值类型 函数名(形参类型 形参);        //形参可以不止一个\n```\n\n## <center>3、函数的调用</center>\n\n```c\n//函数外部的实际数据\n函数名(实参);\n```\n\n```c\n#include<stdio.h>\n//函数声明:告诉编译器该函数存在请通过编译。\nvoid myfun();\nint main(int argc,char *agrv[])\n{\n    //函数的调用:函数名+()\n    myfun();\n    return 0;\n}\n//函数的定义 \nvoid myfun()\n{\n    printf(\"my fun\\n\");\n    return;\n}\n```\n\n# <center>知识点二：函数参数</center>\n\n如果函数的形参啥都不写在调用的时候可以传实参，只是实参 得不到使用\n\n如果函数没有参数请将 <mark>形参</mark> 写成<font color=\"red\">void</font>\n\n# <center>知识点三：函数参数传递</center>\n\n1、函数的 <mark>形参</mark> 本质：函数的局部变量\n\n2、形参在函数<mark>定义</mark>的时候不会开辟空间，只在函数<mark>调用</mark>的时候才开辟空间\n\n3、形参在函数结束的时候才被释放\n\n4、函数名代表的是函数的入口地址\n\n5、函数的<mark>返回值</mark> <font color=\"red\"><=4</font> 字节存放<mark>寄存器</mark> <font color=\"red\">>4</font> 字节存放在<mark>栈区</mark>\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221500662.png\" alt=\"函数参数传递解析\" style=\"zoom: 50%;\" />\n","tags":["C语言"],"categories":["编程语言","C语言"]},{"title":"3.数组","url":"/post/7422213c.html","content":"\n**<font color=\"red\">任何数组的数组名代表数组首元素地址</font>**\n\n# <center>知识点一：<mark>一维</mark>数组</center>\n\n## 1、数组的概述\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221459670.png\" alt=\"一维数组\" style=\"zoom: 50%;\" />\n\n## 2、一维数组的定义\n\n&ensp;&ensp;&ensp;&ensp;&ensp;格式：<font color=\"red\">数据类型 数组名[数组元素个数]</font>\n\n&ensp;&ensp;&ensp;&ensp;&ensp;需求：请定义一个数组，该数组有10个元素每个元素为int   例：int arr[10];\n\n&ensp;&ensp;&ensp;&ensp;&ensp;注意(int arr[10])：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1）数组名arr不能和其他变量名同名\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;2）数组的元素小标是从0开始: 0~9\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;3）数组的元素分别是: arr[0]、 arr[1] ~ arr[9]，如果访问arr[10]数组越界\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;4）数组的元素等价于普通变量\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;5）在定义数组的时候，<mark>[]</mark>里面的值<mark>不能</mark>是<mark>变量</mark>（C89标准）\n\n## 3、数组的遍历\n\n```c\n#include<stdio.h>\nvoid test7()\n{\n    //局部变量，如果不初始化内容不确定 \n    int arr[10];\n    int i = 0;\n    //遍历数组 \n    for(i = 0;i<10;i++)\n    {\n        printf(\"%d\",arr[i]);  //输出的都是不确定的值 \n    }\n    printf(\"\\n\");\n} \n```\n\n## 4、数组初始化\n\n初始化：定义的时候给变量或数组元素赋值的动作叫初始化\n\n### （1）<mark>全部</mark>初始化：\n\n```c\nint arr[5] = {10, 20,30, 40, 50};\n//如果是全部初始化数组 元素的个数 可以省略 实际的元素个数 由初始化个数决定\nint arr[] = {10,20,30, 40,50};       //少用\n```\n\n### （2）<mark>部分</mark>初始化：\n\n```c\n//部分初始化 未被初始化 部分自动补0\nint arr[5] = {10,20, 30};\n//初始化数组 常见的操作 (将数组的所有元素清零)\nint arr[5] = {0};         //只初始化arr[0]=0,未被初始化部分 自动补0，则全部都为0\n```\n\n### （3）扩展：初始化\n\n```c\nint arr[5]={[2]=3,[4]=7};//0 030 7\n//[2]=3将数组的第2个元素，初始化为3\n//[4]=7将数组的第4个元素，初始化为7\n```\n\n## 5、数组的空间大小：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;1）arr数组名作为数组类型时，代表的是数组空间的总大小\n\n&ensp;&ensp;&ensp;&ensp;&ensp;2）数组的总大小 = 元素的个数 * 每个元素的大小\n\n&ensp;&ensp;&ensp;&ensp;&ensp;3）数组：元素的大小  arr[0]是数组的第0个元素\n\n&ensp;&ensp;&ensp;&ensp;&ensp;4）数组元素的`个数` = `数组总大小 / 每个元素的大小`\n\n```c\n#include<stdio.h>\nvoid test1()\n{\n    //arr数组名作为数组类型代表的是数组空间的总大小 \n    int arr [5] = {10,20,30,40,50};\n    int n = 0;\n    \n    //数组的总大小=元素的个数*每个元素的大小 \n    printf(\"数组的总大小:%d\\n\",sizeof(arr));\t//数组的总大小20\n    \n    //数组:元素的大小    arr[0] 是数组的第0个元素\n    printf(\"数组元素的大小=%d\\n\",sizeof(arr[0]));\t//数组元素大小=4\n    \n    //数组元素的个数 = 数组总大小/每个元素的大小\n    n = sizeof(arr)/sizeof(arr[0]);\n    printf(\"数组元素的个数=%d\\n\",n);\t//数组元素的个数=5\n}\nint main(int argc,char *argv[])\n{\n    test1();\n    return 0;\n}\n```\n\n## 6、数组元素的操作\n\n数组的<mark>元素</mark>等价于<font color=\"red\">普通变量</font>\n\n```c\n//num++;\narr [1]++;  //arr[1] = arr[1]+1;\n //scanf(\"%d\",&num)\nscanf(\"%d\",&arr[2]);\n```\n\n## 7、键盘获取一维数组\n\n```c\nint arr [5] = {0};\nint i = 0;\n    \nfor(i=0;i<n;i++)\n{\n    scanf(\"%d\",&arr[i]);\n}\n```\n\n# <center>知识点二：<mark>二维</mark>数组</center>\n\n## 1、二维数组的定义\n\n&ensp;&ensp;&ensp;&ensp;&ensp;格式：<font color=\"red\">数据类型 数组名\\[<mark>行</mark>的个数][<mark>列</mark>的个数]</font>\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221459232.png\" alt=\"二维数组\" style=\"zoom: 33%;\" />\n\n&ensp;&ensp;&ensp;&ensp;&ensp;**int arr \\[3][4]**\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221459546.png\" alt=\"二维数组地址分析\" style=\"zoom: 50%;\" />\n\n## 2、二维数组的遍历\n\n```c\nint i=0;\nint j = 0;\n//遍历第i列\nfor(i=0;i<3;i++)\n{\n    //遍历第j行    \n    for(j = 0;j<4; j++)\n    {\n        printf(\"%d \",arr[i][j] )\n    }\n}\n```\n\n## 3、二维数组初始化\n\n&ensp;&ensp;&ensp;&ensp;&ensp;不管是数值还是字符的二维数组，在初始化的时候是可以<mark>省略行标</mark>的，行数由具体<font color=\"red\">初始化元素个数</font>和<font color=\"red\">列数</font>决定出所需要的行数\n\n<mark>分段初始化</mark>：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;用{}里面的{}明确的表示一行\n\n```c\nint arr[3][4] = { {1,2,3,4}， {5,6,7,8}， {9,10,11,12} };\n```\n\n<mark>连续初始化</mark>：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;放满一行才能放下一行\n\n```c\nint arr[3][4] = {1,2,3,4,5,6,7,8,9, 10,11, 12};\n```\n\n## 4、键盘获取二维数组\n\n```c\nint i,j = 0;\nint arr [3][4] = {0};\nfor(i=0;i<3;i++)\n{\n    for(j=0;j<4;j++)\n    {\n        scanf(\"%d\",&arr[i][j]);\n    }\n}\n```\n\n","tags":["C语言"],"categories":["编程语言","C语言"]},{"title":"2.基本语句","url":"/post/6271a51c.html","content":"\n# <center>知识点一：数据类型转换</center>\n\n## 1、自动类型转换\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221457015.png\" alt=\"自动转换类型图\" style=\"zoom: 33%;\" />\n\n## 2、强制类型转换\n\n&ensp;&ensp;&ensp;&ensp;形式：<font color=\"red\">**(类型说明符) (表达式)**</font>\n\n&ensp;&ensp;&ensp;&ensp;例：(int)(x+y);&ensp;&ensp;&ensp;&ensp;&ensp;// 把x+y的结果值转换为整型\n\n```c\n#include <stdio.h>\nint test04()\n{\n    float x = 3.14f;\n    int j = 0;\n    //强制类型转换 只是临时的转换 当前语句有效，在后面的语句中不会更改x的值\n    j = (int)x;\n    printf(\"j = %d,x = %f\\n\",j,x);\t//j = 3,x = 3.140000\n    return 0;\n}\nint main(int argc,char *argv[])\n{\n    test04();\n    return 0;\n}\n```\n\n\n\n# <center>知识点二：运算符</center>\n\n## 1、运算符\n\n算术运算符\n\n|              +：加              |                        -：减                         |\n| :-----------------------------: | :--------------------------------------------------: |\n|              *：乘              | / ：取整(a/b   a，b必须都为整数)(如果是浮点数是：除) |\n| %：取余(a%b   a，b必须都为整数) |                                                      |\n\n```c\n#include <stdio.h>\nint test05()\n{\n    printf(\"%d\\n\",5/2);  //取整,2\n    printf(\"%d\\n\",5%2);  //取余,1\n    printf(\"%d\\n\",5/2);\t//2\n    printf(\"%f\\n\",5/2.0f);\t//2.500000\n    return 0;\n}\nint main(int argc,char *argv[])\n{\n    test05();\n    return 0;\n}\n```\n\n复合运算符\n\n|  +=：变量 = 左边加右边  |  -=：变量 = 左边减右边  | *=： 变量 = 左边乘右边 |\n| :---------------------: | :---------------------: | ---------------------- |\n| /=：变量 = 左边取整右边 | %=：变量 = 左边取余右边 |                        |\n\n```c\n#include <stdio.h>\nint test13()\n{\n    int data = 3;\n    data *= 3+5;  //data = data *(3+5);\n    printf(\"data = %d\\n\",data);\t//data = 24\n    return 0;\n}\nint main(int argc,char *argv[])\n{\n    test13();\n    return 0;\n}\n```\n\n\n\n## 2、关系运算符\n\n|   ＞：大于    |   ＜：小于   | = =：等于  |\n| :-----------: | :----------: | :--------: |\n| \\>=：大于等于 | <=：小于等于 | !=：不等于 |\n\n## 3、逻辑运算符\n\n&ensp;&ensp;&ensp;&ensp;<mark>&&</mark>：逻辑<font color=\"red\">与</font>\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;A && B \n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;A B同时为真整个表达式结果为真， A B只要有一个为假整个表达式为假\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;短路特性：如果第一个 A 就为假则后面不再执行 B\n\n&ensp;&ensp;&ensp;&ensp;<mark>||</mark>：逻辑<font color=\"red\">或</font>\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;A || B 只要A B任意一个为真，整个表达式结果为真，A B同时为假时结果才为假\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;短路特性：如果表达式 A 为真，则表达式 B 不会进行运算\n\n&ensp;&ensp;&ensp;&ensp;<mark>!</mark>：逻辑<font color=\"red\">非</font>\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;含义：如果原本表达式为真，则为假，原本表达式为假，则为真\n\n## 4、位运算（二进制位操作）\n\n<mark>&</mark>：按位<font color=\"red\">与</font>\n&ensp;&ensp;&ensp;&ensp;语法：<font color=\"red\">全1为1，其他为0</font>\n\n&ensp;&ensp;&ensp;&ensp;例&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1010 1010\n\n&ensp;&ensp;&ensp;&ensp;&&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1111 0000\n\n————————————————————————\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1010 0000\n\n&ensp;&ensp;&ensp;&ensp;特点：和1 相与 保持不变，和0 相与 全清零\n\n&ensp;&ensp;&ensp;&ensp;应用场景：将固定位清零\n\n<mark>|</mark>： 按位<font color=\"red\">或</font>\n&ensp;&ensp;&ensp;&ensp;语法：<font color=\"red\">有1就为1，全0才为0</font>\n\n&ensp;&ensp;&ensp;&ensp;例：&ensp;&ensp;&ensp;&ensp;&ensp;1010 1010\n\n&ensp;&ensp;&ensp;&ensp;|&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1111 0000\n\n————————————————————————————\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1111 1010\n\n&ensp;&ensp;&ensp;&ensp;特点：和0 相或 保持不变，和1 相或 全变1\n\n&ensp;&ensp;&ensp;&ensp;应用场景：将固定为1\n\n<mark>~</mark>：按位取<font color=\"red\">反</font>\n\n&ensp;&ensp;&ensp;&ensp;语法：<font color=\"red\">0变1，1变0</font>\n\n &ensp;&ensp;&ensp;&ensp;~ 1010 1010 == 0101 0101\n\n&ensp;&ensp;&ensp;&ensp;应用场景：配合&|操作\n\n<mark>^</mark>：按位<font color=\"red\">异或</font>\n\n&ensp;&ensp;&ensp;&ensp;语法：<font color=\"red\">相同为0不同为1</font>\n\n&ensp;&ensp;&ensp;&ensp;例：&ensp;&ensp;&ensp;&ensp;&ensp;1010 1010\n\n&ensp;&ensp;&ensp;&ensp;^&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;0000 1111\n\n——————————————————————\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1010 0101\n\n&ensp;&ensp;&ensp;&ensp;&ensp;特点：和0 异或 保持不变，和1 异或 取反\n\n&ensp;&ensp;&ensp;&ensp;&ensp;应用场景：将固定的为发生高低电频翻转\n\n## 5、<< ：左移运算符\n\n<font color=\"red\">左边丢弃，右边补0</font>\n\n注意：移动的位数不要超过自身长度\n\n&ensp;&ensp;&ensp;&ensp;1010 1100 << 2\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221458535.png\" alt=\"左移\" style=\"zoom: 50%;\" />\n\n<mark>右移</mark>分类：\n\n&ensp;&ensp;&ensp;&ensp;<mark>逻辑</mark>右移：<font color=\"red\">右边丢弃，左边补0</font>\n\n&ensp;&ensp;&ensp;&ensp;<mark>算术</mark>右移：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<mark>无</mark>符号数：<font color=\"red\">右边丢弃，左边补0</font>\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<mark>有</mark>符号数：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;正数：<font color=\"red\">右边丢弃，左边补0</font>\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;负数：<font color=\"red\">右边丟弃，左边补</font><mark>1</mark>\n\n总结：右移基本上是右边丢弃左边补0，只有负数且算术右移左边才会补1\n\n逻辑右移和算术右移是编译器决定，但是我们可以检测\n\n<mark>位数</mark>：<font color=\"red\">从右到左数</font>\n\n综合例：将data的第1、5清0，第3, 4位 置1其他为保持不变    data 1010 1010\n\n将data的第1、5清0:\n\n&ensp;&ensp;&ensp;&ensp;data = data & 1101 1101;\n\n&ensp;&ensp;&ensp;&ensp;1101 1101 = ~ (0010 0010) = ~ (0010 0000 | 0000 0010)\n\n&ensp;&ensp;&ensp;&ensp;0010 0000 = 0000 0001 << 5\n\n&ensp;&ensp;&ensp;&ensp;0000 0010 = 0000 0001 << 1\n\n&ensp;&ensp;&ensp;&ensp;1101 1101 = ~(0x01 <<5| 0x01<<1)\n\n&ensp;&ensp;&ensp;&ensp;data = data & ~(0x01<<5 | 0x01<<1)\n\n清零：& ~（0x01<< 清零的位数(大)  |  0x01<<清零的位数(小)）\n\n第3, 4位置1：\n\n&ensp;&ensp;&ensp;&ensp;data = data | 0001 1 000;\n\n&ensp;&ensp;&ensp;&ensp;0001 1000 = 0001 0000 | 0000 1000\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;= 0x01<<4 | 0x01<<3\n\n&ensp;&ensp;&ensp;&ensp;data = data | (0x01<<4 | 0x01<<3); \n\n&ensp;&ensp;&ensp;&ensp;置1： | (0x01<< 置1的位数(大) | 0x01<< 置1的位数(小) )\n\n## 6、条件运算符\n\n&ensp;&ensp;&ensp;&ensp;形式：<font color=\"red\">(  )?(  ):(  )</font>\n\n&ensp;&ensp;&ensp;&ensp;表达式1 ? 值1 : 值2（如果有嵌套看准<mark> ? </mark>分别）\n\n&ensp;&ensp;&ensp;&ensp;语法：如果表达式1为真，整个表达式的值为“值1”，否则为“值2\"\n\n## 7、逗号运算符\n\n&ensp;&ensp;&ensp;&ensp;形式：<font color=\"red\">(... , ... , ...)</font>\n\n&ensp;&ensp;&ensp;&ensp;从左向右依次执行，最后的表达式的值是整个运算的结果\n\n```c\n#include <stdio.h>\nint test12()\n{\n    int data = 0;\n    data = 3>2?5:6;\n    printf(\"data=%d\\n\",data);\t//data = 5\n}\nint main(int argc,char *argv[])\n{\n    test12();\n    return 0;\n}\n```\n\n## 8、自增自减运算符（++  --）\n\n&ensp;&ensp;&ensp;&ensp;<mark>++</mark>i 或 <mark>- -</mark>i  先加、减，后使用\n\n&ensp;&ensp;&ensp;&ensp;i<mark>++</mark> 或 i<mark>- -</mark>   先使用，后加、减\n\n&ensp;&ensp;&ensp;&ensp;注意: i++ 或 ++i 作为单独的指令没有区别\n\n```c\n#include <stdio.h>\nint test14()\n{\n    //++i\n    int i = 3;\n    int j = 0;\n    j = ++i;   //++i == i=i+1     j=i\n    printf(\"j=%d,i=%d\\n\",j,i);\t//j=4,i=4\n    //i++\n    int i = 3;\n    int j = 0;\n    j = i++;   //j=i  i++ == i=i+1\n    printf(\"j=%d,i=%d\\n\",j,i);\t//j=3,i=4\n    \n    //单独使用\n    int j = 3;\n    int i = 3;\n    i++;\n    printf(\"i = %d\\n\",i);\t//i = 4\n    ++j;\n    printf(\"j = %d\\n\",j);\t//j = 4\n    return 0;\n}\nint main(int argc,char *argv[])\n{\n    test14();\n    return 0;\n}\n```\n\n# <center>知识点三：优先级</center>\n\n优先级 高 先执行，同级别的优先级要看结合性。\n\n自己写代码时尽量用 ()\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221458000.png\" alt=\"优先级1\" style=\"zoom:80%;\" />\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221459370.png\" alt=\"优先级2\" style=\"zoom:80%;\" />\n\n# <center>知识点四：键盘输入语句</center>\n\n格式：<font color=\"red\">scanf(\"%相对应的字符输出格式\",要输入对应变量的地址);</font>\n\n```c\n#include<stdio.h>\nint main(int argc,char *argv[])\n{\n    char ch;\n    printf(\"请输入一个字符:\");\n    //scanf中%c只能提取一个字符\n\t//scanf(\"%c\",&ch);\n    ch = getchar();  //获取一个字符\n    printf(\"ch = %c\\n\",ch);\t//ch = a\n    printf(\"ch = %d\\n\",ch);\t//ch = 97\n    return 0;\n}\n```\n\n# <center>知识点五：if条件语句</center>\n\n## <center>1、if</center>\n\n项目只有一个结果\n\n```c\n形式：\nif(表达式)\n{\n    语句1;\n}\n```\n\n运行方式：表达式为真才会执行语句1;\n\n```c\n#include <stdio.h>\nvoid test16()\n{\n    int data = 0;\n    printf(\"请输入一一个int数据:\");\n    scanf(\"%d\",&data);\n    //判断能被2整除\n    if(data % 2 == 0)\n    {\n        printf(\"被2整除\");\n    }\n}\nint main(int argc,char *argv[])\n{\n    test16();\n    return 0;\n}\n```\n\n## <center>2、if......else.....</center>\n\n如果项目的只有两种结果 且不会同时出现\n\n```c\nif(表达式)\n{\n    语句1;\n}\nelse\n{\n    语句2；\n}\n```\n\n运行方式：表达式为真，执行语句1，否则执行语句2\n\n```c\n#include <stdio.h>\nvoid test16()\n{\n    int data = 0;\n    printf(\"请输入一一个int数据:\");\n    scanf(\"%d\",&data);\n    //判断data对2的余数 结果：1或0\n    if(data % 2 == 0)\n    {\n        printf(\"余数为0\\n\");\n    }\n    else\n    {\n        printf(\"余数为1\\n\");\n    }\n}\nint main(int argc,char *argv[])\n{\n    test16();\n    return 0;\n}\n```\n\n## <center>3、if....else if.....else if.....else....</center>\n\n如果一个项目有多个结果且不同时出现\n\n```c\nif(表达式1)\n{\n    语句1;\n}\nelse if(表达式2)\n{\n    语句2;\n}\n......\nelse//可省略\n{\n    语句n;\n}\n```\n\n&ensp;&ensp;&ensp;&ensp;运行方式：只有表达式1为真，执行语句1，只有表达式2为真，执行语句2，所有表达式都为假才执行语句n\n\n&ensp;&ensp;&ensp;&ensp;注意:只有前面的条件不满足才会判断后面的条件，如果前面的条件满足后面的条件不管真假都不会执行\n\n```c\n#include <stdio.h>\nvoid test16()\n{\n    int data = 0;\n    printf(\"请输入一一个int数据:\");\n    scanf(\"%d\",&data);\n    //判断data对3的余数  结果：0 1 2\n    if(data % 3 == 0)\n    {\n        printf(\"余数为0\\n\");\n    }\n    else if(data % 3 == 1)\n    {\n        printf(\"余数为1\\n\");\n    }\n    else if(data % 3 == 2)\n    {\n        printf(\"余数为2\\n\");\n    }\n}\nint main(int argc,char *argv[])\n{\n    test16();\n    return 0;\n}\n```\n\n## <center>4、if单个重复使用</center>\n\n一个项目有多个结果，不确定是否同时出现\n\n其中每个if语句是独立的\n\n```c\nif(表达式1)\n{\n    语句1;\n}\nif(表达式2)\n{\n    语句2;\n}\nif(表达式3)\n    语句3;\n}\n```\n\n# <center>知识点六：switch 选择语句</center>\n\n&ensp;&ensp;&ensp;&ensp;运行方式：将case后的值与switch后面的表达式的值对比，如果表达式的值刚好等于case后面的某一个值，就会立即去执行case后的语句，如果都不是，则会执行default后面的语句\n\n```c\n形式：\nswitch(表达式)\n{\n    case值1:          //值不能是浮点型、字符串\n        语句1;\n        break ;      //break作用：跳出循环但只能跳出离它最近的一层循环\n    case值2:\n        语句2;\n        break ;\n    case值3:\n        语句3;\n        break;\n        ......\n    default:         //可以省略\n        语句n;\n        break;\n}\n```\n\n```c\n#include <stdio.h>\nvoid test18()\n{\n    char ch = 0;\n    printf(\"请输入你的方向：wsda\\n\");\n    ch = getchar();\n    switch(ch)\n    {\n        case'w':\t//break省略\n        case'W':\n            printf(\"向上移动\\n\");\n        break;\n        case'A':\n        case'a':\n            printf(\"向左移动\\n\");\n        break;\n        case'S':\n        case's':\n            printf(\"向下移动\\n\");\n        break;\n        case'd':\n        case'D':\n            printf(\"向右移动\\n\");\n        break;\n    }\n}\nint main(int argc,char *argv[])\n{\n    test18();\n    return 0;\n}\n```\n\n## <center>continue</center>\n\n&ensp;&ensp;&ensp;&ensp;结束本次循环，立即从当前位置，进入下一次循环\n\n```c\n#include <stdio.h>\nvoid test02()\n{\n    int i,sum = 0;\n    for(i = 1;i<=100;i++)\n    {\n        if(i == 50)\n            continue;  //结束本次循环，立即从当前位置，进入下一次循环 \n        sum += i;\n    }\n    printf(\"sum = %d\\n\",sum);\t//sum = 5000\n}\nint main(int argc,char *argv[])\n{\n    test02();\n}\n```\n\n# <center>知识点七：for循环</center>\n\n&ensp;&ensp;&ensp;&ensp;执行顺序：先执行初始语句，然后执行循环条件，如果循环条件成立，则执行循环语句，当语句块执行完毕之后，接着步进条件，然后再执行循环条件，如果循环条件成立，则继续执行循环语句，以此类推，直到循环条件不成立，循环结束\n\n```c\nfor(初始语句;循环条件;步进条件)\n{\n    //循环语句\n}\n//初始语句：只在循环开始时执行一-次\n//循环条件: 每次循环都要执行，如果循环条件为 真 进入循环体，如果为 假 退出循环\n//步进条件：每次循环结束的时候要执行的语句\n```\n\n嵌套for循环：总结外层循环的次数*内层循环的次数==总循环次数\n\n```c\nfor(初始语句;循环条件;步进条件)\n{\n     for(初始语句;循环条件;步进条件)\n    {\n         //循环语句\n    }\n}\n```\n\n```c\n#include <stdio.h>\nvoid test02()\n{\n    int i,sum = 0;\n    for(i = 1;i<=100;i++)\n    {\n        sum = sum + i;\n    }\n    printf(\"sum = %d\\n\",sum);\n}\nint main(int argc,char *argv[])\n{\n    test02();\n}\n```\n\n# <center>知识点八：whie循环</center>\n\n执行顺序：如果“循环条件”为真就进入循环体执行循环语句，直到循环条件为假，循环结束\n\n```c\nwhile(循环条件)\n{\n    //循环语句\n}\n//如果“循环条件”为真就进入循环体执行循环语句\n```\n\n注意：\n&ensp;&ensp;&ensp;&ensp;1）while没有初始化语句，用户提前初始化好\n\n&ensp;&ensp;&ensp;&ensp;2）while没有步进语句，用户必须在循环语句中写好步进语句\n\n```c\n#include <stdio.h>\nvoid test04()\n{\n    int i = 0;\n    int sum = 0;\n    while(i<=100)\n    {\n        sum += i;\n        i++;   //步进条件 \n    }\n    printf(\"sum = %d\\n\",sum);\t//sum = 5050\n} \nint main(int argc,char *argv[])\n{\n    test04();\n}\n```\n\n# <center>知识点九：do.....while()循环</center>\n\n```c\ndo\n{\n    //循环语句;\n}while(循环条件);\n```\n\n先执行循环语句，再判断循环条件是否为真，如果为真进行下次循环，如果为假，直接退出循环\n\n```c\n#include <stdio.h>\nvoid test05()\n{\n    int num = 0;\n    do\n    {\n        printf(\"ok\\n\");\t//输出一次ok\n    }while(num>0);\n} \nint main(int argc,char *argv[])\n{\n    test05();\n}\n```\n\n# <center>知识点十：goto 跳转</center>\n\n```c\nvoid test()\n{\n    ....\n    goto 跳转名;    //在需要跳转的语句插入\n    ....            //中间是被调过的部分\n    跳转名:         //跳转结束的地方插入\n    .....\n}\n```\n\n```c\n#include <stdio.h>\nvoid test6()\n{\n    printf(\"---001----\\n\");\n    printf(\"---002----\\n\");\n    goto here;\n    printf(\"---003----\\n\");\t\t//不输出\n    printf(\"---004----\\n\");\t\t//不输出\n    here:\n    printf(\"---005----\\n\");\n    printf(\"---006----\\n\");\n} \nint main(int argc,char *argv[])\n{\n    test6();\n}\n```\n\n总结：for while 我们如何选择呢?\n\n&ensp;&ensp;&ensp;&ensp;如果循环的次数是<mark>确定</mark>的，建议选择 <font color=\"red\">for</font>\n\n&ensp;&ensp;&ensp;&ensp;如果循环的次数<mark>不确定</mark>，知道退出的条件建议选择 <font color=\"red\">while</font>\n\n","tags":["C语言"],"categories":["编程语言","C语言"]},{"title":"1.数据类型","url":"/post/6f76074c.html","content":"\n使用数据的不同类型的目的：合理利用空间\n\n计算机存储的是<mark>二进制</mark>，是一位二进制只能存放0或1，内存：1bit\n\n1字节 == 8b（八位二进制），范围：0000 0000 ~1111 1111\n\n4B等于4个字节\n\n# <center>知识点一：常用关键字</center>\n\n------------------------------------在32位平台下---------------------------------------\n\n|  关键字   |     类型     |                         所占的空间                          |\n| :-------: | :----------: | :---------------------------------------------------------: |\n|   char    |  字符串类型  |                 占1字节空间（8位二进制位）                  |\n|   short   |    短整型    |                 占2字节空间（16位二进制位）                 |\n|    int    |     整型     |                 占4个字节空间（32位二进制）                 |\n|   long    |    长整型    |    占4个字节空间（32位二进制）（在64为平台下占8个字节）     |\n| long long |   长长整型   |                           占8字节                           |\n|   float   | 单精度浮点数 |   占4个字节空间（32为二进制）（6-7位有效位，指数-37到38）   |\n|  double   | 双精度浮点数 | 占8个字节空间（64为二进制）（15-16位有效位，指数-307到308） |\n\n## <center>字符型</center>\n\n```c\n#include<stdio.h>\t//输出函数等需要的头文件\nint main()\n{\n    char a = 'aaaaa';   //定义字符  //字符单引号，字符串双引号，字符串需要借助数组实现\n    printf(\"%d\\n\",a);   //字符%d输出，按照ASCII码表输入对应字符整数\n    printf(\"%c\\n\",a);   //字符%c输出，则输出字符，%s，输入字符串\n    return 0;\n}\n```\n\n## <center>整型</center>\n\n```c\n#include<stdio.h>\nint main()\n{\n    int a = 123;\t//定义整型\n    short int b = 456;\t//定义短整型\n    long c = 789;\t\t//定义长整型\n    long long d = 1243543511111111;\t//定义长长整型\n    printf(\"%d,%hd,%lu,%lld\",a,b,c,d);\t//输出数据，123,456,789,1243543511111111\n    return 0;\n}\n```\n\n## <center>实型(浮点型)</center>\n\n赋值语句中若涉及到<mark>浮点数</mark>时注意<mark>两边类型尽量保持一致</mark>\n\n浮点数赋值，若赋值<mark>右边</mark>没有加<font color=\"red\"> f </font>默认是<font color=\"red\"> double </font>类型（占8个字节）\n\n<mark>指数</mark>形式：123e3\n\n&ensp;&ensp;&ensp;&ensp;意思：123*10的三次方\n\n```c\n#include<stdio.h>\nint main(int argc,char *argv[])\n{\n    //赋值语句的 = 两边的类型尽量保持一致\n    float f = 3.14f;\n    double d = 3.14;\n    printf(\"sizeof(3.14) = %d\\n\",sizeof(3.14));\t\t//8\n    //不以f结尾的 实型常量 为double类型\n    printf(\"sizeof(3.14) = %d\\n\",sizeof(3.14f));\t//4\n    //以f结尾的 实型常量 为float类型\n    printf(\"f = %f\\n\",f);\n    printf(\"d = %lf\\n\",d);\n    scanf(\"%f\",&f);\n    scanf(\"%lf\",&d);\n    return 0;\n}\n```\n\n```c\n#include<stdio.h>\nint main()\n{\n    float a = 3.14;  //定义float类型\n    double b = 4.311111123456789;   //定义double类型\n    //在输出时%f可以输出float和double，但scanf输入时不能通用\n    printf(\"%f,%f\\n\",a,b);  //3.140000,4.311111\n    //如果输出位数较多，得限制位数才可以输出完整\n    printf(\"%.6f,%.15lf\",a,b);   //3.140000,4.311111123456789\n\n    //如果越界，越界的数字是随机数\n    return 0;\n}\n```\n\n## <center>测试类型所占空间</center>\n\n`sizeof`：测试类型的长度（所占的空间）\n\n```c\n#include<stdio.h>\t//输出函数等需要的头文件\nint main(int argc,char *argv[])\n{\n    printf(\"sizeof(int) = %d\\n\",sizeof(int));\t//4\n    printf(\"sizeof(float) = %d\\n\",sizeof(float));\t//4\n    printf(\"sizeof(doublt) = %d\\n\",sizeof(double));\t//8\n    printf(\"sizeof(long) = %d\\n\",sizeof(long));\t\t//4\n    printf(\"sizeof(short) = %d\\n\",sizeof(short));\t//2\n    printf(\"sizeof(char) = %d\\n\",sizeof(char));\t\t//1\n    return 0;\n}\n```\n\n## <center>布尔型</center>\n\n```c\n#include<stdio.h>\t//输出函数等需要的头文件\n#include<stdbool.h>\t//布尔类型头文件\nint main()\n{\n    bool a = 1;\t//定义布尔类型\n    printf(\"%d\\n\",a);\t//1\n    return 0;\n}\n```\n\n# <center>知识点二：unsigned 和 signed</center>\n\n## <center>1、无符号数：unsigned</center>\n\n&ensp;&ensp;&ensp;&ensp;数据没有符号位，自身所有二进制位都是数据位\n\n&ensp;&ensp;&ensp;&ensp;例：unsigned char       0000 0000 ~ 1111 1111\n\n## <center>2、有符号数：signed（默认省略）</center>\n\n&ensp;&ensp;&ensp;&ensp;二进制最高位为符号位，其他位为数据位\n\n&ensp;&ensp;&ensp;&ensp;例：signed char   xxxx xxxx（x：0或1）\n\n&ensp;&ensp;&ensp;&ensp;最<font color=\"red\">高</font>位为 <mark>1</mark> 表示<font color=\"red\">负</font>数，最<font color=\"red\">高</font>位为 <mark>0</mark> 表示<font color=\"red\">正</font>数\n\n&ensp;&ensp;&ensp;&ensp;负数：1xxx xxxx       正数：0xxx xxxx\n\n```c\n#include<stdio.h>\nint main(int argc,char *argv[])\n{\n    //signed int num1 = 10;\n    int num2 = 10;\t//有符号(signed)默认省略\n    unsigned num3 = 10;\n    return 0;\n}\n```\n\n# <center>知识点三：结构体 struct 和 共用体 union</center>\n\n## 1、struct：结构体中的<mark>成员</mark>拥有<font color=\"red\">独立</font>的空间\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221132241.png\" alt=\"空间\" style=\"zoom:33%;\" />\n\n```c\nstruct data1\n{\n    char a;\n    int b;\n    shuot c;\n};\na,b,c就是结构体dat1中的成员\n```\n\n## 2、union：共用体中的<mark>成员共享</mark>同一部分空间\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221132184.png\" alt=\"空间2\" style=\"zoom:50%;\" />\n\n```c\nunion data2\n{\n    char a；\n    short b；\n    int c；\n}；\n```\n\n# <center>知识点四：enum 和 void</center>\n\n## 1、enum：枚举 \n\n&ensp;&ensp;&ensp;&ensp;将<font color=\"red\">变量要赋值的值</font>一一列举出来\n\n```c\nenum BOOL{false，ture}；\n//括号里面的是可以赋给变量的值，赋的值只能括号里面有的\nenum BOOL bool = false；\n```\n\n## 2、void：无类型\n\n&ensp;&ensp;&ensp;&ensp;不能用void定义变量\n\n# <center>知识点五：其他关键字</center>\n\nauto：自动类型\n\nregister：寄存器变量\n\nstatic：静态变量\n\nconst：只读\n\n<mark>sizeof：测类型大小</mark>\n\ntypedef：为已有的类型重新取别名\n\nvolatile：防止编译器优化\n\n<font color=\"red\">extern</font>：外部的意思，一般用于函数和全局变量的声明\n\n## 1、register：寄存器变量\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221132102.png\" alt=\"寄存器内存图\" style=\"zoom: 50%;\" />\n\n总结：\n\n&ensp;&ensp;&ensp;&ensp;1）如果没有显示表明 register ，类似 int num，如果被<mark>高频</mark>使用系统也会放入寄存器中\n\n&ensp;&ensp;&ensp;&ensp;2）register int num；         //显示表明将num放入寄存器\n\n&ensp;&ensp;&ensp;&ensp;3）<font color=\"red\">寄存器的变量不能取地址</font>\n\n## 2、typedef：为<mark>已有</mark>的类型取别名\n\n&ensp;&ensp;&ensp;&ensp;为已有类型重新取个别名步骤：\n\n&ensp;&ensp;&ensp;&ensp;1）用已有的类型定义一个变量\n\n&ensp;&ensp;&ensp;&ensp;2）用 别名 替换 变量名\n\n&ensp;&ensp;&ensp;&ensp;3）在整个表达式的前方加上 typedef\n\n```c\n#include<stdio.h>\ntypedef int INT32;\t//取别名\nint main(int argc,char *argv[])\n{\n    int num2 = 10;\n    INT32 num1 = 34;\n    printf(\"num1 = %d\\n\",num1);\n    printf(\"num2 = %d\\n\",num2);\n    return 0;\n}\n//num1 = 34\n//num2 = 10\n```\n\n## 3、volatile：防止编译器优化\n\n&ensp;&ensp;&ensp;&ensp;作用：强制访问内存操作\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221133241.png\" alt=\"volatile内存图\" style=\"zoom: 50%;\" />\n\n# <center>知识点六：常量与变量</center>\n\n## 1、常量 \n\n&ensp;&ensp;&ensp;&ensp;值不能被修改（但不能反过来说：值不能被修改是常量）\n\n&ensp;&ensp;&ensp;&ensp;例：10、20、4.14、'a'、\"abcd\"\n\n## 2、变量\n\n&ensp;&ensp;&ensp;&ensp;系统根据变量的类型开辟对应的空间 其值可以被修改\n\n&ensp;&ensp;&ensp;&ensp;变量名  代表的是  空间的内容\n\n&ensp;&ensp;&ensp;&ensp;操作变量 就是对 空间内容的操作\n\n&ensp;&ensp;&ensp;&ensp;变量的命名规制：由数值、字符、下划线组成但是不能以数字开头\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221133968.png\" alt=\"变量所占空间\" style=\"zoom: 50%;\" />\n\n# <center>知识点七：进制</center>\n\n## <center>进制类型及输出方法</center>\n\n输出时在  %  后加 # 表示输出进制的前缀\n\n不同进制仅仅只是数据的表现形式不会修改数据本身\n\n```c\n#include<stdio.h>\nint main(int argc,char *argv[])\n{\n    int num = 100;\n    //加个#号就是输出进制的前缀\n    printf(\"十进制：num = %d\\n\",num);\t//十进制输出  %d  %u  %ld  %lu\n    printf(\"八进制：num = %#o\\n\",num);\t//八进制输出  %o   以0开头\n    printf(\"十六进制：num = %#x\\n\",num);\t//十六进制输出  %x  以0x开头\n    printf(\"十六进制：num = %#X\\n\",num);\t//十六进制输出，但输出的十六进制字母为大写\n    return 0;\n}\n//十进制：num = 100\n//八进制：num = 0144\n//十六进制：num = 0x64\n```\n\n## <center>进制转换</center>\n\n需要分组的只有八进制和十六进制，八进制3个数字为一组，十六进制4个数字为一组\n\n对于整数， 有四种表示方式：\n\n&ensp;&ensp;&ensp;&ensp;二进制：0,1 ，满 2 进 1，以 0b 或 0B 开头\n\n&ensp;&ensp;&ensp;&ensp;十进制：0-9 ，满 10 进 1\n\n&ensp;&ensp;&ensp;&ensp;八进制：0-7 ，满 8 进 1，以数字 0 开头表示\n\n&ensp;&ensp;&ensp;&ensp;十六进制：0-9 及 A(10) - F(15)，满 16 进 1，以 0x 或 0X 开头表示。此处的 A-F 不区分大小写\n\n方法：8421法\n\n### <center>二进制转八进制</center>\n\n三位为一组，一组按1，2，4分\n\n0 0 1 1  0 1 0 0\n\n​      4 2  1 4 2 1\n\n————————————\n\n从左往右，三位一组，第一组三位中二进制为1的相加得八进制的个位，第二组三位中二进制为1的相加得八进制的十位，如果有第三组三位数则为1相加则为八进制的百位，以此类推\n\n第一个三位二进制，1 0 0 则 421，为1的只有4，则八进制个位数为4\n\n第二个三位二进制，1 1 0 则 421，为1的有4 和 2，则八进制十位数为4 + 2 = 6\n\n则八进制为：(0)64\n\n### <center>八进制转二进制</center>\n\n八进制拆开单独数字，一个数字对应三位 再按1，2，4分解\n\n64 --》分为两组(三位一组)，从左到右，第一组为4，第二组为6，6又分为4 + 2，有对应数字的二进制为1，没有为0\n\n4 2 1 4 2 1\n\n1 1 0 1 0 0\n\n位数不足补零\t0011 0100\n\n### <center>二进制转十进制</center>\n\n直接按1、2、4、8.....分，二进制为1的数字相加\n\n0 0 0 1  0 1 0 1\n\n​         16 8 4 2 1\n\n————————————\n\n16+4+1 = 21\n\n### <center>十进制转二进制</center>\n\n十进制拆分，1，2，4，8........组合的数，无需分组\n\n21 = 16 + 4 + 1\n\n16 8 4 2 1\n\n——————\n\n1   0 1 0 1\t位数不足补零，0001 0101\n\n### <center>二进制转十六进制</center>\n\n四位为一组，一组按1，2，4，8分\n\n0 0 1 1  0 1 0 0\n\n8 4 2 1  8 4 2 1\n\n————————\n\n从左往右，四位一组，第一组四位中二进制为1的相加得十六进制的个位，第二组四位中二进制为1的相加得十六进制的十位，第三组四位中二进制为1的相加得十六进制的百位，以此类推\n\n第一个四位二进制，0 1 0 0 则 8421，为1的只有4，则八进制个位数为4\n\n第二个四位二进制，0 0 1 1 则 8421，为1的有1 和 2，则八进制十位数为1 + 2 = 3\n\n则十六进制为：0x34\n\n### <center>十六进制转二进制</center>\n\n十六进制数分开单个数字，一个数字对应四位，并拆分 1，2，4，8....数组成\n\n0x2A =》分为两组(四位一组)，从左到右，第一组为A，A又分为8 + 2，第二组为2，有对应数字的二进制为1，没有为0\n\n8 4 2 1  8 4 2 1\n\n————————————————\n\n0 0 1 0  1 0 1 0\n\n### <center>八进制转十进制</center>\n\n八转二，二转十\n\n### <center>十进制转八进制</center>\n\n十转二，二转八\n\n### <center>八进制转十六进制</center>\n\n八转二，二转十六\n\n### <center>十六进制转八进制</center>\n\n十六转二，二转八\n\n### <center>十进制转十六进制</center>\n\n十转二，二转十六\n\n### <center>十六进制转十进制</center>\n\n十六转二，二转十\n\n# <center>知识点八：（整型变量的操作）取值（读）、赋值（写）</center>\n\n例：另一个中\n\n# <center>知识点九：数据输出</center>\n\n| 符号 |           含义           |\n| :--: | :----------------------: |\n|  %d  |   十进制有符号整数输出   |\n| %ld  | 十进制long有符号整数输出 |\n|  %u  |   十进制无符号整数输出   |\n| %lu  |    有符号long数据输出    |\n| %hd  |   有符号short数据输出    |\n|  %o  |  以八进制表示的整数输出  |\n|  %x  | 以十六进制表示的整数输出 |\n|  %f  |    float型浮点数输出     |\n| %lf  |    double型浮点数输出    |\n|  %e  |   指数形式的浮点数输出   |\n|  %c  |       单个字符输出       |\n|  %s  |        字符串输出        |\n|  %p  |       指针的值输出       |\n\n## 特殊应用\n\n&ensp;&ensp;&ensp;&ensp;%3d&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;%03d&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;%-3d&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;%5.2f\n\n&ensp;&ensp;&ensp;&ensp;%3d：要求宽度为3位，如果不足3位，前面<mark>空格</mark>补齐，如果足够3位，此语句无效\n\n&ensp;&ensp;&ensp;&ensp;%<font color=\"red\">0</font>3d：要求宽度为3位，如果不足3位，前面<mark>0</mark>补齐，如果足够3位，此语句无效\n\n&ensp;&ensp;&ensp;&ensp;%<font color=\"red\">-</font>3d：要求宽度为3位，如果不足3位，<font color=\"red\">后</font>面<mark>空格</mark>补齐，如果足够3位，此语句无效\n\n&ensp;&ensp;&ensp;&ensp;%<font color=\"red\">5.2</font>f：总宽度为5，<mark>.</mark>2表示：小数位保留2位\n\n&ensp;&ensp;&ensp;&ensp;但不能写 %-03d\n\n# <center>知识点十：字符常量与变量</center>\n\n## 1、字符常量  char\n\n用<font color=\"red\"> ' ' </font>包裹字符\n\n<mark>%c</mark> 输出输出<font color=\"red\">字符</font>，用 <mark>%d</mark> 输出字符的<font color=\"red\">ascii值</font>\n\n本质：在内存保存的是字符对应的ASCII码值\n\n使用<font color=\"red\"> scanf </font>键盘输入字符用<font color=\"red\"> %c </font>只能提取<mark>一个字符</mark>\n\n字符与对应的ASCII值完全等价\n\n```c\n#include<stdio.h>\nint main(int argc,char *argv[])\n{\n    //%c输出字符\n    char ch = 'a';\n    printf(\"ch = %d\\n\",ch);\t//ch = 97\n    //%d 输出字符的ASCII值\n    printf(\"ch = %c\\n\",ch);\t//ch = a\n    //'a' == 97时完全等价的\n    int a = 0;\n    a= 98;\n    printf(\"a = %c\\n\",a);\n    //%d输出对应字符的ASCII值\n    printf(\"a = %d\\n\",a);\t//a = b\n    a = a+1;\n    printf(\"a = %c\\n\",a);\t//a = c\n    printf(\"a = %d\\n\",a);\t//a = 99\n    return 0;\n}\n```\n\n# <center>知识点十一：转义字符</center>\n\n| 字符形式 |               功能               | 字符形式 |             功能              |\n| :------: | :------------------------------: | :------: | :---------------------------: |\n|    \\n    |             回车换行             |   \\\\\\    |      一个反斜杠字符(\\\\)       |\n|    \\t    |   将当前位置移到下一个tab位置    |   \\\\'    |         一个单引号(')         |\n|    \\v    | 当前位置移到下一个垂直制表对齐点 |   \\\\\"    |         一个双引号(\")         |\n|    \\r    |              回车符              |   \\ddd   | 三位八进制数代表一个ASCII字符 |\n|    \\f    |              换页符              |   \\xhh   | 二位十六进制代表一个ASCII字符 |\n|    \\b    |      将当前位置后退一个字符      |    \\0    |     空值，其ASCII码值为0      |\n\n# <center>知识点十二：字符串</center>\n\n用<font color=\"red\"> \" \" </font>包裹字符\n\n默认<font color=\"red\">结尾</font>自动添加 <mark>\\0</mark> 结尾（占一个字节）\n\n只要遇到 <mark>\\0</mark> 就<mark>结束</mark>\n\n描述：'a'和\"a\"的区别\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402221133087.png\" alt=\"字符与字符串所占字节\" style=\"zoom: 50%;\" />\n","tags":["C语言"],"categories":["编程语言","C语言"]},{"title":"第二章 新民主主义革命理论","url":"/post/8212f318.html","content":"\n# <center>第一节 新民主主义革命理论形成的依据</center>\n\n**近代中国国情和中国革命的时代特征**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;1. 近代中国国情：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;沦为一个半殖民地半封建社会社会(1840-1949)\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;认清国情是认清一切革命问题的依据\n\n&ensp;&ensp;&ensp;&ensp;&ensp;2. 近代中国社会性质：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;半殖民地半封建社会（国情）\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;认清中国国情，是认清一切革命问题的基本依据\n\n&ensp;&ensp;&ensp;&ensp;&ensp;3. 主要矛盾：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;帝国主义和中华民族(最主要矛盾)\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;封建主义和人民大众\n\n&ensp;&ensp;&ensp;&ensp;&ensp;4.根本任务：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;推翻帝国主义(总根源)、封建主义、官僚资本主义(三座大山)\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;从根本上推翻反动腐朽的政治上层建筑，变革阻碍生产力发展的生产关系\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271745717.png\" alt=\"三座大山\" style=\"zoom: 50%;\" />\n\n&ensp;&ensp;&ensp;&ensp;&ensp;5.近代中国革命性质：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;资产阶级民主革命(革命对象决定革命性质)\n\n|          |         旧民主主义革命         |         新民主主义革命         |\n| :------: | :----------------------------: | :----------------------------: |\n| 领导阶级 |            资产阶级            |            无产阶级            |\n| 指导思想 |          资本主义思想          |         马克思主义思想         |\n| 革命前途 |       资产阶级民主共和国       |          社会主义国家          |\n|   联系   | 反帝反封反官僚(任务)、革命性质 | 反帝反封反官僚(任务)、革命性质 |\n\n&ensp;&ensp;&ensp;&ensp;&ensp;从世界历史来划分(范畴)\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1640~1917为世界资产阶级民主革命(旧民主主义革命)\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1917~至今为世界无产阶级民主革命(新民主主义革命)\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271745123.png\" alt=\"性质及阶级变化\" style=\"zoom: 33%;\" />\n\n&ensp;&ensp;&ensp;&ensp;&ensp;6.时代特征：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;以俄国十月革命胜利为标志，开辟了世界无产阶级社会主义革命的新纪元，使得中国新的资产阶级民主革命，属于世界无产阶级革命的一部分\n\n&ensp;&ensp;&ensp;&ensp;&ensp;以五四运动的爆发为标志，中国资产阶级革命进入新民主主义革命的崭新阶段，中国无产阶级开始以独立的政治力量登上历史舞台，由自在阶级转为自为阶级\n\n**新民主主义革命的实践基础**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;旧民主主义革命的失败呼唤新的革命理论\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;旧民主主义革命的失败 (一系列革命并未完成反帝反封建的革命任务)\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;新民主主义革命理论产生的客观条件(近代中国革命形势的发展，以及世界形势的新变化)\n\n&ensp;&ensp;&ensp;&ensp;&ensp;新民主主义革命的艰辛探索奠定了革命理论形成的实践基础\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;新民主主义革命理论是在总结革命斗争正反两方面实践经验的基础上形成的\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;新民主主义革命实践，是新民主主义理论得以形成的实践基础和智慧源泉\n\n# <center>第二节 新民主主义革命总路线和基本纲领</center>\n\n**新民主主义革命总路线**\n\n既是总路线又是总政策\n\n《论人民民主专政》对新民主主义革命基本经验作了集中概括\n\n|   提出   | 1939年 |  毛泽东《中国革命和中国共产党》  |          第一次提出新民主主义革命的科学概念和总路线          |\n| :------: | :----: | :------------------------------: | :----------------------------------------------------------: |\n| 完整表述 | 1948年 | 毛泽东《在晋绥干部会议上的讲话》 | 完整表述了总路线的内容，即无产阶级领导的，人民大众的，反对帝国主义、封建主义和官僚资本主义(新增对象)的革命 |\n\n&ensp;&ensp;&ensp;&ensp;&ensp;**领导权：**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;无产阶级对于革命的领导权问题是中国革命是的中心问题、也是新民主主义革命理论的核心问题。这是新民主主义革命区别于旧民主主义革命的根本标志。无产阶级及其政党的领导，是中国革命取得胜利的根本保证\n\n&ensp;&ensp;&ensp;&ensp;&ensp;保证 ==>党的领导\n\n&ensp;&ensp;&ensp;&ensp;&ensp;无产阶级的特点和优点\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;基本优点：与先进的生产方式相联系、没有私人占有的生产资料、富有组织纪律性等一般无产阶级的基本优点\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;特点：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;一是，中国无产阶级在革命斗争中比任何别的阶级都来得坚决和彻底\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;二是，它分布集中，有利于无产阶级队伍的组织和团结，有利于革命思想的传播和强大革命力量的形成\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;三是，它的成员中的大部分出身于破产农民，和农民有着天然联系，这使得无产阶级便于农民结成亲密的联盟，共同团结战斗\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;无产阶级及其政党对中国革命的领导权不是自然得来的，而是在与资产阶级争夺领导权的斗争实现的\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第一，无产阶级及其政党实现对于各革命阶级的领导，必须建立以工农联盟为基础的广泛的统一战线，这是实现领导权的关键\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第二，无产阶级在同资产阶级建立统一战线时，必须坚持独立自主的原则，保持党在思想上、政治上和组织上的独立性，实现有联合又斗争的方针，这是坚持领导权的基本策略\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第三，无产阶级要保持在民主革命中的领导权，就必须建立和发展人民的革命武装力量，建立一支无产阶级领导的以农民为主题的强大的革命武装，是保证领导权的坚强支柱\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第四，加强无产阶级政党的建设，是实现领导权的根本保证\n\n&ensp;&ensp;&ensp;&ensp;&ensp;**对象：**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;分清敌友，是革命的首要问题\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;帝国主义(首要对象)、封建主义、官僚资本主义(买办性、封建性、垄断性)\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;帝国主义是近代中国贫困落后和一切灾难祸害的总根源，中国进步和发展的最大障碍\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;封建地主阶级是近代中国经济现代化和政治民主化的主要障碍\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;国共大合作时期，革命的主要对象：帝国主义支持下的北洋军阀\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;土地革命时期，革命的主要对象：国民党新军阀\n\n&ensp;&ensp;&ensp;&ensp;&ensp;**动力：**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;无产阶级：最基本动力，近代最先出现、最进步阶级，新的社会生产力代表，中国革命的领导力量\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;农民阶级：主力军，是无产阶级的可靠同盟军，农民问题是中国革命的基本问题，新民主主义革命实质是党领导的农民革命\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;城市小资产阶级：无产阶级可靠同盟者\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;民族资产阶级：革命动力之一，带有两面性的阶级\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;与生俱来的特性是：软弱性\n\n&ensp;&ensp;&ensp;&ensp;&ensp;**性质：**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;资产阶级民主主义革命\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;中国革命的首要问题：分清敌友\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;中国革命的首要对象：帝国主义\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;中国革命的基本问题：农民问题\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;中国革命的中心问题：无产阶级领导权\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;新民主主义革命理论的核心问题：无产阶级领导权\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;中国经济现代化、政治民主化的主要障碍：地主阶级\n\n**新民主主义革命和社会主义革命的比较**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;相同：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;领导阶级：无产阶级\t\t革命前途：社会主义民主社会\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;指导思想：马克思主义\t\t范畴：世界无产阶级民主革命\n\n&ensp;&ensp;&ensp;&ensp;&ensp;不同：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;对象：新 反帝反封反封建资本  社 反资本家\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;性质：新 资产阶级民主革命 \t社 社会主义民主革命\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;联系：民主主义革命是社会主义革命的必要准备，社会主义革命是民主主义革命的必然趋势\n\n**一次革命论**：看到联系，混淆区别\t**二次革命**：看到区别，混淆联系\n\n**新民主主义革命的基本纲领**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;**政治纲领：**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;推翻帝国主义和封建主义的统治，建立一个无产阶级领导的，以工农联盟为基础的，各革命阶级联合专政的新民主主义的共和国\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;国体：各革命阶级联合专政        政体：人民代表大会\n\n&ensp;&ensp;&ensp;&ensp;&ensp;**经济纲领：**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;没收封建地主阶级的土地归农民所有(主要内容)\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;没收官僚资产阶级的垄断资本归新民主主义的国家所有(应有之义)（包含了新民主主义革命和社会主义革命双重性质）\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;保护民族工商业（极具特色）\n\n&ensp;&ensp;&ensp;&ensp;&ensp;**文化纲领：**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;无产阶级领导的人民大众的反帝反封建的文化，即民族的科学的大众的文化\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;“民族的”内涵：就其内容说是反对帝国主义压迫，主张中华民族的尊严和独立。就其形式说是具体鲜明的民族风格、民族形式和民族特色，要有中国作风和中国气派\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;“科学的”内涵：是反对一切封建思想和迷信思想，主张实事求是、客观真理及理论和实践的一致性。对封建时代创造的文化，应剔除其封建性的糟粕，吸收其民主性精华。要尊重中国的历史，反对民族虚无主义，以历史唯物主义的态度对待古今中外文化，发展民族新文化，提高民族自信心\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;“大众的”内涵：也就是民主文化，文化工作者要用革命文化教育和武装人民大众，使它成为人民大众的有力思想武器。以人民群众的实践作为创作的源泉，坚持为人民大众服务的方向\n\n# <center>第三节 新民主主义革命的总道路和基本经验</center>\n\n**新民主主义革命道路的提出和确定**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;提出：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1928《中国红色政权为什么能够存在》 \t1928《井冈山的斗争》\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1930《星星之火，可以燎原》\t\t1930《反对本本主义》\n\n&ensp;&ensp;&ensp;&ensp;&ensp;中国红色政权为什么能够存在与发展的根本原因：中国是一个政治、经济、文化发展极不平衡的半殖民地半封建大国\n\n&ensp;&ensp;&ensp;&ensp;&ensp;确定：1938 六届六中全会《战争与战略问题》\n\n**新民主主义革命道路形成的必然性**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;**可能性**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;由中国所处的时代特点和具体国情决定的\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;内无民主制度而受封建主义的压迫，外无民族独立而受帝国主义的压迫，中国革命的主要斗争形式只能是武装斗争，以革命的武装消灭反革命的武装，相应的主要组织形式必然是军队\n\n&ensp;&ensp;&ensp;&ensp;&ensp;**必然性**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第一，近代中国存在不少的统治薄弱环节，为党在农村开展革命斗争、建设革命根据地提供了缝隙和可能\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第二，近代中国的广大农村人民革命愿望强烈，加之经历过大革命的洗礼，革命的群众基础好\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第三，全国革命形式的继续向前发展，为在农村建设革命根据地提供了客观条件\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第四，相当力量正式红军的存在，为农村革命根据地的创立、巩固和发展提供了坚强后盾\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第五，党的领导的有力量及其政策的不错误，为根据地建设和发展提供了重要的主观条件\n\n**中国革命道路的内容和意义**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;中国革命走农村包围城市，武装夺取政权的道路，根本在于处理好土地革命、武装斗争、农村革命根据地建设三者之间的关系\n\n&ensp;&ensp;&ensp;&ensp;&ensp;土地革命是民主革命的基本内容\n\n&ensp;&ensp;&ensp;&ensp;&ensp;武装斗争是中国革命的主要形式，是农村革命根据地和土地改革的强有力保证\n\n&ensp;&ensp;&ensp;&ensp;&ensp;农村革命根据地是中国革命的战略阵地，是进行武装斗争和开展土地革命的依托\n\n&ensp;&ensp;&ensp;&ensp;&ensp;在党的领导下，实现了土地革命、武装斗争、农村革命根据地建设三者的密切结合和有机统一\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271745239.png\" alt=\"关系图\" style=\"zoom:67%;\" />\n\n**新民主主义革命理论的意义**\n\n反映了中国半殖民地半封建社会民主革命发展的客观规律\n\n开辟了引导中国革命走向胜利的正确道路，独创性发展了马克思列宁主义\n\n对于推进马克思主义中国化具有重要的方法论意义\n\n**新民主主义革命的三大法宝及其相互关系**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;**三大法宝**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;毛泽东在《<共产党人>发刊词》一文中，总结了中国革命两次胜利和两次失败的经验教训，揭示了中国革命发展的客观规律，把统一战线、武装斗争、党的建设比作党在中国革命中战胜敌人的三个主要的法宝\n\n&ensp;&ensp;&ensp;&ensp;&ensp;**相互关系**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;统一战线和武装斗争是中国革命的两个基本特点，是战胜敌人的两个基本武器\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;统一战线是实行武装斗争的统一战线，武装斗争是统一战线的中心支柱\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;党的组织则是掌握统一战线和武装斗争这两个武器以实行对敌冲锋陷阵的英勇战士\n\n**新民主主义革命的三大法宝之统一战线**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;**建立统一战线必要性**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;由社会阶级状况决定：“两头大中间小”\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;中间：农民阶级、民族资产阶级、城市小资产阶级\n\n<img src=\"https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271745344.png\" alt=\"阶级状况\" style=\"zoom: 33%;\" />\n\n&ensp;&ensp;&ensp;&ensp;&ensp;**两个联盟**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;工人阶级同农民阶级、广大知识分子及其他劳动者的联盟 (主要是工农联盟)\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;工人阶级和非劳动人民的联盟 (主要是和民族资产阶级的联盟)\n\n&ensp;&ensp;&ensp;&ensp;&ensp;**历程**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;国民革命统一战线（1924-1927）（第一次国共合作）\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;工农民主统一战线（1927-1937）（土地革命时期）\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;抗日民族统一战线（1937-1945）（第二次国共合作）\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;党对于顽固势力采取的方针：孤立\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;党对于进步势力采取的方针：发展\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;党对于中间实力采取的方针：争取\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;人民民主统一战线（1946-1949）（解放战争时期）\n\n**&ensp;&ensp;&ensp;&ensp;&ensp;实践经验**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;建立巩固的工农联盟\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;正确对待资产阶级，实行既联合又斗争(民族资产阶级具备两面性)\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;采取区别对待的方针\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;坚持独立自主原则\n\n**新民主主义革命的三点法宝之武装斗争**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;武装斗争是中国革命的特点和优点之一\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;武装的革命反对武装的反革命\n\n&ensp;&ensp;&ensp;&ensp;&ensp;人民军队建设经验\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;坚持党对军队的绝对领导(建设新型人民军队的根本原则，也是毛泽东建军思想的核心)\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;发端于南昌起义 奠基于三湾改编 定型于古田会议 (1927-1927)\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;建设全心全意为人民服务的人民军队(建设新型人民军队的基本前提，人民军队立于不败之地的根本所在)\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;坚持正确的战略战术原则\n\n**新民主主义革命的三点法宝之党的建设**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;加强党的建设的必要性\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;农民和小资产阶级出身的党员占多数\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;党内思想上的主要矛盾是无产阶级思想和非无产阶级思想\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;加强自身建设，赢得群众支持\n\n&ensp;&ensp;&ensp;&ensp;&ensp;新民主主义革命时期党的建设的历史经验\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;必要性\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;必须加强党的思想建设、组织建设和作风建设\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;党内无产阶级思想和非无产阶级思想之间的矛盾成为党内思想上的主要矛盾\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;历史经验\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;必须把思想建设始终放在党的建设的首位。加强党的思想建设，关键是要以无产阶级思想克服和改造各种非无产阶级思想\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;必须在任何时候都要重视党的组织建设。加强党的组织建设，根本的是要贯彻民主集中制这一根本组织原则，坚持在民主基础上的集中和在集中指导下的民主相结合，个人服从组织，少数服从多数，下级服从上级，全党服从中央\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;根本组织原则：民主集中制\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;必须重视党的作风建设。党在领导新民主主义革命的过程中，把党的建设作为一项“伟大工程”，逐步形成了理论联系实际、密切联系群众、批评与自我批评相结合的三大作风，这是中国共产党区别于其他任何政党的显著标志\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;三大优良作风(马克思主义学风)\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;理论联系实际、密切联系群众、批评与自我批评（中国共产党区别于其他任何政党的显著标志）\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;必须联系党的政治路线加强党的建设。加强党的建设，必须同党的政治路线紧密联系起来，在贯彻执行党的政治纲领和路线中推进党的建设\n\n**新民主主义革命理论的意义**\n&ensp;&ensp;&ensp;&ensp;&ensp;理论意义：新民主主义革命的理论，揭示了近代中国革命的客观规律，解决了在一个以农民为主体的、落后的半殖民地半封建的东方大国里进行一系列理论问题，在当时的历史下科学地回答了中国革命何去何从的问题，以及中国革命的发展阶段问题，极大地丰富了马克思主义的理论宝库\n\n&ensp;&ensp;&ensp;&ensp;&ensp;实践意义：在新民主主义革命理论的指导下，党团结带领人民找到了一条以农村包围城市、武装夺取政权的正确革命道路，完成了新民主主义革命，于1949年建立了中华人民共和国\n\n&ensp;&ensp;&ensp;&ensp;&ensp;世界意义：中国新民主主义革命的伟大胜利，是20世纪继俄国十月革命以后改变世界面貌的伟大历史事件，有力地鼓舞和推动了世界上被压迫民族和被压迫人民反抗帝国主义、殖民主义的斗争，极大地增强了他们反对帝国主义斗争的信心，增强了世界人民争取和平的力量\n","tags":["政治"],"categories":["升学"]},{"title":"博客搭建以及使用手册","url":"/post/cb87841d.html","content":"\nHexo+github搭建个人博客 教程\n\n> https://blog.csdn.net/wushibo123/article/details/124619123\n\nhexo博客换主题 教程\n\n> https://zhuanlan.zhihu.com/p/385525053\n\nGitHub+Typora写博客+图片上传 教程，插入图片时若前面有弹出选择不需要选，在source下_ posts 文件夹下生成 md 文件，生成完成之后，会有对应名称的文件夹生成（要删除移到其他文件夹，或改文件夹名字再移动进去），图中要保存在设置的路径下的${fiilename}文件夹中，然后再复制进去（注意：文章距图片路径）\n\n> https://blog.csdn.net/Qxiaofei_/article/details/124629908\n\n![Typora图片插入设置](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402261109569.png)\n\n珍藏的 Hexo 博客主题\n\n> https://docs.anheyu.com/\n\n在项目中的_config.yml网址需要用这个，否则可能上传时卡顿导致错误\n\n![项目地址](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402261109262.png)\n\n创建md文件\n\n```\nhexo new post \"新建博客文章名\"\n```\n\n上传博客\n\n```\nhexo cl && hexo g  && hexo d\n```\n\n文章分类方法\n\n```text\ncategories:\n- 分类名字\n```\n\n文章标签\n\n```text\ntags:\n- 标签名字\n```\n\nHexo添加分类和标签\n\n> https://blog.csdn.net/cflsup/article/details/123452683\n\ngithub 仓库加速方法（生成后的网址复制到Blog文件夹下的_config.yml中的仓库地址(# Deployment)）\n\n> https://github.zhlh6.cn/\n\ngithub 加速下载方法\n\n> https://github.ur1.fun/\n\n更换设备或重装系统时，hexo无损方式重新部署（记得先配置图片上传 教程）\n\n> http://jixiaokang.github.io/2017/01/18/hexo%E5%8D%9A%E5%AE%A2%E6%8D%A2%E7%94%B5%E8%84%91%E4%B9%8B%E5%90%8E%E9%85%8D%E7%BD%AE/\n\nnpm下载插件慢等问题，改用淘宝源 教程\n\n> https://blog.csdn.net/m0_52861000/article/details/132412681\n\nHexo设置文章置顶+私密文章 教程\n\n> https://blog.csdn.net/cungudafa/article/details/104346521\n\nGithub个人库管理网站\n\n> https://github.com/xinzai13414/xinzai13414.github.io\n\nPDF免费转在线分享\n\n> https://maifile.cn/#page-top\n\nTypora编写技巧\n\n```text\n&ensp;&ensp;&ensp;&ensp;\t//编写的缩进要在网页中显示，需要在文本前加入四个\n<center>需要输入的文本</center>\t//需要文本居中\n<font color=\"red\"><strong>需要输入的文本</strong></font>\t//文本标红加粗\nhttps://blog.csdn.net/lose_hair/article/details/128576954\t//文字高亮以及文字标红教程\nhttps://blog.csdn.net/qq_41261251/article/details/102817673\t//一些文本编辑技巧教程\n//高亮\n    ==highlight 1==\t\t//高亮黄色，但网页不显示\n    <mark>highlight 2</mark>\t//高亮黄色\n    <span style=\"background-color:rgb(100,200,200,0.5)\">highlight 3</span>\t//高亮自定义颜色\n    ```code 1```\t//高亮灰色\n    `code 2`\t//高亮灰色\n若一些符号显示不了，则在前面打一个 \\ 显示，或打空格\n图片有两种语法，一种HTML（可以缩放但不美观且图片下面没有小标题）另一种 Markdown（美观且有小标题\n但不能缩放图片）图片右键可选择图片转换语法，选择对应需要的语法\n超链接：[名字](链接)\t快捷键：ctrl+k\n```\n\n","tags":["博客使用手册"],"categories":["技术教程"]},{"title":"第一章 毛泽东思想及其历史地位","url":"/post/b2041fc0.html","content":"\n# <center>第一节 毛泽东思想的形成和发展</center>\n\n近代、当代史\n\n![近代史图](https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271749746.png)\n\n1924 第一次国共合作正式形成\n\n1926.7.9 叶挺独立团      1927.4.12 上海 四一二政变     1927.7.15湖北 七一五政变(大肆屠杀中共)\n\n1927.8.1 南昌起义 9月 秋收起义(开辟井冈山根据地) 12月广州起义\n\n1935 遵义会议(标志毛泽东思想成熟，也标志党的领导认识到马克思主义与中国实际相结合的重要性)\n\n第一次世界大战：1914年7月-1918年11月\n\n第二次世界大战：1931年9月-1945年9月\n\n**毛泽东思想形成的历史条件**\n\n&ensp;&ensp;&ensp;&ensp;时代条件： 世界进入帝国主义和无产阶级革命时代。时代主题：战争与革命\n\n&ensp;&ensp;&ensp;&ensp;理论条件：十月革命给中国送来了马克思列宁主义\n\n&ensp;&ensp;&ensp;&ensp;实践基础：中国共产党领导人民进行革命和建设的成功实践\n\n**毛泽东思想的形成和发展过程**\n\n&ensp;&ensp;&ensp;&ensp;首先提出“毛泽东实现”这一概念的是：王稼祥\n\n&ensp;&ensp;&ensp;&ensp;毛泽东提出正确处理人民内部矛盾的理论时间：解放战争时期和中华人民共和国成立以后\n\n&ensp;&ensp;&ensp;&ensp;系统分析了党内“左”的和右的错误的思想根源的著作：《实现论》、《矛盾论》\n\n|              |                  时间                   |                             著作                             |                             标志                             |\n| :----------: | :-------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |\n|   形成时期   |    第一次国内革命战争时期(1924-1927)    |       《中国社会各阶级的分析》《湖南农民运动考察报告》       |                提出了新民主主义革命的基本思想                |\n|   形成时期   |        土地革命前中期(1927-1935)        | 《中国的红色政权为什么能够存在？》《星星之火，可以燎原》《反对本本主义》《井冈山的斗争》 | 提出并阐述了农村包围城市、武装夺取政权的思想，标志毛泽东思想初步形成 |\n|   成熟时期   |   遵义会议后至抗日战争时期(1935-1945)   | 《实践论》《矛盾论》《<共产党人>发刊词》《中国改革和中国共产党》《新民主主义论》《论联合政府》 | 新民主主义革命理论系统阐述(成熟标志)。1945年中共七大将毛泽东思想写入党章，确立为党必须长期坚持的指导思想 |\n| 继续发展时期 | 解放战争时期和新中国成立以后(1945-1976) | 《论人民民主专政》《论十大关系》《关于正确处理人民内部矛盾的问题》 |           关于社会主义革命和社会主义建设的重要思想           |\n\n# <center>第二节 毛泽东思想的主要内容</center>\n\n1、**新民主主义革命理论**\n\n&ensp;&ensp;&ensp;&ensp;在新民主主义革命时期，以毛泽东为首的中国共产党人从近代中国的特殊国情和现实状况出发，创立了无产阶级领导的，以工农联盟为基础的，人民大众的，反对帝国主义、封建主义、官僚资本主义的新民主主义革命理论。\n\n&ensp;&ensp;&ensp;&ensp;实行又团结又斗争、以斗争求团结的政策\n\n2.**社会主义革命和社会主义建设理论**\n\n&ensp;&ensp;&ensp;&ensp;党在过渡时期提出总路线“一化三改”，即要在一个相当长的时期内，逐步实现社会主义工业化，并逐步实现对农业、手工业、资本主义工商业进行改造，提出了系统的社会主义革命理论。\n\n&ensp;&ensp;&ensp;&ensp;1956年底，三大改造完成，我国正式进入社会主义社会。在社会主义建设初步探索时期，中国共产党积极探索适合中国情况的社会主义\t建设道路\n\n&ensp;&ensp;&ensp;&ensp;要求处理好积累和消费的关系，注意综合平衡的思想\n\n&ensp;&ensp;&ensp;&ensp;正确处理人民内部矛盾的具体方针：“<span style=\"background-color:yellow\">团结——批评——团结</span>“的方针\n\n&ensp;&ensp;&ensp;&ensp;经济领域实行的方针：“<font color=\"red\">统筹兼顾、适当安排</font>”\n\n&ensp;&ensp;&ensp;&ensp;处理党与民族党派关系的方针：“长期共存、互相监督”\n\n3.**革命军队建设和军事战略的理论**\n\n&ensp;&ensp;&ensp;&ensp;1927年 三湾改编 提出党指挥枪的根本原则，支部建在连上\n&ensp;&ensp;&ensp;&ensp;1927年 八七会议 提出枪杆子里出政权\n\n&ensp;&ensp;&ensp;&ensp;革命军队建设理论\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;新型人民军队\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;原则：党指挥枪\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;人民军队唯一宗旨：全心全意为人民服务\n\n&ensp;&ensp;&ensp;&ensp;军事战略\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;把游击战提到了战略的地位(主要作战方式(游击战和运动战))\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;随着敌我力量的变化正确地实行军事战略的转变\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;把战略上的劣势转变为战役、战斗上的优势，集中优势兵力、各个歼灭敌人\n\n&ensp;&ensp;&ensp;&ensp;中华人民共和国成立后的指导思想\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;建设现代化革命武装力量\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;发展现代国防技术\n\n4.**政策和策略的理论**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;政策和策略是党的生命，政策和策略思想包括：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;弱小的革命力量在变化着的主客观条件下能够最终战胜强大的反动力量\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;战略上要藐视敌人，战术上要重视敌人\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;要掌握斗争的主要方向，不要四面出击\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;要对敌人区别对待、分化瓦解，实行利用矛盾、争取多数、反对少数、各个击破的策略，并做到有理、有利、有节\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;在反动统治地区，把公开斗争和秘密斗争结合起来，在组织上采取隐蔽精干的方针\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;对被打倒的反动统治阶级成员和反动分子，只要他们不造反、不捣乱，都给予生活出路，让他们在劳动中改造成为自食其力的劳动者\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;无产阶级及其政党要实现自己对同盟党的领导，必须具备两个条件：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;一是率领被领导者向着共同的敌人做坚决斗争并取得胜利\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;二是领导者给以物质利益，至少不损害其利益，同时给以政治教育\n\n5.**思想政治工作和文化工作的理论**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;关于思想政治工作是经济工作和其他一切工作的生命线，要实行政治和经济的统一、政治和技术统一、又红又专的方针\n\n&ensp;&ensp;&ensp;&ensp;&ensp;关于发展民族的、科学的、大众的文化，实行百花齐放、百家争鸣和古为今用、洋为中用、推陈出新的方针\n\n&ensp;&ensp;&ensp;&ensp;&ensp;关于知识分子在革命和建设中具有重要作用，知识分子要同工农相结合，通过学习马克思列宁主义、参与社会和工作实践，树立无产阶级世界观的思想\n\n6.**党的建设理论**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;“三大作风”：理论和实践相结合、和人民群众紧密地联系在一起(核心)、自我批评的作风。这是中国共产党区别于其他任何政党的显著标志（最显著：自我革命）\n\n&ensp;&ensp;&ensp;&ensp;&ensp;延安整风运动的方针：“惩前毖后、治病救人”，党内斗争中要达到既弄清思想又团结同志的目的\n\n&ensp;&ensp;&ensp;&ensp;&ensp;创造了全党通过批评和自我批评进行马克思列宁主义思想教育的整风形式\n\n&ensp;&ensp;&ensp;&ensp;&ensp;“两个务必”：\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;务必使同志们继续保持谦虚、谨慎、不骄、不燥的作风\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;务必使同志们继续保持艰苦奋斗的作风\n\n**毛泽东思想活的灵魂**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;出处：1981年 十一届六中全会 《中共中央关于建国以来党的若干历史问题的决议》\n\n&ensp;&ensp;&ensp;&ensp;&ensp;实事求是(思想路线)\t\t（七大，在全党确立为思想路线）\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;科学内涵：一切从实际出发（前提和基础），理论联系实际（途径），坚持在实践中检验真理和发展真理。《改造我们的学习》提出“实事”指客观存在的一切事务，“求”指我们去研究，“是” 指 规律性\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;重要性：根本观点、根本要求、精髓\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;如何坚持实事求是？\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;深入实际了解事物本来面貌，把握事物内在必然联系，按照客观规律办事\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;清醒认识和正确把握基本国情\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;不断推进实践基础上的理论创新\n\n&ensp;&ensp;&ensp;&ensp;&ensp;群众路线\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;科学内涵：一切为了群众，一切依靠群众，从群众中来，到群众中去。\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;重要性：党的生命线和根本工作路线，是我们党永葆青春和战斗力的重要传家宝\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;如何坚持群众路线？\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;坚持人民是推动历史发展的根本力量\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;坚持全心全意为人民服务的根本宗旨，全心全意为人民服务，是我们党一切行动的根本出发点和落脚点，是我们区别于其他一切政党的根本标志（党的根本出发点和落脚点 ==> 人)\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;保持党同人民群众的血肉联系\n\n&ensp;&ensp;&ensp;&ensp;&ensp;独立自主\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;科学内涵：就是坚持独立思考，走自己的路，就是坚定不移地维护民族独立、捍卫国家主权，把立足点放在依靠自己力量的基础上，同时积极争取外援，开展国际经济文化交流，学习外国一切对我们有益的先进事务\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;重要性：立党立国的重要原则\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;如何坚持独立自主？\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;坚持中国的事情必须由中国人民自己处理\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;坚持独立自主和平外交政策，坚定不移走和平发展道理\n\n新中国时期，毛泽东提出的外交方针\n\n一边倒    另起炉灶    打扫干净屋子再请客\n\n# <center>第三节 毛泽东思想的历史地位</center>\n\n对毛泽东和毛泽东思想历史地位进行科学评价的文献：《历史决议》\n\n**毛泽东思想历史地位**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;1、毛泽东思想是马克思主义中国化的第一个重大理论成果\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第一，毛泽东第一个提出“马克思主义中国化”的科学命题和重大任务，为党的领导的革命和建设事业的发展奠\t定了坚实的思想理论基础\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第二，毛泽东思想是马克思主义中国化第一次历史性飞跃的理论成果\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第三，毛泽东思想是推进马克思主义大众化的光辉典范\n\n&ensp;&ensp;&ensp;&ensp;&ensp;2、毛泽东思想是中国革命和建设的科学指南\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;毛泽东思想是被实践证明了的关于中国革命和建设的正确的理论原则和经验总结，是中国革命和建设的科学指南\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第一，在毛泽东思想指引下，我们党领导全国人民，找到了一条新民主主义革命的正确道路，完成了反对帝国主义、封建主义、官僚资本主义的任务，结束了中国半殖民地半封建社会的历史，建立了中华人民共和国\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第二，在毛泽东思想指引下，我们党找到了一条从新民主主义向社会主义过渡的道路，确立了社会主义基本制度，实现了中国历史上最深刻最伟大的社会变革\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第三，对适合中国国情的社会主义道路进行了艰苦探索，并取得了重要的理论成果\n\n&ensp;&ensp;&ensp;&ensp;&ensp;3、毛泽东思想是中国共产党和中国人民宝贵的精神财富\n\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;毛泽东思想包含了基本原理、基本原则和科学方法具有普遍的指导意义\n\n**科学评价毛泽东和毛泽东思想**\n\n&ensp;&ensp;&ensp;&ensp;&ensp;科学评价毛泽东\n\n&ensp;&ensp;&ensp;&ensp;&ensp;毛泽东同志是伟大的马克思主义者，伟大的无产阶级革命家、战略家、理论家，是马克思主义中国化的\t伟大开拓者。不能否认，毛泽东同志在社会主义建设道路的探索中走过弯路，他在晚年特别是在“文化大革命”犯了严重错误。应该全面、历史、辩证地看待和分析。就他一生来看，功绩是第一位的，错误是第二位的\n\n&ensp;&ensp;&ensp;&ensp;&ensp;科学评价毛泽东思想\n\n&ensp;&ensp;&ensp;&ensp;&ensp;将毛泽东晚年所犯的错误同经过长期历史考验成为科学理论的毛泽东思想区别开来。毛泽东思想具有科学的真理性和强大的生命力，不因时代变迁而褪色，始终是中国共产党人、中华民族和中国人民团结奋斗、开拓前进的强大精神支柱，是我们世世代代要高举的伟大旗帜。\n","tags":["政治"],"categories":["升学"]}]