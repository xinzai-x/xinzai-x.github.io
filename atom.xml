<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>星仔人生录</title>
  
  <subtitle>珍惜当下 不负此生</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-03-14T14:42:37.113Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>星仔</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>小狼毫配置</title>
    <link href="http://example.com/post/5f6e69ef.html"/>
    <id>http://example.com/post/5f6e69ef.html</id>
    <published>2024-03-14T13:57:15.000Z</published>
    <updated>2024-03-14T14:42:37.113Z</updated>
    
    <content type="html"><![CDATA[<h1 id="下载小狼毫软件"><a href="#下载小狼毫软件" class="headerlink" title="下载小狼毫软件"></a><center>下载小狼毫软件</center></h1><p>小狼毫下载：<a href="https://rime.im/download/#">地址</a></p><h1 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a><center>安装步骤</center></h1><p>下载好安装包后，打开安装包，安装，步骤如下</p><p>点击我接受</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403142202912.png" alt="步骤一" style="zoom:50%;"><p>这里是软件安装路径，选择自己要安装的位置，后直接点击安装</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403142203014.png" alt="步骤二" style="zoom:50%;"><p>后续还有个<code>用户配置文件</code>的安装目录，这个目录保存好，在别的电脑可以直接恢复配置。</p><p>方案选定，选择图片单个即可，选择 中 下一步</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403142204796.png" alt="步骤三" style="zoom:50%;"><p>然后，选择自己喜欢的风格，点击中，即可安装完成。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>在任务栏中，在 中 字右键，选择用户文件夹</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403142207761.png" alt="配置一" style="zoom:67%;"><p>在大佬整理的文件下载词库配置，大佬的：GitHub<a href="https://github.com/iDvel/rime-ice">地址</a>，直接整个打包下载</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403142209429.png" alt="打包下载" style="zoom: 33%;"><h1 id="重点配置"><a href="#重点配置" class="headerlink" title="重点配置"></a>重点配置</h1><p>解压下载好的词库配置包，右键退出算法服务（若点击退出没有反应，直接重启即可），然后删除用户文件夹内的所有文件（最好备份一下原本的文件），复制大佬仓库中的所有文件到你的用户文件夹中，重启电脑，刚重启之后，等待一会儿，如果还不行，再右键重新部署，这期间会出现 输入法调出来但是无法打字的问题，等重新部署完成，可以打字即部署完成</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;下载小狼毫软件&quot;&gt;&lt;a href=&quot;#下载小狼毫软件&quot; class=&quot;headerlink&quot; title=&quot;下载小狼毫软件&quot;&gt;&lt;/a&gt;&lt;center&gt;下载小狼毫软件&lt;/center&gt;&lt;/h1&gt;&lt;p&gt;小狼毫下载：&lt;a href=&quot;https://rime.im/do</summary>
      
    
    
    
    <category term="技术教程" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="小狼毫输入法" scheme="http://example.com/tags/%E5%B0%8F%E7%8B%BC%E6%AF%AB%E8%BE%93%E5%85%A5%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>GitHub+Picgo图片上传</title>
    <link href="http://example.com/post/d20e58f5.html"/>
    <id>http://example.com/post/d20e58f5.html</id>
    <published>2024-03-01T09:14:17.000Z</published>
    <updated>2024-03-01T09:42:37.913Z</updated>
    
    <content type="html"><![CDATA[<p> Picgo下载，修改安装路径，其他一路下一步！</p><blockquote><p><a href="https://github.com/Molunerfinn/picgo/releases">地址</a></p></blockquote><p> 注册GitHub，注册过程不详细展开，不会的百度一下</p><blockquote><p><a href="https://github.com/">地址</a></p></blockquote><h1 id="新建GitHub仓库存放图片"><a href="#新建GitHub仓库存放图片" class="headerlink" title="新建GitHub仓库存放图片"></a>新建GitHub仓库存放图片</h1><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011715417.png" alt="新建" style="zoom: 33%;"><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011718105.png" alt="填写信息"></p><h1 id="生成Token令牌"><a href="#生成Token令牌" class="headerlink" title="生成Token令牌"></a>生成Token令牌</h1><p>点击头像，点击Settings</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011720770.png" alt="img" style="zoom: 50%;"><p>滑到最后</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011720876.png" alt="进入生成令牌" style="zoom: 33%;"><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011721976.png" alt="选择对应选项"></p><p>过期时间：<code>No expiration</code>(永久不过期)</p><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011722080.png" alt="设置令牌信息"></p><blockquote><p><strong>务必将令牌保存起来</strong>，放在一个安全的地方，页面关掉后就看不到了。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011726560.png" alt="生产令牌"></p><h1 id="创建img文件夹"><a href="#创建img文件夹" class="headerlink" title="创建img文件夹"></a>创建img文件夹</h1><p>回到刚才新建存放图片的仓库，新建文件夹</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011726060.png" alt="创建文件夹" style="zoom:50%;"><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011727746.png" alt="命名文件夹" style="zoom: 33%;"><h1 id="设置GitHub图床"><a href="#设置GitHub图床" class="headerlink" title="设置GitHub图床"></a>设置GitHub图床</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">自定义域名需要配置为：https://cdn.jsdelivr.net/gh/用户名/仓库名，这样就才可以通过cdn访问图片</span><br><span class="line">仓库名：GitHub用户名/GitHub仓库地址</span><br><span class="line">分支名：main</span><br><span class="line">Token：GitHub中设定的AccessToken</span><br><span class="line">自定义域名：https://cdn.jsdelivr.net/gh/用户名/仓库名</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011728215.png" alt="Picgo设置"></p><p>点击上传区上传图片</p><p>上传成功之后</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011729915.png" alt="例图" style="zoom: 50%;"><p>如果提示网络不好等错误，可能不稳定，稍后再试试看。或者可以重启试试看!！</p><p>在Typora中，文件-》偏好设置中，设置成下图，将语法偏好所有选项关闭，可以避免直接复制图片进Typora报错</p><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011729398.png" alt="img"></p><p>仓库可能最多只能存放1g，网上说的，所以最好快到的时候重新建一个仓库</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; Picgo下载，修改安装路径，其他一路下一步！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Molunerfinn/picgo/releases&quot;&gt;地址&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 注册GitHu</summary>
      
    
    
    
    <category term="技术教程" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="GitHub+Picgo图片上传" scheme="http://example.com/tags/GitHub-Picgo%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/"/>
    
  </entry>
  
  <entry>
    <title>GitHub同步gitee并部署</title>
    <link href="http://example.com/post/6c3f8114.html"/>
    <id>http://example.com/post/6c3f8114.html</id>
    <published>2024-02-28T14:32:35.000Z</published>
    <updated>2024-02-28T15:29:04.008Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建并同步GitHub仓库"><a href="#创建并同步GitHub仓库" class="headerlink" title="创建并同步GitHub仓库"></a><center>创建并同步GitHub仓库</center></h1><p>点击加号，选择从GitHub仓库导入</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402282300375.jpg" alt="导入仓库" style="zoom:67%;"><p>选择导入GitHub仓库</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402282301124.jpg" alt="选择仓库" style="zoom: 50%;"><p>导入对应GitHub仓库，此时需要注意仓库名字需要和你创建gitee时的名字相同，如果不知道名字可先往下看，中间可修改仓库名字</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402282303081.jpg" alt="导入仓库" style="zoom: 50%;"><p>查看名字为哪个，可看浏览器网址，中间名字就是</p><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402282318977.jpg" alt="查看用户名"></p><p>设置仓库为公有，为了可以开启pages，进入仓库，点击管理</p><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402282306887.jpg" alt="进入设置"></p><p>基本信息最下方找到，是否开源，点击开源</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402282307142.jpg" alt="开源" style="zoom: 50%;"><h1 id="部署gitee-pages"><a href="#部署gitee-pages" class="headerlink" title="部署gitee pages"></a>部署gitee pages</h1><p>进入对应仓库，点击服务，点击gitee pages，此处需要实名认证，实名认证完之后才可以开启</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402282320319.jpg" alt="部署" style="zoom: 50%;"><p>进入之后，直接选中对应仓库中的分支，点击部署即可</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402282322599.jpg" alt="部署中" style="zoom: 50%;"><p>GitHub上传部署之后不会自动更新gitee，需要手动部署，只需要在对应的仓库中，点击仓库名字旁边的旋转图标，强制更新即可，更新就直接部署了，不需要自己再进入pages重新部署。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;创建并同步GitHub仓库&quot;&gt;&lt;a href=&quot;#创建并同步GitHub仓库&quot; class=&quot;headerlink&quot; title=&quot;创建并同步GitHub仓库&quot;&gt;&lt;/a&gt;&lt;center&gt;创建并同步GitHub仓库&lt;/center&gt;&lt;/h1&gt;&lt;p&gt;点击加号，选择从G</summary>
      
    
    
    
    <category term="技术教程" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="GitHub同步gitee并部署" scheme="http://example.com/tags/GitHub%E5%90%8C%E6%AD%A5gitee%E5%B9%B6%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>云图床</title>
    <link href="http://example.com/post/2ec6e870.html"/>
    <id>http://example.com/post/2ec6e870.html</id>
    <published>2024-02-23T01:53:48.000Z</published>
    <updated>2024-02-24T06:29:59.265Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图床导航"><a href="#图床导航" class="headerlink" title="图床导航"></a>图床导航</h1><p><a href="http://imgdh.com/">网址</a></p><h1 id="路过图床"><a href="#路过图床" class="headerlink" title="路过图床"></a>路过图床</h1><p><a href="https://imgse.com/">网址</a></p><h1 id="Picgo图床"><a href="#Picgo图床" class="headerlink" title="Picgo图床"></a>Picgo图床</h1><p><a href="https://www.picgo.net/">网址</a></p><h1 id="sm-ms图床"><a href="#sm-ms图床" class="headerlink" title="sm.ms图床"></a>sm.ms图床</h1><p><a href="https://sm.ms/">网址</a></p><h1 id="薄荷图床"><a href="#薄荷图床" class="headerlink" title="薄荷图床"></a>薄荷图床</h1><p><a href="https://zixiaoyun.com/">网址</a></p><h1 id="风筝图床"><a href="#风筝图床" class="headerlink" title="风筝图床"></a>风筝图床</h1><p><a href="https://www.imgbed.link/">网址</a></p><h1 id="ImgURL图床"><a href="#ImgURL图床" class="headerlink" title="ImgURL图床"></a>ImgURL图床</h1><p><a href="https://www.imgurl.org/vip/manage/upload">网址</a></p><h1 id="Z4A图床"><a href="#Z4A图床" class="headerlink" title="Z4A图床"></a>Z4A图床</h1><p><a href="https://z4a.net/">网址</a></p><h1 id="Hello图床"><a href="#Hello图床" class="headerlink" title="Hello图床"></a>Hello图床</h1><p><a href="https://www.helloimg.com/">网址</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;图床导航&quot;&gt;&lt;a href=&quot;#图床导航&quot; class=&quot;headerlink&quot; title=&quot;图床导航&quot;&gt;&lt;/a&gt;图床导航&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://imgdh.com/&quot;&gt;网址&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;路过图床&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="技术教程" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="云图床" scheme="http://example.com/tags/%E4%BA%91%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>魔法</title>
    <link href="http://example.com/post/812d49a5.html"/>
    <id>http://example.com/post/812d49a5.html</id>
    <published>2024-02-22T14:02:09.000Z</published>
    <updated>2024-02-29T01:47:42.993Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="3e4ed3aabf804adcace86fa937a891749266fd69f74b238b13adbf9a32734931">d0082e95ce53ece4a4c0f5b8a727fc3f7abb847cc98e7a9a6a2fde3b380d7c463eab01dd65778c150e07dcadb67c6af1d15b71b699b47174951fa67a2912481f86bfc3f40db66f875cde4163a833c2282a5ef27e4dce42910951c1fb29d2bcede01f597d9b999b5ae308c011e3a8bcfe87f6943b92da1629ebf2f20f85e1ff09f7ac03362d4799f57091d1ce3affbc597b5318e09fba03e79b9330c9282a9530ab686db628d7499492ad97c86bcd148c5955f26e767728282d95e46c39afe37e7b3125e16426491d24604cb05862abbd276c34f94a0a10e1d1c5a3f40e3aa3f2a340378712f0329a6c38f361781b02e77129aece2ee545f49116099dd42be108e85d0d6c93d1650da9e333105a9e2ce14df0b1d76be27466bd48064da706e38d7a7aa70e122cda666c38c16945e90fd655b5e1b7f482947e00fe39a263f7243626482cfc6e33301285edfce86fe4bd930a32a247a2fd08747b7d0bdb3d3ac2bc43fe860f7ec0967543000929eb011651ba4494aca9ce5937be5d5a872ea65ebad211ace06566d8c6b1ec3973953c8979b0715d02068f688ba0cd9165cc13279583427e9e9b64810ea8c48fd5ebc786fc10eb5ffa5c656853f859a8e923f6f1f2569f74ebc27a1072ab5d68201b5ba236d2288b01d101eb7e56da22546facb31bba2589b3b247a0fca3c376543294e3207ab5fe131ff4e463ad77635bbcd2de80781b01397a0b1fb02e9a68e1f165ea4a16f8f2aa5019f87a69f4cc32172bace6fae2b612a33c2a1d41568fa05d6b5c11421b5ed153a2bc30ed1dd7ad95b1945b1515ded15105b848d3221e0970a97d1c00d043bd72a393ec8e41cdbe4c12a04c7e6542464818d1c7cf8b92eb2a7fa54c109ad2d1da526115efb0283c574f87a692a906e999b154d8f13ee65d404f2293c8edfd7d371e169db7cdbc78badc605dfec3e973401ea627bc085ffce44893a7b3e593c2c6c10145aa13cf69b3e12e6c8b8a2465dd48099ff75a9b115bd424b3f7bd881e195548d349ee915739846c44bb8ca00c8cadd40441744d47faf0ccad1f92cd058d833c1674db48beb210e76d5720b13f4f3b13bbe4cceca797d8aa1fa2f7186d6e3a84ee73c556697ae2811781b52dc815be916c3a201992ee752c9baaf08616a4432c8b68b23e36504a68108a2a29fddb68cb51a7d13471e94b714d7145add1f134cae8b148b8a087117315fd685def827124b9db4b052a9d02416861e8da24a0121ca52ea80c5cb9193d4e</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码，查看文章。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这是一篇加密文章，内容可能是个人情感宣泄或者收费技术。如果你非常好奇，请与我联系。</summary>
    
    
    
    <category term="技术教程" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="魔法" scheme="http://example.com/tags/%E9%AD%94%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>计算机备考</title>
    <link href="http://example.com/post/df95841.html"/>
    <id>http://example.com/post/df95841.html</id>
    <published>2024-01-06T01:00:00.000Z</published>
    <updated>2024-03-23T03:32:16.164Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C语言程序和程序设计概述"><a href="#C语言程序和程序设计概述" class="headerlink" title="C语言程序和程序设计概述"></a><center>C语言程序和程序设计概述</center></h1><p>程序：可以连续执行的一条条指令的集合</p><p>开发过程：C源程序(.c文件) –&gt; 目标程序(.obj二进制文件，目标文件) –&gt; 可执行文件(.exe文件) –&gt;结果</p><p>在任何机器上可以运行C源程序生成的<code> .exe 文件</code></p><p>没有安装C语言集成开发环境，不能编译C语言程序，<code>函数</code>是C程序的<code>基本单位</code></p><p>程序设计有以下几个部分：</p><ol><li>确定数据结构</li><li>确定算法</li><li>编码（编写代码）</li><li>计算机上调试程序</li><li>整理并写出文档资料</li></ol><p>C语言运行方法：编译执行，python：解释执行</p><p>头文件：#include&lt;stdio.h&gt;</p><p>C语言的结构特点：</p><ul><li>函数是C程序的主要组成部分</li></ul><p>&ensp;&ensp;&ensp;&ensp;一个C程序是由一个或多个函数组成</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;必须包含一个main函数（只能有一个）</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;每个函数都用来实现一个或多个特定功能</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;被调用的函数可以是库函数，也可以是自己编制设计的函数</p><ul><li>程序总是从main函数开始执行</li><li>C程序书写可以一行内写几个语句，也可以一个语句分写在多行上（以<mark>分号</mark>为标准，判断是否是一个语句）</li><li>数据声明和语句最后必须有分号</li><li>C语言本事不提供输入输出语句，由库函数提供</li></ul><p>算法表示方法：</p><ol><li>自然语言</li><li>用伪代码表示</li><li>用流程图表示</li></ol><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402220850908.png" alt="流程图常用符号" style="zoom:50%;"><ol start="4"><li>N-S流程图表示</li></ol><h2 id="标识符、常量和变量"><a href="#标识符、常量和变量" class="headerlink" title="标识符、常量和变量"></a><center>标识符、常量和变量</center></h2><p>常量</p><p>整型常量：12、0、-3</p><p>实型常量：</p><p>&ensp;&ensp;&ensp;&ensp;十进制小数：0.34、-56.79</p><p>&ensp;&ensp;&ensp;&ensp;指数形式：12.34e3（12.34×10³）</p><p>符号常量：’a’、’b’</p><p>字符串常量：”Beijing”</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">常量在程序运行期间，值不可以改变的</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159<span class="comment">//定义符号常量不需要分号</span></span></span><br></pre></td></tr></table></figure><p>变量</p><p>&ensp;&ensp;&ensp;&ensp;在程序运行期间，值是可以改变的</p><p>&ensp;&ensp;&ensp;&ensp;定义变量时指定该变量的名字和类型</p><p>&ensp;&ensp;&ensp;&ensp;变量名实际上是以一个名字代表一个存储地址</p><p>&ensp;&ensp;&ensp;&ensp;从变量取值，实际上是通过变量名找到相应的内存地址，从该存储单元中读取数据</p><p>标识符</p><p>&ensp;&ensp;&ensp;&ensp;只能由字母、数字和下划线组成，且第一个字符必须为字符或下划线，不能使用C语言关键字作为标识符</p><p>C语言是严格区分字母大小写</p><p>关键字必须用小写字母</p><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402220849778.png" alt="关键字"></p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><center>数据类型</center></h2><h3 id="整型数据"><a href="#整型数据" class="headerlink" title="整型数据"></a>整型数据</h3><p>&ensp;&ensp;&ensp;&ensp;整型常量3种表示形式</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;十进制整数，如2，-983</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;八进制整数。以0开头，由0~7构成，通常为无符号数，如012，八进制12</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;十六进制整数。以0x开头，由 0 ~ 9 和 A ~ F 或 a ~ f 构成，如0x12A，十六进制12A</p><p>&ensp;&ensp;&ensp;&ensp;整型变量：<font color="red">类型说明符 变量名标识符;</font>如 int a,b,c;</p><p>&ensp;&ensp;&ensp;&ensp;在定义变量的同时给变量赋初值，称变量初始化，若没有初始化，则内容不确定</p><p>计算机最小存储单位：位(bit)</p><p>&ensp;&ensp;&ensp;&ensp;一个<mark>字节</mark>(byte) &#x3D; 8bit</p><table><thead><tr><th align="center">关键字</th><th align="center">类型</th><th align="center">所占的空间</th></tr></thead><tbody><tr><td align="center">char</td><td align="center">字符串类型</td><td align="center">占1字节空间（8位二进制位）</td></tr><tr><td align="center">short</td><td align="center">短整型</td><td align="center">占2字节空间（16位二进制位）</td></tr><tr><td align="center">int</td><td align="center">整型</td><td align="center">占4个字节空间（32位二进制）</td></tr><tr><td align="center">long</td><td align="center">长整型</td><td align="center">占4个字节空间（32位二进制）（在64为平台下占8个字节）</td></tr><tr><td align="center">float</td><td align="center">单精度浮点数</td><td align="center">占4个字节空间（32为二进制）（7位有效位，指数-37到38）</td></tr><tr><td align="center">double</td><td align="center">双精度浮点数</td><td align="center">占8个字节空间（64为二进制）（16位有效位，指数-307到308）</td></tr></tbody></table><p>在存储有符号数时，存储单元最高为代表符号位，0为正，1为负</p><p>设计程序时，注意变量类型的取值范围，当赋值超过取值范围时，会出现溢出错误</p><p>一个整 型常量后加 U或u 后缀则被认为时unsigned类型，内存中按unsigned规定方式存放</p><p>一个整型常量后加 L或l 后缀则被认为时long类型，内存中按long规定位数存放</p><p>无符号长整数：用后缀 UL&#x2F;ul表示，如：15ul</p><h3 id="浮点型-实型-数据"><a href="#浮点型-实型-数据" class="headerlink" title="浮点型(实型)数据"></a>浮点型(实型)数据</h3><p>实型常量</p><p>&ensp;&ensp;&ensp;&ensp;又称实属或浮点数</p><p>&ensp;&ensp;&ensp;&ensp;十进制小数形式，如123.456</p><p>&ensp;&ensp;&ensp;&ensp;指数形式：以 “e” 或 “E” 后跟一个整数来表示以10为底的幂数，如 2.3026e2</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;规定：字母 e 或 E 之前必须有数字，且e或E后面指数必须为整数</p><p>&ensp;&ensp;&ensp;&ensp;10⁸不能写成e8，必须写成：1e8 或 1.0E8</p><p>实型变量</p><p>&ensp;&ensp;&ensp;&ensp;实型(3.14159)数据在内存中存放的形式：</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;+：数符</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;.314159：小数部分</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1：指数</p><p>&ensp;&ensp;&ensp;&ensp;小数部分占的为数越多，数的有效数字越多，精度越高</p><p>&ensp;&ensp;&ensp;&ensp;指数部分占的位数越多，则能表示的数值范围越大</p><h3 id="字符型数据"><a href="#字符型数据" class="headerlink" title="字符型数据"></a>字符型数据</h3><p>字符常量</p><p>&ensp;&ensp;&ensp;&ensp;用单引号括起来的一个字符，如’a‘、’E‘，不能 ’ab‘</p><p>&ensp;&ensp;&ensp;&ensp;字符常量以ASCII码存储，一个字符占一个字节，<mark>大写</mark>字母与<mark>小写</mark>字母ASCII码值相差 32</p><p>字符变量</p><p>&ensp;&ensp;&ensp;&ensp;如：char c1,c2,c3; c1 &#x3D; ‘A’; c2 &#x3D; ‘\n’;</p><p>&ensp;&ensp;&ensp;&ensp;每个字符变量分配一个字节用于存放一个字符（存放的是字符的ASCII码值）</p><p>字符数据与整型数据可相互赋值，直接运算</p><p>用%d输出，则输出整型数，用%c输出，则输出字符</p><p>字符串常量</p><p>&ensp;&ensp;&ensp;&ensp;一对双引号(“ “)括起来的字符序列，字符个数称为其长度，如：”hellow”</p><p>&ensp;&ensp;&ensp;&ensp;长度为n的字符串，在计算机存储中占n+1个字节，原因：会自动在结尾添加 ’\0‘</p><p>ASCII码表</p><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402220849502.png" alt="ASCII码表"></p><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><table><thead><tr><th align="center">字符形式</th><th align="center">功能</th><th align="center">字符形式</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">\n</td><td align="center">回车换行</td><td align="center">\\</td><td align="center">一个反斜杠字符(\)</td></tr><tr><td align="center">\t</td><td align="center">将当前位置移到下一个tab位置</td><td align="center">\‘</td><td align="center">一个单引号(‘)</td></tr><tr><td align="center">\v</td><td align="center">当前位置移到下一个垂直制表对齐点</td><td align="center">\“</td><td align="center">一个双引号(“)</td></tr><tr><td align="center">\r</td><td align="center">回车符</td><td align="center">\ddd</td><td align="center">三位八进制数代表一个ASCII字符</td></tr><tr><td align="center">\f</td><td align="center">换页符</td><td align="center">\xhh</td><td align="center">二位十六进制代表一个ASCII字符</td></tr><tr><td align="center">\b</td><td align="center">将当前位置后退一个字符</td><td align="center">\0</td><td align="center">空值，其ASCII码值为0</td></tr></tbody></table><h3 id="符号常量"><a href="#符号常量" class="headerlink" title="符号常量"></a>符号常量</h3><p>用标识符表示的常量，一般符号常量名用大写字母表示，命令通常放在文件头，在程序中不允许重新赋值，注意：不需要分号结尾</p><p>格式：#define 标识符 常量如：#define PI 3</p><h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402220849431.png" alt="数学函数" style="zoom: 50%;"><h2 id="运算符和表达式"><a href="#运算符和表达式" class="headerlink" title="运算符和表达式"></a><center>运算符和表达式</center></h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>优先级越小，越优先，优先级相同时，运算次序由<mark>结合性</mark>决定</p><table><thead><tr><th align="center">运算符</th><th align="center">运算规则</th><th align="center">操作数数目</th><th align="center">优先级</th><th align="center">结合方向</th></tr></thead><tbody><tr><td align="center">-</td><td align="center">负号</td><td align="center">单目</td><td align="center">2</td><td align="center">左结合</td></tr><tr><td align="center">+</td><td align="center">加法</td><td align="center">双目</td><td align="center">4</td><td align="center">左结合</td></tr><tr><td align="center">-</td><td align="center">减法</td><td align="center">双目</td><td align="center">4</td><td align="center">左结合</td></tr><tr><td align="center">*</td><td align="center">乘法</td><td align="center">双目</td><td align="center">3</td><td align="center">左结合</td></tr><tr><td align="center">&#x2F;</td><td align="center">除法</td><td align="center">双目</td><td align="center">3</td><td align="center">左结合</td></tr><tr><td align="center">%</td><td align="center">取余或模</td><td align="center">双目</td><td align="center">3</td><td align="center">左结合</td></tr></tbody></table><p>1.&#x2F;3 + 1.&#x2F;3 + 1.&#x2F;3 &#x3D; 1</p><p>取余运算符，所得结果的符号与运算符左侧操作数符号相同，如：-5 % 2 &#x3D; -1，5 % -2 &#x3D; 1，<code>运算对象只能是整型</code>，结果也是整型，如：5 % 2 &#x3D;1</p><h3 id="自增、自减运算符"><a href="#自增、自减运算符" class="headerlink" title="自增、自减运算符"></a>自增、自减运算符</h3><p>自增和自减运算符只能用于变量，不能用于常量和表达式</p><table><thead><tr><th align="center">含义</th><th align="center">运算符</th><th align="center">优先级</th><th align="center">结合性</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">自增</td><td align="center">++</td><td align="center">2</td><td align="center">右结合</td><td align="center">使变量的值增1</td></tr><tr><td align="center">自减</td><td align="center">–</td><td align="center">2</td><td align="center">右结合</td><td align="center">使变量的值减1</td></tr></tbody></table><p>使用形式：</p><p>&ensp;&ensp;&ensp;&ensp;++i 或 –i 变量 i 先自增或自减 1，再引用 i</p><p>&ensp;&ensp;&ensp;&ensp;i++ 或 i– 先使用变量 i，再自增或自减1</p><h3 id="不同数据类型间的转换"><a href="#不同数据类型间的转换" class="headerlink" title="不同数据类型间的转换"></a>不同数据类型间的转换</h3><p>自动转换类型：数据类型自动由低级向高级转换</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402220849472.png" alt="自动转换类型图" style="zoom:33%;"><p>强制转换：将表达式的运算结果强制转换成指定的数据类型</p><p>格式：(数据类型说明符)(表达式)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="type">float</span> z;</span><br><span class="line">(<span class="type">float</span>)(x+y);<span class="comment">//浮点型</span></span><br><span class="line">(<span class="type">int</span>)z+x;<span class="comment">//整型</span></span><br></pre></td></tr></table></figure><h3 id="关系运算符（比较运算）"><a href="#关系运算符（比较运算）" class="headerlink" title="关系运算符（比较运算）"></a>关系运算符（比较运算）</h3><p>关系表达式：</p><p>&ensp;&ensp;&ensp;&ensp;格式：表达式1 关系运算符 表达式2;如：m+n &lt;&#x3D; 20; 成立表达式值为 1，不成立值为0</p><table><thead><tr><th align="center">含义</th><th align="center">运算符</th><th align="center">优先级</th><th align="center">结合性</th></tr></thead><tbody><tr><td align="center">小于</td><td align="center">&lt;</td><td align="center">6</td><td align="center">左结合</td></tr><tr><td align="center">小于等于</td><td align="center">&lt;&#x3D;</td><td align="center">6</td><td align="center">左结合</td></tr><tr><td align="center">大于</td><td align="center">&gt;</td><td align="center">6</td><td align="center">左结合</td></tr><tr><td align="center">大于等于</td><td align="center">&gt;&#x3D;</td><td align="center">6</td><td align="center">左结合</td></tr><tr><td align="center">等于</td><td align="center">&#x3D;&#x3D;</td><td align="center">7</td><td align="center">左结合</td></tr><tr><td align="center">不等于</td><td align="center">!&#x3D;</td><td align="center">7</td><td align="center">左结合</td></tr></tbody></table><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><table><thead><tr><th>含义</th><th>运算符</th><th>优先级</th><th>结合性</th><th>运算逻辑</th></tr></thead><tbody><tr><td>逻辑非</td><td>!</td><td>2</td><td>右结合</td><td>取反</td></tr><tr><td>逻辑与</td><td>&amp;&amp;</td><td>11</td><td>左结合</td><td>全真为真，其余为假</td></tr><tr><td>逻辑或</td><td>||</td><td>12</td><td>左结合</td><td>全假为假，其余为真</td></tr></tbody></table><h4 id="逻辑表达式"><a href="#逻辑表达式" class="headerlink" title="逻辑表达式"></a>逻辑表达式</h4><p>&ensp;&ensp;&ensp;&ensp;形式：表达式1 逻辑运算符 表达式2如：5 &gt; 3 &amp;&amp; 2 || 4 - !’a’</p><p>判断时，0 代表 假，非0 代表真</p><p>逻辑与 和 逻辑或 短路能力</p><p>&ensp;&ensp;&ensp;&ensp;逻辑与：只有表达式1值为真，才求表达式2 的值</p><p>&ensp;&ensp;&ensp;&ensp;逻辑或：只有表达式1值为假，才判断表达式2的值</p><h3 id="三目表达式"><a href="#三目表达式" class="headerlink" title="三目表达式"></a>三目表达式</h3><p>形式：表达式1 ? 表达式2 : 表达式3如：max &#x3D; (a&gt;b)?a:b;</p><p>如果表达式1为真，执行表达式2，为假，执行表达式3</p><p>最终判断出的值类型，为表达式2和表达式3 中较高的类型</p><p>可以嵌套的，这种嵌套是右结合，如：a &gt; b ? c : c &gt; d ? b : d;</p><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>复合赋值运算符：+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;、%&#x3D;优先级14，右结合性</p><h3 id="赋值表达式"><a href="#赋值表达式" class="headerlink" title="赋值表达式"></a>赋值表达式</h3><p>简单赋值表达式</p><p>&ensp;&ensp;&ensp;&ensp;格式：变量 &#x3D; 表达式如：k &#x3D; i+++–j</p><p>&ensp;&ensp;&ensp;&ensp;执行顺序：先计算，再赋值</p><p>复合表达式</p><p>&ensp;&ensp;&ensp;&ensp;x +&#x3D; y +&#x3D; z*z–&gt; x&#x3D; x+(y&#x3D;y+z*z)</p><h3 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h3><p>符号：,</p><p>优先级15，左结合</p><h3 id="逗号表达式"><a href="#逗号表达式" class="headerlink" title="逗号表达式"></a>逗号表达式</h3><p>格式：表达式1,表达式2,表达式3如：a &#x3D; 3*5,a*10,a+8</p><p>求解过程中：先求表达式1的值，再表达式2的值，再表达式n的值，<mark>表达式n</mark>的值作为<font color="red">整个逗号表达式的值</font></p><h2 id="选择结构（分支结构）"><a href="#选择结构（分支结构）" class="headerlink" title="选择结构（分支结构）"></a><center>选择结构（分支结构）</center></h2><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p>格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式) 语句<span class="number">1</span>;<span class="comment">//语句1，只能是一条语句</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(表达式)</span><br><span class="line">&#123;</span><br><span class="line">语句块<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>()</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>()</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：else 与 if 必须成对出现，且else总是与<mark>最近</mark>的一个未配对的 if 配对</p><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p>格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)<span class="comment">//表达式类型要与case后面常量值类型匹配，只能是整型、字符型或枚举型</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> 常量表达式:<span class="comment">//每个case后的常量表达式不允许相同</span></span><br><span class="line">语句<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> 常量表达式:</span><br><span class="line">语句<span class="number">2</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">语句n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>语句终止<span class="keyword">switch</span>语句的执行</span><br></pre></td></tr></table></figure><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a><center>循环结构</center></h2><h3 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h3><p>格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(表达式)</span><br><span class="line">&#123;</span><br><span class="line">    语句块;<span class="comment">//循环体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先判断，再执行，有可能一次也不执行</span></span><br></pre></td></tr></table></figure><p>注意：<br>&ensp;&ensp;&ensp;&ensp;1）while没有初始化语句，用户提前初始化好</p><p>&ensp;&ensp;&ensp;&ensp;2）while没有步进语句，用户必须在循环语句中写好步进语句</p><p>&ensp;&ensp;&ensp;&ensp;3）循环变量的值可以被引用、修改，但不能赋新值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test04</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=<span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">        i++;   <span class="comment">//步进条件 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum = %d\n&quot;</span>,sum);<span class="comment">//sum = 5050</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    test04();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当循环体是空语句或单个语句</span></span><br><span class="line"><span class="keyword">while</span>(x++ &lt; <span class="number">1000</span>);<span class="comment">//分号不能省略</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span>(x-- &gt; <span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,x);</span><br></pre></td></tr></table></figure><h3 id="do-while语句"><a href="#do-while语句" class="headerlink" title="do-while语句"></a>do-while语句</h3><p>格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//循环体语句</span></span><br><span class="line">&#125;<span class="keyword">while</span>(表达式);</span><br><span class="line"><span class="comment">//特点：先执行，再判断，至少执行一次循环体</span></span><br></pre></td></tr></table></figure><h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h3><p>格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始语句;循环条件;步进条件)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//循环语句</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始语句：只在循环开始时执行一次</span></span><br><span class="line"><span class="comment">//循环条件: 每次循环都要执行，如果循环条件为 真 进入循环体，如果为 假 退出循环</span></span><br><span class="line"><span class="comment">//步进条件：每次循环结束的时候要执行的语句</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始语句可以省略，但要在for语句之前给循环变量赋初值</span></span><br><span class="line"><span class="comment">//循环条件为空时，则会陷入死循环</span></span><br><span class="line"><span class="comment">//进步条件省略时，需要在循环体内写进步条件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始语句和进步条件可以有多项，若有多项则使用逗号表达式</span></span><br><span class="line"><span class="keyword">for</span>(s = <span class="number">0</span>,i = <span class="number">1</span>;i &lt;= <span class="number">100</span>;s += i,i++);</span><br><span class="line"></span><br><span class="line"><span class="comment">//单个语句时</span></span><br><span class="line"><span class="keyword">for</span>(初始语句;循环条件;步进条件)</span><br><span class="line">    语句;</span><br><span class="line"><span class="comment">//特点：先判断，再执行，有可能一次也不执行</span></span><br></pre></td></tr></table></figure><p>嵌套for循环：总结外层循环的次数*内层循环的次数&#x3D;&#x3D;总循环次数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并列的循环变量可以同名，但嵌套的循环变量不能同名</span></span><br><span class="line"><span class="keyword">for</span>(初始语句;循环条件;步进条件)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">for</span>(初始语句;循环条件;步进条件)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="comment">//循环语句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h2><p>格式：break;</p><p>作用：提前退出某个循环或跳出switch结构</p><p>只能在switch语句和循环体中使用</p><h2 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h2><p>格式：continue;</p><p>作用：结束本次循环，接着下次循环，通常与if语句连用</p><h2 id="数组与结构"><a href="#数组与结构" class="headerlink" title="数组与结构"></a><center>数组与结构</center></h2><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><p>格式：<font color="red">类型说明符 数组名[常量表达式];</font></p><p>常量表达式可以是 <mark>正</mark>整数常量、符号常量或常量表达式，不能包含变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 10</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">11</span>],b[N],c[<span class="string">&#x27;0&#x27;</span>];</span><br><span class="line"><span class="type">float</span> d[<span class="number">2</span>*N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//sizeof(类型) * 数组长度 = 总字节数</span></span><br><span class="line"><span class="type">int</span>(<span class="number">4</span>字节) * <span class="number">11</span> = <span class="number">44</span></span><br><span class="line"><span class="comment">//引用方式</span></span><br><span class="line">数组名 [下标]</span><br><span class="line"><span class="comment">//数组初始化</span></span><br><span class="line">类型符 数组名[表达式] = &#123;初值表&#125;;</span><br><span class="line"><span class="comment">//全部元素赋初值</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">8</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;<span class="comment">//初始数据个数&gt;数组长度，编译出错</span></span><br><span class="line"><span class="comment">//部分元素赋初值</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">8</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;<span class="comment">//剩下元素的初值为0</span></span><br><span class="line"><span class="comment">//给全部元素赋初值时可以不指定数组长度</span></span><br><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;<span class="comment">//数组长度是初值表中数值的个数</span></span><br><span class="line"><span class="comment">//当对全部数组元素初始化为0时，可以写成</span></span><br><span class="line"><span class="type">int</span> x[<span class="number">5</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">或 <span class="type">int</span> x[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//初值表不能为空 如：int a[5] = &#123;&#125;;但是可以int a[5]; 但元素值不确定</span></span><br><span class="line"><span class="comment">//如果没有初始化的数组，元素的值不确定</span></span><br></pre></td></tr></table></figure><p>数组是数目固定，类型相同的若干变量的有序集合</p><p>数组中每一个变量称为数组元素，属于同一个数据类型</p><p>数组在内存占有一段连续的存储空间</p><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>格式：类型说明符 数组名[常量表达式1] [常量表达式2];如：int a[3][4];</p><p>注意：下标从0开始</p><p>二维数组总字节数：行数 * 列数 * 类型字节数</p><h3 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h3><h1 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a><center>标准库</center></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如使用输入输出函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//使用字符串处理函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">//使用数学库中的函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span><span class="comment">//所有数学函数返回都是double型</span></span></span><br></pre></td></tr></table></figure><p>C语言中将 null 定义为 0，则null表示则为0</p><p>EOF：为-1</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><center>数据结构</center></h1><blockquote><p>课件：<a href="https://maifile.cn/est/a65c2e423881c5/pdf">https://maifile.cn/est/a65c2e423881c5/pdf</a></p></blockquote><h2 id="第二章-线性表"><a href="#第二章-线性表" class="headerlink" title="第二章 线性表"></a><center>第二章 线性表</center></h2><p>线性表定义：n(&gt;&#x3D; 0)个数据特性相同的元素的有限序列，记作(a1,a2,…..,an)</p><p>线性表逻辑结构：一对一</p><p>ai是表中数据元素，n是表长度</p><p>遍历：逐项访问，从前向后，从后向前</p><p>线性表特点：</p><p>&ensp;&ensp;&ensp;&ensp;除了第一个元素外，其他每一个元素有且只有一个<font color="red">直接前驱</font></p><p>&ensp;&ensp;&ensp;&ensp;除了最后一个元素外，其他每一个元素有且只有一个<font color="red">直接后驱</font></p><p>&ensp;&ensp;&ensp;&ensp;例：a1&lt;–&gt;a2&lt;—-&gt;a3&lt;—-&gt;a4</p><p>&ensp;&ensp;&ensp;&ensp;线性表的存储结构：顺序存储结构、链式存储结构（单链表、双链表、循环链表）</p><p>顺序表（顺序存储）：</p><p>&ensp;&ensp;&ensp;&ensp;每个节点只存放数据元素</p><p>&ensp;&ensp;&ensp;&ensp;定义：将线性表中的元素相继存放在一个连续的存储空间中</p><p>&ensp;&ensp;&ensp;&ensp;特点：线性表的顺序存储方式，可以随机存取</p><p>&ensp;&ensp;&ensp;&ensp;优点：可随机存取，存储密度高</p><p>&ensp;&ensp;&ensp;&ensp;缺点：要求大片连续空间，改变容量不方便</p><p>&ensp;&ensp;&ensp;&ensp;插入&#x2F;删除 要将后续元素后移&#x2F;前移动，可通过下表确定目标元素位置，时间开销主要移动元素(O(n))</p><p>&ensp;&ensp;&ensp;&ensp;按位查找 O(1) ，按值查找(需要对元素值一一比较) O(n)</p><p>链表（链式存储）</p><p>&ensp;&ensp;&ensp;&ensp;每个节点除了存放数据元素外，还存储向下一个节点的指针</p><p>&ensp;&ensp;&ensp;&ensp;优点：不要求大片连续空间，改变容量方便</p><p>&ensp;&ensp;&ensp;&ensp;缺点：不可随机存取，要耗费一定空间存放指针</p><p>&ensp;&ensp;&ensp;&ensp;单链表：无法逆向检索，增加头节点目的：方便运算的实现(使得对第一个元素的操作与其他元素操作相同)</p><p>&ensp;&ensp;&ensp;&ensp;双链表：可进退检索</p><p>&ensp;&ensp;&ensp;&ensp;空表：头节点指针域都指向头节点</p><p>&ensp;&ensp;&ensp;&ensp;循环单链表：表尾节点的指针指向头节点，形成循环</p><p>&ensp;&ensp;&ensp;&ensp;循环双链表：双向指针域，尾节点指向头节点，头节点指向下一个节点和尾节点，形成循环且可进退</p><p>&ensp;&ensp;&ensp;&ensp;复杂度：若从头节点找到尾部，时间复杂度为O(n)，n：n个元素</p><p>&ensp;&ensp;&ensp;&ensp;插入&#x2F;删除 元素只需修改指针即可，但需要遍历找到对应修改元素的位置，时间开销主要查找目标元素(O(n))</p><p>&ensp;&ensp;&ensp;&ensp;按位查找 O(n) ，按值查找 O(n)</p><p>总结：</p><p>&ensp;&ensp;&ensp;&ensp;链表：用于经常需要增加&#x2F;删除元素(弹性)</p><p>&ensp;&ensp;&ensp;&ensp;顺序表：用于查询(搜索)操作</p><p>栈：<code>先进后出</code>（全部元素不用全部进栈才可以出栈，进栈和出栈的顺序可组成不同的序列）</p><p>&ensp;&ensp;&ensp;&ensp;压栈(push)，出栈(pop)</p><p>队列：<code>先进先出</code></p><p>栈和队列的共同点：只允许端点处插入和删除元素，都是线性表</p><p>括号配对算法结构：栈 最佳</p><h2 id="串和广义表"><a href="#串和广义表" class="headerlink" title="串和广义表"></a><center>串和广义表</center></h2><h3 id="串"><a href="#串" class="headerlink" title="串"></a>串</h3><p>串或字符串：由零个或多个字符组成的有限序列</p><p>串也称为字符串，在 C 语言中是由数字、字母、下划线以及特殊字符组成的串字符，字符串需要用一对双引号括起来。在一个字符串中取一部分作为一个新字符串，这个新字符串叫子串，另一个叫做它的母串</p><p>s &#x3D; “a₁ a₂ a₃ … an” （n &gt;&#x3D; 0） n为串的长度</p><p>子串：串中任意个连续字符组成的子序列，包含字串的串称为主串</p><p>空串：零个字符的串</p><p>例：a &#x3D; “BEI”b &#x3D; “JING”c &#x3D; “BEIJING”d &#x3D; “BEI JING”</p><p>&ensp;&ensp;&ensp;&ensp;a和b都是c和d的字串，a在c和d中的位置都是1，b在c中的位置是4，在d中的位置是5</p><p>只有两个串的长度相等，并各个对应位置的字符都相等时，则这两个串都是相等的</p><h3 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h3><p>定义：广义表是线性表的推广，也称为列表</p><p>广义表的深度，可以通过观察该表中所包含括号的层数间接得到</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如：&#123;&#123;1,2&#125;,&#123;3,&#123;4,5&#125;&#125;&#125; 中，子表 &#123;1,2&#125; 和 &#123;3,&#123;4,5&#125;&#125; 位于同层，此广义表中包含 3 层括号，因此深度为 3</span><br></pre></td></tr></table></figure><p>广义表的长度(广度)：广义表中所包含的数据元素的个数</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如：广义表 &#123;&#123;a,b,c&#125;&#125; 中只有一个子表 &#123;a,b,c&#125;，因此它的长度为 1</span><br></pre></td></tr></table></figure><h2 id="树"><a href="#树" class="headerlink" title="树"></a><center>树</center></h2><p>树的逻辑结构：一对多</p><p>空树：节点数为0的树</p><p>有且只有一个根节点</p><p>没有后继的节点：叶子节点</p><p>有后继的节点：分支节点</p><p>除了根节点外，任何一个节点有且只有一个前驱</p><p>每个节点可以有 0 个或 多个后继</p><p>路径：由一节点到另一节点间的分支构成（只能从上往下）</p><p>路径长度：路径上的分支数目（经过几条边）</p><p>树的路径长度：树中所有叶子节点到根的路径长度之和</p><p>节点的层次(深度)：从上往下数</p><p>节点的高度：从下往上数</p><p>树的高度(深度)：总共有多少层</p><p>节点的度：有几个孩子(分支)</p><p>树的度：各节点的度的最大值</p><p>树的性质：</p><p>&ensp;&ensp;&ensp;&ensp;<code>总点数 = 总度数 + 1</code></p><p>&ensp;&ensp;&ensp;&ensp;m叉树：每个节点最多只能有m个孩子的树，可以是空树</p><p>&ensp;&ensp;&ensp;&ensp;度为 m 的树第 i 层最多有 m的 i-1 次方 个节点</p><p>&ensp;&ensp;&ensp;&ensp;m叉树第 i 层最多有 <code>m的 i-1次方</code> 个节点</p><p>&ensp;&ensp;&ensp;&ensp;高度为 h 的m叉树至多有几个节点（每一层都最多，则使用每层计算最多节点的方法再相加）</p><p>&ensp;&ensp;&ensp;&ensp;高度为 h 的m叉树至少有 h 个节点</p><p>&ensp;&ensp;&ensp;&ensp;高度为 h，度为m的树至少有 <code>h+m-1</code> 个节点</p><p>&ensp;&ensp;&ensp;&ensp;具有n个节点的m叉树的最小高度？ 每一层节点打满</p><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>特点：每个节点至多只有两颗子树，左右子树不能颠倒(二叉树是有序树)</p><p>任意二叉树满足：<code>n0 = n2 + 1</code></p><p>二叉树转森林：二叉树从根(包含)开始路过几个节点就有几个根，也就是有森林有几棵树</p><h4 id="满二叉"><a href="#满二叉" class="headerlink" title="满二叉"></a>满二叉</h4><p>&ensp;&ensp;&ensp;&ensp;一颗高度为h，含有 <code>2的h次方-1</code> 个节点的二叉树</p><p>&ensp;&ensp;&ensp;&ensp;特点：</p><p>&ensp;&ensp;&ensp;&ensp;只有最后一层有叶子节点</p><p>&ensp;&ensp;&ensp;&ensp;不存在度为1 的节点</p><p>&ensp;&ensp;&ensp;&ensp;按层序从1开始编号，节点 i 的左孩子为 2i，右孩子为 2i + 1，节点i的父亲节点为 i&#x2F;2(向下取整)</p><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>&ensp;&ensp;&ensp;&ensp;在满二叉树的基础上可去掉若干个编号更大的节点(最后几个缺失)，某节点只有一个孩子，一定是左孩子</p><p>&ensp;&ensp;&ensp;&ensp;高度：H &#x3D; ㏒₂N + 1</p><p>&ensp;&ensp;&ensp;&ensp;特点：</p><p>&ensp;&ensp;&ensp;&ensp;只有最后两层可能有叶子节点</p><p>&ensp;&ensp;&ensp;&ensp;最多只有一个度为 1 的节点</p><p>&ensp;&ensp;&ensp;&ensp;按层序从1开始编号，节点 i 的左孩子为 2i，右孩子为 2i + 1，节点i的父亲节点为 i&#x2F;2(向下取整)</p><p>&ensp;&ensp;&ensp;&ensp;i &lt;&#x3D; n&#x2F;2 为分支节点，i &gt; n&#x2F;2 为叶子节点  n：节点数</p><h4 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h4><p>&ensp;&ensp;&ensp;&ensp;左子树上所有节点的关键字均小于根节点的关键字</p><p>&ensp;&ensp;&ensp;&ensp;右子树上所有节点的关键字均大于根节点的关键字</p><p>&ensp;&ensp;&ensp;&ensp;左子树和右子树又各是一颗二叉排序树</p><p>&ensp;&ensp;&ensp;&ensp;判断二叉排序树的元素大小</p><p>&ensp;&ensp;&ensp;&ensp;在树图下方画个向右的坐标轴，从图中对应元素垂直到坐标轴，则可得到元素从小到大排序</p><p>&ensp;&ensp;&ensp;&ensp;查找(考察比较次数 &#x3D;&#x3D; 查找长度)</p><p>&ensp;&ensp;&ensp;&ensp;从上往下寻找，左树比根小，右数比根大，查找成功，返回结点指针，查找失败，返回null</p><p>&ensp;&ensp;&ensp;&ensp;查找成功时  平均查找长度(ASL)：每层的 查找长度 * 节点数 相加 &#x2F; 节点数</p><p>&ensp;&ensp;&ensp;&ensp;查找失败时  平均查找长度(ASL)：有叶子节点每一层的 同一层叶子节点数 * 查找长度 相加 &#x2F; 总叶子节点数</p><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>&ensp;&ensp;&ensp;&ensp;平衡二叉树是排序二叉树的特殊情况</p><p> &ensp;&ensp;&ensp;&ensp;树上，任一节点的左子树和右子树的深度之差不超过1</p><p>&ensp;&ensp;&ensp;&ensp;节点平衡因子 &#x3D; 左子树高 - 右子树高，只能是 <code>-1  0 或 1</code></p><h4 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h4><p>&ensp;&ensp;&ensp;&ensp;都是先左树后右树</p><p>&ensp;&ensp;&ensp;&ensp;先序遍历：根左右（从上到下，从左到右）</p><p>&ensp;&ensp;&ensp;&ensp;中序遍历：左根右（小嵌套再大嵌套）</p><p>&ensp;&ensp;&ensp;&ensp;后续遍历：左右根（小嵌套再大嵌套）</p><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402220848250.jpg" alt="二叉树遍历"></p><p>&ensp;&ensp;&ensp;&ensp;层序遍历：从上到下，从左到右</p><p>只给出前、中、后、层序遍历序列中的一种，可能对应多种二叉树形态，所以不能确定唯一一颗二叉树</p><p>需要两种来确定唯一（给出两个序列画图）</p><p>&ensp;&ensp;&ensp;&ensp;前序(确根) + 中序遍历(确左右)</p><p>&ensp;&ensp;&ensp;&ensp;后序(确根) + 中序遍历(确左右)</p><p>&ensp;&ensp;&ensp;&ensp;层序 + 中序遍历</p><h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><p>结点的权(节点上面的数值)：有某种显示含义的数值（如：表示结点的重要性等）</p><p><code>结点</code>的带权路径长度：从树的根到该结点的路径长度(经过边数) 与 该<code>结点上权值</code>的乘积</p><p><code>树</code>的带权路径长度(WPL)：树中所有<code>叶子结点</code>的带权路径长度之和</p><p>定义：含有n个带权叶子结点的二叉树中，其中树的<code>带权路径长度最小</code>的二叉树，哈夫曼树(最优二叉树)</p><p>构造</p><p>&ensp;&ensp;&ensp;&ensp;选取<code>权值最小</code>的结点构成新结点，新结点的权值为左 右子树上根结点权值之和，直到全部结点拼接完</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403172258571.png" alt="哈夫曼树构造" style="zoom:50%;"><p>&ensp;&ensp;&ensp;&ensp;特点：</p><p>&ensp;&ensp;&ensp;&ensp;每个初始结点(给出)最终都成为叶子结点，且权值越小的结点到根结点的路径长度越大</p><p>&ensp;&ensp;&ensp;&ensp;哈夫曼树的结点总数为：2n-1n：初始结点数</p><p>&ensp;&ensp;&ensp;&ensp;哈夫曼树中<code>不存在度为 1 的结点</code></p><p>&ensp;&ensp;&ensp;&ensp;哈夫曼树并不唯一，但WPL(树的带权路径长度)必然相同且最优</p><p>哈夫曼编码</p><p>&ensp;&ensp;&ensp;&ensp;固定长度编码：每个字符用相等长度的二进制表示</p><p>&ensp;&ensp;&ensp;&ensp;可变长编码：允许对不同字符用不等长的二进制位表示（使用哈夫曼树编辑二进制位）</p><p>&ensp;&ensp;&ensp;&ensp;前缀编码：没有一个编码是另一个编码的前缀，无歧义。非前缀编码有歧义</p><p>&ensp;&ensp;&ensp;&ensp;哈夫曼编码可以用于数据压缩</p><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>图(G)由顶点集(V)和边集(E)组成，|V|：图中顶点的个数|E|：图中边的条数</p><p>元素存在<code>多对多</code>的关系</p><p>图不可以是空，即 V 一定是非空集，但E可为0</p><p>有向图：边是有方向的(有向边)</p><p>G &#x3D; (V,E)</p><p>V &#x3D; {A,B,C,D,E}</p><p>E &#x3D; {&lt;A,B&gt;,&lt;A,C&gt;,&lt;A,D&gt;,&lt;A,E&gt;,&lt;B,A&gt;,&lt;B,C&gt;,&lt;B,E&gt;,&lt;C,D&gt;}</p><p>无向图：边是没有方向的(无向边)</p><p>G &#x3D; (V,E)</p><p>V &#x3D; {A,B,C,D,E}</p><p>E &#x3D; {(A,B),(B,D),(B,E),(C,D),(C,E),(D,E)}</p><p>简单图：不存在重复边，不存在顶点到自身的边（有向图中两个方向不同的边不属于重复边）</p><p>多重图：两个结点之间边数多余一条，允许顶点通过同一条边和自己联系</p><p>对于无向图</p><p>&ensp;&ensp;&ensp;&ensp;顶点的度：依附于该顶点的边的条数</p><p>&ensp;&ensp;&ensp;&ensp;无向图的全部顶点的度的和 等于 边数的2倍</p><p>对于有向图</p><p>&ensp;&ensp;&ensp;&ensp;入度(进来)：顶点 v 为终点的有向边的数目</p><p>&ensp;&ensp;&ensp;&ensp;出度(出去)：顶点 v 为起点的有向边的数目</p><p>&ensp;&ensp;&ensp;&ensp;顶点v的度：入度和出度之和入度之和 &#x3D; 出度之和 &#x3D; 边数</p><p>路径：顶点到顶点之间的路径</p><p>回路或环：第一个顶点和最后一个顶点相同的路径(构成闭环)</p><p>简单路径：顶点不重复出现的路径</p><p>简单回路：除了第一个顶点和最后一个顶点外，其余顶点不重复出现的回路</p><p>路径长度：路径上 边的数目</p><p>点到点的距离：顶点u到顶点v的最短路径若存在，则此路径的长度为u到v的距离，若不存在，则该距离为无穷(∞)</p><p>无向图中，顶点v 到 顶点w 有路径存在，则称 v 和 w 是<mark>连通</mark>的</p><p>有向图中，顶点v 到 顶点w 和 顶点w 到 顶点v 之间都有路径，则这两个顶点为<mark>强连通</mark>的</p><p>若图(无向)中，任意两个顶点都是连通的，则成为连通图，否则为非连通图</p><p>&ensp;&ensp;&ensp;&ensp;对于n个顶点的无向图G</p><p>&ensp;&ensp;&ensp;&ensp;若G是连通图，则最少有 <code>n-1</code> 条边</p><p>&ensp;&ensp;&ensp;&ensp;若G是非连通图，则最多可能有n(n-1)&#x2F;2</p><p>若图(有向)中，任何一堆顶点都是强连通，则此图为强连通图</p><p>&ensp;&ensp;&ensp;&ensp;n个顶点的强连通图，最少有<code>n</code>条边(形成回路)</p><p>生成子图：无向图中包含全部点(父图)</p><p>连通分量：无向图中有几个分开的整体，几个整体就是连通分量</p><p>强连通分量：有向图中有几个分开的整体，几个整体就是连通分量</p><p>连通图生成树：包含图中全部顶点，边尽可能少，但要保持连通</p><p>无向全连通图边数：<code>n(n-1)/2</code>n：顶点数</p><p>n个顶点有向图，每个顶点的度最大可达 <code>2(n-1)</code></p><h3 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h3><h4 id="邻接矩阵法"><a href="#邻接矩阵法" class="headerlink" title="邻接矩阵法"></a>邻接矩阵法</h4><p>&ensp;&ensp;&ensp;&ensp;注意：有向图的方向，<font color="red"><code>无向图</code></font><code>斜角45度对称</code></p><p>&ensp;&ensp;&ensp;&ensp;在无向图中，第i个结点的度 &#x3D; 第i行(或者第i列)的非零元素个数</p><p>&ensp;&ensp;&ensp;&ensp;在有向图中，第i个结点的<mark>出度</mark> &#x3D; 第i行的非零元素个数</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第i个结点的<mark>入度</mark> &#x3D; 第i列的非零元素个数</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第i个结点的度 &#x3D; 第i行、第i列的非零元素的个数之和</p><p>&ensp;&ensp;&ensp;&ensp;邻接矩阵法求顶点的度 出度 入度 的时间复杂度为 O(|v|)v：顶点个数</p><p>&ensp;&ensp;&ensp;&ensp;邻接矩阵法：所占存储空间与顶点个数相关</p><p>&ensp;&ensp;&ensp;&ensp;结点数为n，邻接矩阵A是 n*n 的</p><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402220848000.jpg" alt="邻接矩阵法"></p><p>&ensp;&ensp;&ensp;&ensp;邻接矩阵法存储带权图</p><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402220847724.jpg" alt="邻接矩阵图_带权"></p><p>&ensp;&ensp;&ensp;&ensp;邻接矩阵图性能分析</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;空间复杂度：O(|v|²)v：顶点数只和顶点数有关，和实际边数无关</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;适合用于存储稠密图</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<code>无向图</code>的的邻接矩阵是<code>对称矩阵</code>，<code>可以压缩存储</code></p><h4 id="邻接表-顺序-链式存储"><a href="#邻接表-顺序-链式存储" class="headerlink" title="邻接表(顺序+链式存储)"></a>邻接表(顺序+链式存储)</h4><p>&ensp;&ensp;&ensp;&ensp;边结点的数量是2|E|（每条边被记录了两次）</p><p>&ensp;&ensp;&ensp;&ensp;无向图空间复杂度为：O(|v| + 2|E|)</p><p>&ensp;&ensp;&ensp;&ensp;有向图空间复杂度为：O(v+e)</p><p>&ensp;&ensp;&ensp;&ensp;排列方式：<code>不唯一</code>。存储稀疏图(边较少)</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402220847734.jpg" alt="邻接表法" style="zoom:50%;"><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291650507.png" style="zoom:50%;"><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p>可能序列排序不唯一，按节点编号的<code>升序</code>一次访问</p><h4 id="广度优先遍历-BFS"><a href="#广度优先遍历-BFS" class="headerlink" title="广度优先遍历(BFS)"></a>广度优先遍历(BFS)</h4><p>树：类似<code>层序遍历</code>，一层一层遍历，先孩子再孙子，按编号升序访问</p><p>时间复杂度：O(n+e)n：顶点数  e：边数</p><p>使用<code>队列</code>数据结构</p><h4 id="深度优先遍历-DFS"><a href="#深度优先遍历-DFS" class="headerlink" title="深度优先遍历(DFS)"></a>深度优先遍历(DFS)</h4><p>树：类似<code>先序遍历</code>，一条直线走到底，走完再换另一个，按编号升序访问方向</p><p>时间复杂度：O(n+e)n：顶点数  e：边数</p><p>使用<code>栈</code>数据结构，是一个递归过程</p><p>图：</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402220846594.jpg" alt="图1" style="zoom:33%;"><p>广度优先：以2为先，21653748</p><p>深度优先：以3为先，34762158以2为先，21563478</p><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>连通图生成树：包含图中全部点，最少边，保持连通</p><p>最小生成树：带权值，边权值最小，<code>图形不唯一</code>，但最小代价唯一</p><h3 id="Prim算法-普里姆"><a href="#Prim算法-普里姆" class="headerlink" title="Prim算法(普里姆)"></a>Prim算法(普里姆)</h3><p>贪心算法</p><p>先选最小权值的边，再从以选中的顶点所附带的边中选择最小权值的边，以此类推，推出树图</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402220829529.jpg" alt="图2" style="zoom:33%;"><h3 id="Kruskal算法-克鲁斯卡尔"><a href="#Kruskal算法-克鲁斯卡尔" class="headerlink" title="Kruskal算法(克鲁斯卡尔)"></a>Kruskal算法(克鲁斯卡尔)</h3><p>贪心算法</p><p>每次选择一条权值最小的边，这条边两头连通（原本连通的就不选）</p><h2 id="排序-需要代码"><a href="#排序-需要代码" class="headerlink" title="排序(需要代码)"></a>排序(需要代码)</h2><h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><p>冒泡：把最大的或最小的冒到一边</p><p>每两个数字相互比较，按对应顺序排序，比较完一次，再和后面的一个数比较，以此类推</p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>类似打扑克牌时整理牌的顺序一样，从左往右整理</p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h3 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h3><p>只能在顺序存储，不能在链表，元素有序</p><h1 id="简答题备考"><a href="#简答题备考" class="headerlink" title="简答题备考"></a><center>简答题备考</center></h1><h2 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h2><p>机器语言：紧密依赖于计算机的硬件</p><p>高级语言：比较接近人们习惯使用的自然语言和数学语言</p><p>程序：一组计算机能识别和执行的指令</p><p>源程序：用高级语言编写的程序</p><p>常量：程序运行过程中不能改变的量</p><p>变量：程序运行过程中其值可以改变的量</p><p>变量名：以一个容易记忆的名字代表存储单元的地址</p><p>转义字符：将反斜杠 “\“ 后面的字符转换成另外的意义</p><p>字符串常量：一对双撇号括起来的字符序列</p><p>算术表达式：用算术运算符和括号将运算对象连接起来的、符合C语法规则的式子</p><p>数据结构：在程序中指定数据类型和数据的组织形式 </p><p>算法：即操作步骤</p><p>修饰符：用来丰富格式字符功能的附加字符</p><p>关系表达式：用关系运算符将两个表达式连接起来的式子</p><p>逻辑表达式：用逻辑运算符将两个表达式连接起来的式子</p><p>用选择机构来检查所指定的条件是否满足，并根据判断的结果决定执行哪种操作</p><p>循环结构就是用来处理需要重复处理的问题</p><p>数组：具有相同类型的变量，用连续空间存储起来</p><p>字符数组：用来存放字符数据的数组</p><p>函数就是用来完成一定的功能的</p><p>函数的声明称为函数原型</p><p>递归调用：在调用一个函数的过程中又出现直接或间接地调用函数本身</p><p>局部变量：在函数或复合语句中定义的变量，只在本函数或复合语句内范围内有效</p><p>全局变量：在函数之外定义的变量，从定义变量到本源程序文件结束有效，在范围内可以为本程序文件中所有函数共用</p><p>静态存储：在程序运行期间由系统在静态存储区分配存储空间的方式，在程序运行期间不释放</p><p>动态存储：在函数调用期间根据需要在动态存储分配存储空间的方式</p><p>寄存器变量(register)：一些变量频繁使用，将局部变量的值放在CPU中的寄存器，寄存器对于存取速度远高于内存的存取速度，这样可以提高执行效率</p><p>内部函数(静态函数)：用static声明的，函数作用只局限于所在文件，其他文件不能引用</p><p>外部函数：函数首部最左端添加extern，可供其他文件调用</p><p>函数的定义：对函数功能的确立，包括指定函数名、函数值类型、形参及其类型以及函数体等，它是一个完整的、独立的函数单位</p><p>函数的声明：好吧函数的名字、函数类型以及形参的类型、个数和顺序通知编译系统，以便在调用该函数时系统按此进行对照检查</p><p>变量的定义：定义变量时，要指明数据类型，编译系统要据此给变量分配存储空间，称为定义行声明</p><p>变量的声明：不必指定数据类型，数据类型在定义时指定了，只是为了引用的需要，称为引用性声明</p><p>将地址形象化地称为“指针”</p><p>指针变量：一个变量专门用来存放另一个变量的地址</p><p>结构体：用户自己建立由不同类型的数据组成的组合型的数据结构</p><p>结构体数组：一个结构体变量中可以存放一组有关联的数据</p><p>结构体指针：指向结构</p><p>枚举：将变量的值一一列举出来，变量的值只限于列举出来的值的范围内</p><p>程序文件：包括源程序(后缀为.c)、目标文件(后缀.obj)、可执行文件(后缀为.exe)文件等。这种文件是用来存放程序的，以便实现程序的功能</p><p>数据文件：文件内容不是程序，而是供程序运行时读写的数据，或共程序运行时读入内存的数据</p><p>文件分类：按数据的组织形式，数据文件可分为<code>ASCII文件</code>和<code>二进制文件</code></p><h2 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h2><p>数据：客观事物的符号表示，是所有能输入计算机中并被计算机程序处理的符号的总称</p><p>数据元素：是数据的基本单位，在计算机中通常作为一个整体进行考虑</p><p>数据项：组成数据元素的、有独立含义的、不可分割的最小单位</p><p>数据对象：是性质相同的数据元素的集合，是数据的一个子集</p><p>数据结构：相互之间存在一种或多种特定关系的数据元素的集合</p><p>算法：为了解决某类问题而规定的一个有限长的操作序列</p><p>算法特性：有穷性、确定性、可行性、输入、输出</p><p>算法基本标准：正确性、可读性、健壮性、高效性</p><p>线性表：由n个数据特性相同的元素构成的有限序列</p><p>&ensp;&ensp;&ensp;&ensp;如学生基本信息表，每个学生为一个数据元素，包括学号、姓名、性别、籍贯等数据项</p><p>节点：存储七本身的信息之外，还需存储一个指示七直接后继的信息，这两部分信息组成数据元素的存储映像</p><p>数据域：存储数据元素信息的域</p><p>指针域：存储直接后继存储位置的域</p><p>链表：n个节点链接成的表</p><p>栈：限定仅在表尾进行插入或删除操作的线性表</p><p>栈底：表头端</p><p>栈顶：表尾端</p><p>队列：一种先进先出的线性表</p><p>队尾：允许插入的一端</p><p>对头：允许删除的一端</p><p>栈和队列都有：顺序和链式存储</p><p>串也称为字符串，在 C 语言中是由数字、字母、下划线以及特殊字符组成的串字符，字符串需要用一对双引号括起来。在一个字符串中取一部分作为一个新字符串，这个新字符串叫子串，另一个叫做它的母串</p><p>树：n个节点的有限集</p><p>森林：n棵互不相交的树的集合</p><p>图(G)：由两个集合V和E组成，记为G &#x3D; (V,E)，V是顶点的有穷非空集合，E是V中顶点偶对的有穷集合，这些顶点偶对 称为 边</p><p>查找表：由同一个类型的数据元素构成的集合</p><p>关键字：数据元素中某个数据项的值，用它可以标识一个数据元素</p><p>&ensp;&ensp;&ensp;&ensp;主关键字：此关键字可以唯一地标识一个记录</p><p>&ensp;&ensp;&ensp;&ensp;次关键字：用以识别若干记录的关键字</p><p>查找：指根据给定的某个值，在查找表中确定一个关键字等于给定值的记录或数据元素，如果存在查找成功，不存在查找失败</p><p>查找分类：顺序查找、折半查找、分块查找</p><p>排序：按关键字的非递减或非递增顺序对一组记录重新进行排列的操作</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C语言程序和程序设计概述&quot;&gt;&lt;a href=&quot;#C语言程序和程序设计概述&quot; class=&quot;headerlink&quot; title=&quot;C语言程序和程序设计概述&quot;&gt;&lt;/a&gt;&lt;center&gt;C语言程序和程序设计概述&lt;/center&gt;&lt;/h1&gt;&lt;p&gt;程序：可以连续执行的一条条</summary>
      
    
    
    
    <category term="插本" scheme="http://example.com/categories/%E6%8F%92%E6%9C%AC/"/>
    
    <category term="计算机程序与基础" scheme="http://example.com/categories/%E6%8F%92%E6%9C%AC/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计算机程序与基础" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>25.网络编程</title>
    <link href="http://example.com/post/f1dbdc9f.html"/>
    <id>http://example.com/post/f1dbdc9f.html</id>
    <published>2023-12-30T05:12:09.000Z</published>
    <updated>2024-03-01T15:03:29.738Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识点一：什么是网络编程"><a href="#知识点一：什么是网络编程" class="headerlink" title="知识点一：什么是网络编程"></a><center>知识点一：什么是网络编程</center></h1><p>Java是Internet上语言，它从语言级别上提供了对网络编程支持，程序猿可以利用Java语言进行网络应用程序编写，Java提供大量网络库，可以实现不同网络连接【TCP&#x2F;UDP】，联网的底层实现已经被Java进行封装了，只需调用网络包中提供实现类方法就可以完成网络编程</p><p>网络编程就是提供互联网应用程序，互联网是什么？把分布在不同区域的计算机与专门外部设备进行通信相互链接在一起，提供一个强大网络关系，从而通过链接网络就可以方便计算机与计算机之间的信息传递，共享硬件，数据和软件信息</p><p>之所以计算机之间可以进行网络通信是因为提供网络连接【网线和wifi】</p><h1 id="知识点二：网络通信协议"><a href="#知识点二：网络通信协议" class="headerlink" title="知识点二：网络通信协议"></a><center>知识点二：网络通信协议</center></h1><p>网络通信协议就是联网设备之间可以进行更好交互，需要遵守一套通信规则</p><p>通讯协议有两套【一套是理论协议和一套是实际操作协议】</p><h2 id="1、OSI通信模型【网络7层协议】"><a href="#1、OSI通信模型【网络7层协议】" class="headerlink" title="1、OSI通信模型【网络7层协议】"></a><center>1、OSI通信模型【网络7层协议】</center></h2><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012250386.png" alt="OSI通信模型"></p><p>在7协议的基础至少之上进行网络协议修改，修改之后的协议更加适合现实生活中网络的实现【TCP&#x2F;IP通信模型】</p><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012250533.png" alt="层次"></p><p>在这个模型中 传输层和网络层是需要使用的，提供TCP&#x2F;IP编程可以完成网络通信操作</p><h1 id="知识点三：网络编程三要素"><a href="#知识点三：网络编程三要素" class="headerlink" title="知识点三：网络编程三要素"></a><center>知识点三：网络编程三要素</center></h1><p><strong>协议、IP地址、端口号</strong>，在这三个要素的前提下得到到两种网络编程模式【软件结构】-&gt; <strong>C&#x2F;S架构和B&#x2F;S架构</strong></p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012251097.png" alt="三要素" style="zoom:50%;"><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012252229.png" alt="B/S结构" style="zoom:50%;"><p>其实这两种框架开发时各有有点，但是无论是那种框架，都要离不开【“网络”】，需要提供网络编程，就可以架构通信操作了</p><h2 id="1、协议"><a href="#1、协议" class="headerlink" title="1、协议"></a><center>1、协议</center></h2><p>通信协议是计算必须遵守规则， 只有遵守规则才可以进行计算机与计算机之间通信，这就好比道路中行驶的汽车必须遵守交通规则，通讯协议也是一样的，通信协议中提供对数据的【传输格式、传输速率、传输步骤】等等都提供统一的规范，通讯双方必须遵守这个规范，最终完成数据的交换</p><h2 id="2、TCP协议"><a href="#2、TCP协议" class="headerlink" title="2、TCP协议"></a><center>2、TCP协议</center></h2><p>在 java.net 这个包中就提供了这种常见协议：</p><p>TCP：传输控制协议，TCP协议是<strong>面向连接</strong>的通信协议，即传输数据之前，在发送端和接收端需要建立起逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输</p><p>TCP协议的特点: <strong>面向连接、传输数据安全、传输速度低</strong></p><p>例如： 大宝发现了李四家里牛丢了</p><p>&ensp;&ensp;&ensp;&ensp;TCP协议： 大宝一定要找到李四，面对面的告诉他你们家牛丢了</p><p>TCP如何保证面向连接安全？</p><p>&ensp;&ensp;&ensp;&ensp;TCP在连接时会进行【<strong>三次握手</strong>】，TCP协议中，在发送数据的准备阶段，客户端与服务器之间进行三次交互，以保证可靠连接</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012253925.png" alt="TCP协议" style="zoom:50%;"><p>第一次握手： 客户端向服务器发送连接请求，等待服务器确认</p><p>第二次握手：服务器端接收客户端请求并向客户端回送一个响应，通知客户端收到了连接请求</p><p>第三次握手：客户端接收到服务器响应，再次向服务器端发送确认信息，确认连接</p><p>客户端与服务器之间就可以开始进行通信操作了</p><p>完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了，由于这种连接时面思连接的特性，所以TCP协议可以保证传输数据的安全，所以TCP通信协议被广泛的应用【HTTP协议（网页浏览）、文件上传、文件下载】等等</p><p>三次握手可以理解为打电话</p><p>&ensp;&ensp;&ensp;&ensp;第一次握手就相当于 —》 你拿起电话开始拨号</p><p>&ensp;&ensp;&ensp;&ensp;第二次握手就相当于 —》 对方拿起电话说“喂”</p><p>&ensp;&ensp;&ensp;&ensp;第三次握手就相当于 —》 听到“喂”就说明两端连同，开始通话</p><h2 id="3、UDP协议"><a href="#3、UDP协议" class="headerlink" title="3、UDP协议"></a><center>3、UDP协议</center></h2><p>在 java.net 这个包中就提供了这种常见协议：</p><p>UDP被称之为 【数据报（文）协议】，UDP协议是一个面向无连接的协议，传输数据时候，不需要建立连接，不管对方服务器是否启动，【直接将数据，数据源和目的地都封装到数据包，直接发送】，每个数据包的大小被限制在64KB，因为连接不可靠而且是面向无连接，所以它传输速度快，但是容易丢包【数据】，日日常应用中：视频、游戏等等</p><p>例如： 大宝发现了李四家里牛丢了</p><p>UDP协议： 大宝在村里的广播站广播以下李四你家牛丢了，效率快</p><h2 id="4、IP地址"><a href="#4、IP地址" class="headerlink" title="4、IP地址"></a><center>4、IP地址</center></h2><p>IP地址：是互联网中协议地址，俗称IP，<strong>IP地址用来给一个网络中的计算机设备做唯一的编号</strong></p><p>IP地址分类</p><p>&ensp;&ensp;&ensp;&ensp;IPv4：是一个32位的二进制数，通常被划分4个字节，表示形式D.D.D.D 形式表示</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;例如： 192.168.10.27 这就是IP地址，其中的每一位即 D 范围是一个从0~255结束范围 ，最多表示42亿个IP地址，就算这样全世界的IPv4地址已经没有了</p><p>&ensp;&ensp;&ensp;&ensp;IPv6：中国主导的，随着全世界互联网网络发展IPv4已经不能满足所有需求，但是网络资源地址还是需要的，使用IPv6来缓解IPv4的缺失，IPv6是一个128位的二进制数，每16个字节划分一组，8组16进制，表示形成 F.F.F.F.F.F.F.F</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;例如： fdb2:2c26:f4e4:0:3421:943d:8040:8eef</p><p><strong>windows中CMD中 输入 ipconfig可以查看本机的IP地址</strong></p><p>所有的人电脑其实在出厂时都有自己的一个IP地址，这个IP地址是供给计算机内容进行通信使用，称之为“环形网络”–》这个IP地址是127.0.0.1 –》 称之为 localhost</p><h2 id="5、端口号"><a href="#5、端口号" class="headerlink" title="5、端口号"></a><center>5、端口号</center></h2><p>网络的通信，本质上是有两个进程（应用程序）的通信，每台计算机都有很多的进程，那么在网络通信时，如何区分是哪个进程呢？</p><p>如果说“IP地址”可以唯一标识网络中的设备，那么“端口号”就可以唯一标识设备中进程（应用程序)了</p><p>端口号：用两个字节标识的整数，它的取值范围是0<del>65535。其中，**0</del>1023之间端口号用于一些知名的网络服务器与系统应用<strong>，普通的应用程序需啊哟使用1024以上的端口号。</strong>如果端口号被另外一个服务器或应用程序所占用，会导致当前程序启动失败**</p><p>开中常见端口号 ： MySQL ： 3306 Oracle 1521 或 1520 Tomcat： 8080</p><p>利用这个三个组合 <strong>协议 + IP地址 + 端口号</strong>就可以提供网络中进程（应用程序）</p><h1 id="知识点四：InteAddress类"><a href="#知识点四：InteAddress类" class="headerlink" title="知识点四：InteAddress类"></a><center>知识点四：InteAddress类</center></h1><p>此类表示互联网协议 (IP) 地址，能够通过InetAddress这个类获取到IP地址，InteAddress也可以理解为一个IP地址的在Java代码中抽象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterAddressDemo</span> 。</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------创建局域网IP地址对象-------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//1.使用本机的IP地址创建对象</span></span><br><span class="line">        <span class="comment">//提供一个编译时异常Unhandled exception: java.net.UnknownHostException【无法获取主机（IP地址）】</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">localHost</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">        <span class="comment">//获取封装在对象中IP地址</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ip地址：&quot;</span>+localHost.getHostAddress());</span><br><span class="line">        <span class="comment">//获取封装在对象中主机名</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主机名：&quot;</span>+localHost.getHostName());</span><br><span class="line">        <span class="comment">//通过赋值IP地址来创建IP地址对象 --》这个参数也可以赋值为 localhost(主机) ---》赋值网络域名</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">byName</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;10.211.55.3&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------创建外网IP地址对象-------------------------------&quot;</span>);</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">byName1</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;百度IP地址：&quot;</span>+byName1.getHostAddress());</span><br><span class="line">        System.out.println(<span class="string">&quot;百度主机名：&quot;</span>+byName1.getHostName());</span><br><span class="line">        <span class="comment">//判断连接访问 ---》 ping命令</span></span><br><span class="line">        System.out.println(<span class="string">&quot;2秒内是否可以访问到？&quot;</span>+ byName1.isReachable(<span class="number">2000</span>));    <span class="comment">// ping www.baidu.com</span></span><br><span class="line">        <span class="comment">//获取IP地址对象中所有的信息</span></span><br><span class="line">        InetAddress[] allByName = InetAddress.getAllByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(InetAddress ip : allByName)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(ip);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点五：TCP协议编程"><a href="#知识点五：TCP协议编程" class="headerlink" title="知识点五：TCP协议编程"></a><center>知识点五：TCP协议编程</center></h1><p>Java中TCP协议编程并不需要我们从头开始写，Java已经在net包中提供操作，专门提供两个类来完成TCP操作</p><p><strong>Socket</strong>【客户端】：此类实现客户端套接字（也可以就叫“套接字”）。套接字是两台机器间通信的端点</p><p><strong>ServerSocket</strong>【服务器】：此类实现服务器套接字。服务器套接字等待请求通过网络传入。它基于该请求执行某些操作，然后可能向请求者返回结果</p><p>因为TCP连接时面向连接的，也就是属于“长连接”，所以需要进行关闭操作，<strong>客户端是可以与服务器进行通信使用的是字节流</strong></p><p>案例1</p><p>&ensp;&ensp;&ensp;&ensp;需求：客户端向服务器发送请求，并传递数据发送【服务你好】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.TCP.V1;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="comment">//客户端程序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建客户端对象提供IP地址和端口号</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            第一个参数：字符串类型IP地址</span></span><br><span class="line"><span class="comment">            第二个参数：通信端口号</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;10.211.55.3&quot;</span>,<span class="number">8888</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端信息：&quot;</span>+client);</span><br><span class="line">        <span class="comment">//2.获取网络字节输出流对象【建立一条客户端通向服务器的通道】</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> client.getOutputStream();</span><br><span class="line">        <span class="comment">//利用字节输入流的对象向服务器发送数据即可</span></span><br><span class="line">        outputStream.write(<span class="string">&quot;服务器你好，我是客户端，来自远方问候.....嘿嘿(*^▽^*)！！！&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">//强烈推荐在使用网路流传输数据时必须要写刷新</span></span><br><span class="line">        outputStream.flush();</span><br><span class="line">        <span class="comment">//3.关闭客户端</span></span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">package</span> com.qfedu.TCP.V1;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建服务器端对象，参数只有一个需要和客户端一样的端口号</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器在等待客户端的链接.......&quot;</span>);</span><br><span class="line">        <span class="comment">//2.通过服务器端对象调用 accept 方法获取到连接服务器的客户端对象进行操作</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">sClient</span> <span class="operator">=</span> server.accept();    <span class="comment">//返回的是客户端的信息(端口号等信息)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;恭喜!来自客户端&quot;</span>+sClient+<span class="string">&quot;已经链接上了.......&quot;</span>);</span><br><span class="line">        <span class="comment">//3.创建网络字节输入流对象，获取传输的数据【建立客户端与服务器连接通道】</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> sClient.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> inputStream.read(bs);</span><br><span class="line">        <span class="comment">//4.打印客户端的信息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;来自客户端的信息是：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(bs,<span class="number">0</span>,len));</span><br><span class="line">        <span class="comment">//5.关闭服务器</span></span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>案例2</p><p>&ensp;&ensp;&ensp;&ensp;需求：此时客户端与服务器之间是建立了连接发送了信息，客户端服务器发送了信息，服务器要给客户端予以响应</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.TCP.V2;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="comment">//客户端程序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建客户端对象提供IP地址和端口号</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            第一个参数是字符串类型IP地址</span></span><br><span class="line"><span class="comment">            第二个参数通信端口号</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;10.211.55.3&quot;</span>,<span class="number">8888</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端信息：&quot;</span>+client);</span><br><span class="line">        <span class="comment">//2.获取网络字节输出流对象【建立一条客户端通向服务器的通道】</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> client.getOutputStream();</span><br><span class="line">        <span class="comment">//利用字节输入流的对象向服务器发送数据即可</span></span><br><span class="line">        outputStream.write(<span class="string">&quot;服务器你好，我是客户端，来自远方问候.....嘿嘿(*^▽^*)！！！&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">//强烈推荐在使用网路流传输数据时必须要写刷新</span></span><br><span class="line">        outputStream.flush();</span><br><span class="line">        <span class="comment">//3.接收服务器的反馈信息[获取网络字节输入流对象]</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> client.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> inputStream.read(bs);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前来之服务器的反馈信息：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(bs,<span class="number">0</span>,len));</span><br><span class="line">        <span class="comment">//4.关闭客户端</span></span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">package</span> com.qfedu.TCP.V2;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建服务器端对象，参数只有一个需要和客户端一样的端口号</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器在等待客户端的链接.......&quot;</span>);</span><br><span class="line">        <span class="comment">//2.通过服务器端对象调用 accept 方法获取到连接服务器的客户端对象进行操作</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">sClient</span> <span class="operator">=</span> server.accept();</span><br><span class="line">        System.out.println(<span class="string">&quot;恭喜!来自客户端&quot;</span>+sClient+<span class="string">&quot;已经链接上了.......&quot;</span>);</span><br><span class="line">        <span class="comment">//3.创建网络字节输入流对象，获取传输的数据【建立客户端与服务器连接通道】</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> sClient.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> inputStream.read(bs);</span><br><span class="line">        <span class="comment">//4.打印客户端的信息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;来之客户端的信息是：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(bs,<span class="number">0</span>,len));</span><br><span class="line">        <span class="comment">//5.服务器向客户予以响应</span></span><br><span class="line">        <span class="comment">//5.1提供网络字节输出流对象</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> sClient.getOutputStream();</span><br><span class="line">        outputStream.write(<span class="string">&quot;已收到信息，感谢访问(#^.^#)！&quot;</span>.getBytes());</span><br><span class="line">        outputStream.flush();</span><br><span class="line">        <span class="comment">//6.关闭服务器</span></span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>案例3</p><p>&ensp;&ensp;&ensp;&ensp;需求: 提供客户端与服务器之间聊天程序， 当某一个方输入 886 停止聊天</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.TCP.V3;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="comment">//提供一个客户端程序，完成客户端接收与发送信息给服务器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供客户端对象</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;10.211.55.3&quot;</span>,<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//2.提供网络字节输入输出流对象</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">//3.提供Scanner获取控制台信息</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端向服务器说：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> input.next();</span><br><span class="line">            outputStream.write(content.getBytes());</span><br><span class="line">            outputStream.flush();</span><br><span class="line">            <span class="comment">//做了一个约定，如果哪一方输入886 就关闭聊天</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;886&quot;</span>.equals(content))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//提供数组存数据操作</span></span><br><span class="line">            <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> inputStream.read(bs);</span><br><span class="line">            System.out.println(<span class="string">&quot;来之服务器的信息：&quot;</span>+ <span class="keyword">new</span> <span class="title class_">String</span>(bs,<span class="number">0</span>,len));</span><br><span class="line">        &#125; </span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">package</span> com.qfedu.TCP.V3;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span></span><br><span class="line">Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建服务器端对象</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//2.利用serverSocket对象中accept方法获取客户端连接</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">accept</span> <span class="operator">=</span> server.accept();</span><br><span class="line">        <span class="comment">//3.提供网络字节输入输出流对象完成信息发送</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> accept.getInputStream();</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> accept.getOutputStream();</span><br><span class="line">        <span class="comment">//4.提供控制台获取数据</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//4.1接收客户端向服务器发送的数据</span></span><br><span class="line">            <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> inputStream.read(bs);</span><br><span class="line">            <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bs,<span class="number">0</span>,len);</span><br><span class="line">            System.out.println(<span class="string">&quot;来之客户端的信息：&quot;</span>+content);</span><br><span class="line">            <span class="comment">//判断客户单输入的输入的数据是什么</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;886&quot;</span>.equals(content))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//4.2服务器向客户端发送数据</span></span><br><span class="line">            System.out.println(<span class="string">&quot;服务器端向客户端说：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> input.next();</span><br><span class="line">            outputStream.write(str.getBytes());</span><br><span class="line">            outputStream.flush();</span><br><span class="line">        &#125; </span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1、使用TCP模拟Tomcat服务器"><a href="#1、使用TCP模拟Tomcat服务器" class="headerlink" title="1、使用TCP模拟Tomcat服务器"></a><center>1、使用TCP模拟Tomcat服务器</center></h2><p>需求：利用浏览器进行网页访问，访问服务器中HTML页面，展示服务器端HTML页面在浏览器中</p><p>需要在项目中提供web目录并在web目录下提供html页面</p><p>在浏览器中访问地址时：</p><p>&ensp;&ensp;&ensp;&ensp;IP地址:服务器端口号&#x2F;访问资源路径 –》 相当于 –》127.0.0.1:9999&#x2F;web&#x2F;regist.html</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="comment">//利用ServerSocket模拟Tomcat服务器提供网页访问服务器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TomcatServer</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.通过读取浏览器页面请求信息，获取浏览器需要访问的路径</span></span><br><span class="line">        <span class="comment">//提供ServerSocket服务器端对象</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//调用accept方法获取连接的客户端</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> server.accept();</span><br><span class="line">        <span class="comment">//通过返回socket对象获取网络字节输入流对象【建立连接通道】</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="comment">//将字节流转换为字符流【缓冲的】--》读取到字符串了</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream));</span><br><span class="line">        <span class="comment">//利用字符缓冲输入流读取文件访问路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">        System.out.println(path);</span><br><span class="line">        <span class="comment">//利用空格将path路径进行分隔，获取到访问资源路径</span></span><br><span class="line">        String[] s = path.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="comment">//通过下标获取出资源路径，将路径最前面的/去掉</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> s[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;浏览器访问服务器的资源路径：&quot;</span>+realPath);</span><br><span class="line">        <span class="comment">//利用相对路径读取服务器中相对路径中资源反馈给浏览器</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(realPath);</span><br><span class="line">        <span class="comment">//在通过accept方法获取Socket对象获取网络字节输出流【将流中数据反馈给浏览器】</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">//开始读写</span></span><br><span class="line">        <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8192</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="comment">//响应页面的时候需要将服务器返回给浏览器的必要信息</span></span><br><span class="line">        outputStream.write(<span class="string">&quot;HTTP/1.1 200OK\r\n&quot;</span>.getBytes());</span><br><span class="line">        outputStream.write(<span class="string">&quot;ContentType:text/html\r\n&quot;</span>.getBytes());</span><br><span class="line">        outputStream.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(bs))!=-<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            outputStream.write(bs,<span class="number">0</span>,len);</span><br><span class="line">        &#125; </span><br><span class="line">        outputStream.flush();</span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">        fis.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点六：UDP协议编程（了解）"><a href="#知识点六：UDP协议编程（了解）" class="headerlink" title="知识点六：UDP协议编程（了解）"></a><center>知识点六：UDP协议编程（了解）</center></h1><p>Java中也提供UDP编程操作提供两个必要类：</p><p>&ensp;&ensp;&ensp;&ensp;<strong>DatagramSocket【即是客户端也是服务器】 和DatagramPacket【UDP需要的数据包】</strong></p><p>UDP是无责任的发送模式类似于【广播电台】，UDP发送数据是不保证包安全，UDP的客户端与服务器是同一个类，发送数据时候需要使用DatagramPacket进行数据封装，包的限制64K</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.UDP;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketException;</span><br><span class="line"><span class="comment">//UDP发送数据类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Send</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建UDP对象</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">sender</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">        <span class="comment">//2.提供信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;今天天气好晴朗，下班要下雨了，赶快跑路....&quot;</span>;</span><br><span class="line">        <span class="comment">//3.提供数据包将数据封装到包中</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(</span><br><span class="line">            content.getBytes(),            <span class="comment">//提供数据字节数组</span></span><br><span class="line">            content.getBytes().length,    <span class="comment">//字节数组的长度</span></span><br><span class="line">            InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="comment">//设置发送IP地址</span></span><br><span class="line">            <span class="number">9999</span>    <span class="comment">//发送端口号</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//发送信息</span></span><br><span class="line">        sender.send(packet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketException;</span><br><span class="line"><span class="comment">//UDP接收类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Receiver</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建UDP对象并指定接收数据端口号</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">receiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//2.需要提供byte类型数据接收存数据</span></span><br><span class="line">        <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//3.创建数据包对象</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bs,bs.length);</span><br><span class="line">        <span class="comment">//接收数据存储在包对象中</span></span><br><span class="line">        receiver.receive(packet);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        拆包:</span></span><br><span class="line"><span class="comment">            getData() 获取包中字节数组</span></span><br><span class="line"><span class="comment">            getLength() 获取包中字节数组的长度</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(packet.getData(),<span class="number">0</span>,packet.getLength());</span><br><span class="line">        System.out.println(content);</span><br><span class="line">        receiver.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;知识点一：什么是网络编程&quot;&gt;&lt;a href=&quot;#知识点一：什么是网络编程&quot; class=&quot;headerlink&quot; title=&quot;知识点一：什么是网络编程&quot;&gt;&lt;/a&gt;&lt;center&gt;知识点一：什么是网络编程&lt;/center&gt;&lt;/h1&gt;&lt;p&gt;Java是Internet</summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>26.反射</title>
    <link href="http://example.com/post/5883a4af.html"/>
    <id>http://example.com/post/5883a4af.html</id>
    <published>2023-12-30T05:11:56.000Z</published>
    <updated>2024-03-01T15:13:58.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识点一：类的加载"><a href="#知识点一：类的加载" class="headerlink" title="知识点一：类的加载"></a><center>知识点一：类的加载</center></h1><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012304354.png" alt="类的加载过程" style="zoom: 50%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qf.Demo03;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作者：星仔</span></span><br><span class="line"><span class="comment"> * 描述：永无Bug</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反射：在程序运行期获取的相关信息（对象、构造、方法、属性..）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 以前创建对象：通过new关键字去创建</span></span><br><span class="line"><span class="comment">     *      User user = new User();</span></span><br><span class="line"><span class="comment">     * 如果学习了反射，那么可以在代码运行期间创建类的对象（String）</span></span><br><span class="line"><span class="comment">     * 类的对象：通过new关键字创建的对象是类的对象（可以创建多个）</span></span><br><span class="line"><span class="comment">     * 类对象：在类加载的时候会产生一个类对象（包含类的所有的信息：属性、方法、构造方法、父类、接口、包名）（只会有一个）</span></span><br><span class="line"><span class="comment">     * 所有类的类对象的类型是Class类型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 类加载的时机；</span></span><br><span class="line"><span class="comment">     *      1.创建对象</span></span><br><span class="line"><span class="comment">     *      2.创建子类对象</span></span><br><span class="line"><span class="comment">     *      3.调用类中的静态方法和属性</span></span><br><span class="line"><span class="comment">     *      4.通过Class.forName(&quot;&quot;);  主动触发类加载</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在JVM中类的加载是有细分操作，当程序启动时候说那个到某个类，如果该类被加载到内存中，则JVM会通过三个步骤进行类的初始化操作【加载、连接和初始化】</p><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012304757.png" alt="初始化"></p><h1 id="知识点二：什么是Class对象？"><a href="#知识点二：什么是Class对象？" class="headerlink" title="知识点二：什么是Class对象？"></a><center>知识点二：什么是Class对象？</center></h1><p>PS：在Java中提供一个类这个类叫做Class，用于存储类的字节码文件对象【存储自定义类中描述信息】</p><p>例如：Java中需要创建某个类的对象</p><p>做法： Student stu &#x3D; new Student(); —》通过Student类来创建stu这个对象，stu对象是Student类的实例，在创建过程中隐藏了一些内部实现的细节【类的加载】，就可以直接在代码中使用stu这个对象触发Student类中的属性和方法了</p><p>&ensp;&ensp;&ensp;&ensp;Java是一门面向对象的语言，面向对象核心【世间万物皆对象】，所有东西都以对象角度为出发来进行思考，既然是这样那么就可以看待提供stu这个实例的类也是一个对象，那么Java就提供了一个可以描述自定义类的类Class【即描述类的类】，在整个类的加载过程中，反复提到了一点就是在类的字节文件【.class文件】加载到内存中时候，会生成一个【Class类的对象】，整个对象存中存储的就是类中所描述的信息，所以外界就可以提供Student stu &#x3D; new Student(); —》通过Student类来创建stu这个对象</p><p>&ensp;&ensp;&ensp;&ensp;但是除了这种创建方式之外，因为JVM中是存在Class类对象的，所以Java就提供了另外一种方式，可以直接通过Class类的对象加载出来对应类的对象操作，这个操作就叫做“【反射reflect】”</p><p>正常创建对象 —》 Student stu &#x3D; new Student()；</p><p>但是在JVM中先得到Student类的.class字节码文件，通过字节码文件创建出Student这类的对象</p><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012305610.png" alt="解说"></p><h1 id="知识点三：获取Class对象"><a href="#知识点三：获取Class对象" class="headerlink" title="知识点三：获取Class对象"></a><center>知识点三：获取Class对象</center></h1><p>如何获取Class对象,一共有三种方式获取类对象</p><p>&ensp;&ensp;&ensp;&ensp;1、通过对象的getClass方法</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;应用场景：必须有类的对象</p><p>&ensp;&ensp;&ensp;&ensp;2、通过类的class属性</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;应用场景：一般多用于方法传参</p><p>&ensp;&ensp;&ensp;&ensp;3、通过Class类的forName方法</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;应用场景：一般在运行期获取类对象(使用较多)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfeud.JDBC2.reflect;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassTest</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//通过Class类的对象获取Student类的对象</span></span><br><span class="line">        <span class="comment">//1.正常创建Student类的对象操作</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;stu就是Student类的对象&quot;</span>);</span><br><span class="line">        <span class="comment">//通过反射获取到Student类的class对象并创建Student类的对象</span></span><br><span class="line">        <span class="comment">//1.通过Class类中静态方法，forName获取Student类的对象【Class对象】</span></span><br><span class="line">        <span class="comment">//参数需要是一个类的全限定名称【包名+类名】</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">aClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.qfeud.JDBC2.reflect.Student&quot;</span>);</span><br><span class="line">        <span class="comment">//此时aClass对象就代表着Student类的【Class对象】</span></span><br><span class="line">        <span class="comment">//Class对象存储的就是Student类中提供描述信息，所以可以得到 Student类的对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot;通过反射得到o对象是Student类的对象吗？&quot;</span>+(o <span class="keyword">instanceof</span> Student));</span><br><span class="line">        <span class="comment">//2.Java中每个类都有一个静态方法，Class类是描述类的类，那么所有类都是Class的实例(即Class对象)</span></span><br><span class="line">        <span class="comment">// Java中每个类都了一调用class这个静态方法获取到Class类的对象</span></span><br><span class="line">        Class&lt;Student&gt; studentClass = Student.class;    <span class="comment">//Class对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> studentClass.newInstance();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            3.利用了Object类中提供getClass方法获取到Class对象【强烈不推荐】</span></span><br><span class="line"><span class="comment">            PS：这个操作需要创建类的对象，并通过对象调用从Object类中继承而来的方法进行获取</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">aClass1</span> <span class="operator">=</span> stu1.getClass();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> aClass1.newInstance();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Class类中提供方法有两个比较常用</span></span><br><span class="line"><span class="comment">            newInstance() 这个方法是可以通过Class对象创建出与之相关联的类的对象【调用时无参方法】</span></span><br><span class="line"><span class="comment">            getName()     这个方法可以获取到类的全限定名称 ---&gt; 包名+类名</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.out.println(aClass1.getName());</span><br><span class="line">        System.out.println(stu);</span><br><span class="line">        <span class="comment">//强烈推荐第一种方式来获取Class对象，它不收到.java源文件的影响</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java中有九大内置Class对象【他们是JVM预先加载好的Class实例】 –》 【byte、short、int、long、float、double、char、boolean、void】其中八中基本数据类型对应包装类中存在一个静态属性Type，这个Type属性就可以获取到基本数据类型所对应Class对象</p><p>当执行 Integer.Type 等价于 int.class</p><p>除此之外Class对象还支持数组，得到数组的Class对象只能通过 数据类型[].class 或 数据对象.getClass()</p><h1 id="知识点四：反射操作"><a href="#知识点四：反射操作" class="headerlink" title="知识点四：反射操作"></a><center>知识点四：反射操作</center></h1><p>反射其实可以帮组我们做很多的操作，通过分装性将属性和方法进行私有化操作，但是私有化的属性和方法之后，外界就无法获取到属性和方法，如果通过反射的形式来获取类属性和方法可以无视权限修饰符，在返回面前是没有权限修饰符可言，<strong>可以利用反射中操作形成【代理模式】，可以通过【代理模式】动态向类中添加方法【在不改变原码的前提下添加类中方法】—》spring框架（IOC&#x2F;AOP）</strong>，反射可以作为资源文件加载操作方式</p><h2 id="1、Class对象的常用方法"><a href="#1、Class对象的常用方法" class="headerlink" title="1、Class对象的常用方法"></a><center>1、Class对象的常用方法</center></h2><ul><li>c.getSimpleName() 获取类名</li><li>c.getName() 获取类的全限定名</li><li>c.getSuperclass(); 获取父类的类对象</li><li>c.getInterfaces(); 获取父接口的类对象，返回的是一个数组</li><li>newInstance(); 通过类对象创建的类的对象</li></ul><p>调用newInstance方法需要注意：</p><ul><li>1、这个了类必须有一个无参构造方法 InstantiationException</li><li>2、这个类的构造方法必须是public修饰 IllegalAccessException</li></ul><p>提供演示操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个是一个类的 ---&gt; 提供Student类中一些方法属性操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> age,String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Student</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个没有参数的方法&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span> a)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个参数的方法&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span> a ,String b)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是多个参数的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">package</span> com.qfeud.JDBC2.reflect;</span><br><span class="line"><span class="keyword">import</span> jdk.nashorn.internal.ir.CallNode;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//利用反射来处理这个类的操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1. 获取到Student类的class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">aClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.qfeud.JDBC2.reflect.Student&quot;</span>);</span><br><span class="line">        <span class="comment">//2.通过反射获取到类中所提供构造方法【Constructor】</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        相当于通过反射操作获取到Constructor构造方法对象，在通过这个对象创建类的对象</span></span><br><span class="line"><span class="comment">        这个方法可以获取到class对象中对应类的构造方法对象,参数是可变参数</span></span><br><span class="line"><span class="comment">        【这个参数如果不传递（不赋值得到就是无参构造方法）、这个参数进行传递(赋值操作，根据赋值个数决定获取对应构造方法)】</span></span><br><span class="line"><span class="comment">        getConstructor(Class&lt;?&gt;... parameterTypes)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//获取到的就是constructor对象【就是Student类中无参构造方法的对象】</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> aClass.getConstructor();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            这个方法是使用constructor构造方法对象调用newInstance方法</span></span><br><span class="line"><span class="comment">            操作就相当于间接的调用对应构造方法得到这个class对象中存储类的对应对象</span></span><br><span class="line"><span class="comment">            newInstance(Object ... initargs) 方法中使用也是可变参数</span></span><br><span class="line"><span class="comment">            所以这个方法参数的传递时根据getConstructor这个方法的参数决定的，如果getConstructor方法没有设置参数</span></span><br><span class="line"><span class="comment">            newInstance这个方法也要没有参数 --》触发的就是无参构造方法</span></span><br><span class="line"><span class="comment">            如果如果getConstructor方法设置参数调用 newInstance这个方法也要给与参数，就是对构造方法参数的赋值</span></span><br><span class="line"><span class="comment">            PS：之前演示Class这个操作的时候，提供newInstance方法调用，并没有获取Constructor对象</span></span><br><span class="line"><span class="comment">            这样操作也是可以的，但是只能调用类中提供无参构造方法，无法选择有参构造方法</span></span><br><span class="line"><span class="comment">            这个方式调用构造方法必须是公有的</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> constructor.newInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot;此时o这个对象得到是Student类的对象吗?&quot;</span>+(o <span class="keyword">instanceof</span> Student));</span><br><span class="line">        <span class="comment">//通过上面方式获取有参构造方法的操作 ---》 方法参数传递就是传递方法参数的 class对象</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            获取有参构造方法的对象必须传递方法参数class对象到getConstructor这个方法中</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor1</span> <span class="operator">=</span> aClass.getConstructor(<span class="type">int</span>.class,String.class);</span><br><span class="line">        <span class="comment">//对构造方法中参数进行赋值操作了</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> constructor1.newInstance(<span class="number">18</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="comment">//得到这个返回值类型时Object类型，所以得到操作是不能直接使用子类数据的</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> (Student)o1;</span><br><span class="line">        System.out.println(<span class="string">&quot;stu对象中age属性的值是：&quot;</span>+stu.age);</span><br><span class="line">        <span class="comment">//反射操作---》在反射面前是没有任何权限修饰符可言 ---》 利用反射操作获取到私有构造方法对象</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            获取到非public修饰的构造方法、属性或方法怎么办？</span></span><br><span class="line"><span class="comment">            在Class这个类中提供带有 Declared 单词的方法就是 ---》 翻译为暴力反射[无视权限修饰符]</span></span><br><span class="line"><span class="comment">            getDeclaredConstructor 这个方法的使用和getConstructor方法是一样的</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor2</span> <span class="operator">=</span> aClass.getDeclaredConstructor(String.class);</span><br><span class="line">        <span class="comment">//private权限是一个特殊权限，因为在权限修饰符中代表最低权限，为了防止外界恶意进行暴力反射</span></span><br><span class="line">        <span class="comment">//反射获取到操作对象之后，需要再次做一个操作，开启访问权限</span></span><br><span class="line">        <span class="comment">//setAccessible这个是开启权限的方法，参数是boolean类型，如果为true就开启权限，false就是不开启</span></span><br><span class="line">        constructor2.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> constructor2.newInstance(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu2</span> <span class="operator">=</span> (Student)o2;</span><br><span class="line">        System.out.println(<span class="string">&quot;stu对象中name属性的值是：&quot;</span>+stu2.getName());</span><br><span class="line">        <span class="comment">//类中通过反射访问类中属性</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            通过两个反射方法获取 getField() --&gt; 针对的public修饰的属性</span></span><br><span class="line"><span class="comment">                               DeclaredField() ---&gt; 针对非public(private)修饰的属性</span></span><br><span class="line"><span class="comment">            通过属性对象调用setAccessible(true)开启权限配合使用 ---》 针对private使用</span></span><br><span class="line"><span class="comment">            通过反射方法可以得到一个 Field对象 ---》这个对象可以操作类中属性</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">age</span> <span class="operator">=</span> aClass.getField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        <span class="comment">//获取这个属性值如何操作？</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            只需要使用Field类中提供 get方法即可以获取到 属性值，但是get方法是有参数</span></span><br><span class="line"><span class="comment">            这个参数就是通过反射创建的对象即通过newInstance创建出来的对象</span></span><br><span class="line"><span class="comment">            PS:获取的是静态变量 get方法参数就是null值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o3</span> <span class="operator">=</span> age.get(stu);</span><br><span class="line">        System.out.println(<span class="string">&quot;stu这个对象中age属性的值是：&quot;</span>+o3);</span><br><span class="line">        <span class="comment">//对类中提供属性进行赋值操作？</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        只需要使用Field类中提供 set方法即可以对属性进行赋值</span></span><br><span class="line"><span class="comment">        这个方法有两个参数</span></span><br><span class="line"><span class="comment">            第一个参数:一共有两种赋值方式，原则是根据获取的数据类型决定【成员变量还是静态变量】</span></span><br><span class="line"><span class="comment">            如果是成员变量 ---》 这个参数就是通过反射创建的对象即通过newInstance创建出来的对象</span></span><br><span class="line"><span class="comment">            如果是静态变量 ---》 null ---》 对应的是Static修饰符</span></span><br><span class="line"><span class="comment">            第二个参数对属性赋值的具体数据</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        age.set(stu,<span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;stu对象中age属性修改之后的数据是：&quot;</span>+age.get(stu));</span><br><span class="line">        <span class="comment">//【重点记忆】 ---》 获取类中方法操作【通过反射】</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            通过两个反射方法获取</span></span><br><span class="line"><span class="comment">                getMethod() --&gt; 针对的public修饰的方法</span></span><br><span class="line"><span class="comment">                DeclaredMethod() ---&gt; 针对非public修饰的方法</span></span><br><span class="line"><span class="comment">            通过属性对象调用</span></span><br><span class="line"><span class="comment">                setAccessible(true)开启权限配合使用 --&gt; 针对private</span></span><br><span class="line"><span class="comment">            通过反射获取方法的操作是需要两个参数的</span></span><br><span class="line"><span class="comment">                第一个参数 : 方法的名字</span></span><br><span class="line"><span class="comment">                第二个参数： 是一个可变参数，需要传递方法中参数的数据类型---》是class对象</span></span><br><span class="line"><span class="comment">                不传递参数赋值就是无参方法 传递参数赋值就是有参方法</span></span><br><span class="line"><span class="comment">                getMethod(String name, Class&lt;?&gt;...parameterTypes)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">show</span> <span class="operator">=</span> aClass.getMethod(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">        <span class="comment">//得到是一个方法对象要执行方法</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            需要调用 invoke这个方法，这个方法也是有两个参数</span></span><br><span class="line"><span class="comment">            第一个参数:</span></span><br><span class="line"><span class="comment">                一共有两种赋值方式，原则是根据获取的方法类型决定【成员方法还是静态方法】</span></span><br><span class="line"><span class="comment">                    如果是成员变量 ---》 这个参数就是通过反射创建的对象即通过newInstance创建出来的对象</span></span><br><span class="line"><span class="comment">                    如果是静态变量 ---》 null ---》 对应的是Static修饰符</span></span><br><span class="line"><span class="comment">            第二个参数:</span></span><br><span class="line"><span class="comment">                需要和getMethod方法相配合 ，如果调用无参方法，这个可变参数就不传递数据</span></span><br><span class="line"><span class="comment">                如果调用有参反方，这个可变参数就需要进行赋值操作</span></span><br><span class="line"><span class="comment">                invoke(Object obj, Object... args)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        show.invoke(stu);</span><br><span class="line">        <span class="comment">//获取一个show方法对象，如果方法有参数，需要将方法参数类型Class对象传递到参数中</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">show1</span> <span class="operator">=</span> aClass.getMethod(<span class="string">&quot;show&quot;</span>, <span class="type">int</span>.class,</span><br><span class="line"><span class="type">int</span>.class);</span><br><span class="line">        show1.invoke(stu,<span class="number">1</span>,<span class="number">1</span>);    <span class="comment">//对应数据类型赋值即可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>可以利用反射操作在没有【.java】文件的前提之下可以操作类【构造方法、属性和方法】</p><p>针对与使用public修饰构造方法、成员或静态属性和成员或静态方法 —》提供方法是</p><p>&ensp;&ensp;&ensp;&ensp;getConstructor() —-》 获取构造方法  —》配套使用方法 —》 newInstance()</p><p>&ensp;&ensp;&ensp;&ensp;getField() —》 获取属性的 —》配套使用方法—》 get获取 、 set赋值【这个方法中如果是成员属性需要传递反射创建对象，如果是静态属性传递null】</p><p>&ensp;&ensp;&ensp;&ensp;getMethod —》 获取方法的 【重点记忆】—》 配套使用方法 –》 invoke() 【这个方法中如果是成员方法需要传递反射创建对象，如果是静态方法传递null】</p><p>如果遇到非public修饰的，可以使用带有Declared单词的方法记性获取，并且如果修饰符是private修饰那么就需要配合使用setAccessible(true)开启权限</p><h2 id="2、利用反射可以直接加载properties文件"><a href="#2、利用反射可以直接加载properties文件" class="headerlink" title="2、利用反射可以直接加载properties文件"></a><center>2、利用反射可以直接加载properties文件</center></h2><p>这个操作是在开发中比较常见的一种方式，多用于对资源文件加载</p><p>在工程中创建文件夹就不能是普通文件夹，这里需要创建是一个资源文件夹【Source Folder】</p><p>这个文件在工程内部的特点：自动编译文件夹中所有文件并且添加到classPath路径【也就是说将文件添加到工程内部存储字节码文件的文件夹中】，就可以利用反射进行文件的加载</p><p>PS:资源文件夹在项目中是以【“蓝色标色”】，在工程中src这个文件夹就是资源文件夹</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfeud.JDBC2.reflect;</span><br><span class="line"><span class="keyword">import</span> jdk.nashorn.internal.ir.CallNode;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectReadPropertiesFile</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//使用这种方式加载文件，这个文件必须在资源文件夹中</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            利用的原理就是 使用类加载器对classPath路径中文件进行加载，会返回一个流资源对象</span></span><br><span class="line"><span class="comment">            类的加载器在加载这个文件时会去classPath(在IDEA中就是out目录)下寻找这个同名文件</span></span><br><span class="line"><span class="comment">            建立流资源进行读取操作</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//提供一个Properties资源文件对象</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">//提供一个类的加载器【每一个类都有类的加载器】</span></span><br><span class="line">        <span class="comment">//利用线程对象获取类的加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">contextClassLoader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">        <span class="comment">//利用本类的class对象获取类的加载器</span></span><br><span class="line">        <span class="comment">//ClassLoader classLoader = ReflectReadPropertiesFile.class.getClassLoader();</span></span><br><span class="line">        <span class="comment">//使用类的加载器对象加载资源文件夹--》这个方法的参数不需要路径，只要文件名字就可以了</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> contextClassLoader.getResourceAsStream(<span class="string">&quot;db.properties&quot;</span>);</span><br><span class="line">        <span class="comment">//通过字节输入流对象加载资源</span></span><br><span class="line">        p.load(resourceAsStream);</span><br><span class="line">        System.out.println(p);</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">resourceAsStream1</span> <span class="operator">=</span>ReflectReadPropertiesFile.class.getClassLoader()</span><br><span class="line">                                                            .getResourceAsStream(<span class="string">&quot;db.properties&quot;</span>);</span><br><span class="line">        <span class="comment">//这个方法只能在JavaSE中调用在，在后续学习中EE中是不可以调用</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">systemResourceAsStream</span> <span class="operator">=</span> contextClassLoader.getSystemResourceAsStream(<span class="string">&quot;db.properties&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、扩展：静态方法和数组参数如何传递"><a href="#3、扩展：静态方法和数组参数如何传递" class="headerlink" title="3、扩展：静态方法和数组参数如何传递"></a><center>3、扩展：静态方法和数组参数如何传递</center></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfeud.JDBC2.reflect;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>    <span class="comment">//这是一个员工类</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">(<span class="type">int</span>... arr)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doWork1被调用了:&quot;</span>+ Arrays.toString(arr));</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">(String... arr)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doWork1被调用了:&quot;</span>+ Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectInvokeStaticMethod</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这里简化获取操作</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">employeeClass</span> <span class="operator">=</span> Employee.class;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">doWork</span> <span class="operator">=</span> employeeClass.getMethod(<span class="string">&quot;doWork&quot;</span>,<span class="type">int</span>[].class);</span><br><span class="line">        <span class="comment">//调用静态方法执行并对可变参数进行赋值操作</span></span><br><span class="line">        <span class="comment">//执行方法时，如果是静态方法第一个参数传递null值,第二个参数需要传递一个数组对象进来</span></span><br><span class="line">        doWork.invoke(<span class="literal">null</span>,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">doWork1</span> <span class="operator">=</span> employeeClass.getMethod(<span class="string">&quot;doWork&quot;</span>, String[].class);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            如果此时方法的参数类型是存储引用类型数组，此时通过反射方式调用，编译器对方法参数的认知不是String</span></span><br><span class="line"><span class="comment">            认知为当前参数是一个Object类型的数组，这个数组中存储这个String类型数组</span></span><br><span class="line"><span class="comment">            即将String类型的数组作为Object类型数组的一个元素存储</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        doWork1.invoke(<span class="literal">null</span>,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>&#125;&#125;);</span><br><span class="line">        <span class="comment">//提示：只要是数组作为方法的参数类型，无论是基本数据类型数据还是引用数据类型的数组</span></span><br><span class="line">        <span class="comment">// 统一作为反射调用方法参数传递时，都使用 new</span></span><br><span class="line">        Object[]&#123;具体数据值&#125;；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点五：Stream流"><a href="#知识点五：Stream流" class="headerlink" title="知识点五：Stream流"></a><center>知识点五：Stream流</center></h1><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a><center>1、概念</center></h2><p>流（Stream）与集合类似，但集合中保存的是数据，而Stream中保存对集合或数组数据的操作</p><h2 id="2、Stream特点"><a href="#2、Stream特点" class="headerlink" title="2、Stream特点"></a><center>2、Stream特点</center></h2><p>Stream 自己不会存储元素</p><p>Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</p><p>Stream 操作是延迟执行的，会等到需要结果的时候才执行</p><h2 id="3、Stream使用步骤"><a href="#3、Stream使用步骤" class="headerlink" title="3、Stream使用步骤"></a><center>3、Stream使用步骤</center></h2><p>创建：</p><p>&ensp;&ensp;&ensp;&ensp;新建一个流</p><p>中间操作：</p><p>&ensp;&ensp;&ensp;&ensp;在一个或多个步骤中，将初始Stream转化到另一个Stream的中间操作。</p><p>终止操作：</p><p>&ensp;&ensp;&ensp;&ensp;使用一个终止操作来产生一个结果。该操作会强制之前的延迟操作立即执行，在此之后，该Stream就不能使用了</p><h2 id="4、创建Stream的方法"><a href="#4、创建Stream的方法" class="headerlink" title="4、创建Stream的方法"></a><center>4、创建Stream的方法</center></h2><ol><li>通过Collection对象的stream()或parallelStream()方法</li><li>通过Arrays类的stream()方法</li><li>通过Stream接口的of()、iterate()、generate()方法</li><li>通过IntStream、LongStream、DoubleStream接口中的of、range、rangeClosed方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取Stream对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;22&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;456557&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;56789&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">    <span class="comment">//list.forEach(System.out::println);    //集合中有forEach遍历方法</span></span><br><span class="line">    <span class="comment">//通过集合对象获取Stream对象</span></span><br><span class="line">    Stream&lt;String&gt; stream = list.stream();</span><br><span class="line">    stream.forEach(s -&gt; System.out.println(s));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取Stream对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">IntStream</span> <span class="variable">stream</span> <span class="operator">=</span> Arrays.stream(arr);    <span class="comment">//返回一种流</span></span><br><span class="line">    stream.forEach(System.out::println);    <span class="comment">//快捷方式：soutc</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//获取Stream对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王五&quot;</span>);</span><br><span class="line">    stream.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、中间操作的方法"><a href="#5、中间操作的方法" class="headerlink" title="5、中间操作的方法"></a><center>5、中间操作的方法</center></h2><p>常见中间操作方法：</p><ul><li>filter、limit、skip、distinct、sorted</li><li>map</li><li>parallel</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Stream对象中常用的方法 中间操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;22&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;456557&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;56789&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">    <span class="comment">//获取集合中长度大于3的元素</span></span><br><span class="line">    <span class="comment">//list.stream().filter(li -&gt; li.length()&gt;3).forEach(System.out::println);</span></span><br><span class="line">    <span class="comment">//获取集合的第一页数据（前三条）</span></span><br><span class="line">    <span class="comment">//list.stream().limit(3).forEach(System.out::println);</span></span><br><span class="line">    <span class="comment">//获取集合的第二页数据（4~6条）</span></span><br><span class="line">    <span class="comment">//list.stream().skip(3).limit(3).forEach(System.out::println);</span></span><br><span class="line"><span class="comment">//第一个三是跳过几个元素,第二个是获取几个</span></span><br><span class="line">    <span class="comment">//获取集合中不重复的元素</span></span><br><span class="line">    <span class="comment">//list.stream().distinct().forEach(System.out::println);</span></span><br><span class="line">    <span class="comment">//将集合中的元素进行排序(注意：集合中的元素必须实现了Comparable接口)</span></span><br><span class="line">    <span class="comment">//list.stream().sorted().forEach(System.out::println);</span></span><br><span class="line">    <span class="comment">//将集合中的元素进行排序(按照元素的长度降序)</span></span><br><span class="line">    <span class="comment">//list.stream().sorted((o1, o2) -&gt; o2.length() - o1.length()).forEach(System.out::println);</span></span><br><span class="line">    <span class="comment">//将集合中的元素转换成int类型</span></span><br><span class="line">    <span class="comment">//list.stream().map(li -&gt; Integer.parseInt(li)+1).forEach(System.out::println);</span></span><br><span class="line">    <span class="comment">//list.stream().map(Integer::parseInt).forEach(System.out::println);</span></span><br><span class="line">    <span class="comment">//使用多线程操作集合中的元素</span></span><br><span class="line">    <span class="comment">// list.stream().forEach(li-&gt;    //单线程操作</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//     System.out.println(Thread.currentThread().getName()+&quot;=====&gt;&quot;+li);</span></span><br><span class="line">    <span class="comment">//&#125;);</span></span><br><span class="line">    list.stream().parallel().forEach(li-&gt;    <span class="comment">//多线程操作</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=====&gt;&quot;</span>+li);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、终止操作"><a href="#6、终止操作" class="headerlink" title="6、终止操作"></a><center>6、终止操作</center></h2><p>常见终止操作：</p><ul><li>forEach、min、max、count</li><li>reduce、collect</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Stream对象中常用的方法 终止操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m5</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;22&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;456557&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;562789&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">    <span class="comment">//遍历集合中的元素</span></span><br><span class="line">    <span class="comment">//list.forEach(System.out::println);</span></span><br><span class="line">    <span class="comment">//list.stream().forEach(System.out::println);</span></span><br><span class="line">    <span class="comment">//获取集合中元素长度最小的元素</span></span><br><span class="line">    <span class="comment">//Optional&lt;String&gt; min = list.stream().min((o1, o2) -&gt; o1.length() - o2.length());</span></span><br><span class="line">    <span class="comment">//System.out.println(min.get());</span></span><br><span class="line">    <span class="comment">//Optional&lt;String&gt; max = list.stream().max((o1, o2) -&gt; o1.length() - o2.length());</span></span><br><span class="line">    <span class="comment">//System.out.println(max.get());</span></span><br><span class="line">    <span class="comment">//获取集合中长度为3的元素个数</span></span><br><span class="line">    <span class="comment">//long count = list.stream().filter(li -&gt; li.length() == 3).count();</span></span><br><span class="line">    <span class="comment">//System.out.println(count);</span></span><br><span class="line">    <span class="comment">//将集合中的元素转成int类型并计算总和(计算)</span></span><br><span class="line">    <span class="comment">//Integer result = list.stream().map(Integer::parseInt).reduce(0, (o1, o2) -&gt; o1 + o2);</span></span><br><span class="line">    <span class="comment">//System.out.println(result);</span></span><br><span class="line">    <span class="comment">//将Stream流对象转换成List、set、Map集合</span></span><br><span class="line">    List&lt;String&gt; collect = list.stream().filter(li -&gt; li.contains(<span class="string">&quot;2&quot;</span>)).collect(Collectors.toList());</span><br><span class="line">    collect.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;知识点一：类的加载&quot;&gt;&lt;a href=&quot;#知识点一：类的加载&quot; class=&quot;headerlink&quot; title=&quot;知识点一：类的加载&quot;&gt;&lt;/a&gt;&lt;center&gt;知识点一：类的加载&lt;/center&gt;&lt;/h1&gt;&lt;img src=&quot;https://cdn.jsdeli</summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>24.多线程</title>
    <link href="http://example.com/post/fbc0ae86.html"/>
    <id>http://example.com/post/fbc0ae86.html</id>
    <published>2023-12-30T05:11:26.000Z</published>
    <updated>2024-03-01T14:49:02.328Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识点一：Thread线程基础"><a href="#知识点一：Thread线程基础" class="headerlink" title="知识点一：Thread线程基础"></a><center>知识点一：Thread线程基础</center></h1><p>有一个场景：在一个程序中即可以玩游戏又可以播放音乐？</p><p>以现在编程手段而言 —》 提供编程结构【顺序、分支、循环】</p><p>代码是要遵守顺序执行，代码需要遵守从上至下逐行执行，利用分支和循环修改循环执行一些操作，选择性执行某代码或者是让某些代码重复执行，无论如何操作代码依旧要顺序执行，没有办法让两段代交替执行</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012202919.png" alt="线程流程" style="zoom: 50%;"><p>此时Java为了解决这样的问题，提供一个操作，这个操作就叫做<strong>线程</strong>，可以在代码中使用多线程形式来完成这个操作</p><p>PS:现在电脑基本上都是多核CPU，所以每个人电脑上运行线程程序结果可能都不一样，这是一个非常正常现象，多线程运行时是一个不可预知状态，程序猿可以通过代码干预线程运行，以达到我们运行效果</p><h1 id="知识点二：并行和并发"><a href="#知识点二：并行和并发" class="headerlink" title="知识点二：并行和并发"></a><center>知识点二：并行和并发</center></h1><p>这两个概念在宏观的角度而言他们是一样(相似)的，但是在微观的角度而言他们是有区别</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012203194.png" alt="并行和并发" style="zoom:50%;"><p><strong>并行就是同时执行，并发就是在交替执行</strong></p><p>&ensp;&ensp;&ensp;&ensp;在操作系统中，安装了很多程序，并发指的是在一段时间内宏观上多个程序同时执行，这个在单个CPU系统中，每一个时刻只有一个程序执行，即微观上这些程序是分时交替的执行，只不过给人感觉是在同时运行，因为分时交替运行时间非常短暂</p><p>&ensp;&ensp;&ensp;&ensp;现在而言都是多核CPU，则这些并发执行程序可以分配到不同的处理器上（CPU），实现多个任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序就可以同时执行了，你的电脑CPU核心越多你电脑的性能就相对更加强悍</p><p>PS:单核处理的计算机肯定是不能并行处理多个任务，只能是多个任务在单个CPU上并发需要运行，同理线程也是一样的从宏观的角度而言线程并行运行从微观角度看就是串行运行，即线程是一个一个去执行的，当系统只有一个CPU是，线程会以某种顺序执行多个线程，这个情况称之线程调度【线程提供CPU时间争抢】</p><h1 id="知识点三：线程和进程"><a href="#知识点三：线程和进程" class="headerlink" title="知识点三：线程和进程"></a><center>知识点三：线程和进程</center></h1><p><strong>进程</strong></p><p>&ensp;&ensp;&ensp;&ensp;进程是程序的一次执行过程，是系统运行程序的基本单元，系统运行一个程序即在运行一个进程【从创建、运行、消亡的一个过程】，每一个进程都有自己一个独立的空间【内存空间】，一个应用程序(进程)可以同时运行多个线程</p><p>特点：</p><ol><li>进程是一个独立程序单元并且拥有自己独立空间</li><li>一个进程中可以同时运行多个线程</li></ol><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012204035.png" alt="进程" style="zoom:50%;"><p>进程是可以完成多个任务交替执行的，可以开发一个音乐软件（QQ音乐、网易云音乐、酷狗音乐），也可以开发一个打游戏软件（L0L、吃鸡战场、Dota2），只要运行这两个进程程序就可以完成一边听音乐，一边打游戏，这样做开发成本高，进行是独立的进程与进程之间是无法进行“<strong>通信</strong>”的</p><p><strong>线程</strong></p><p>&ensp;&ensp;&ensp;&ensp;线程是进程中一个内部执行单元，负责当前进程中的程序执行，一个进程中至少有一个线程，一个进程可以有多个线程，这些线程在进程中被称之为“多线程”，进程就可以利用这些多线程，去完成不同操作</p><p>特点:</p><ol><li>线程是在进程的内部执行，并且可以存在多个，彼此之间共享进程的内存区域</li><li>线程与线程之间彼此独立，但是可以进行“通信”</li></ol><p>可以利用这个轻量级的开发完成一个进程内部程序交替执行效果（线程并发执行）</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012205517.png" alt="线程" style="zoom:50%;"><p>总结进程与线程的区别：</p><p>&ensp;&ensp;&ensp;&ensp;进程： 有独立的内存空间，进程中数据存放的空间是独立的并且至少有一个线程</p><p>&ensp;&ensp;&ensp;&ensp;线程：堆空间是共享的，栈空间是独立的，线程消耗的资源要比进程小，并且可以多个线程存在同一个进程中</p><p>PS:需要知道了解的知识点：</p><ol><li>因为一个程序中有多个线程并发运行，那么从微观的角度而言是有先后顺序的，那么线程执行的顺序是取决于CPU的调度【线程争抢CPU时间片】，程序猿只能进行干涉，在不加干涉前提下线程执行就会出现很多随机性</li><li>Java程序进程中最少包含两个线程，一个是主线程就是main()方法【它在执行方法是或者执行程序时它的优先级永远最高】，另外一个垃圾回收机制线程(GC)【守护线程】，每当Java执行一个类的时候，实际上都会启动一个JVM，每一个JVM实际上就是在操作系统中启动了一个线程，Java本身就被垃圾回收机制所守护，所Java运行时至少启动了两个线程</li><li>由于创建一个线程开销远比创建一个进程开销要小很多，那么我们在开发多任务运行时，通常会优先考虑创建多线程，而不是多进程</li><li>所有的线程轮流使用CPU，每一个线程都会得到CPU分配的时间片，这个分配“尽量”平均分配CPU资源，但是这个效果不一定能达到，所以同优先级的线程对CPU时间的争抢是存在随机性的，可以对线程进行优先级设置来概念获取CPU时间片的几率，优先级越高几率越大，优先级越低几率越小</li></ol><h1 id="知识点四：Java程序中实现线程的方式"><a href="#知识点四：Java程序中实现线程的方式" class="headerlink" title="知识点四：Java程序中实现线程的方式"></a><center>知识点四：Java程序中实现线程的方式</center></h1><p>在Java中主要创建线程方式有四种：</p><ol><li>继承Thread类，此时子类就是线程类</li><li>实现Runnable接口，此时实现类不是线程类，使用Thread类才可成为线程</li></ol><p><strong>无论是上述两种方式中那种方式都需必须重写run方法实现线程逻辑</strong></p><ol start="3"><li>实现Callable接口， 此实现方方式并不是线程类，主要针对的是线程池提供</li><li>线程池可以帮组我们创建线程并进行管理操作</li></ol><p>如果实现线程需要继承Thread或实现Runnable接口，但是无论是那种都需要实现一个必要核心方法</p><p><strong>这个run方法是提供线程实现的核心逻辑，需要线程什么样需求代码，就将将代码写入到这个线程中</strong></p><table><thead><tr><th align="center">void</th><th align="center">run() 使用实现接口 Runnable 的对象创建一个线程时，启动该线程将导致在独立执行的线程中调用对象的 run方法</th></tr></thead><tbody><tr><td align="center"></td><td align="center"><strong>PS：通过观察可以发现这个run方法是没有参数和返回值类型，所以这个run不能通过方法接收参数和返回数据值</strong></td></tr></tbody></table><h2 id="1、线程创建方式之继承Thread类"><a href="#1、线程创建方式之继承Thread类" class="headerlink" title="1、线程创建方式之继承Thread类"></a><center>1、线程创建方式之继承Thread类</center></h2><p>步骤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 定义一个普通类继承与`java.lang.Thread`类</span><br><span class="line"><span class="number">2.</span> 在子类中重新给父类Thread中run方法并提供线程实现逻辑</span><br><span class="line"><span class="number">3.</span> 在测试类中main方法中，通过线程子类或Thread这个父类创建线程对象并执行线程启动完成调用run方法中逻辑执行</span><br></pre></td></tr></table></figure><p>PS：因为Thread本身就是线程类，所以继承Thread类子类也是线程类，具备父类中Thread所提供的所有操作者线程方法</p><p>需求：使用继承Thread类方法是完成边打游戏和边听音乐</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了演示效果方便观察写在同一个文件中</span></span><br><span class="line"><span class="comment">//此时GameThread继承与Thread类所以GameThread就是线程类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GameThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//必须重写Thread父类中的run方法，提供这个线程需要的执行逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span> ; i&lt;=<span class="number">50</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;打游戏：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//此时MusicThread继承与Thread类所以GameThread就是线程类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MusicThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//必须重写Thread父类中的run方法，提供这个线程需要的执行逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span> ; i&lt;=<span class="number">50</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;听音乐：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//提供一个测试类完成线程创建与调用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//main方法本身一个线程，主线线程优先级最高</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如何创建线程对象</span></span><br><span class="line">        <span class="comment">//下面两种创建线程方式并没有指定线程优先级，所以都是默认优先级athread和bthread的优先级相同</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1. 使用多态的效果【Thread是子线程类父类，所以可以使用Thread方式创建】</span></span><br><span class="line"><span class="comment">                Thread 线程对象的名字 = new 子线程类();</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">athread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GameThread</span>();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            2. 直接使用继承线程子类创建对象</span></span><br><span class="line"><span class="comment">                子线程类 线程对象的名字 = new 子线程类();</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">MusicThread</span> <span class="variable">bthread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MusicThread</span>();</span><br><span class="line">        <span class="comment">//启动线程执行 ---》调用 Thread类中提供 start方法 ，而不是调用run方法</span></span><br><span class="line">        athread.start();</span><br><span class="line">        bthread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、线程创建方式之实现Runnable接口"><a href="#2、线程创建方式之实现Runnable接口" class="headerlink" title="2、线程创建方式之实现Runnable接口"></a><center>2、线程创建方式之实现Runnable接口</center></h2><p>PS：<strong>实现Runnable接口的类并不是线程类，只是实现Runnable接口并提供run方法的重写，需要配合使用Thread类创建线程对象，此时线程才可以操作</strong>。因为Runnable接口中提供run方法的实现【实现Runnable接口的类】，传入到Thread类中时，就会覆盖Thread类中run方法，所以Thread提供创建线程对象就会执行重写Runnable接口中run方法，就会得到线程的效果</p><p>步骤:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 定义一个普通类实现Runnable接口</span><br><span class="line"><span class="number">2.</span> 实现Runnable接口的类必须重写run方法提供线程需要执行的逻辑</span><br><span class="line"><span class="number">3.</span> 在测试类中main方法中，使用Thread创建线程对象完成线程操作</span><br></pre></td></tr></table></figure><p>需求：使用继承Thread类方法是完成边打游戏和边听音乐</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.Runnable;</span><br><span class="line"><span class="comment">//为了演示效果方便观察写在同一个文件中</span></span><br><span class="line"><span class="comment">//此类就是实现Runnable接口并提供run方法实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GameRunnableImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">1</span>; i&lt;=<span class="number">50</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;打游戏：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MusicRunnableImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">1</span>; i&lt;=<span class="number">50</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;听音乐：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建Runnable接口实现类作为Thread线程对象操作</span></span><br><span class="line">        <span class="comment">//需要将Runnable接口的对象传递到Thread这个类中</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1. 先创建Runnable接口实现类的对象，然后再传递到Thread类中进行线程对象创建</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">GameRunnableImpl</span> <span class="variable">gri</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GameRunnableImpl</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(gri);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            2.使用匿名对象的方式进行Thread构造方法Runnable参数传递</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MusicRunnableImpl</span>());</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、Thread类创建线程和Runnable接口创建线程"><a href="#3、Thread类创建线程和Runnable接口创建线程" class="headerlink" title="3、Thread类创建线程和Runnable接口创建线程"></a><center>3、Thread类创建线程和Runnable接口创建线程</center></h2><p>&ensp;&ensp;&ensp;&ensp;两种方式皆可，因为都要实现run方法，但是从类的扩展角度而言，建议使用实现Runnable接口方式来完成作，因为Java中类是单一继承，所以如果继承Thread类就无法在继承其他类，所以就会影响类的扩展，但是如果实现接口方式完成，不仅可以继承一个类还可以实现多个接口所以就比较推荐实现Runnable接口</p><p>继承效果：</p><p>&ensp;&ensp;&ensp;&ensp;class A extends Thread{} &#x2F;&#x2F;没有办法让A在继承</p><p>&ensp;&ensp;&ensp;&ensp;class B extends XXXX implements Runnable{} &#x2F;&#x2F; 不仅可以作为线程类操作而且还可以进行继承其他类</p><h2 id="4、start方法和run方法"><a href="#4、start方法和run方法" class="headerlink" title="4、start方法和run方法"></a><center>4、start方法和run方法</center></h2><p>PS：<strong>创建完毕线程对象之后，线程执行需要调用的是start方法而不是run方法</strong></p><p>start方法： 用start方法来启动线程，真正的实现了线程运行，通过Thread类中给提供start来启动一个线程，此时线程会进入到“<strong>准备就绪</strong>”状态，但是真正运行，一旦线程获取到CPU时间片，此时线程才会真正的执行，执行调用提供run方法完成线程逻辑</p><p>run方法：run方法只是一个普通方法，只是在run方法中实现线程执行逻辑，如果外界直接调用run方法，线程是没有启动，只不过是在main方法调用了run方法执行，执行出run方法提供操作，和线程一点关系都没有</p><h2 id="5、使用匿名内部类或Lambda表达式便捷的创建线程对象并执行（了解）"><a href="#5、使用匿名内部类或Lambda表达式便捷的创建线程对象并执行（了解）" class="headerlink" title="5、使用匿名内部类或Lambda表达式便捷的创建线程对象并执行（了解）"></a><center>5、使用匿名内部类或Lambda表达式便捷的创建线程对象并执行（了解）</center></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousAndLambdaThread</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这种方式，线程是现创建现使用，只会使用一次即可</span></span><br><span class="line">        <span class="comment">//1.针对Thread类提供匿名内部类创建【只支持匿名内部类】</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i&lt;<span class="number">50</span>;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;听音乐：&quot;</span>+i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();     <span class="comment">// 在最外侧的大括号中调用start方法</span></span><br><span class="line">        <span class="comment">//2.针对Runnable接口提供匿名内部类和Lambda表达式实现</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i&lt;<span class="number">50</span>;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;打游戏：&quot;</span>+i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start(); <span class="comment">// 在最外侧的大括号中调用start方法</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i&lt;<span class="number">50</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;吃饭：&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start(); <span class="comment">// 在最外侧的大括号中调用start方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点五：线程常用方法"><a href="#知识点五：线程常用方法" class="headerlink" title="知识点五：线程常用方法"></a><center>知识点五：线程常用方法</center></h1><h2 id="1、线程状态getState"><a href="#1、线程状态getState" class="headerlink" title="1、线程状态getState"></a><center>1、线程状态getState</center></h2><p>这个方法可以返回线程运行状态</p><p>PS：API有一个静态属性 State【API中给返回类型时错误的，它不是静态类，他是一个枚举】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetStateDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//使用run方法进行求和操作【GetStateDemo 是 Thread子类</span></span><br><span class="line">        所以会得到所有方法】</span><br><span class="line">        System.out.println(<span class="string">&quot;进入run方法是当前线程状态：&quot;</span> + <span class="built_in">this</span>.getState());</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;=<span class="number">100</span> ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(<span class="string">&quot;sum = &quot;</span>+sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetStateDemo</span>();</span><br><span class="line">        <span class="comment">//在启动线程之前</span></span><br><span class="line">        System.out.println(<span class="string">&quot;start方法之前线程状态：&quot;</span>+thread.getState());</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;start方法之后线程状态：&quot;</span>+thread.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以表示线程状态说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 出生、新生</span></span><br><span class="line"><span class="comment">* 至今尚未启动的线程就是这种状态</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">NEW,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 准备就绪和执行</span></span><br><span class="line"><span class="comment">*PS：Java中提供Thread类并没有提供准备就绪的状态描述，所以RUNNABLE就有两个概念</span></span><br><span class="line"><span class="comment">* 调用start方法时是 ---&gt; 准备就绪</span></span><br><span class="line"><span class="comment">* 执行run方法时是 ---&gt; 执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">RUNNABLE,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 阻塞或睡眠 ---》 sleep方法</span></span><br><span class="line"><span class="comment">* 当线程出现【阻塞状态】，当前线程就会出现让出CPU时间片的操作等待后续执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">BLOCKED,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 等待 ---》 wait</span></span><br><span class="line"><span class="comment">* 等待是无限期等待只有进行唤醒之后等待效果才会消失【等待不是阻塞状态】</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">WAITING,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 时间等待</span></span><br><span class="line"><span class="comment">* 在设置等待状态时设置一个时间，只要在时间范围内都是等待状</span></span><br><span class="line"><span class="comment">态，如果到了并且在等待时期并没有进行唤 </span></span><br><span class="line"><span class="comment">* 醒从操作，等待线程会自动唤醒</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">TIMED_WAITING,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 消亡，死亡</span></span><br><span class="line"><span class="comment">* 线程都执行完毕不会在执行就出现这个状态【线程结束】</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">TERMINATED;</span><br></pre></td></tr></table></figure><h2 id="2、线程优先级setPriority"><a href="#2、线程优先级setPriority" class="headerlink" title="2、线程优先级setPriority"></a><center>2、线程优先级setPriority</center></h2><p>理论上线程优先级越高，获取CPU时间片的几率越大，反之获取几率越小</p><p>PS：但是优先级只是相当于给CPU一个暗示【先由我开始】，但是CPU是否会决定将时间片给当前线程，是CPU决定</p><p>所有在没有修改优先级之前的线程默认优先级都是相同，在Java中使用1~10之间数字表示线程优先级，数值越大优先级越高，所有在没有</p><p>修改优先级之前默认优先级是【5】API中提供三个静态常量方便对优先级的定义</p><table><thead><tr><th align="center">static int</th><th align="center">MAX_PRIORITY 线程可以具有的最高优先级【等级10】</th></tr></thead><tbody><tr><td align="center">static int</td><td align="center">MIN_PRIORITY 线程可以具有的最低优先级【等级1】</td></tr><tr><td align="center">static int</td><td align="center">NORM_PRIORITY 分配给线程的默认优先级【等级5】</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetPriorityDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span> ;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//getName()获取线程名字</span></span><br><span class="line">            System.out.println(getName()+<span class="string">&quot;：i的数值：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//利用线程创建两个线程对象使用默认优先级</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">athread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SetPriorityDemo</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">bthread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SetPriorityDemo</span>();</span><br><span class="line">        <span class="comment">//可能会出现Thread-0先执行 或 Thread-1先执行</span></span><br><span class="line">        <span class="comment">// athread.start(); // Thread-0</span></span><br><span class="line">        <span class="comment">// bthread.start(); // Thread-1</span></span><br><span class="line">        <span class="comment">//修改优先级</span></span><br><span class="line">        <span class="comment">// 【只要优先级的差别较大就可以的得到先执行和后执行效果】</span></span><br><span class="line">        <span class="comment">// 【只要优先级等级差别不是很大(比较接近)，执行效果就不是很明显了】</span></span><br><span class="line">        athread.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        bthread.setPriority(<span class="number">6</span>);</span><br><span class="line">        athread.start();     <span class="comment">// Thread-0</span></span><br><span class="line">        bthread.start();     <span class="comment">// Thread-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、更改和获取线程的名字"><a href="#3、更改和获取线程的名字" class="headerlink" title="3、更改和获取线程的名字"></a><center>3、更改和获取线程的名字</center></h2><p>线程是有默认名字组成方式 —》 使用到一个关键字“Thread” + “-” +“数字”，数字的从0开始，随着线程创建而逐渐增多，随着线程的减少而逐渐减少 —》 默认名字 【Thread-数字】</p><p>在编写线程程序时可以通过<strong>getName方法获取线程名字</strong>，但是如果创建线程过多使用默认名字看到效果就不是很明显</p><p>Java中提供线程名字修改方式有三种：</p><ol><li>在创建出线程对象之后调用setName(“线程新的名字”)</li><li>使用类实现Runnable接口并使用Thread类创建线程对象，调用两个参数版本构造方法进行名字设置</li></ol><p>&ensp;&ensp;&ensp;&ensp;Thread(Runnable接口实现类的对象，”线程名字”);</p><ol start="3"><li>使用类继承与Thread类，子类中提供一个仿照父类生成构造方法，这个方法参数是String name，子类只需要实现这个构造方法即可，在创建线程对象时只需要调用有参构造方法就可以指定线程名字</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetNameDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//方式一</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">athread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AThread</span>();</span><br><span class="line">        athread.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        System.out.println(athread.getName());</span><br><span class="line">        <span class="comment">//方式二</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">bthread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">BThread</span>(),<span class="string">&quot;线程B&quot;</span>);</span><br><span class="line">        System.out.println(bthread.getName());</span><br><span class="line">        <span class="comment">//方式三</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">cthread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CThread</span>(<span class="string">&quot;线程C&quot;</span>);    <span class="comment">//多态</span></span><br><span class="line">        System.out.println(cthread.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//实现Runnable接口不是线程类，所以不能在实现Runnable接口类中调用Thread类中方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// System.out.println(&quot;线程的名字：&quot;+getName());</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 如何在实现Runnable接口的类中获取当前线程</span></span><br><span class="line"><span class="comment">        * Thread类中提供一个静态方法currentThread() 可以获取当前线程对象</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;通过静态访获取到线程对象：&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//子类只要仿照生成一个带有String类型参数方法即可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CThread</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、线程休眠sleep【使用几率极高】"><a href="#4、线程休眠sleep【使用几率极高】" class="headerlink" title="4、线程休眠sleep【使用几率极高】"></a><center>4、线程休眠sleep【使用几率极高】</center></h2><p>sleep这个方法是静态方法，它可以让线程进入到【阻塞状态】即让线程进行到休眠时间，<strong>进入休眠之后线程会让出CPU时间片，给其他的线程进行争抢，当休眠时间到了之后恢复之后线程会继续和其线程进行CPU时间片的争抢</strong></p><p>sleep方法的参数是毫秒值 —》 1000毫秒 等于 1秒</p><p>线程如果触发sleep方法会有两种方式可以醒来：</p><ol><li>自然醒来【睡眠时间到了，自动醒来】</li><li>中断醒来【会通过Thread类中添加中断标记，强行让sleep醒来】</li></ol><p>所以sleep方法在调用时候会有一个编译时异常【InterruptedException(中断异常)】</p><p><strong>特别注意：如果sleep方法被调用在【同步锁、对象锁、同步监听器、同步代码块】中，sleep方法休眠之后是不会让出当前系统时间片【虽然会睡眠时间片也会释放，但是外界线程是无法获取】</strong></p><p>需求：通过sleep方法来实现以下交替执行效果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SleepDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;=<span class="number">100</span> ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">5</span> == <span class="number">0</span>)    <span class="comment">//只要i值可以对5整除</span></span><br><span class="line">            &#123; </span><br><span class="line">                System.out.println(<span class="string">&quot;当前线程:&quot;</span>+getName()+<span class="string">&quot;~~~~~~~~~&quot;</span>+i);</span><br><span class="line">                <span class="comment">//在run方法中调用sleep方法是不可以throws异常，只能try-catch抓取</span></span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">athread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SleepDemo</span>();</span><br><span class="line">        athread.setName(<span class="string">&quot;子线程&quot;</span>);</span><br><span class="line">        athread.start();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Java程序会默认提供两个线程一个是GC 和 一个是main方法【主线程作为线程操作】</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//在主线程中提供和SleepDemo类中一样的操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i&lt;=<span class="number">100</span> ;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">5</span> ==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;当前线程：&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;~~~~~~~~~&quot;</span>+i);</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sleep方法确实可以让线程进入到休眠状态，并且释放出CPU时间片，但是时间无法正确把控就会造成无法使用sleep方法进行代码的交替执行</p><h2 id="5、线程礼让yield（了解）"><a href="#5、线程礼让yield（了解）" class="headerlink" title="5、线程礼让yield（了解）"></a><center>5、线程礼让yield（了解）</center></h2><p>礼让线程的作用就是在调用yield方法的线程中，让出CPU时间片【相当于通知CPU不急着执行】，让出之后CPU会不会回收CPU时间片取决于CPU，礼让原则是：线程优先级越高礼让效果就是会明显一些</p><p>yield和sleep方法是有一定区别的，sleep是立即让出CPU时间片，在睡眠时间内是不会争抢CPU时间片，yield方法执行之后，礼让线程会进入“准备就绪”，礼让线程可能会再次持有CPU时间片</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YieldDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span> ; i&lt;=<span class="number">50</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程的名字：&quot;</span>+getName()+<span class="string">&quot;~~~~~~~~&quot;</span>+i);</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Thread.<span class="keyword">yield</span>(); <span class="comment">//让线程礼让</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建两个线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">athread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">YieldDemo</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">bthread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">YieldDemo</span>();</span><br><span class="line">        athread.setName(<span class="string">&quot;a线程&quot;</span>);</span><br><span class="line">        bthread.setName(<span class="string">&quot;b线程&quot;</span>);</span><br><span class="line">        athread.start();</span><br><span class="line">        bthread.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        bthread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、线程合并join"><a href="#6、线程合并join" class="headerlink" title="6、线程合并join"></a><center>6、线程合并join</center></h2><p>合并线程是一个效果非常明显操作，合并线程是一个线程正处于运行阶段，此时这个线程达到某个条件时，可以让其他线程合并到这个执行线程中，只要使用join合并，合并线程<strong>必然</strong>会得到CPU时间片，被合并的线程需要等待合并线程执行完毕之后才会继续运行</p><p>需求：妹子在看葫芦娃【50级】，当看到【10级】汉子要看喜洋洋</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoinDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Meizi</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Meizi</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;=<span class="number">50</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;妹子正在看精钢葫芦娃大战蛇精：&quot;</span>+i);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//启动另外一个线程进行合并操作</span></span><br><span class="line">                <span class="type">Hanzi</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hanzi</span>();</span><br><span class="line">                <span class="comment">//合并之前必要前提：要合并线程必须进入准备就绪状态，即调用start方法</span></span><br><span class="line">                thread.start();</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    thread.join();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hanzi</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;=<span class="number">10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;汉子正在看喜羊羊与灰太狼：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程合并必然是让出CPU时间片，CPU时间片会join的线程，线程必须是启动状态【调用start】</p><h2 id="7、线程中断-标记"><a href="#7、线程中断-标记" class="headerlink" title="7、线程中断(标记)"></a><center>7、线程中断(标记)</center></h2><p>在Thread这个类中提供让线程停止方法 stop方法，但是这个方法被Java进行过时处理，所以就不建议在线程中进行使用了，所以Java就提供一个替代 stop方法的方法 —》interrupt方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptThreadDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;=<span class="number">20</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(getName()+<span class="string">&quot;线程中执行i值是:&quot;</span>+i);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//停止线程 --&gt;过时的stop方法</span></span><br><span class="line">                <span class="comment">// stop();</span></span><br><span class="line">                <span class="comment">//中断线程</span></span><br><span class="line">                interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InterruptThreadDemo</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这个线程中断标记方法向线程中添加【中断标记】，只有被含有中断异常方法检测到这个标记就会终止方法的执行效果【sleep明显 和join不明显】，<strong>直接在线程调用这个方法是无用的</strong>，只是添加标记不会停止线程，配合API中所提供的一个方法来使用【<strong>interrupted</strong>】，作用检查线程中是否存在中断标记，如果存在着返回true，不存在则返回false</p><p><strong>正确使用方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptThreadDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;=<span class="number">20</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(getName()+<span class="string">&quot;线程中执行i值是:&quot;</span>+i);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//使用替代stop方法中断线程时，当遇到某个条件要终止线程时，检查中断标记</span></span><br><span class="line">                <span class="keyword">if</span>(Thread.interrupted())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//停止线程</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">InterruptThreadDemo</span> <span class="variable">interruptThreadDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterruptThreadDemo</span>();</span><br><span class="line">        interruptThreadDemo.start();</span><br><span class="line">        <span class="comment">//向线程中添加中断标记</span></span><br><span class="line">        interruptThreadDemo.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>强行终止睡眠</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.ThreadMethod;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptThreadDemo2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入线程&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;没有被中断正常睡眠苏醒&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;中断睡眠苏醒&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(<span class="string">&quot;线程结束&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">InterruptThreadDemo2</span> <span class="variable">interruptThreadDemo2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterruptThreadDemo2</span>();</span><br><span class="line">        interruptThreadDemo2.start();</span><br><span class="line">        <span class="comment">//为了效果让主线程休眠2秒之后在触发中断标记</span></span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">        interruptThreadDemo2.interrupt();  <span class="comment">//如果检查到中断标记就会强行终止睡眠</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点六：火车售票问题"><a href="#知识点六：火车售票问题" class="headerlink" title="知识点六：火车售票问题"></a><center>知识点六：火车售票问题</center></h1><p>需求：火车站买票，一共有且仅有【100】张票，4个窗口同时贩卖临界资源就是这个票，多个线程访问保证票有且仅有100张，开4个线程同时买100张票</p><p>&ensp;&ensp;&ensp;&ensp;其实这个卖票案例就是多线程下同时操作一个资源(临界资源),如何保证线程操作资源安全不出现以下情况</p><p>&ensp;&ensp;&ensp;&ensp;买票不会出现重票 –&gt; 线程1 卖出第99张票 线程2 卖出99张票</p><p>&ensp;&ensp;&ensp;&ensp;错误票 —&gt; 线程1 卖出第75张票. 线程2 卖出76张票 —&gt; 这个是对</p><p>&ensp;&ensp;&ensp;&ensp;但是 线程2 卖出49张票</p><p>&ensp;&ensp;&ensp;&ensp;负数票 —&gt; 某个线程买完最后一张票的时候 剩余线程就不能在卖票0 -1 -2…票</p><p>&ensp;&ensp;&ensp;&ensp;1秒卖一张 —&gt; 有且仅有100张 —&gt;不要卖出400张票数</p><p><strong>问题1：如何将票固定在100张，而不是每个线程都卖出100张票</strong></p><p>&ensp;&ensp;&ensp;&ensp;如何做到所有的线程都共享这一个资源？</p><ol><li>将票作为成员变量，作为成员变量之后，需要保证这个提供票的类在外界创建对象必须是唯一的，如果不唯一的，就会出现你创建票的对象每个对象都会唯一，一个成员变量，4个对象就是4个成员变量，此时相当于400张票【单例设计模式】</li></ol><p>PS：单例设计模式的原则：保证外界无论如何获取对象都是唯一的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v1基础版本</span></span><br><span class="line"><span class="keyword">package</span> com.qfedu.Thread.SellTicket1;</span><br><span class="line"><span class="comment">//v1版本</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    不要让类继承与Thread，继承Thread必然要提供四个线程对象</span></span><br><span class="line"><span class="comment">    这样就会出现无法控制票100张</span></span><br><span class="line"><span class="comment">    建议实现Runnable，以Runnable实现类方式创建线程处理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicket1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供成成员变量存储票的信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//执行买票操作</span></span><br><span class="line">        <span class="comment">//提供一个for循环，这个循环执行100次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//提供买票的逻辑</span></span><br><span class="line">            <span class="keyword">if</span>(tickets &gt; <span class="number">0</span>)    <span class="comment">//证明还票可以出售</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//休眠1秒在买票</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//买票</span></span><br><span class="line">                System.out.println(<span class="string">&quot;当前售票员[&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;]第&quot;</span>+<span class="string">&quot;[&quot;</span>+(tickets--)+<span class="string">&quot;]票&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果提供的是成员变量【保证存储成员变量的这个类所得到对象是必须唯一】</span></span><br><span class="line">        <span class="comment">//出现400张票问题[在构建线程对象时，提供四个Runnable接口实现类对象创建]</span></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">            Thread thread1 = new Thread(new SellTicket1(),&quot;刘德华&quot;);</span></span><br><span class="line"><span class="comment">            Thread thread2 = new Thread(new SellTicket1(),&quot;张学友&quot;);</span></span><br><span class="line"><span class="comment">            Thread thread3 = new Thread(new SellTicket1(),&quot;郭富城&quot;);</span></span><br><span class="line"><span class="comment">            Thread thread4 = new Thread(new SellTicket1(),&quot;吴奇隆&quot;);</span></span><br><span class="line"><span class="comment">            thread1.start();</span></span><br><span class="line"><span class="comment">            thread2.start();</span></span><br><span class="line"><span class="comment">            thread3.start();</span></span><br><span class="line"><span class="comment">            thread4.start();</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//在外界只创建一个Runnable接口实现类对象，保证对象是唯一的</span></span><br><span class="line">        <span class="type">SellTicket1</span> <span class="variable">sellTicket1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicket1</span>(); <span class="comment">//只会维护一份的票对象【100】张</span></span><br><span class="line">        <span class="comment">//利用这个对象初始化创建4个线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket1,<span class="string">&quot;刘德华&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket1,<span class="string">&quot;张学友&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket1,<span class="string">&quot;郭富城&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket1,<span class="string">&quot;吴奇隆&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="GetInstance"><a href="#GetInstance" class="headerlink" title="GetInstance"></a><center>GetInstance</center></h2><p>在主函数开始时调用，返回一个实例化对象，此对象是static的，在内存中保留着它的引用，即内存中有一块区域专门用来存放静态方法和变量，可以直接使用，调用多次返回同一个对象</p><p>GetInstance与new区别</p><p>&ensp;&ensp;&ensp;&ensp;如Object object &#x3D; new Object()，这时候，就必须要知道有第二个Object的存在，而第二个Object也常常是在当前的应用程序域中的，可以被直接调用的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qf.Demo03.test;</span><br><span class="line"><span class="comment">//提供了成员变量</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SellTicket2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供成员变量，变量是存储票信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    单设计模式的原则--》保证在外界获取对象时都是同一个对象【地址也是相同的】</span></span><br><span class="line"><span class="comment">    1.私有化构造方法</span></span><br><span class="line"><span class="comment">    2.提供一个私有化静态变量并对静态变量进行赋值【类型是本类类型提供对象创建】</span></span><br><span class="line"><span class="comment">    3.提供一个静态共有方法可以获取本类对象的唯一途径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SellTicket2</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="comment">//使用本类类型创建对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SellTicket2</span> <span class="variable">sellTicket2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicket2</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SellTicket2 <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> sellTicket2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//执行买票操作</span></span><br><span class="line">        <span class="comment">//提供一个for循环，这个循环执行100次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//提供买票的逻辑</span></span><br><span class="line">            <span class="keyword">if</span>(tickets &gt; <span class="number">0</span>)    <span class="comment">//证明还票可以出售</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//休眠1秒在买票</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//买票</span></span><br><span class="line">                System.out.println(<span class="string">&quot;当前售票员[&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;]第&quot;</span>+<span class="string">&quot;[&quot;</span>+(tickets--)+<span class="string">&quot;]票&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 提供了静态变量，这个类的创建对象方式就无所谓</span></span><br><span class="line">        <span class="type">SellTicket2</span> <span class="variable">sellTicket2</span> <span class="operator">=</span> SellTicket2.getInstance();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;刘德华&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;张学友&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;郭富城&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;吴奇隆&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>定义一个变量保证所有对象共享，无论外界如何创建线程对象【实现Runnable还是继承Thread类】，这里都可以保证所有兑现共享这个变量，可以提供一个static修饰变量即静态变量</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.Thread.SellTicket1;</span><br><span class="line"><span class="comment">//v1.1版本 ---&gt; 提供了静态变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicket2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供静态成员变量存储票的信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//执行买票操作</span></span><br><span class="line">        <span class="comment">//提供一个for循环，这个循环执行100次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//提供买票的逻辑</span></span><br><span class="line">            <span class="keyword">if</span>(tickets &gt; <span class="number">0</span>)    <span class="comment">//证明还票可以出售</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//休眠1秒在买票</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//买票</span></span><br><span class="line">                System.out.println(<span class="string">&quot;当前售票员[&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;]第&quot;</span>+<span class="string">&quot;[&quot;</span>+(tickets--)+<span class="string">&quot;]票&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 提供了静态变量，这个类的创建对象方式就无所谓</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SellTicket2</span>(),<span class="string">&quot;刘德华&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SellTicket2</span>(),<span class="string">&quot;张学友&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SellTicket2</span>(),<span class="string">&quot;郭富城&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SellTicket2</span>(),<span class="string">&quot;吴奇隆&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题2：在买票的时候会出现、重票、错票、排序顺序的混乱的问题</p><p>&ensp;&ensp;&ensp;&ensp;这个问题产生就是多线程并发争抢”临界资源”出现里临界资源不安全问题</p><h2 id="1、如何解决多线程并发访问临界资源，保证资源安全问题"><a href="#1、如何解决多线程并发访问临界资源，保证资源安全问题" class="headerlink" title="1、如何解决多线程并发访问临界资源，保证资源安全问题"></a><center>1、如何解决多线程并发访问临界资源，保证资源安全问题</center></h2><p>此时Java为了保证多线程并发访问临界资源线程安全问题，提供了一个处理机制，可以在处理临界资源代码中添加（同步锁&#x2F;对象锁&#x2F;同步代码块&#x2F;同步监听器），这里四个名称都是指的是同一个操作，可以添加“锁机制”，保证在同一个时刻的只有一个线程操作临界资源，保证临界资源安全</p><h2 id="2、synchronized关键字"><a href="#2、synchronized关键字" class="headerlink" title="2、synchronized关键字"></a><center>2、synchronized关键字</center></h2><p>synchronized翻译意思：同步</p><p>使用synchronized关键字进行同步操作，使用synchronized组成同步操作叫做【同步锁&#x2F;对象锁&#x2F;同步代码块】</p><p>语法 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(资源锁对象)</span><br><span class="line">&#123;</span><br><span class="line">    提供操作临界资源的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行原理： 利用了同一时间内【只能有一个线程对象持有当前资源锁对象】，只要线程不释放这个所资源对象，外界线程是无法执行线程逻辑资源代码，在同步代码块中执行线程进行休眠是不会释放CPU时间片到外界给其他线程，因为sleep方法是不会释放锁资源</p><p>需要注意还需要保证【<strong>资源锁对象必须是唯一的</strong>】，不唯一锁对象数无法进行同步操作</p><p>如果保证资源锁对象是唯一的？</p><p>个人建议：十分不推荐使用 this 作为锁资源对象，this可能锁不了，this代表的是当前对象，那么就意味着这个提供临界支援类必须是创建唯一的对象才可以，这样才可以保证this是唯一的</p><p>替代方案一：</p><p>&ensp;&ensp;&ensp;&ensp;在静态资源处理线程类中提供一个全局静态常量“锁资源”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">synchronized</span>(obj)</span><br><span class="line">&#123;</span><br><span class="line">    提供操作临界资源的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>替代方案二【推荐】</p><p>&ensp;&ensp;&ensp;&ensp;天生对象就是唯一的，Java中这个对象无论你如何操作，就可以保证他是唯一的地址都是同一个，String字符串类，直接使用字符串对象即可—-&gt;【使用 “” (双引号)创建】</p><p>提供字符串空串处理 —&gt; 即 提供字符串空串对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    提供操作临界资源的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用同步代码块修改买票的案例的</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.Thread.SynchronizedSellTicket1;</span><br><span class="line"><span class="comment">//v2版本 ---&gt; 提供了静态变量 和 同步代码块执行买票操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供静态成员变量存储票的信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//执行买票操作</span></span><br><span class="line">        <span class="comment">//提供一个for循环，这个循环执行100次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//提供买票的逻辑</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>) <span class="comment">//同步代码块</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) <span class="comment">//证明还票可以出售</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">try</span> </span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//休眠1秒在买票</span></span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="comment">//买票</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;当前售票员[&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;]第&quot;</span></span><br><span class="line">                                                    + <span class="string">&quot;[&quot;</span> + (tickets--) + <span class="string">&quot;]票&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 提供了静态变量，这个类的创建对象方式就无所谓</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SellTicket</span>(),<span class="string">&quot;刘德华&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SellTicket</span>(),<span class="string">&quot;张学友&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SellTicket</span>(),<span class="string">&quot;郭富城&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SellTicket</span>(),<span class="string">&quot;吴奇隆&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、同步方法-对象同步方法-成员同步方法"><a href="#3、同步方法-对象同步方法-成员同步方法" class="headerlink" title="3、同步方法&#x2F;对象同步方法&#x2F;成员同步方法"></a><center>3、同步方法&#x2F;对象同步方法&#x2F;成员同步方法</center></h2><p>使用synchronized关键字进行成员方法的修饰，这个方法就会成为<strong>同步方法</strong>将操作资源代码写入到这个方法中就可以进行同步操作了</p><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">访问权限修饰符 <span class="keyword">synchronized</span> 返回值类型 方法名(参数列表)</span><br><span class="line">&#123;</span><br><span class="line">    方法体；</span><br><span class="line">    <span class="keyword">return</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特别注意：使用是同步方法，所以这个方法使用锁资源对象是【this】，提供同步方法的这个类所创建对象必须是唯一的才可以锁住资源</strong></p><p>PS：到目前位置 方法定义中其他修饰符就已经全部介绍完毕</p><p>&ensp;&ensp;&ensp;&ensp;类中方法可以使用：【static、final、abstract、synchronized】</p><p>&ensp;&ensp;&ensp;&ensp;接口中方法可以使用：【abstract、static、default】</p><p><strong>修饰同步方法是该买票案例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.Thread.SynchronizedSellTicket1;</span><br><span class="line"><span class="comment">//v2.1版本 ---&gt; 提供了静态变量 和 同步方法进行买票</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicket2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供静态成员变量存储票的信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//执行买票操作</span></span><br><span class="line">        <span class="comment">//提供一个for循环，这个循环执行100次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//提供买票的逻辑 ---》调用同步方法即可</span></span><br><span class="line">            seller();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//同步方法 --&gt; 这个锁资源对象是this</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">seller</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//提供就是线程处理临界资源操作</span></span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) <span class="comment">//证明还票可以出售</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//休眠1秒在买票</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//买票</span></span><br><span class="line">            System.out.println(<span class="string">&quot;当前售票员[&quot;</span> +</span><br><span class="line">            Thread.currentThread().getName() + <span class="string">&quot;]第&quot;</span></span><br><span class="line">            + <span class="string">&quot;[&quot;</span> + (tickets--) + <span class="string">&quot;]票&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 提供了静态变量，这个类的创建对象方式就无所谓</span></span><br><span class="line">        <span class="comment">//同步方法提供类如果是线程类，需要保证线程类对象是唯一的</span></span><br><span class="line">        <span class="type">SellTicket2</span> <span class="variable">sellTicket2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicket2</span>();   <span class="comment">//这是保证线程类对象唯一</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;刘德华&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;张学友&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;郭富城&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;吴奇隆&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、类锁-类同步代码块-类同步方法-静态同步方法"><a href="#4、类锁-类同步代码块-类同步方法-静态同步方法" class="headerlink" title="4、类锁&#x2F;类同步代码块&#x2F;类同步方法&#x2F;静态同步方法"></a><center>4、类锁&#x2F;类同步代码块&#x2F;类同步方法&#x2F;静态同步方法</center></h2><p>如果使用是同步代码块的语法，就是将资源锁对象，从当前对象替换成类对象，通过类的方式获取对象【通反射获取】，静态同步方法就是使用static和synchronized同时修饰方法</p><p><strong>类锁&#x2F;类同步代码块</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(类名.class)    <span class="comment">// 类锁对象</span></span><br><span class="line">&#123;</span><br><span class="line">    操作临界资源代码即可</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类同步方法&#x2F;静态同步方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">访问权限修饰符 <span class="keyword">static</span> <span class="keyword">synchronized</span> 返回值类型 方法名(参数列表)</span><br><span class="line">&#123;</span><br><span class="line">    方法代码</span><br><span class="line">    <span class="keyword">return</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v2.2版本 ---&gt; 提供了静态变量 和 静态同步操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicket3</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供静态成员变量存储票的信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//执行买票操作</span></span><br><span class="line">        <span class="comment">//提供一个for循环，这个循环执行100次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//提供买票的逻辑 ---》调用同步方法即可</span></span><br><span class="line">            <span class="comment">//seller();</span></span><br><span class="line">            <span class="keyword">synchronized</span> (String.class)    <span class="comment">// 类锁</span></span><br><span class="line">            &#123; </span><br><span class="line">                <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) <span class="comment">//证明还票可以出售</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">try</span> </span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//休眠1秒在买票</span></span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="comment">//买票</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;当前售票员[&quot;</span> +</span><br><span class="line">                    Thread.currentThread().getName() + <span class="string">&quot;]第&quot;</span></span><br><span class="line">                    + <span class="string">&quot;[&quot;</span> + (tickets--) + <span class="string">&quot;]票&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态同步方法 --&gt; 这个锁资源就是当前类的对象【是唯一的】，通过类获取即 类.class</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">seller</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//提供就是线程处理临界资源操操作</span></span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) <span class="comment">//证明还票可以出售</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//休眠1秒再买票</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//卖票</span></span><br><span class="line">            System.out.println(<span class="string">&quot;当前售票员[&quot;</span> +Thread.currentThread().getName() + <span class="string">&quot;]第&quot;</span> </span><br><span class="line">                                                        + <span class="string">&quot;[&quot;</span> + (tickets--) + <span class="string">&quot;]票&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 提供了静态变量，这个类的创建对象方式就无所谓</span></span><br><span class="line">        <span class="comment">//同步方法提供类如果是线程类，需要保证线程类对象是唯一的</span></span><br><span class="line">        <span class="type">SellTicket3</span> <span class="variable">sellTicket2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicket3</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;刘德华&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;张学友&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;郭富城&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;吴奇隆&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>synchronized总结：</p><ol><li>在开发中常用肯定是对象锁【同步代码块】但是这个代码块的范围不要太大，不然的话会影响执行效率</li></ol><p>&ensp;&ensp;&ensp;&ensp;PS: 在什么位置对资源操作就在什么位置添加 同步代码块</p><ol start="2"><li>使用synchronized关键字之后线程就会变成安全，间接就将并行线程修改为串行线程，使用锁机制将线程变成 【一个一个站排执行效果】</li></ol><h1 id="知识点七：线程通信"><a href="#知识点七：线程通信" class="headerlink" title="知识点七：线程通信"></a><center>知识点七：线程通信</center></h1><p>到现目前位置线程与线程之间依旧是彼此独立，就算使用同步代码块，也是让线程执行有一定顺序，但是还是没有进行通信操作，如果需要遇到某个线程执行完毕之后需要通知另外一个线程继续执行，此时就需要使用到线程通信，可以在一个进程中开发多个线程，每个线程之间可以进行通信操作，从而协调性的完成某个进程中需要执行逻辑</p><p><strong>线程通信有一个标准的通信模型【生产者与消费者模式】</strong></p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012227153.png" alt="线程通信" style="zoom:50%;"><h2 id="1、完成生产者和消费者通信模型v1版本"><a href="#1、完成生产者和消费者通信模型v1版本" class="headerlink" title="1、完成生产者和消费者通信模型v1版本"></a><center>1、完成生产者和消费者通信模型v1版本</center></h2><p>Bank(银行类) —》 提供数据维护与使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基础的第一个版本 ---》 提供临界资源并提供操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bank</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        临界资源一共有两种提供方式【提供成员变量和提供静态变量】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;    <span class="comment">//存储前的临界变量</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        外界无论如何创建Bank类对象，都需要是唯一的，不然的话成员变量会跟着对象多少而进行创建</span></span><br><span class="line"><span class="comment">        提供对象唯一创建方式【单例设计模式】</span></span><br><span class="line"><span class="comment">        单例设计模式可以保证外界无论如何操作得到对象都是唯一单例设计模式的实现：</span></span><br><span class="line"><span class="comment">        1. 一定要私有化构造方法 --&gt; 防止外界调用构造方法创建对象</span></span><br><span class="line"><span class="comment">        2. 提供一个私有静态常量对象，这个对象就是单例类唯一创建对象</span></span><br><span class="line"><span class="comment">        3. 提供一个静态方法，获取这个创建好的对象，得到实例【外界只能通过这个方法获取对象】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Bank</span> <span class="variable">bank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> bank;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *生产者向共享资源中存储数据的方法【生产】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 存储钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        money = m+money;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;存了&quot;</span>+m+<span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *消费者向共享资源中存储数据的方法【消费】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 消费钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">popMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        money = money-m;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;取了&quot;</span>+m+<span class="string">&quot;余额是：&quot;</span>+money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产者【是一个线程提供数据存储操作】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供银行属性</span></span><br><span class="line">    <span class="keyword">private</span> Bank bank;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Bank bank)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.bank = bank;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//提供线程存储钱的操作 存储十次 每次1000元</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            bank.pushMoney(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者【是一个线程提供数据获取操作】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供银行属性</span></span><br><span class="line">    <span class="keyword">private</span> Bank bank;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(Bank bank)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.bank = bank;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//提供线程存获取的操作 获取十次 每次1000元</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            bank.popMoney(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供一个测试类Test进行测试操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.Thread.waitAndnotfiny;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//通过单例获取银行对象</span></span><br><span class="line">        <span class="type">Bank</span> <span class="variable">bank1</span> <span class="operator">=</span> Bank.getInstance();</span><br><span class="line">        <span class="comment">//2.创建线程对象并启动操作</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(bank1),<span class="string">&quot;花花&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(bank1),<span class="string">&quot;菲菲&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题1：现在执行速度太快了，看不到交替执行效果，让线程休眠1秒操作</p><p>问题2：虽然让线程休眠之后，出现了一个执行错乱的问题，因为多线程并发访问临界资源money，出现线程挣抢的问题，所以出现临界资源部不安全问题，添加同步代码块</p><p>Bank银行类需要修改为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.Thread.waitAndnotfiny;</span><br><span class="line"><span class="comment">//基础的第一个版本 ---》 提供临界资源并提供操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bank</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        临界资源一共有两种提供方式【提供成员变量和提供静态变量】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;<span class="comment">//存储前的临界变量</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        外界无论如何创建Bank类对象，都需要是唯一的，不然的话成员变量会跟着对象多少而进行创建</span></span><br><span class="line"><span class="comment">        提供对象唯一创建方式【单例设计模式】</span></span><br><span class="line"><span class="comment">        单例设计模式可以保证外界无论如何操作得到对象都是唯一</span></span><br><span class="line"><span class="comment">        单例设计模式的实现：</span></span><br><span class="line"><span class="comment">        1. 一定要私有化构造方法 --&gt; 防止外界调用构造方法创建对象</span></span><br><span class="line"><span class="comment">        2. 提供一个私有静态常量对象，这个对象就是单例类唯一创建对象</span></span><br><span class="line"><span class="comment">        3. 提供一个静态方法，获取这个创建好的对象，得到实例【外界只能通过这个方法获取对象】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Bank</span> <span class="variable">bank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> bank;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *生产者向共享资源中存储数据的方法【生产】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 存储钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                money = m + money;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;存了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *消费者向共享资源中存储数据的方法【消费】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 消费钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">popMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                money = money - m;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、完成生产者和消费者通信模型v2版本"><a href="#2、完成生产者和消费者通信模型v2版本" class="headerlink" title="2、完成生产者和消费者通信模型v2版本"></a><center>2、完成生产者和消费者通信模型v2版本</center></h2><p>使用了同步代码块+sleep方法，虽然让程序执行有序了也保证线程中操作临界资源过程也安全了，但是还是无法保证线程可以做到交替执行的效果【<strong>即生产者生产完数据之后通知消费者可以进行消费，消费者消费完数据之后通知生产者可以生产</strong>】，所以如何完成这个通信操作呢？</p><p>此时就需要使用Java中Object类中提供三个方法了</p><table><thead><tr><th align="center">线程通信方法</th><th align="center">方法说明</th></tr></thead><tbody><tr><td align="center">wait()</td><td align="center">执行该方法的线程对象会释放【同步锁资源】，JVM会把当前线程放到等待池中，等待其他线程唤醒操作</td></tr><tr><td align="center">notify()</td><td align="center">执行该方法的线程对象会在等待池【随机唤醒】一个等待的线程，把线程转移到锁池中等待，再次获取资源</td></tr><tr><td align="center">notifyAll()</td><td align="center">执行该方法的线程对象会在等地池中【唤醒所有的线程】，把线程转移到锁池中等待，再次获取资源</td></tr></tbody></table><p>&ensp;&ensp;&ensp;&ensp;就可以利用这三个方法进行线程通信操作了，<strong>特别注意调用通信方法必须是锁资源对象，否则会出现异常提示信息【在哪里调用等待方法就在位置被唤醒】</strong></p><p>线程通信执行流程：</p><p>&ensp;&ensp;&ensp;&ensp;假设<strong>A线程</strong>和<strong>B线程</strong>共同操作一个<strong>X锁对象</strong>，A、B线程可以通过X锁对象调用wait和notify方法进行如下线程通信操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当A线程执行到X锁对象时，A线程持有X锁对象，B线程是没有执行机会的，B线程在X对象的等待锁池中</span><br><span class="line">A线程在同步代码块种执行到X.wait方法时，A线程会释放X对象所资源，A线程会进入到X对象的等待锁池中</span><br><span class="line">B线程就会在等待锁池中得到A线程释放的X资源锁对象，B线程就开始执行操作</span><br><span class="line">B线程在同步代码块中执行到X.notify方法时，JVM把A线程从X对象等待池中，移动到等待X对象锁资源中得到锁资源</span><br><span class="line">B线程执行完毕之后释放锁资源，A线程就有机会获取到锁，继续执行同步方法</span><br></pre></td></tr></table></figure><p>修改Bank类提供线程通信操作者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.Thread.waitAndnotfiny.V2;</span><br><span class="line"><span class="comment">//通信的版本 ---》 提供临界资源并提供操作[添加线程通信和同步代码块+sleep方法]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bank</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        临界资源一共有两种提供方式【提供成员变量和提供静态变量】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;    <span class="comment">//存储前的临界变量</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        外界无论如何创建Bank类对象，都需要是唯一的，不然的话成员变量会跟着对象多少而进行创建</span></span><br><span class="line"><span class="comment">        提供对象唯一创建方式【单例设计模式】</span></span><br><span class="line"><span class="comment">        单例设计模式可以保证外界无论如何操作得到对象都是唯一</span></span><br><span class="line"><span class="comment">        单例设计模式的实现：</span></span><br><span class="line"><span class="comment">            1. 一定要私有化构造方法 --&gt; 防止外界调用构造方法创建对象</span></span><br><span class="line"><span class="comment">            2. 提供一个私有静态常量对象，这个对象就是单例类唯一创建对象</span></span><br><span class="line"><span class="comment">            3. 提供一个静态方法，获取这个创建好的对象，得到实例【外界只能通过这个方法获取对象】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Bank</span> <span class="variable">bank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> bank;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        在外界创建生产者与消费者线程对象中都是可以获取到CPU资源</span></span><br><span class="line"><span class="comment">        但是问题在于，如果消费者先获取到资源，但是没有数据不能消费</span></span><br><span class="line"><span class="comment">        所以就提供一个变量来存储状态的，通过对这个状态的判断决定执行哪个线程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *生产者向共享资源中存储数据的方法【生产】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 存储钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//添加线程通信操作</span></span><br><span class="line">                <span class="keyword">if</span>(isEmpty)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//如果条件为true值，就证明现在有数据，无需生产</span></span><br><span class="line">                    <span class="comment">//生产这个就进入到等待状态</span></span><br><span class="line">                    <span class="string">&quot;&quot;</span>.wait();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//因为if没有执行就证明，没有数据可以生产</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                money = m + money;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;存了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">                <span class="comment">//生产数据完毕之后需要修改状态信息</span></span><br><span class="line">                isEmpty = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//执行唤醒操作</span></span><br><span class="line">                <span class="string">&quot;&quot;</span>.notify();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *消费者向共享资源中存储数据的方法【消费】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 消费钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">popMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 增加线程通信操作</span></span><br><span class="line">                <span class="comment">//isEmpty状态值 false代表没有数据 true代表有属性</span></span><br><span class="line">                <span class="keyword">if</span>(!isEmpty)    <span class="comment">//没有数据的时候不能执行消费，等待生产</span></span><br><span class="line">                &#123; </span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                        没有数据isEmpty值是false，取非操作 !false --》 true if就执行等待</span></span><br><span class="line"><span class="comment">                        有数据isEmpty值是true ，取非操作 !true --》false if就不执行等待，进行消费</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="string">&quot;&quot;</span>.wait();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//if分支语句不执行就证明有数据，进行消费操作</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                money = money - m;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">                <span class="comment">//修改状态数据</span></span><br><span class="line">                isEmpty = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//进行唤醒操作</span></span><br><span class="line">                <span class="string">&quot;&quot;</span>.notify();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、分析执行流程"><a href="#3、分析执行流程" class="headerlink" title="3、分析执行流程"></a><center>3、分析执行流程</center></h2><ol><li>现有的两个线程生产者【花花】和消费者【菲菲】默认初始isEmpty状态都是false</li><li>消费者【菲菲】先获取到CPU时间片，持有所资源，判断if分支条件为!false,消费者【菲菲】就会释放锁资源并且进入到等待池中</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待池</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    生产者【花花】</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ol start="3"><li>等待池中生产者【花花】就会或得到执行CPU时间片，并且获取到锁资源，判断if分支条件false，证明没有数据，生产数据并且唤醒等待池中【菲菲】修改isEmpty值true，生产者线程就执行完毕了</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待池</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    消费者【菲菲】</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ol start="4"><li>此时生产者【花花】和消费者【菲菲】就会再次同时争抢CPU时间片和锁资源对象，假如生产者【花花】再次获取哦到CPU时间片和锁资源对象，执行线程逻辑，判断if分支条件为true，此时花花就会释放资源进入到等待池中</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待池</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    生产者【花花】</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ol start="5"><li>消费者【菲菲】必然获取到CPU时间片，执行操作逻辑判断条件!true 得到是false，就执行消费，并且修改状态为false，唤醒等待池中生产者，这样就完成交替执行效果</li></ol><p><strong>PS：以上这些操作就是典型的一对一生产者与消费者模型</strong></p><h1 id="知识点八：多对多通信模型"><a href="#知识点八：多对多通信模型" class="headerlink" title="知识点八：多对多通信模型"></a><center>知识点八：多对多通信模型</center></h1><p>提供线程对象创建操作， 这里从原有一对一的模式，变成多对多的模式，原来的一个生产者对应一个消费者，修改为了多个生产者对应多个消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//通过单例获取银行对象</span></span><br><span class="line">        <span class="type">Bank</span> <span class="variable">bank1</span> <span class="operator">=</span> Bank.getInstance();</span><br><span class="line">        <span class="comment">//2.创建线程对象并启动操作</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(bank1),<span class="string">&quot;花花1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(bank1),<span class="string">&quot;菲菲2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(bank1),<span class="string">&quot;花花3&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(bank1),<span class="string">&quot;菲菲4&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当将线程对象增多之后，执行多线程同时操作就出现两个问题“<strong>负数问题和死等待问题</strong>”</p><h2 id="1、负数问题"><a href="#1、负数问题" class="headerlink" title="1、负数问题"></a><center>1、负数问题</center></h2><p>现有线程【花花1（存)、菲菲2（取）、花花3（存）、菲菲4（取）】，模拟一个执行流程</p><ol><li>菲菲2先抢到线程，不能取，所以进入到等待队列中，释放CPU时间片和释放锁资源</li><li>菲菲4抢到线程资源，不能取，所以进入到等待列中，释放CPU时间片和释放锁资源</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待队列 菲菲2、菲菲4</span></span><br></pre></td></tr></table></figure><ol start="3"><li>花花1抢到线程，存储了数据，修改标记为true值，并唤醒等待队列中的线程的线程对象，现在使用唤醒机制notify方法【随机唤醒一个等待队列汇总线程对象】，假设唤醒了菲菲4</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待队列中 菲菲2</span></span><br><span class="line"><span class="comment">//外部争抢CPU操作的时间片 花花1、花花3、菲菲4</span></span><br><span class="line"><span class="comment">//临界资源中存储数据是 ---》 1000</span></span><br></pre></td></tr></table></figure><ol start="4"><li>菲菲4抢到了线程，在哪里等待就在哪里被唤醒，而且if分支语句特点，只会执行一次判断即if分支条件判断完成之后【不添加循环前提】，只会执行一次判断，菲菲4正好是在if分支语句中进行等待操作，醒来之后机会继续向后执行【它是不会在判断if分支语句】，菲菲4进行正常消费，修改标记为false，需要执行notify，唤醒等待队列菲菲2【菲菲2这个线程是通过wait进入到等待状态，它已经执行了if判断】</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待队列中 空</span></span><br><span class="line"><span class="comment">// 外部增强CPU操作者时间片 花花1、菲菲2【从等待状态恢复而来】、花花3、菲菲4</span></span><br><span class="line"><span class="comment">// 临界资源中存储的数据是 ----》 0 【因为菲菲4消费了】</span></span><br></pre></td></tr></table></figure><ol start="5"><li>菲菲2抢到了执行权，会在if分支语句继续执行操作，此时虽然标记已经修改为false，正常而言不应该消费的，但是if分支语句已经被执行过，所以不会进行判断继续执行，进行消费，修改标记，执行唤醒</li></ol><p>但是现在的数据是 0 在执行消费出现数据就是 -1000</p><p><strong>为了保证线程通信可以正常执行，建议在开发的时候，不要书写if作为状态判断操作，建议使用while循环语句替代if分支，while循环语句只有条件为false，才不执行，否者就继续执行，这样就可以让等待位置线程在次被唤醒之后可以再次判断状态操作，以防出现错误数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.Thread.waitAndnotfiny.V3;</span><br><span class="line"><span class="comment">//通信的版本【多对多】 ---》 提供临界资源并提供操作[添加线程通信和同步代码块+sleep方法]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bank</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    临界资源一共有两种提供方式【提供成员变量和提供静态变量】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;<span class="comment">//存储前的临界变量</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        外界无论如何创建Bank类对象，都需要是唯一的，不然的话成员变量会跟着对象多少而进行创建</span></span><br><span class="line"><span class="comment">        提供对象唯一创建方式【单例设计模式】</span></span><br><span class="line"><span class="comment">        单例设计模式可以保证外界无论如何操作得到对象都是唯一</span></span><br><span class="line"><span class="comment">        单例设计模式的实现：</span></span><br><span class="line"><span class="comment">        1. 一定要私有化构造方法 --&gt; 防止外界调用构造方法创建对象</span></span><br><span class="line"><span class="comment">        2. 提供一个私有静态常量对象，这个对象就是单例类唯一创建对象</span></span><br><span class="line"><span class="comment">        3. 提供一个静态方法，获取这个创建好的对象，得到实例【外界只能通过这个方法获取对象】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Bank</span> <span class="variable">bank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> bank;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        在外界创建生产者与消费者线程对象中都是可以获取到CPU资源</span></span><br><span class="line"><span class="comment">        但是问题在于，如果消费者先获取到资源，但是没有数据不能消费</span></span><br><span class="line"><span class="comment">        所以就提供一个变量来存储状态的，通过对这个状态的判断决定执行哪个线程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *生产者向共享资源中存储数据的方法【生产】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 存储钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//添加线程通信操作</span></span><br><span class="line">                <span class="comment">//只需要将if修改为while即可</span></span><br><span class="line">                <span class="keyword">while</span>(isEmpty)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//如果条件为true值，就证明现在有数据，无需生产</span></span><br><span class="line">                    <span class="comment">//生产这个就进入到等待状态</span></span><br><span class="line">                    <span class="string">&quot;&quot;</span>.wait();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//因为if没有执行就证明，没有数据可以生产</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                money = m + money;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;存了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">                <span class="comment">//生产数据完毕之后需要修改状态信息</span></span><br><span class="line">                isEmpty = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//执行唤醒操作</span></span><br><span class="line">                <span class="string">&quot;&quot;</span>.notify();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *消费者向共享资源中存储数据的方法【消费】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 消费钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">popMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 增加线程通信操作</span></span><br><span class="line">                <span class="comment">//isEmpty状态值 false代表没有数据 true代表有属性</span></span><br><span class="line">                <span class="comment">//只需要将if修改为while即可</span></span><br><span class="line">                <span class="keyword">while</span>(!isEmpty)    <span class="comment">//没有数据的时候不能执行消费，等待生产</span></span><br><span class="line">                &#123; </span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                        没有数据isEmpty值是false，取非操作 !false --》 true if就执行等待</span></span><br><span class="line"><span class="comment">                        有数据isEmpty值是true ，取非操作 !true --》false if就不执行等待，进行消费</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="string">&quot;&quot;</span>.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//if分支语句不执行就证明有数据，进行消费操作</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                money = money - m;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">                <span class="comment">//修改状态数据</span></span><br><span class="line">                isEmpty = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//进行唤醒操作</span></span><br><span class="line">                <span class="string">&quot;&quot;</span>.notify();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、死等待问题"><a href="#2、死等待问题" class="headerlink" title="2、死等待问题"></a><center>2、死等待问题</center></h2><p>所有线程都进入到等待池中无人唤醒</p><p><strong>PS：这个效果是需要特殊情况下才会出现【它属于一个极端情况】</strong></p><p><strong>这个原因的产生就是使用notfiy随机唤醒机制</strong></p><p>现有线程【花花1（存)、菲菲2（取）、花花3（存）、菲菲4（取）】模拟一个执行流程</p><ol><li>菲菲2先抢到线程，不能取，所以进入到等待池中，释放锁和CPU时间片</li><li>菲菲4抢到线程，不能取，所以进入到等待池中，释放锁和CPU时间片</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待队列中 菲菲2、菲菲4</span></span><br></pre></td></tr></table></figure><ol start="3"><li>花花1抢到线程，存储数据，修改标记为true并进行唤醒操作【随机唤醒】</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待队列中 菲菲2</span></span><br><span class="line"><span class="comment">//争抢CPU资源 花花1、花花3、菲菲4</span></span><br></pre></td></tr></table></figure><ol start="4"><li>花花1在次获取线程，不能存储，所以要进入到等待队列中，释放锁和CPU时间片</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待队列中 菲菲2、花花1 //争抢CPU资源 花花3、菲菲4</span></span><br></pre></td></tr></table></figure><ol start="5"><li>花花3抢到线程，不能存储，所以要进入到等待队列中，释放锁和CPU时间片</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待队列中 菲菲2、花花1、花花3 //争抢CPU资源 菲菲4</span></span><br></pre></td></tr></table></figure><ol start="6"><li>菲菲4抢到线程，取钱消费，修改标记为false，并进入唤醒操作【随机唤醒】 –》 菲菲2唤醒</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待队列汇总 花花1、花花3 //争抢CPU资源 菲菲4、菲菲2 ，现在状态时false</span></span><br></pre></td></tr></table></figure><ol start="7"><li>生产者都在等待队列中，外部都是消费这个，现在状态时false</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待队列中 花花1、花花3、菲菲4、菲菲2</span></span><br></pre></td></tr></table></figure><p>所有线程都进入到等待队列中，无人唤醒就出现死的等待问题</p><p>&ensp;&ensp;&ensp;&ensp;之所以会出现死等待原因就因为使用了notify的操作，它是随机唤醒，等待池中两个消费，外界两个生产【生产完毕，状态修改，无法唤醒】，或等待池中两个生产，外界两个消费【消费完毕，状态修改，无法唤醒】，<strong>建议使用notifyAll 替换 notfiy</strong>，进行全部唤醒，然后再进行条件判断执行操作，决定好是否存储与消费</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通信的版本 ---》 提供临界资源并提供操作[添加线程通信和同步代码块+sleep方法]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bank</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        临界资源一共有两种提供方式【提供成员变量和提供静态变量】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;<span class="comment">//存储前的临界变量</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        外界无论如何创建Bank类对象，都需要是唯一的，不然的话成员变量会跟着对象多少而进行创建</span></span><br><span class="line"><span class="comment">        提供对象唯一创建方式【单例设计模式】</span></span><br><span class="line"><span class="comment">        单例设计模式可以保证外界无论如何操作得到对象都是唯一</span></span><br><span class="line"><span class="comment">        单例设计模式的实现：</span></span><br><span class="line"><span class="comment">        1. 一定要私有化构造方法 --&gt; 防止外界调用构造方法创建对象</span></span><br><span class="line"><span class="comment">        2. 提供一个私有静态常量对象，这个对象就是单例类唯一创建对象</span></span><br><span class="line"><span class="comment">        3. 提供一个静态方法，获取这个创建好的对象，得到实例【外界只能通过这个方法获取对象】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Bank</span> <span class="variable">bank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> bank;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        在外界创建生产者与消费者线程对象中都是可以获取到CPU资源</span></span><br><span class="line"><span class="comment">        但是问题在于，如果消费者先获取到资源，但是没有数据不能消费</span></span><br><span class="line"><span class="comment">        所以就提供一个变量来存储状态的，通过对这个状态的判断决定执行哪个线程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *生产者向共享资源中存储数据的方法【生产】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 存储钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//添加线程通信操作</span></span><br><span class="line">                <span class="keyword">while</span>(isEmpty)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//如果条件为true值，就证明现在有数据，无需生产</span></span><br><span class="line">                    <span class="comment">//生产这个就进入到等待状态</span></span><br><span class="line">                    <span class="string">&quot;&quot;</span>.wait();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//因为if没有执行就证明，没有数据可以生产</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                money = m + money;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;存了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">                <span class="comment">//生产数据完毕之后需要修改状态信息</span></span><br><span class="line">                isEmpty = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//执行唤醒操作进行全部唤醒操作</span></span><br><span class="line">                <span class="string">&quot;&quot;</span>.notifyAll();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *消费者向共享资源中存储数据的方法【消费】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 消费钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">popMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 增加线程通信操作</span></span><br><span class="line">                <span class="comment">//isEmpty状态值 false代表没有数据 true代表有属性</span></span><br><span class="line">                <span class="keyword">while</span>(!isEmpty)    <span class="comment">//没有数据的时候不能执行消费，等待生产</span></span><br><span class="line">                &#123; </span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    没有数据isEmpty值是false，取非操作 !false --》 true if就执行等待</span></span><br><span class="line"><span class="comment">                    有数据isEmpty值是true ，取非操作 !true --》false if就不执行等待，进行消费</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="string">&quot;&quot;</span>.wait();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//if分支语句不执行就证明有数据，进行消费操作</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                money = money - m;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">                <span class="comment">//修改状态数据</span></span><br><span class="line">                isEmpty = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//进行唤醒操作修改为全部唤醒</span></span><br><span class="line">                <span class="string">&quot;&quot;</span>.notifyAll();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：如果在日后的开发中出现线程通信操作，建议判断状态标签的位置使用while关键字而不是if，进行唤醒操作建议使用notfiyAll而不是notify</strong></p><h2 id="3、扩展：Lock接口【显示锁】"><a href="#3、扩展：Lock接口【显示锁】" class="headerlink" title="3、扩展：Lock接口【显示锁】"></a><center>3、扩展：Lock接口【显示锁】</center></h2><p>Lock接口是Java5中新加入与Synchronized比较操作，它属于显示定义，结构更加灵活，提供了一个更加便捷的操作，相对比synchronized更加简洁易用</p><p>PS：这个锁资源Lock虽然语法更加简洁易用，但是它不能定义锁对象，Lock使用锁对象是【this】，<strong>使用Lock时就需要保证this的唯一性了</strong></p><p><strong>Lock锁如何操作？</strong></p><p>&ensp;&ensp;&ensp;&ensp;Lock是一个接口所以需要使用到他实现类进行锁的操作</p><p><strong>ReentrantLock</strong>提供两常用操作</p><table><thead><tr><th align="center">Lock锁方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">lock()</td><td align="center">添加锁(对象上锁)</td></tr><tr><td align="center">unlock()</td><td align="center">释放锁(对象所释放)</td></tr></tbody></table><p>&ensp;&ensp;&ensp;&ensp;以为Lock是一个显示锁对象，所有不能调用Object类中提供wait、notify、notifyAll方法进行线程通信，所以系统就提供了<strong>一个和Lock锁一起使用线程通信接口Condititon</strong></p><table><thead><tr><th align="center">通信方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">await()</td><td align="center">线程等待释放锁资源和CPU时间片</td></tr><tr><td align="center">signal()</td><td align="center">唤醒等待池中某一个线程对象【随机唤醒】</td></tr><tr><td align="center">signalAll()</td><td align="center">唤醒等待池中所有线程对象</td></tr></tbody></table><p>使用Lock锁替代Synchronized同步代码块进行数据操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="comment">//通信的版本【多对多】 ---》 提供临界资源并提供操作[添加线程Lock锁+sleep方法+线程通信]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankLock</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        临界资源一共有两种提供方式【提供成员变量和提供静态变量】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;<span class="comment">//存储前的临界变量</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        外界无论如何创建Bank类对象，都需要是唯一的，不然的话成员变量会跟着对象多少而进行创建</span></span><br><span class="line"><span class="comment">        提供对象唯一创建方式【单例设计模式】</span></span><br><span class="line"><span class="comment">        单例设计模式可以保证外界无论如何操作得到对象都是唯一</span></span><br><span class="line"><span class="comment">        单例设计模式的实现：</span></span><br><span class="line"><span class="comment">        1. 一定要私有化构造方法 --&gt; 防止外界调用构造方法创建对象</span></span><br><span class="line"><span class="comment">        2. 提供一个私有静态常量对象，这个对象就是单例类唯一创建对象</span></span><br><span class="line"><span class="comment">        3. 提供一个静态方法，获取这个创建好的对象，得到实例【外界只能通过这个方法获取对象】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">BankLock</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">BankLock</span> <span class="variable">bank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BankLock</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BankLock <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> bank;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//提供锁资源对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">//提供线程通信资源对象【它是接口不能new，使用lock对象调用newCondition创建】</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        在外界创建生产者与消费者线程对象中都是可以获取到CPU资源</span></span><br><span class="line"><span class="comment">        但是问题在于，如果消费者先获取到资源，但是没有数据不能消费</span></span><br><span class="line"><span class="comment">        所以就提供一个变量来存储状态的，通过对这个状态的判断决定执行哪个线程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *生产者向共享资源中存储数据的方法【生产】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 存储钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//synchronized (&quot;&quot;) //替换成lock锁资源对象</span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//添加线程通信操作</span></span><br><span class="line">                <span class="comment">//只需要将if修改为while即可</span></span><br><span class="line">                <span class="keyword">while</span>(isEmpty)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//如果条件为true值，就证明现在有数据，无需生产</span></span><br><span class="line">                    <span class="comment">//生产这个就进入到等待状态</span></span><br><span class="line">                    <span class="comment">// &quot;&quot;.wait();</span></span><br><span class="line">                    condition.await();    <span class="comment">//使用通信资源创建对象</span></span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//因为if没有执行就证明，没有数据可以生产</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                money = m + money;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;存了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">                <span class="comment">//生产数据完毕之后需要修改状态信息</span></span><br><span class="line">                isEmpty = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//执行唤醒操作</span></span><br><span class="line">                <span class="comment">//&quot;&quot;.notifyAll();</span></span><br><span class="line">                condition.signalAll();    <span class="comment">//使用通信资源创建对象</span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> </span><br><span class="line">            &#123;</span><br><span class="line">                lock.unlock(); <span class="comment">//锁资源释放</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *消费者向共享资源中存储数据的方法【消费】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 消费钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">popMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//synchronized (&quot;&quot;) </span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 增加线程通信操作</span></span><br><span class="line">                    <span class="comment">//isEmpty状态值 false代表没有数据 true代表有属性</span></span><br><span class="line">                    <span class="comment">//只需要将if修改为while即可</span></span><br><span class="line">                    <span class="keyword">while</span>(!isEmpty)    <span class="comment">//没有数据的时候不能执行消费，等待生产</span></span><br><span class="line">                    &#123; </span><br><span class="line">                    </span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                            没有数据isEmpty值是false，取非操作 !false --》 true if就执行等待</span></span><br><span class="line"><span class="comment">                            有数据isEmpty值是true ，取非操作 !true --》false if就不执行等待，进行消费</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">                        <span class="comment">//&quot;&quot;.wait();</span></span><br><span class="line">                        condition.await();</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="comment">//if分支语句不执行就证明有数据，进行消费操作</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    money = money - m;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">                    <span class="comment">//修改状态数据</span></span><br><span class="line">                    isEmpty = <span class="literal">false</span>;</span><br><span class="line">                    <span class="comment">//进行唤醒操作</span></span><br><span class="line">                    <span class="comment">// &quot;&quot;.notifyAll();</span></span><br><span class="line">                    condition.signalAll();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点九：线程声明周期"><a href="#知识点九：线程声明周期" class="headerlink" title="知识点九：线程声明周期"></a><center>知识点九：线程声明周期</center></h1><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012240972.png" alt="声明周期" style="zoom:50%;"><p>线程声明周期分为两条线:</p><ol><li>基础线程声明周期： 新建 —》 准备就绪 —》 运行状态 —》 死亡状态</li><li>对线程添加了一些操作造成线程阻塞现象的产生【sleep、join、wait、synchronized等等】</li></ol><p>新建 —》 准备就绪 —》 运行状态 —》【 阻塞状态 —》 准备就绪 —》 运行状态】 —》 死亡状态</p><p>PS：在阻塞状态没有消失之前</p><p>准备就绪 —》 运行状态 —》阻塞状态 —》 准备就绪 —》 运行状态 ….. 【会一直重复执行】</p><p>1、新建状态(new):使用new创建一个线程对象,仅仅在堆中分配内存空间,在调用start方法之前.</p><p>&ensp;&ensp;&ensp;&ensp;新建状态下,线程压根就没有启动,仅仅只是存在一个线程对象而已.</p><p>&ensp;&ensp;&ensp;&ensp;Thread t &#x3D; new Thread();&#x2F;&#x2F;此时t就属于新建状态</p><p>&ensp;&ensp;&ensp;&ensp;当新建状态下的线程对象调用了start方法,此时从新建状态进入可运行状态</p><p>&ensp;&ensp;&ensp;&ensp;线程对象的start方法只能调用一次,否则报错:IllegalThreadStateException</p><p>2、可运行状态(runnable):分成两种状态，ready和running。分别表示就绪状态和运行状态</p><p>&ensp;&ensp;&ensp;&ensp;就绪状态:线程对象调用start方法之后,等待JVM的调度(此时该线程并没有运行).</p><p>&ensp;&ensp;&ensp;&ensp;运行状态:线程对象获得JVM调度,如果存在多个CPU,那么允许多个线程并行运行</p><p>3、阻塞状态(blocked):正在运行的线程因为某些原因放弃CPU,暂时停止运行,就会进入阻塞状态.</p><p>&ensp;&ensp;&ensp;&ensp;此时JVM不会给线程分配CPU,直到线程重新进入就绪状态,才有机会转到运行状态.</p><p>&ensp;&ensp;&ensp;&ensp;阻塞状态只能先进入就绪状态,不能直接进入运行状态</p><p>&ensp;&ensp;&ensp;&ensp;阻塞状态的两种情况:</p><p>&ensp;&ensp;&ensp;&ensp;（1）当A线程处于运行过程时,试图获取同步锁时,却被B线程获取.此时JVM把当前A线程存到对象的锁池中,A线程进入阻塞状态.</p><p>&ensp;&ensp;&ensp;&ensp;（2）当线程处于运行过程时,发出了IO请求时,此时进入阻塞状态</p><p>4、等待状态(waiting)(等待状态只能被其他线程唤醒):此时使用的无参数的wait方法,</p><p>&ensp;&ensp;&ensp;&ensp;（1）当线程处于运行过程时,调用了wait()方法,此时JVM把当前线程存在对象等待池中</p><p>5、计时等待状态(timed waiting)(使用了带参数的wait方法或者sleep方法)</p><p>&ensp;&ensp;&ensp;&ensp;(1)当线程处于运行过程时,调用了wait(long time)方法,此时JVM把当前线程存在对象等待池中.</p><p>&ensp;&ensp;&ensp;&ensp;(2)当前线程执行了sleep(long time)方法.</p><p>6、终止状态(terminated):通常称为死亡状态，表示线程终止.</p><p>&ensp;&ensp;&ensp;&ensp;(1)正常执行完run方法而退出(正常死亡).</p><p>&ensp;&ensp;&ensp;&ensp;(2)遇到异常而退出(出现异常之后,程序就会中断)(意外死亡)</p><p>线程一旦终止,就不能再重启启动,否则报错(IllegalThreadStateException).</p><p>在Thread类中过时的方法(因为存在线程安全问题,所以弃用了【真心好用，绝对不能用】)</p><p>&ensp;&ensp;&ensp;&ensp;void suspend() :暂停当前线程</p><p>&ensp;&ensp;&ensp;&ensp;void resume() :恢复当前线程</p><p>&ensp;&ensp;&ensp;&ensp;void stop() :结束当前线程</p><h1 id="知识点十：拓展"><a href="#知识点十：拓展" class="headerlink" title="知识点十：拓展"></a><center>知识点十：拓展</center></h1><h2 id="1、线程池【重点】"><a href="#1、线程池【重点】" class="headerlink" title="1、线程池【重点】"></a><center>1、线程池【重点】</center></h2><h3 id="（1）线程池概念"><a href="#（1）线程池概念" class="headerlink" title="（1）线程池概念"></a>（1）线程池概念</h3><p>如果有非常的多的任务需要多线程来完成，且每个线程执行时间不会太长，这样频繁的创建和销毁线程。</p><p>频繁创建和销毁线程会比较耗性能。有了线程池就不要创建更多的线程来完成任务，因为线程可以重用</p><p>线程池用维护者一个队列，队列中保存着处于等待（空闲）状态的线程。不用每次都创建新的线程</p><h3 id="（2）线程池实现原理"><a href="#（2）线程池实现原理" class="headerlink" title="（2）线程池实现原理"></a>（2）线程池实现原理</h3><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012242641.png" alt="实现原理" style="zoom:50%;"><h3 id="（3）线程池中常见的类"><a href="#（3）线程池中常见的类" class="headerlink" title="（3）线程池中常见的类"></a>（3）线程池中常见的类</h3><p>常用的线程池接口和类(所在包java.util.concurrent)</p><p>Executor：线程池的顶级接口。</p><p>ExecutorService：线程池接口，可过submit(Runnable task) 提交任务代码</p><p>Executors工厂类：通过此类可以获得一个线程池</p><table><thead><tr><th align="center">方法名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">newFixedThreadPool(int nThreads)</td><td align="center">获取固定数量的线程池。参数：指定线程池中线程的数量</td></tr><tr><td align="center">newCachedThreadPool()</td><td align="center">获得动态数量的线程池，如不够则创建新的，无上限</td></tr></tbody></table><p><strong>创建方法一：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qf.demo.thread1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作者：星仔</span></span><br><span class="line"><span class="comment"> * 描述：永无Bug</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建一个线程池对象   创建了一个固定数量3个的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);   <span class="comment">//返回ExecutorService对象</span></span><br><span class="line">        <span class="comment">//2.通过线程池对象调用sumit方法来提交线程任务</span></span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable1</span>());   <span class="comment">//传入实现runnable接口的类</span></span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable2</span>());</span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable3</span>());</span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable4</span>());</span><br><span class="line">        <span class="comment">//3.结束线程池</span></span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable3</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">20</span>; i &lt; <span class="number">30</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable4</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">30</span>; i &lt; <span class="number">40</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建方式二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qf.demo.thread1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作者：星仔</span></span><br><span class="line"><span class="comment"> * 描述：永无Bug</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo02</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建一个线程池对象   创建一个带缓存的连接池对象</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//2.通过线程池对象，提交线程任务，并启动线程执行任务</span></span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;--&gt;&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;--&gt;&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;--&gt;&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//3.关闭连接池</span></span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（4）Callable接口"><a href="#（4）Callable接口" class="headerlink" title="（4）Callable接口"></a>（4）Callable接口</h3><p>JDK5加入，与Runnable接口类似，实现之后代表一个线程任务。</p><p>Callable具有泛型返回值、可以声明异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt; V &gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不使用返回值和Runnable的作用一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qf.demo.thread1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作者：星仔</span></span><br><span class="line"><span class="comment"> * 描述：永无Bug</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建一个线程对象</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//2.通过线程池对象提交线程任务，并启动线程执行任务</span></span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.关闭线程对象</span></span><br><span class="line">        es.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>   <span class="comment">//Callable接口的泛型表示call方法返回值的类型</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qf.demo.thread1;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作者：星仔</span></span><br><span class="line"><span class="comment"> * 描述：永无Bug</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableDemo02</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建一个线程对象</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//2.通过线程池对象提交线程任务，并启动线程执行任务</span></span><br><span class="line">        Future&lt;String&gt; future = es.submit(<span class="keyword">new</span> <span class="title class_">MyCallable2</span>());   <span class="comment">//保存线程的返回结果</span></span><br><span class="line">        System.out.println(future.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.关闭线程对象</span></span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable2</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;这是call方法返回值&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qf.demo.thread1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作者：星仔</span></span><br><span class="line"><span class="comment"> * 描述：永无Bug</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableDemo03</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//需求：线程A 计算1~50 线程B 51~100  最终得到结果</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        Future&lt;Integer&gt; f1 = es.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">51</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    sum += i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Future&lt;Integer&gt; f2 = es.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">51</span>; i &lt; <span class="number">101</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    sum += i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;结果为:&quot;</span> + (f1.get() + f2.get()));</span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（5）Future接口"><a href="#（5）Future接口" class="headerlink" title="（5）Future接口"></a>（5）Future接口</h3><p>Future接口表示将要执行完任务的结果。</p><p>get()以阻塞形式等待Future中的异步处理结果（call()的返回值）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCallable2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Runnable接口和Callable接口的区别？</span></span><br><span class="line"><span class="comment">    * 1、这两个接口都可以当做线程任务提交并执行</span></span><br><span class="line"><span class="comment">    * 2、Callable接口执行完线程任务之后有返回值，而Runnable接口没有返回值</span></span><br><span class="line"><span class="comment">    * 3、Callable接口中的call方法已经抛出了异常，而Runnable接口不能抛出编译异常</span></span><br><span class="line"><span class="comment">    * Future接口：</span></span><br><span class="line"><span class="comment">    * 用于接口Callable线程任务的返回值。</span></span><br><span class="line"><span class="comment">    * get()方法当线程任务执行完成之后才能获取返回值，这个方法是一个阻塞式的方法</span></span><br><span class="line"><span class="comment">    *随堂案例：</span></span><br><span class="line"><span class="comment">    * 使用两个线程，并发计算1-100的和， 一个线程计算1~50,另一个线程计算51~100， 最终汇总结果</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException,</span><br><span class="line">ExecutionException </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1、创建线程池对象</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//2、通过线程池提交线程并执行任务</span></span><br><span class="line">        Future&lt;String&gt; future = es.submit(<span class="keyword">new</span> <span class="title class_">MyCallable1</span>());</span><br><span class="line">        <span class="comment">//获取线程任务的返回值</span></span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;哈哈哈哈哈哈&quot;</span>);</span><br><span class="line">        <span class="comment">//3、关闭线程池</span></span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable1</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&gt;&quot;</span>+i);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;这是Callable线程任务的返回值&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（6）读写锁"><a href="#（6）读写锁" class="headerlink" title="（6）读写锁"></a>（6）读写锁</h3><p>ReentrantReadWriteLock：</p><p>&ensp;&ensp;&ensp;&ensp;一种支持一写多读的同步锁，读写分离，可分别分配读锁、写锁。</p><p>&ensp;&ensp;&ensp;&ensp;支持多次分配读锁，使多个读操作可以并发执行。</p><p>互斥规则：</p><p>&ensp;&ensp;&ensp;&ensp;写-写：互斥，阻塞</p><p>&ensp;&ensp;&ensp;&ensp;读-写：互斥，读阻塞写、写阻塞读。</p><p>&ensp;&ensp;&ensp;&ensp;读-读：不互斥、不阻塞。</p><p>&ensp;&ensp;&ensp;&ensp;在读操作远远高于写操作的环境中，可在保障线程安全的情况下，提高运行效率</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qf.demo.thread2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作者：星仔</span></span><br><span class="line"><span class="comment"> * 描述：永无Bug</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriterLockDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//记录开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//1.创建线程池对象</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//2.提交8个读操作任务，提交2个写操作任务</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        <span class="type">ReadThread</span> <span class="variable">readThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReadThread</span>(user);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            es.submit(readThread);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="type">WriteThread</span> <span class="variable">writeThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WriteThread</span>(user);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            es.submit(writeThread);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.结束线程池</span></span><br><span class="line">        es.shutdown();</span><br><span class="line">        <span class="comment">//es.isTerminated();    获取当前线程池的状态，如果线程池钟的任务执行结束，那么返回true，否则返回false</span></span><br><span class="line">        <span class="comment">//System.out.println(es.isTerminated());</span></span><br><span class="line">        <span class="comment">//我们希望以下的代码在线程任务执行结束之后再执行.利用代码空转来判断</span></span><br><span class="line">        <span class="keyword">while</span> (!es.isTerminated())</span><br><span class="line">        &#123;&#125;</span><br><span class="line">        <span class="comment">//记录结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时&quot;</span> + (end-start) + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写线程</span></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">WriteThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    User user;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WriteThread</span><span class="params">(User user)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        user.setName(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReadThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    User user;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReadThread</span><span class="params">(User user)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        user.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//读写锁</span></span><br><span class="line">    <span class="type">ReentrantReadWriteLock</span> <span class="variable">rrwl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="comment">//读锁</span></span><br><span class="line">    ReentrantReadWriteLock.<span class="type">ReadLock</span> <span class="variable">readLock</span> <span class="operator">=</span> rrwl.readLock();</span><br><span class="line">    <span class="comment">//写锁</span></span><br><span class="line">    ReentrantReadWriteLock.<span class="type">WriteLock</span> <span class="variable">writeLock</span> <span class="operator">=</span> rrwl.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读操作</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读和写都需要花一秒，而读和读是不影响的，读和写的互斥的，写和写是互斥的</span></span><br><span class="line"><span class="comment">//class User</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    private String name;</span></span><br><span class="line"><span class="comment">//    Lock lock = new ReentrantLock();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    //写操作</span></span><br><span class="line"><span class="comment">//    public void setName(String name)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        lock.lock();</span></span><br><span class="line"><span class="comment">//        try</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            Thread.sleep(1000);</span></span><br><span class="line"><span class="comment">//            this.name = name;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        catch (InterruptedException e)</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        finally</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            lock.unlock();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    //读操作</span></span><br><span class="line"><span class="comment">//    public String getName()</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        lock.lock();</span></span><br><span class="line"><span class="comment">//        try</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            Thread.sleep(1000);</span></span><br><span class="line"><span class="comment">//            return name;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        catch (InterruptedException e)</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        finally</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            lock.unlock();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        return null;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><h3 id="（7）重入锁"><a href="#（7）重入锁" class="headerlink" title="（7）重入锁"></a>（7）重入锁</h3><p>重入锁:在同步锁中可以继续加入同步锁(锁对象是同一个)</p><p>&ensp;&ensp;&ensp;&ensp;synchronized和Lock锁都可以实现锁的重入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestReentrantLock</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 重入锁:在同步锁中可以继续加入同步锁(锁对象是同一个)</span></span><br><span class="line"><span class="comment">    * synchronized和Lock锁都可以实现锁的重入</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        a();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//当前锁对象为this</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        b();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//当前锁对象为this</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        c();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">c</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（8）公平锁"><a href="#（8）公平锁" class="headerlink" title="（8）公平锁"></a>（8）公平锁</h3><p>公平锁和非公平锁</p><p>&ensp;&ensp;&ensp;&ensp;非公平锁：优先使用上一个线程接着执行下面的线程任务</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;synchronized是非公平锁的实现，无法实现公平锁</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;lock锁默认是非公平锁，如果想要实现公平锁，那么需要在构造方法设置为true</p><p>&ensp;&ensp;&ensp;&ensp;公平锁：让每个线程都公平去执行线程任务</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;lock锁可以实现公平锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Lock锁实现公平锁 参数为true表示是公平锁，默认是false表示非公平锁</span></span><br><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;知识点一：Thread线程基础&quot;&gt;&lt;a href=&quot;#知识点一：Thread线程基础&quot; class=&quot;headerlink&quot; title=&quot;知识点一：Thread线程基础&quot;&gt;&lt;/a&gt;&lt;center&gt;知识点一：Thread线程基础&lt;/center&gt;&lt;/h1&gt;&lt;p&gt;有</summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>23.IO流</title>
    <link href="http://example.com/post/3e1167ea.html"/>
    <id>http://example.com/post/3e1167ea.html</id>
    <published>2023-12-30T05:11:05.000Z</published>
    <updated>2024-03-01T12:21:57.526Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识点一：概念"><a href="#知识点一：概念" class="headerlink" title="知识点一：概念"></a><center>知识点一：概念</center></h1><p><strong>PS：IO很简单主要记忆的就是IO中进行文件读写操作</strong></p><p>Java中IO流的作用：IO流在Java中作用就是将内存中数据写入到磁盘进行保存，程序运行时将磁盘中的数据读取到内存中进行处理</p><p>在Java中在没有学习到IO流之前，在程序中所有处理数据都是在内存中进行存储的【栈和堆】，在内存中存储的好处在于【执行效率高】坏处【数据无法持久存储】</p><p>内存中存储体现在于【DVD操作系统】：所有数据使用集合存储之后依旧是在内存中进行存储，每次执行程序时，都会在内存从新初始化集合中数据，这样就造成无论你如何修改集合中数据，只要程序重新运行数据使用保持原始状态</p><p>所以需要将内存中数据保存到磁盘中进行持久保存【将内存中数据写成文件中内容进行保存操作】，如果将内存中数据写到磁盘中，就需要使用到IO流【使用输出流】，数据存存储在磁盘文件之后，程序运行时需要加载磁盘中文件数据【将磁盘文件中内容读取到内存中进行处理】，如果需要将磁盘中文件内读取到内存中，就需要使用到IO流【使用输入流】</p><p>什么是IO流？</p><p>I —》 顾名思义 —》IN(读取、输入、读入) –》将磁盘中文件内容读取到内存中</p><p>O—》 顾名思义 –》OUT(输出、写出、写入) —》将内存中数据写入到磁盘文件中</p><p><strong>IO流就是内存与磁盘【存储设备】之间数据传输通道</strong></p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011942738.png" alt="传输过程" style="zoom:33%;"><p>在程序中所有的数据都是以流的方式进行传输与保存，程序需要数据时使用输入流读取数据，当程序需要保存数据时使用输出流保存数据</p><p>除了对数据保存之外，实际在网页中的文件上传与下载操作就是IO流完成</p><p><strong>PS：IO操作属于“长连接”，需要管理这个连接操作，如果不管理这个连接操作，会造成IO流操作会持续在内存中存在，会造成内存浪费，所以在不使用IO操作下，一定要关闭IO流</strong></p><h1 id="知识点二：Java中提供常用IO流"><a href="#知识点二：Java中提供常用IO流" class="headerlink" title="知识点二：Java中提供常用IO流"></a><center>知识点二：Java中提供常用IO流</center></h1><p>IO流其实就是建立起内存与硬盘【存设备】之间数据传输通道，通过这个通道可以将数据进行读取与写入操作，这个就是IO流本质</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011943586.png" alt="输入输出关系" style="zoom:50%;"><p>可以根据IO流进行简单的分类</p><p>根据流的流向：</p><p>&ensp;&ensp;&ensp;&ensp;输入流： 把存储在磁盘中数据读取到内存中</p><p>&ensp;&ensp;&ensp;&ensp;输出流 : 把内存中数据写入到磁盘中</p><p>根据流中数据：</p><p>&ensp;&ensp;&ensp;&ensp;字节流： 无论是输入还是输出流中数据都是byte类型</p><p>&ensp;&ensp;&ensp;&ensp;字符流： 无论是输入还是输出流中数据都是char类型</p><h1 id="知识点三：字节输入输出流"><a href="#知识点三：字节输入输出流" class="headerlink" title="知识点三：字节输入输出流"></a><center>知识点三：字节输入输出流</center></h1><p>这个流中数据类型就是byte，这个流既可以进行输入操作【读取】，也可以进行输出操作【写出】</p><h2 id="1、InputStream【字节输入流】"><a href="#1、InputStream【字节输入流】" class="headerlink" title="1、InputStream【字节输入流】"></a><center>1、InputStream【字节输入流】</center></h2><p>InputStream流是所有字节输入流的父类，所有字节输入流都要直接或间接继承InputStream</p><p>这个流是一个抽象类不能直接创建对象，所以需要使用到这个流的子类来完成对字节输入流操作</p><p>在API文档中提供创建语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InputStream</span> <span class="keyword">extends</span> <span class="title class_">Object</span> <span class="keyword">implements</span> <span class="title class_">Closeable</span></span><br></pre></td></tr></table></figure><p>在API文档中已知实现之类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AudioInputStream, ByteArrayInputStream,<span class="string">&quot;FileInputStream&quot;</span>, FilterInputStream, InputStream,</span><br><span class="line">ObjectInputStream, PipedInputStream,SequenceInputStream, StringBufferInputStream</span><br></pre></td></tr></table></figure><p>这里多子类中，使用那个之类来操作呢？学习流目的在于什么？–》将内存数据写出到磁盘中【持久保存】，程序需要使用时将磁盘中文件存储内容读取到内存中，整个操作过程中都需要使用磁盘文件，所以就需要操作一个处理文件的流来进行操作 –》需要使用其之类FileInputStream</p><h2 id="2、FileInputSteam【文件字节输入流】"><a href="#2、FileInputSteam【文件字节输入流】" class="headerlink" title="2、FileInputSteam【文件字节输入流】"></a><center>2、FileInputSteam【文件字节输入流】</center></h2><p>FileInputStream是InputStream字节入的子类，这个流主要提供是对文件读取操作，这个文件是泛指【指代的是：所有文档二进制文件（文本文件、音频、视频、压缩包、图片等等）】，都可以通过</p><p>FileInputStream进行读取操作，FileInputSteam是字节输入流所以流中数据是【<strong>byte类型</strong>】</p><p>在API文档中提供创建定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStream</span> <span class="keyword">extends</span> <span class="title class_">InputStream</span></span><br></pre></td></tr></table></figure><p>PS：Java中提供原生流【系统API中定义好流】只能对文本文件中内容进行操作即【txt】文件，无法对Office文件记性操作，如果需要对这些文件进行操作需要导入【第三方jar包（别人封装好实现）】</p><h3 id="（1）核心构造方法"><a href="#（1）核心构造方法" class="headerlink" title="（1）核心构造方法"></a>（1）核心构造方法</h3><table><thead><tr><th align="center">构造方法</th></tr></thead><tbody><tr><td align="center">FileInputStream(File file) 通过一个File对象创建FileInputStream字节输入流对象</td></tr><tr><td align="center">FileInputStream(String name) 通过一个String对象(文件的路径)创建FileInputStream字节输入流对象</td></tr></tbody></table><p>PS：这两个构造方法创建出对象方式是一样的，只是参数不一样，个人选取</p><h3 id="（2）核心API方法"><a href="#（2）核心API方法" class="headerlink" title="（2）核心API方法"></a>（2）核心API方法</h3><table><thead><tr><th align="center">返回值类型</th><th align="center">方法说明</th></tr></thead><tbody><tr><td align="center">int</td><td align="center">read() 一次读取一个字节的数据</td></tr><tr><td align="center">int</td><td align="center">read(byte[] bs) 一次读取参数字节数组长度的数据并存储在字节数组中[常用]</td></tr><tr><td align="center">int</td><td align="center">read(byte[] bs, int off, int len) 一次读取字节数组长度的数据,根据len读取实际内容长度,并从off位置开始入写到字节数组中</td></tr><tr><td align="center">void</td><td align="center">close() IO流式一个长连接,所以需要需要关闭流对象【常用】</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStreamAPIDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//文件字节输入流操作</span></span><br><span class="line">        <span class="comment">//1.提供文件字节输入流对象创建</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            这个构造方法中一共提供两种参数</span></span><br><span class="line"><span class="comment">            第一种传入File --&gt;FileInputStream fis = new FileInputStream(new File(&quot;绝对或相对文件路径&quot;));</span></span><br><span class="line"><span class="comment">            第二种传入String类型参数 --》 String类型赋值时一个路径</span></span><br><span class="line"><span class="comment">            FileInputStream fis = new FileInputStream(&quot;绝对或相对文件路径&quot;);</span></span><br><span class="line"><span class="comment">            在创建文件字节输入流对象同时需要处理创建对象时提供 编译时异常</span></span><br><span class="line"><span class="comment">                         Unhandled exception:java.io.FileNotFoundException</span></span><br><span class="line"><span class="comment">            今天---》使用try-catch进行处理 ---》 特殊用途</span></span><br><span class="line"><span class="comment">            明天---》 throws处理 --》 开发通用</span></span><br><span class="line"><span class="comment">            后续流开发如果出现异常行，自行选择处理方式</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//先声明流资源对象赋值为null值</span></span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//IO流的链接是长链接，所以在不使用IO流前提下要进行关闭操作</span></span><br><span class="line">            <span class="comment">//在try代码块进行流对象具体赋值操作</span></span><br><span class="line">            fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dir/file1.txt&quot;</span>));</span><br><span class="line">            <span class="comment">//读取文件中数据的read方法都有编译时异常Unhandled exception: java.io.IOException</span></span><br><span class="line">            <span class="comment">//1. 一次读取一个字节的内容--》几乎与不使用</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> fis.read();    <span class="comment">//返回文件内容中对应的ASCII，所以要看到读取内容效果需要强制类型转换</span></span><br><span class="line">            System.out.println(<span class="string">&quot;一次读取一个字节的内容是:&quot;</span>+ ((<span class="type">char</span>)read));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//2. 一次读取参数中字节数组长度内容，并且将内容存存储到字节数组中 --》【常用】</span></span><br><span class="line">            <span class="comment">//2.1 需要提供一个字节数组</span></span><br><span class="line">            <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">            <span class="comment">//2.2通过字节输入流对象调用read方法参数是字节数组</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                千万不要理解为:通过fis流对象读取字节数组bs中内容【错误理解】</span></span><br><span class="line"><span class="comment">                真正含义:通过fis流对象读取文件中内容，读取文件中内容是参数bs数组长度，并且将读取到内容存储到bs数组中</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            fis.read(bs);</span><br><span class="line">            <span class="comment">//因为byte类型数组，存储都是整数，所以存储都是文件内容中字符对应十进制形式</span></span><br><span class="line">            System.out.println(Arrays.toString(bs)); <span class="comment">//相当于查看字节数内容，但是不是具体文件中内容</span></span><br><span class="line">            <span class="comment">//利用String这个类构造方法将字节数组转换成字符串查看内容</span></span><br><span class="line">            System.out.println(<span class="string">&quot;读取文件中内容是：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(bs));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//3.一次读取参数中字节数组长度内容并且存储在字节数组中，根据off参数指定下标为开始写入数据，</span></span><br><span class="line">            <span class="comment">// 再根据len参数为基础进行实际读取内容长度作为写入数组中内容长度</span></span><br><span class="line">            <span class="comment">//3.1提供一个byte类型数组</span></span><br><span class="line">            <span class="type">byte</span>[] bs2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>];</span><br><span class="line">            <span class="comment">//3.2在通过文件字节输入流对象调用read方法进行读取</span></span><br><span class="line">            fis.read(bs2,<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line">            System.out.println(Arrays.toString(bs2));</span><br><span class="line">            System.out.println(<span class="string">&quot;读取文件中内容是:&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(bs2));</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (Exception e) </span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//无论try代码块是否出现异常，finally语句代码块都会执行，多用于资源释放 ---》 管理流就是资源释放</span></span><br><span class="line">            <span class="comment">//因为是在try外界创建对象赋值为null，如果赋值成功会存在堆中地址，这样才有关闭价值</span></span><br><span class="line">            <span class="keyword">if</span>(Objects.nonNull(fis))    <span class="comment">//判断数据是否为null</span></span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//释放流资源--》关闭流 --&gt;close方法也有一个编译时异常Unhandled exception: java.io.IOException</span></span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题：如果使用FileInputStream文件字节输入流读取一个文件，这个文件大小未知（文件存储内容不确定），使用刚刚讲解API中 read(byte[]bs) 进行文件内容读取，此时提供byte数组应该多大？，如何获取到文件中所有内容？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStreamLoopReadFile</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供文件字节输入流对象【因为InputStream是</span></span><br><span class="line">        FileInputStream父类，所以可以利用多态创建】</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dir/FileInputStreamAPIDemo.java&quot;</span>));</span><br><span class="line">            <span class="comment">//提供字节数组 ---》 1024 --&gt;给读取文件数组中大小即 1024</span></span><br><span class="line">            <span class="comment">//在开发中如果使用流进行操作，提供byte类型数组或char类型数组使用初始化大小默认给1024</span></span><br><span class="line">            <span class="comment">//如果1024并不能满足你读取文件内容需求，建议倍数递增</span></span><br><span class="line">            <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//因为给定初始容量1024，但是不能完全读取文件中所有内容</span></span><br><span class="line">            <span class="comment">//is.read(bs);</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                只需要让读取文件中内容操作重复执行就行--》提供循环让is.read可以去重复去读文件内容</span></span><br><span class="line"><span class="comment">                提供死循环确实可以让读取操作重复执行，但是需要提供读取文件停止方式，不然话程序执行是不合理</span></span><br><span class="line"><span class="comment">                只需要知道是否读取到文件的末尾，就可以停止循环操作了，如何得到读取到文件末尾的操作？</span></span><br><span class="line"><span class="comment">                read 方法在读取文件数据时，如果读取到文件的末尾返回-1作为提示</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">                //提供一个变量len 存储read读取到长度</span></span><br><span class="line"><span class="comment">                int len = 0;</span></span><br><span class="line"><span class="comment">                while(true)</span></span><br><span class="line"><span class="comment">                &#123;</span></span><br><span class="line"><span class="comment">                    len = is.read(bs);</span></span><br><span class="line"><span class="comment">                    if(len == -1)</span></span><br><span class="line"><span class="comment">                    &#123;</span></span><br><span class="line"><span class="comment">                        break;</span></span><br><span class="line"><span class="comment">                    &#125; </span></span><br><span class="line"><span class="comment">                    System.out.println(new String(bs));</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                通过文件字节读取到数据之后进行打印，发现输出内容末尾的位置多出了一些内容，但是在源文件中是不存在</span></span><br><span class="line"><span class="comment">                当调用read方法读取文件中内容时，是按照bs数组的长度进行读取，然后写入到bs数组中，这是一次读取</span></span><br><span class="line"><span class="comment">                下一次循环读取时，也会按照bs数组的长度进行读取，然后是覆盖写入到bs数组中，即不会清除原有数组中存的内容</span></span><br><span class="line"><span class="comment">                而是直接覆盖进新读取到文件内容到数组</span></span><br><span class="line"><span class="comment">                例如：现在读取文件大小是 4063字节 存储数据数组的大小1024字节</span></span><br><span class="line"><span class="comment">                第一次读取时 4063-1024 --》剩余字节 3039 但是读取到 1024字节内容</span></span><br><span class="line"><span class="comment">                第二次读取时 3039-1024 --》剩余字节 2015 但是读取到 1024字节内容</span></span><br><span class="line"><span class="comment">                第二次读取时 2015-1024 --》剩余字节 991 但是读取到 1024字节内容</span></span><br><span class="line"><span class="comment">                第四次读取时 读取字节是991 并没有填充满1024 --》 实际读取991个字节</span></span><br><span class="line"><span class="comment">                991个字节覆盖到byte数组中之后 会剩余33个字节没有进行覆盖内容</span></span><br><span class="line"><span class="comment">                所以通过new String方式打印数组内容时，就会将33个没有覆盖内容数据打印出来</span></span><br><span class="line"><span class="comment">                read(byte[] bs)这个方法的返回值不仅可以返回读取到文件末尾-1值</span></span><br><span class="line"><span class="comment">                                而且这个方法还可以返回读取到实际文件内容长度的实际值</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">//提供流循环读取文件内容的while循环书写方式</span></span><br><span class="line">            <span class="comment">//需要提供一个存储实际读取文件内容长度变量【包括文件末尾值】</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((len = is.read(bs))!=-<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//循环内部对数组中存储内容进行操作</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    第一个参数是存储数据数组</span></span><br><span class="line"><span class="comment">                    第二个参数是从数组中什么位置开始获取数据【默认值是0(使用是下标值)】</span></span><br><span class="line"><span class="comment">                    第三个参数 实际读取文件内容长度，因为可以避免输出书中没有被覆盖掉内容</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bs,<span class="number">0</span>,len));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (Exception e) </span><br><span class="line">        &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Objects.nonNull(is))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、OutputStream字节输出流"><a href="#3、OutputStream字节输出流" class="headerlink" title="3、OutputStream字节输出流"></a><center>3、OutputStream字节输出流</center></h2><p>OutputStream字节输出流是所有字节输出的父类，所有字节输入出流都是直接或间接继承OutputStream类</p><p>根据API文档中提供类创建方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">OutputStream</span> <span class="keyword">extends</span> <span class="title class_">Object</span> <span class="keyword">implements</span> <span class="title class_">Closeable</span>, Flushable</span><br></pre></td></tr></table></figure><p>OutputStream是抽象类无法直接创建对象使用，所以需要提供子类来完成对流操作</p><p>根据API文档中提供子类有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteArrayOutputStream, *FileOutputStream*,</span><br><span class="line">FilterOutputStream, ObjectOutputStream, OutputStream, PipedOutputStream</span><br></pre></td></tr></table></figure><p>根据现在操作数据原则，将数据从磁盘文件读取到内容，将内存中数据写出到磁盘文件中，始终要处理是File文件，所以使用<strong>子类是FileOutputStream文件字节输出流</strong></p><h2 id="4、FileOutputStream文件字节输出流"><a href="#4、FileOutputStream文件字节输出流" class="headerlink" title="4、FileOutputStream文件字节输出流"></a><center>4、FileOutputStream文件字节输出流</center></h2><p>FileOutputStream文件字节输出流类是OutputStream的子类，这个类主要用用于将内存中存储数据写入到磁盘文件中进行保存操作，这里的文件是泛指【<strong>指代是二进制文件（文本文件、音频、视频、图片、压缩包等等）</strong>】都可以使用FileOutputStream这个流对象将数据写入到磁盘中</p><p>根据API文档中说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileOutputStream</span> <span class="keyword">extends</span> <span class="title class_">OutputStream</span></span><br></pre></td></tr></table></figure><p><strong>核心构造方法</strong></p><table><thead><tr><th align="center">构造方法</th></tr></thead><tbody><tr><td align="center">FileOutputStream(File file) 通过一个File对象(封装的文件路径)创建文件字节输出流对象</td></tr><tr><td align="center">FileOutputStream(File file, boolean append)通过一个File对象(封装的文件路径)创建文件字节输出流对象,并根据第二个参数的值决定是否是对文件进行追加写入数据 true是追加 false 不追加</td></tr><tr><td align="center">FileOutputStream(String name) 通过一个String对象(封装的文件路径)创建文件字节输出流对象</td></tr><tr><td align="center">FileOutputStream(String name, boolean append)通过一个String对象(封装的文件路径)创建文件字节输出流对象,并根据第二个参数的值决定是否是对文件进行追加写入数据 true是追加 false不追加</td></tr></tbody></table><h3 id="（1）核心API方法"><a href="#（1）核心API方法" class="headerlink" title="（1）核心API方法"></a>（1）核心API方法</h3><table><thead><tr><th align="center">void</th><th align="center"><strong>close() 关闭此文件输出流并释放与此流有关的所有系统资源 【常用】</strong></th></tr></thead><tbody><tr><td align="center">void</td><td align="center">write(byte[] b) 将以字节数组长度的内容写入到磁盘文件中</td></tr><tr><td align="center">void</td><td align="center"><strong>write(byte[] b, int off, int len) 将实际len长度的内容****从数组b中off位置开始写入到磁盘文件中【常用】</strong></td></tr><tr><td align="center">void</td><td align="center">write(int b) 一次写一个字节的内容写入到磁盘文件中</td></tr><tr><td align="center">void</td><td align="center"><strong>flush() 加快流的流速,强制清空缓冲区中数据</strong>【加快输出效果（在使用网络流的时候一定要添加）】</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileOutputStreamAPIDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建文件字节输出流对象【一个参数的版本】</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            一个参数的版本参数可以传递两种方式</span></span><br><span class="line"><span class="comment">            第一种：传入File对象 --》fos = new FileOutputStream(new File(&quot;绝对或相对路径文件&quot;));</span></span><br><span class="line"><span class="comment">            第二种：传入String类型对象(代表的是文件的路径)</span></span><br><span class="line"><span class="comment">                                fos = new FileOutputStream(&quot;绝对或相对路径文件&quot;);</span></span><br><span class="line"><span class="comment">            在创建文件字节输出流对象时，需要处理编译时异常 Unhandled exception: java.io.FileNotFoundException</span></span><br><span class="line"><span class="comment">            处理方式 要么 try-catch 要么 throws</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                创建文件字节输出流对象【两个参数的版本】</span></span><br><span class="line"><span class="comment">                第一个参数可以是File对象或String类型对象，只要提供文件绝对或相对路径</span></span><br><span class="line"><span class="comment">                第二个参数需要注意是一个boolean类型参数，传入true时会开启追加写入操作</span></span><br><span class="line"><span class="comment">                    new FileOutputStream(&quot;绝对或相对路径文件&quot;,true);</span></span><br><span class="line"><span class="comment">                或者</span></span><br><span class="line"><span class="comment">                    new FileOutputStream(new File(&quot;绝对或相对路径文件&quot;),true);</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">//写出数据到磁盘中时，磁盘中可以不存在这个文件，在写数据时会自动创建这个文件</span></span><br><span class="line">            fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;dir/file2.txt&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//常用写出方法中都存在一个编译时异常Unhandledexception: java.io.IOException</span></span><br><span class="line">            <span class="comment">//1.一次向文件中写入一个字节的数据</span></span><br><span class="line">            <span class="comment">//fos.write(65);     //参数是int类型对应ASCII值的字符</span></span><br><span class="line">            <span class="comment">//不是“连续”向文件中写入内容，而是再次向file2.txt内容时，覆盖写入</span></span><br><span class="line">            <span class="comment">//2.向文件中一次性写过字节数组中的所有内容</span></span><br><span class="line">            <span class="comment">//getBytes()--&gt;将字符串转换为字节数组</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                如果是分批写入数据，为了防止文件中内容被后一次书写数据进行覆盖，</span></span><br><span class="line"><span class="comment">                可以使用FileOutputStream中构造方法【两个参数版本】，开启追加写入</span></span><br><span class="line"><span class="comment">                一般追加写入的作用都是生成日志文件，记录用户写入一些数据到文件中，一般不追加的比较常用</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            fos.write(<span class="string">&quot;BCDEFGHIJKLMN&quot;</span>.getBytes());    <span class="comment">//getBytes()将字符串转换成字节数组</span></span><br><span class="line">            <span class="comment">//3.从字节数组中将内容写入到文件中，从off参数提供的位置读取数据开始写，写len提供长度内容</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                第一个参数是存储数据字节数组</span></span><br><span class="line"><span class="comment">                第二个参数是从字节数组什么位置开始读取和写出数据【默认0（下标）】</span></span><br><span class="line"><span class="comment">                第三个参数实际写出内容长度（一般会配合输入流中read方法获取实际长度进行写出）</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            fos.write(<span class="string">&quot;BCDEFGHIJKLMN&quot;</span>.getBytes(),<span class="number">6</span>,<span class="string">&quot;HIJKMLN&quot;</span>.length());</span><br><span class="line">            <span class="comment">//执行刷新操作</span></span><br><span class="line">            fos.flush();</span><br><span class="line">            System.out.println(<span class="string">&quot;老子写完了！！！&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (FileNotFoundException e) </span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (IOException e) </span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">finally</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Objects.nonNull(fos))    <span class="comment">//也可以是 fos != null</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//存在一个编译时异常要处理</span></span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、图片拷贝案例"><a href="#5、图片拷贝案例" class="headerlink" title="5、图片拷贝案例"></a><center>5、图片拷贝案例</center></h2><p>利用文件字节输入输出流完成图片拷贝操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.InputStreamAndOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileCopy</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供文件字节输入输出流对象</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dir/1_io.jpg&quot;</span>));</span><br><span class="line">            os = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;desc/1_io.jpg&quot;</span>));</span><br><span class="line">            <span class="comment">//2.一定明确在使用是什么流【字节或字符】-》提供对应数组进行数据存储与接收</span></span><br><span class="line">            <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];    <span class="comment">//提供存储读取数据的字节数组</span></span><br><span class="line">            <span class="comment">//3. 提供一个变量存储读取文件实际内容长度【存储读取到文件末尾-1的值】</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//4.提供流的循环读写操作【读和写都是有编译时异常的要处理】</span></span><br><span class="line">            <span class="keyword">while</span>((len = is.read(bs))!=-<span class="number">1</span>)    <span class="comment">//循环读取数据并存储在bs数组中</span></span><br><span class="line">            &#123; </span><br><span class="line">                <span class="comment">//将存储在bs数组中数据写出到磁盘文件中</span></span><br><span class="line">                os.write(bs,<span class="number">0</span>,len);</span><br><span class="line">            &#125; </span><br><span class="line">            os.flush();    <span class="comment">//刷新</span></span><br><span class="line">            System.out.println(<span class="string">&quot;老子写完了！！！&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (FileNotFoundException e) </span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (IOException e) </span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">finally</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//谁先创建谁最后关闭</span></span><br><span class="line">            <span class="keyword">if</span>(Objects.nonNull(os))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(is))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、利用字节流将文件中的内容进行拷贝赋值操作"><a href="#6、利用字节流将文件中的内容进行拷贝赋值操作" class="headerlink" title="6、利用字节流将文件中的内容进行拷贝赋值操作"></a><center>6、利用字节流将文件中的内容进行拷贝赋值操作</center></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.InputStreamAndOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileCopy2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供字节输入输出流对象</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dir/1.txt&quot;</span>));</span><br><span class="line">            ois = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;desc/1.txt&quot;</span>));</span><br><span class="line">            <span class="comment">//2.明确使用是字节流还是字符流</span></span><br><span class="line">            <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//3.提供循环读写操作【处理编译时异常】</span></span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = fis.read(bs))!=-<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// ois.write(bs,0,len);</span></span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bs,<span class="number">0</span>,len));</span><br><span class="line">            &#125; </span><br><span class="line">            ois.flush();</span><br><span class="line">            System.out.println(<span class="string">&quot;老子写完了！！！&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (FileNotFoundException e) </span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (IOException e) </span><br><span class="line">        &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">finally</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Objects.nonNull(ois))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    ois.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(Objects.nonNull(fis))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结:字节输入输出流在文件进行操作，因为字节流中使用数据类型byte类型主要针对是二进制的文件，所以<strong>字节流主要对的是【图片、音频、视频、压缩包】这类的二进制文件</strong>，在读取和写出文本文件时，会在处理文件时出现一些乱码问题�，所以字节流主要是处理二进制文件而使用，如果处理文件文件的数据就不太建议使用字节流来完成操作，就是因为容易出现乱码问题�</p><h1 id="知识点四：字符输入输出流"><a href="#知识点四：字符输入输出流" class="headerlink" title="知识点四：字符输入输出流"></a><center>知识点四：字符输入输出流</center></h1><p>字符输入输出流是专门用于对文本文件进行操作流，用于弥补字节流对文本文件操作时容易出现乱码的为题，所以用字符输入输出流对文本文件进行处理操作</p><h2 id="1、Reader字符输入流"><a href="#1、Reader字符输入流" class="headerlink" title="1、Reader字符输入流"></a><center>1、Reader字符输入流</center></h2><p>Reader是字符输入的父类，所有字符输入流都要直接或间接继承与Reader类，因为这个流是字符流，所以流中数据是char，要提供数组也是char类型数组</p><p>根据API文档中描述可以发现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Reader</span> <span class="keyword">extends</span> <span class="title class_">Object</span> <span class="keyword">implements</span> <span class="title class_">Readable</span>, Closeable</span><br></pre></td></tr></table></figure><p>提供已知的之类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader, CharArrayReader, FilterReader, InputStreamReader, PipedReader, StringReader</span><br></pre></td></tr></table></figure><p>操作文件FileReader这个类并不是Reader的直接子类，而是间接子类，操作文件FileReader类是继承与InputStreamReader这个类，InputStreamReader这个类是Reader直接子类，可以利用FileReader进行文件操作</p><h2 id="2、FileReader文件字符输入流"><a href="#2、FileReader文件字符输入流" class="headerlink" title="2、FileReader文件字符输入流"></a><center>2、FileReader文件字符输入流</center></h2><p>FileReader是Reader的间接子类，FileReader的直接父类是InputStreamReader，InputStreamReader这个类提供文件编码集和缓冲区操作，API文档中也说明【此类的构造方法假定默认字符编码和默认字节缓冲区大小都是适当的】</p><p>通过流操作文本文件时，文本文件是存在编码集的，在使用FileReader类操作是使用就是默认编码集，这个默认编码集是根据系统进行获取，编码集的目的【提供文件的编码让文件可以达到统一性Unicode(UTF-8)】</p><p>在使用字节流时，API文档中是没有描述字节流具备缓冲区，但是在使用字符流的时，API文档提供缓冲区的概念，当使用流写出数据时，有一个方法<strong>flush方法</strong>，这个方法就是专门针对缓冲区进行设计，提供缓冲这个概念可以大大提高，流的使用效率</p><p>在API文档中提供FileReader中定义描述</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReader</span> <span class="keyword">extends</span> <span class="title class_">InputStreamReader</span></span><br></pre></td></tr></table></figure><p><strong>常用构造方法</strong></p><table><thead><tr><th align="center">构造方法摘要</th></tr></thead><tbody><tr><td align="center">FileReader(File file) 通过一个File对象(封装着文件路径)创建一个FileReader对象进行数据读取</td></tr><tr><td align="center">FileReader(String fileName) 通过一个String对象(封装着文件路径)创建一个FileReader对象进行数据读取</td></tr></tbody></table><h3 id="（1）常用API方法"><a href="#（1）常用API方法" class="headerlink" title="（1）常用API方法"></a>（1）常用API方法</h3><table><thead><tr><th align="center">方法摘要</th><th align="center"></th></tr></thead><tbody><tr><td align="center">void</td><td align="center"><strong>close() 关闭该流并释放与之关联的所有资源</strong></td></tr><tr><td align="center">int</td><td align="center">read() 读取单个字符</td></tr><tr><td align="center">int</td><td align="center"><strong>read(char[] cbuf) 读取字符数组长度的内容(常用)</strong></td></tr><tr><td align="center">int</td><td align="center">read(char[] cbuf, int off, int len) 将读取len的长度内容写入到cbuf数组中并且从off的位置开始在数组中写入</td></tr></tbody></table><p>PS:直接参考FileInputStream即可，只要将byte数组换char数组就可以了</p><h2 id="3、Writer字符输出流"><a href="#3、Writer字符输出流" class="headerlink" title="3、Writer字符输出流"></a><center>3、Writer字符输出流</center></h2><p>Writer字符输入流是所有字符输入流父类，所有字符输入流都要直接或间接继承与Writer，因为这个流是字符流，所以流中数据是char类型，需要提供char类型数组</p><p>根据API文档中描述</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Writer</span> <span class="keyword">extends</span> <span class="title class_">Object</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, Closeable, Flushable</span><br></pre></td></tr></table></figure><p>它是一个抽象类不能直接创建流对象进行操作，所以需要使用到其子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BufferedWriter, CharArrayWriter, FilterWriter, OutputStreamWriter, PipedWriter, PrintWriter, StringWriter</span><br></pre></td></tr></table></figure><p>操作文件的FileWriter这个类不是Writer的直接子类，而是间接子类，但是FileWriter可以完成对文件写出操作</p><h2 id="4、FileWriter文件字符输出流"><a href="#4、FileWriter文件字符输出流" class="headerlink" title="4、FileWriter文件字符输出流"></a><center>4、FileWriter文件字符输出流</center></h2><p>FileWriter是Writer的间接子类，FileWriter的直接父类是OutputStreamWriter，OutputStreamWriter个类提供文件编码集和缓冲区操作，API文档中也说明【此类的构造方法假定默认字符编码和默认字节缓冲区大小都是适当的】</p><p>通过流操作文本文件时，文本文件时存在编码集的，在使用FileWriter类操作时使用就是默认编码集，这个默认编码集是根据系统进行获取，编码集的目的【提供文件的编码让文件可以达到统一性Unicode(UTF-8)】</p><p>在使用字节流时，API文档中是没有描述字节流具备缓冲区，但是在使用字符流的时，API文档提供缓冲区的概念，当使用流写出数据时，有一个方法flush方法，这个方法就是专门针对缓冲区进行设计，提供缓冲这个概念可以大大提高，流的使用效率</p><h3 id="（1）常用构造方法"><a href="#（1）常用构造方法" class="headerlink" title="（1）常用构造方法"></a>（1）常用构造方法</h3><table><thead><tr><th align="center">常用构造方法</th></tr></thead><tbody><tr><td align="center">FileWriter(File file) 构建了一个文件对象FileWriter对象</td></tr><tr><td align="center">FileWriter(File file, boolean append) 构建了一个文件对象FileWriter对象</td></tr><tr><td align="center">FileWriter(String fileName) 构造给定文件名的FileWriter对象</td></tr><tr><td align="center">FileWriter(String fileName, boolean append) 构造FileWriter对象给出一个文件名与一个布尔值，指示是否附加写入的数据</td></tr></tbody></table><p>PS:构建方法中多了一个第二参数，是boolean参数值作用就是提供文件追加写入操作，当设置参数为true时，当前写入文件中数据操作就是追加写入【主要适合：记录日志的工作】，如果是连续写出数据，可以不开启这个操作</p><h3 id="（2）常用API方法"><a href="#（2）常用API方法" class="headerlink" title="（2）常用API方法"></a>（2）常用API方法</h3><table><thead><tr><th align="center">void</th><th align="center">close() 关闭此流，但要先刷新它</th></tr></thead><tbody><tr><td align="center">void</td><td align="center">flush() 刷新该流的缓冲</td></tr><tr><td align="center">void</td><td align="center">write(char[] cbuf) 写入字符数组</td></tr><tr><td align="center">void</td><td align="center">write(char[] cbuf, int off, int len) 从cbuf数组读取数据并写入到文件中,len是实际写出数据长度,off是从cbuf数组中什么位置开始写出 (使用字符数组时核心方法)</td></tr><tr><td align="center">void</td><td align="center">write(int c) 写入单个字符</td></tr><tr><td align="center">void</td><td align="center">write(String str) 写入字符串(非常有用的核心方法)</td></tr></tbody></table><p>PS: 在写出数据到文件中时，只有字符流中会提供一个参数为String类型write方法，这个方法可以帮我们便捷将数据写出到文件中，这个方法极其重要</p><p>FileWriter操作可以完全参考FileOutputStream这个类，基本上是一模一样，只不过将byte类型转换char类型即可</p><h2 id="5、使用字符输入输出流进行文本文件的拷贝操作"><a href="#5、使用字符输入输出流进行文本文件的拷贝操作" class="headerlink" title="5、使用字符输入输出流进行文本文件的拷贝操作"></a><center>5、使用字符输入输出流进行文本文件的拷贝操作</center></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.ReaderAndWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReaderAndFileWriterCopyFile</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供字符输入输出流对象创建</span></span><br><span class="line">        <span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//在创建对象时要处理编译时异常Unhandled exception: java.io.FileNotFoundException 处理方法和字节流一样</span></span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dir/1.txt&quot;</span>));</span><br><span class="line">            writer = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;desc/2.txt&quot;</span>));</span><br><span class="line">            <span class="comment">//2.一定要明确使用是什么流--》字符流</span></span><br><span class="line">            <span class="type">char</span>[] buf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//3. 提供循环读写操作</span></span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = reader.read(buf))!=-<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buf,<span class="number">0</span>,len));</span><br><span class="line">                <span class="comment">//writer.write(buf,0,len);</span></span><br><span class="line">            &#125; </span><br><span class="line">            writer.flush();</span><br><span class="line">            System.out.println(<span class="string">&quot;老子写完了！！！！&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (IOException e) </span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">finally</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Objects.nonNull(writer))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    writer.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(reader))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    reader.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、使用字符输入输出流进行图片的拷贝操作"><a href="#6、使用字符输入输出流进行图片的拷贝操作" class="headerlink" title="6、使用字符输入输出流进行图片的拷贝操作"></a><center>6、使用字符输入输出流进行图片的拷贝操作</center></h2><p>打开拷贝之后图片，观察拷贝之后图片与原来图片的大小</p><p>使用字符流进行图片复制拷贝操作是不可以完成，图片出现问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.ReaderAndWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReaderAndFileWriterCopyFile2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供字符输入输出流对象创建</span></span><br><span class="line">        <span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//在创建对象时要处理编译时异常Unhandled exception: java.io.FileNotFoundException</span></span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dir/1_io.jpg&quot;</span>));</span><br><span class="line">            writer = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;desc/2_io.jpg&quot;</span>));</span><br><span class="line">            <span class="comment">//2.一定要明确使用是什么流--》字符流</span></span><br><span class="line">            <span class="type">char</span>[] buf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//3. 提供循环读写操作</span></span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = reader.read(buf))!=-<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                writer.write(buf,<span class="number">0</span>,len);</span><br><span class="line">            &#125; </span><br><span class="line">            writer.flush();</span><br><span class="line">            System.out.println(<span class="string">&quot;老子写完了！！！！&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (IOException e) </span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">finally</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Objects.nonNull(writer))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    writer.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(reader))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    reader.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e)</span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点五：字节流和字符流之间区别"><a href="#知识点五：字节流和字符流之间区别" class="headerlink" title="知识点五：字节流和字符流之间区别"></a><center>知识点五：字节流和字符流之间区别</center></h1><p>字节流和字符流是有本质上区别：</p><ol><li>流中数据是不同，字节流流中的数据是byte而字符流流中数据是char</li><li>根据流中不同数据类型所以字节流主要处理是二进制文件【图片、音频、视频、压缩包的等等】也可以处理【文本文件】但是容易出现乱码，而字符流主要是处理文本文件提供流，它是无处理二进制文件的</li><li>字节流和字符流之间还有一个很大区别</li></ol><p>&ensp;&ensp;&ensp;&ensp;字节流在操作流的过程中是【没有使用缓冲区】，直接对文件本身进行操作</p><p>&ensp;&ensp;&ensp;&ensp;字符流在操作流的过程中是【使用了缓冲区】，通过缓冲区进行进行对文件操作</p><p><strong>什么是缓冲区？</strong></p><p>&ensp;&ensp;&ensp;&ensp;缓冲区可以理解为一段特殊区域，某些情况下，如果一个程序频繁的操作一个资源（如文件或数据库），则会出现性能下降的问题，此时为了提升性能，就可以将内存中部分数据读取到一个内存区域中，以后直接从这个区域进行数据去读，这样化就可以提升系统的性能，那么这个提供区域就是“缓冲区”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span></span><br><span class="line">Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            在同等条件下进行操作</span></span><br><span class="line"><span class="comment">            创建文件字节输出流和文件字符输出流对象，将数据通过流写入到文件中</span></span><br><span class="line"><span class="comment">            创建了字节和字符文件输出流对象，进行数据书写到文件中并关闭了流资源，此时外界文件中是可以存在数据</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">            OutputStream os = new FileOutputStream(new File(&quot;desc/字节流文件.txt&quot;));</span></span><br><span class="line"><span class="comment">            os.write(&quot;Hello World&quot;.getBytes());</span></span><br><span class="line"><span class="comment">            os.close();</span></span><br><span class="line"><span class="comment">            Writer writer = new FileWriter(new File(&quot;desc/字符流文件.txt&quot;));</span></span><br><span class="line"><span class="comment">            //自有字符流中提供可以将字符串写入到文件中方法</span></span><br><span class="line"><span class="comment">            writer.write(&quot;Hello world&quot;);</span></span><br><span class="line"><span class="comment">            writer.close();</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//-------------------------------------------------------------------------------------</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            在同等条件下进行操作            创建文件字节输出流和文件字符输出流对象，将数据通过流写入到文件中，但是不添加close方法</span></span><br><span class="line"><span class="comment">            字节流可以将数据直接写出到磁盘文件中，在没有使用close方法前提下程序正常结束也可以将流中数据写入到文件中</span></span><br><span class="line"><span class="comment">            字符流在没有使用close方法的前提下，程序正常结束是没有办法将数据写入到文件中的</span></span><br><span class="line"><span class="comment">            就是因为 字符流使用 缓冲区技术即使用“缓冲区”</span></span><br><span class="line"><span class="comment">            在字符流操作过程中，所有字符都是在“内存中形成”的，在输出前会将“所有的暂时保存在内存中内容”输出到文件中</span></span><br><span class="line"><span class="comment">            使用close这个方法在在关闭流资源自后会将缓冲区中数据输出文件中(有flush功能)，所以字符流就要更加要关闭流资源</span></span><br><span class="line"><span class="comment">            但是为了防止忘记书写close方法，并且共缓冲区的利用率，Java对所有输出流都提供了一个方法flush</span></span><br><span class="line"><span class="comment">            flush这个方法可以强制的刷新出缓冲区中数据，所以就算没有关闭流资源可以将字符流中数据写出到文件中</span></span><br><span class="line"><span class="comment">            所以建议在所有写出数据操作中添加flush这个方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;desc/字节流文件.txt&quot;</span>));</span><br><span class="line">        os.write(<span class="string">&quot;Hello World&quot;</span>.getBytes());</span><br><span class="line">        <span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;desc/字符流文件.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//自有字符流中提供可以将字符串写入到文件中方法</span></span><br><span class="line">        writer.write(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">        writer.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用字符流还是使用字节流？</p><p>&ensp;&ensp;&ensp;&ensp;区分场景而言文本文件使用字符流，二进制文件使用字节流，但是字节流处理场景明显要比字符流多，所以建议优先使用字节流处理数据，如果数据是文本文件在考虑转换流操作</p><h1 id="知识点六：字符编码"><a href="#知识点六：字符编码" class="headerlink" title="知识点六：字符编码"></a><center>知识点六：字符编码</center></h1><p>阶段1:</p><p>&ensp;&ensp;&ensp;&ensp;所以规定使用的字节的最高位是0.每一个字节都是以【0~127之间的数字来表示】,比如A对应65,a对应97.这就是美国标准信息交换码【ASCII】.</p><p>‘A’<del>‘Z’ ‘a’</del>‘z’ ‘0’~‘9’</p><p><strong>阶段2:</strong></p><p>&ensp;&ensp;&ensp;&ensp;随着计算机在全球的普及,很多国家和地区都把自己的字符引入了计算机,比如汉字.</p><p>&ensp;&ensp;&ensp;&ensp;此时发现一个字节能表示数字范围太小,不能包含所有的中文汉字那么就规定使用两个字节来表示一个汉字.</p><p>&ensp;&ensp;&ensp;&ensp;规定:原有的ASCII字符的编码保持不变,仍然使用一个字节表示,为了区别一个中文字符和ASCII码字符中文字符的每个字节最高位规定为1(中文的二进制是负数).这个规范就是【GB2312】编码,后来在GB2312的基础上增加了更多的中文字符,比如汉字,也就出现了【GBK】.</p><p>阶段3:</p><p>&ensp;&ensp;&ensp;&ensp;新的问题,在中国是认识汉字的,但是如果把汉字传递给其他国家,该国家的码表中没有收录汉字,其实就显示另一个符号或者乱码为了解决各个国家因为本地化字符编码带来的影响,咱们就把全世界所有的符号统一进行编码-【Unicode万国码】编码.此时某一个字符在全世界任何地方都是固定的,比如【哥】,在任何地方都是以十六进制的【54E5】来表示.Unicode的编码字符都占有【2个字节大小】</p><p>常用字符编码集</p><p>&ensp;&ensp;&ensp;&ensp;ASCII码： 占一个字节，只能包含128个符号，不能表示汉字</p><p>&ensp;&ensp;&ensp;&ensp;ISO-8859-1【latin-1】占一个字节，收录的是西欧语言，不能表示汉字 —》properties</p><p>&ensp;&ensp;&ensp;&ensp;ANSI【GB2312】占两个字节，在简体中文操作系统中ANSI就是值的GB2312(淘汰了)</p><p>&ensp;&ensp;&ensp;&ensp;GB18030&#x2F;GBK 占两个字节，支持中文</p><p>&ensp;&ensp;&ensp;&ensp;UTF-8：是一种针对Unicode的可变长字符编码，又称万国码，UTF-8是Unicode的实现方式之一，这个编码兼容ASCII码 UTF-8表示汉字’\u0000’~’\uffff’</p><p>ps：在UTF家族中提供了其他编码 UTF-8E ，UTF-16 ,UTF-32， 这里有一个特殊编码集千万不要使用，这个编码集是MS公司搞出来UTF-8 BOM，默认3个字节一个汉字【不要使用】</p><h1 id="知识点七：InputStreamReader-字节字符转换输入流"><a href="#知识点七：InputStreamReader-字节字符转换输入流" class="headerlink" title="知识点七：InputStreamReader 字节字符转换输入流"></a><center>知识点七：InputStreamReader 字节字符转换输入流</center></h1><p>字节字符转换输入流的作用：<strong>将字节流转换为字符流，并且可以设置文件编码集</strong></p><p>“特别说明：<strong>InputStreamReader的父类是Reader类，所以这个流中数据是char类型</strong>”</p><p>&ensp;&ensp;&ensp;&ensp;“<strong>InputStreamReader是FileReader的直接父类</strong>”</p><h2 id="1、核心构造方法"><a href="#1、核心构造方法" class="headerlink" title="1、核心构造方法"></a><center>1、核心构造方法</center></h2><table><thead><tr><th align="center">常用构造方法</th></tr></thead><tbody><tr><td align="center">InputStreamReader(InputStream in) 通过参数InputStream流的对象构建InputStreamReader流对象并使用的是默认编码集</td></tr><tr><td align="center">InputStreamReader(InputStream in, Charset cs) 通过参数</td></tr><tr><td align="center">InputStream流的对象构建InputStreamReader流对象并用过Charset设置读取文件编码集</td></tr><tr><td align="center">InputStreamReader(InputStream in, String charsetName)通过参数InputStream流的对象构建InputStreamReader流并用过字符串设置读取文件编码集</td></tr></tbody></table><p>PS： 转换输入流，所以构建InputStreamReader对象时，需要提供一个字节输入流作为转换对象</p><p>通过InputStreamReader可以设置编码集，设置编码集方式是通过InputStreamReader构造方法中第二参数进行设置，这里设置有两种方式</p><p>&ensp;&ensp;&ensp;&ensp;第一种方式：使用Charset类型进行设置 —》 Charset.forName(“编码集名字”)</p><p>&ensp;&ensp;&ensp;&ensp;第二种方式：使用String类型进行设置 —》 “编码集名字”</p><h2 id="2、核心API方法"><a href="#2、核心API方法" class="headerlink" title="2、核心API方法"></a><center>2、核心API方法</center></h2><table><thead><tr><th align="center"></th><th align="center">常用方法</th></tr></thead><tbody><tr><td align="center">void</td><td align="center">close() 关闭流并释放与它相关联的任何系统资源</td></tr><tr><td align="center">String</td><td align="center">getEncoding() 返回此流使用的字符编码的名称。(在读取文件的同时读取文件编码集)</td></tr><tr><td align="center">int</td><td align="center">read() 读取单个字符</td></tr><tr><td align="center">int</td><td align="center">read(char[] cbuf, int offset, int length) 将字符读入一个数组的一部分</td></tr><tr><td align="center">int</td><td align="center">read(char[] cbuf) 将读取的数据存储到字符数组中</td></tr></tbody></table><h1 id="知识点八：OutputStreamWriter-字节字符转换输出流"><a href="#知识点八：OutputStreamWriter-字节字符转换输出流" class="headerlink" title="知识点八：OutputStreamWriter 字节字符转换输出流"></a><center>知识点八：OutputStreamWriter 字节字符转换输出流</center></h1><p>字节字符转换输出流作用:将字符流转换为字节流输出，并可以设置编码集</p><p>特别注意:”<strong>OutputStreamWriter的父类是Writer,所以这个流中数据是char类型</strong></p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;”<strong>OutputStreamWriter是FileWriter的父类</strong>“</p><h2 id="1、核心构造方法-1"><a href="#1、核心构造方法-1" class="headerlink" title="1、核心构造方法"></a><center>1、核心构造方法</center></h2><table><thead><tr><th align="center">常用构造方法</th></tr></thead><tbody><tr><td align="center">OutputStreamWriter(OutputStream out) 通过OutputStream对象创建OutputStreamWriter对象并使用默认编码集写出数据</td></tr><tr><td align="center">OutputStreamWriter(OutputStream out, Charset cs) 通过OutputStream对象创建OutputStreamWriter对象并使用Charset设置写出文件编码集</td></tr><tr><td align="center">OutputStreamWriter(OutputStream out, StringcharsetName) 通过OutputStream对象创建OutputStreamWriter对象并使用String类型设置写出文件编码集</td></tr></tbody></table><p>PS： 转换输出流，所以构建OutputStreamWriter对象时，需要提供一个字节输出流作为转换对象</p><p>通过OutputStreamWriter可以设置编码集，设置编码集方式是通过OutputStreamWriter构造方法中第二参数进行设置，这里设置有两种方式</p><p>&ensp;&ensp;&ensp;&ensp;第一种方式：使用Charset类型进行设置 —》 Charset.forName(“编码集名字”)</p><p>&ensp;&ensp;&ensp;&ensp;第二种方式：使用String类型进行设置 —》 “编码集名字”</p><h2 id="2、核心的API方法"><a href="#2、核心的API方法" class="headerlink" title="2、核心的API方法"></a><center>2、核心的API方法</center></h2><table><thead><tr><th align="center"></th><th align="center">常用方法</th></tr></thead><tbody><tr><td align="center">void</td><td align="center">close() 关闭流，冲洗它</td></tr><tr><td align="center">void</td><td align="center">flush() 冲流</td></tr><tr><td align="center">String</td><td align="center">getEncoding() 返回此流使用的字符编码的名称</td></tr><tr><td align="center">void</td><td align="center">write(char[] cbuf, int off, int len) 写入一个字符数组的一部分</td></tr><tr><td align="center">void</td><td align="center">write(int c) 写一个字符</td></tr><tr><td align="center">void</td><td align="center">write(String str, int off, int len) 写入字符串的一部分</td></tr></tbody></table><p>PS： 因为OutputStreamWriter是父类Writer方法，所以也会继承到Writer方法中参数为String类方法，所以提供直接输出字符串的方法</p><p><strong>这两流的操作可以完全操作FileRader和FileWriter进行操作</strong></p><p>需求：使用转换流在设置编码集的前提下进行文件的赋值与粘贴</p><ol><li>读取文件使用UTF-8编码集进行，输出文件时将文件编码集修改为GBK</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.BufferedInputStreamAndBufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileEncodingCopyDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//使用转换流进行文件的编码集设置操作</span></span><br><span class="line">        <span class="comment">//1.提供创建字节字符转换输入输出流对象</span></span><br><span class="line">        <span class="comment">//在创建转换流对象时，是存在一个编译时异常 UnsupportedEncodingException【不支持设置编码集】</span></span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dir/1.txt&quot;</span>)),<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">//只有读对了才可以写对</span></span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;desc/1.txt&quot;</span>)),</span><br><span class="line">        Charset.forName(<span class="string">&quot;GBK&quot;</span>));</span><br><span class="line">        <span class="comment">//2.这两个转换流是父类都是字符类型，所以流中的数据都是char类型</span></span><br><span class="line">        <span class="type">char</span>[] buf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//提供一个变量存储实际读取到文件长度【包括文件末尾-1的返回值】</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//3.循环读取数据并将当前数据输出</span></span><br><span class="line">        <span class="keyword">while</span>((len = isr.read(buf))!=-<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            osw.write(buf,<span class="number">0</span>,len);</span><br><span class="line">        &#125; </span><br><span class="line">        osw.flush();</span><br><span class="line">        osw.close();</span><br><span class="line">        isr.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;老子写完了！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需求：仿照上面代码提供一个通用方法可以设置文件编码集并且使用转换流进行拷贝与粘贴操作</p><ol><li>读取文件使用UTF-8编码集进行，输出文件时将文件编码集修改为GBK</li><li>读取文件使用GBK编码集进行，输出文件时将文件编码集修改为UTF-8</li><li>使用GBK编码集读取一个UTF-8文件，输出文件时使用UTF-8编码集输出</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.BufferedInputStreamAndBufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileEncodingCopyDemo2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 1. 读取文件是UTF-8，写出文件GBK</span></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">            copyFile(new File(&quot;dir/1.txt&quot;),&quot;UTF-8&quot;,new File(&quot;desc/1.txt&quot;),&quot;GBK&quot;);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//2. 读取文件是GBK ，写出文件是UTF-8编码</span></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">            copyFile(new File(&quot;desc/1.txt&quot;),&quot;GBK&quot;, new File(&quot;dir/UFT-8文件.txt&quot;),&quot;UTF-8&quot;);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// 3. 读取一个UTF-8的编码文件使用GBK编码，写出文件是使用UTF-8写出</span></span><br><span class="line">        copyFile(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dir/UFT-8文件.txt&quot;</span>),<span class="string">&quot;GBK&quot;</span>, <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;desc/将UFT-8文件设置为GBK之后修</span></span><br><span class="line"><span class="string">                                                                                改为UTF-8.txt&quot;</span>),<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 设置文件编码集进行赋值粘贴的方法</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> srcFile 源文件</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> srcCharset 源文件编码集</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> descFile 目标文件</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> descCharset 目标文件编码集</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@throws</span> Exception 代表方法所有要抛出的编译时异常</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFile</span><span class="params">(File srcFile,String srcCharset,File descFile,String descCharset)</span><span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供字节字符转换输入输出流对象</span></span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile),srcCharset);</span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(descFile),descCharset);</span><br><span class="line">        <span class="comment">//2.使用的是什么流，流中数据是什么 --》 他们都是字符流</span></span><br><span class="line">        <span class="type">char</span>[] buf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = isr.read(buf))!=-<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            osw.write(buf,<span class="number">0</span>,len);</span><br><span class="line">        &#125; </span><br><span class="line">        osw.flush();</span><br><span class="line">        osw.close();</span><br><span class="line">        isr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>转换流的总结：</strong></p><p>&ensp;&ensp;&ensp;&ensp;<strong>转换流的目的在于提供了字节与字符流之间的一种转换效果，我们可以通过转换流将字符流和字节流进行转化，除此之外还可以设置文件的编码集进行文件的读取和写出操作</strong>，这样可以完成文件的编码集转换操作【文件编码集的转换操作原则是：只有读取文件时编码集设置正确，才可在写出文件时将编码集设置正确】</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012007515.png" alt="字符流转字节流" style="zoom: 67%;"><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012008623.png" alt="字节流转字符流" style="zoom:67%;"><h1 id="知识点九：缓冲流"><a href="#知识点九：缓冲流" class="headerlink" title="知识点九：缓冲流"></a><center>知识点九：缓冲流</center></h1><p>有了缓冲流之后，不建议使用原始流进行操作，缓冲流效率是远远高于原始流，缓冲流提供缓冲区让流可以进行操作</p><p>原始流指的是：InputStream和OutputStream 或者 Reader和Writer不使用缓冲区的流</p><p>PS：需要注意的是 字符流 默认使用了缓冲区，所以和缓冲流的效果差不多</p><h2 id="1、字节缓冲流"><a href="#1、字节缓冲流" class="headerlink" title="1、字节缓冲流"></a><center>1、字节缓冲流</center></h2><p>字节缓冲流是针对原始字节流而提供一种流，这个中流可以更加高效处理流中操作</p><p><strong>BufferedInputStream字节缓冲输入流 和 BufferedOutputStrem 字节缓冲输出流</strong></p><p>BufferedInputStream字节缓冲输入流是InputStream字节输入流的子类，这个流提供一个缓冲区，这个缓冲区可以帮组流进行数据缓冲与操作，<strong>这个缓冲区的大小默认是8192K</strong>,提供BufferedInputStream这个流可以包装一个普通字节输入流进行缓冲操作，这个缓冲区大小是可以用过BufferedInputStream构造方法进行设置，但是<strong>这个缓冲区的设置不要低于8192，设置时按照1024倍数设置即可</strong></p><h3 id="（1）BufferedInputStream常用构造方法"><a href="#（1）BufferedInputStream常用构造方法" class="headerlink" title="（1）BufferedInputStream常用构造方法"></a>（1）BufferedInputStream常用构造方法</h3><table><thead><tr><th align="center">常用构造方法</th></tr></thead><tbody><tr><td align="center">BufferedInputStream(InputStream in) 创建一个BufferedInputStream 和保存它的参数，输入流 in ，供以后使用</td></tr><tr><td align="center">BufferedInputStream(InputStream in, int size) 创建一个具有指定的缓冲区大小 BufferedInputStream ，并保存它的参数，输入流 in ，供以后使用</td></tr></tbody></table><p>PS：缓冲流的使用其实就是对原始流进行二次“包装”，让原始就具备一个缓冲区可以快速进行流操作，所以构建字节缓冲输入流对象时，<strong>需要提供一个“InputStream字节输入流对象”</strong>，不仅如此还可以设置缓冲区的默认大小，<strong>不要低于8192这个数据，设置时按照1024倍数设置即可</strong>，缓冲流输入流是唯一支持字节输入流父类中提供mark和reset方法【但是没有任何效果】</p><h3 id="（2）BufferedInputStream常用API方法"><a href="#（2）BufferedInputStream常用API方法" class="headerlink" title="（2）BufferedInputStream常用API方法"></a>（2）BufferedInputStream常用API方法</h3><table><thead><tr><th align="center"></th><th align="center">常用方法</th></tr></thead><tbody><tr><td align="center">void</td><td align="center">close() <strong>关闭此输入流并释放与流关联的任何系统资源</strong></td></tr><tr><td align="center">int</td><td align="center">read() 看到的 InputStream 的 read 方法一般合同</td></tr><tr><td align="center">int</td><td align="center">read(byte[] b) <strong>读取文件存储到数组中</strong>【常用】</td></tr><tr><td align="center">int</td><td align="center">read(byte[] b, int off, int len) 从这个字节的输入流读取到指定的字节数组中的字节，从给定的偏移量开始</td></tr><tr><td align="center">boolean</td><td align="center">markSupported() 如果输入流的支持 mark 和reset 方法【无用】</td></tr><tr><td align="center">void</td><td align="center">mark(int readlimit) 看到的 InputStream 的mark 方法一般合同【无用】</td></tr><tr><td align="center">void</td><td align="center">reset() 看到的 InputStream 的 reset 方法一般合同【无用】</td></tr></tbody></table><p>&ensp;&ensp;&ensp;&ensp;BufferedOutputStream字节缓冲输出流是OutputStream字节输出流子类，这个流提供一个缓冲区，这个缓冲区可以帮组流进行数据缓冲与操作，<strong>这个缓冲区的大小默认是8192K</strong>,提供BufferedOutputStream这个流可以包装一个普通字节输出流进行缓冲操作，这个缓冲区大小是可以用过BufferedOutputStream构造方法进行设置，<strong>但是这个缓冲区的设置不要低于8192，设置时按照1024倍数设置即可</strong></p><h3 id="（3）BufferedOutputStream常用构造方法"><a href="#（3）BufferedOutputStream常用构造方法" class="headerlink" title="（3）BufferedOutputStream常用构造方法"></a>（3）BufferedOutputStream常用构造方法</h3><table><thead><tr><th align="center">常用构造方法</th></tr></thead><tbody><tr><td align="center">BufferedOutputStream(OutputStream out) 创建一个新的缓冲输出流，将数据写入到指定的基本输出流中</td></tr><tr><td align="center">BufferedOutputStream(OutputStream out, int size) 创建一个新的缓冲输出流，用指定的缓冲区大小写数据到指定的基本输出流中</td></tr></tbody></table><p>PS：缓冲流的使用其实就是对原始流进行二次“包装”，让原始就具备一个缓冲区可以快速进行流操作，所以构建字节缓冲输出流对象时，<strong>需要提供一个“OutputStream字节输出流对象”</strong>，不仅如此还可以设置缓冲区的默认大小，<strong>不要低于8192这个数据，设置时按照1024倍数设置即可</strong></p><h3 id="（4）BufferedOutputStream常用API方法"><a href="#（4）BufferedOutputStream常用API方法" class="headerlink" title="（4）BufferedOutputStream常用API方法"></a>（4）BufferedOutputStream常用API方法</h3><table><thead><tr><th align="center"></th><th align="center">常用方法</th></tr></thead><tbody><tr><td align="center">void</td><td align="center">flush() 刷新缓冲输出流</td></tr><tr><td align="center">void</td><td align="center">write(byte[] b, int off, int len) 写 len 字节指定字节数组中的起始偏移 off 这个缓冲输出流</td></tr><tr><td align="center">void</td><td align="center">write(int b) 将指定的字节写入该缓冲输出流中</td></tr><tr><td align="center">void</td><td align="center">close() 关闭此输出流并释放与此流关联的任何系统资源</td></tr></tbody></table><p>PS:字节缓冲输入输出流没有任何特殊方法，这个操作可以完全参考FileInputStream 和FileOutputStream</p><p>字节缓冲输入输出流就是提供缓冲区提高操作效率而已</p><p>性能对比： 使用缓冲字节流和普通字节流进行 大于2GB文件拷贝操作计算时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span></span><br><span class="line">com.qfedu.BufferedInputStreamAndBufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileCopyTest</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span></span><br><span class="line">Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//提供一个开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">beginTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//先提供字节输入输出流拷贝操作</span></span><br><span class="line">     <span class="comment">//copyFileToByte(new File(&quot;C:\\Users\\jkmaster\\Desktop\\23_IO流1.zip&quot;),new File(&quot;C:\\abc\\23_IO流1.zip&quot;));</span></span><br><span class="line">        <span class="comment">//在提供缓冲字节输入输出流拷贝操作</span></span><br><span class="line">        copyFileToBufferedByte(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\jkmaster\\Desktop\\23_IO流1.zip&quot;</span>),</span><br><span class="line">                                                                        <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\abc\\23_IO流1.zip&quot;</span>));</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//System.out.println(&quot;缓冲字节输入输出流拷贝文件的时间</span></span><br><span class="line">                                                    <span class="comment">//是：&quot;+(endTime-beginTime)+&quot;毫秒&quot;);5869毫秒 --》约等于 6秒</span></span><br><span class="line">        <span class="comment">//System.out.println(&quot;普通字节输入输出流拷贝文件的时间</span></span><br><span class="line">                                                   <span class="comment">//是：&quot;+(endTime-beginTime)+&quot;毫秒&quot;);21387毫秒 --》约等于 21秒</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 普通字节输入输出流拷贝文件操作</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> srcFile 源文件</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> descFile 目标文件</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> Exception 抛出所有编译时异常信息    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFileToByte</span><span class="params">(File srcFile, File descFile)</span><span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供字节输入输出对象</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(descFile);</span><br><span class="line">        <span class="comment">//2.提供byte类型数组</span></span><br><span class="line">        <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//3.提供一个变量存储读取实际文件长度【读取文件末尾-1值】</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = is.read(bs))!=-<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            os.write(bs,<span class="number">0</span>,len);</span><br><span class="line">        &#125; </span><br><span class="line">        os.flush();</span><br><span class="line">        os.close();</span><br><span class="line">        is.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;字节输入输出流拷贝文件结束！&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 提供缓冲字节输入输出流拷贝文件操作</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> srcFile 源文件</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> descFile 目标文件</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> Exception 抛出所有编译时异常信息    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFileToBufferedByte</span><span class="params">(File srcFile, File descFile)</span><span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供缓冲字节输入输出对象</span></span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile));</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(descFile));</span><br><span class="line">        <span class="comment">//2.提供byte类型数组</span></span><br><span class="line">        <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//3.提供一个变量存储读取实际文件长度【读取文件末尾-1值】</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = bis.read(bs))!=-<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            bos.write(bs,<span class="number">0</span>,len);</span><br><span class="line">        &#125; </span><br><span class="line">        bos.flush();</span><br><span class="line">        bos.close();</span><br><span class="line">        bis.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;缓冲字节输入输出流拷贝文件结束！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//PS：能用缓冲流就用缓冲流，不要使用普通字节流</span></span><br></pre></td></tr></table></figure><h2 id="2、字符缓冲流"><a href="#2、字符缓冲流" class="headerlink" title="2、字符缓冲流"></a><center>2、字符缓冲流</center></h2><p>PS：这个流才是我们真记忆，他符合内容数据写入到磁盘，在从磁盘将数据读取到内容使用流</p><p>字符缓冲流对于将内存中数据写入到磁盘中和将磁盘中数据读取到内容中有非常好支持，所以只要是这样数据操作就一定使用这个流</p><p>字符缓冲流也是缓冲流，所有字符缓冲输入输出流都具备缓冲区，默认大小也是8192K，如果要修改缓冲区大小需要比8192K大，并且是提供1024倍数进行修改</p><p>BufferedReader缓冲字符输入流是Reader字节输入的子类，提供8192K缓冲区，可以包装一个普通的字符输入流提高操作效率</p><h3 id="（1）BufferedReader常用构造方法"><a href="#（1）BufferedReader常用构造方法" class="headerlink" title="（1）BufferedReader常用构造方法"></a>（1）BufferedReader常用构造方法</h3><table><thead><tr><th align="center">构造方法</th></tr></thead><tbody><tr><td align="center">BufferedReader(Reader in) 创建一个使用默认大小输入缓冲区的缓冲字符输入流</td></tr><tr><td align="center">BufferedReader(Reader in, int sz) 创建一个使用指定大小的输入缓冲区的缓冲字符输入流</td></tr></tbody></table><p>PS：BuffereReader是缓冲字符输入流，所以需要提供一个字符输入流作为对象传入到缓冲字符输入流中进行对象创建，除此之外提供修改默认缓冲区大小</p><h3 id="（2）BufferedReader常用API方法"><a href="#（2）BufferedReader常用API方法" class="headerlink" title="（2）BufferedReader常用API方法"></a>（2）BufferedReader常用API方法</h3><table><thead><tr><th align="center"></th><th align="center">常用方法</th></tr></thead><tbody><tr><td align="center">string</td><td align="center">readLine() 读一行文本【强烈推荐】</td></tr></tbody></table><p>说明：</p><ol><li>BufferedReader是一个流，所以也需要调用close方法</li><li>BufferedReader读取数据方式一共有两种：</li></ol><p>&ensp;&ensp;&ensp;&ensp;2.1 使用原始字符输入流的方式进行数据读取 –》 提供char数组，使用read方法读取数据【不推荐】</p><p>&ensp;&ensp;&ensp;&ensp;2.2 使用BufferedReader中独有的方法进行数据读取 —》 readLine方法【强烈推荐】</p><p> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;readLine这个方法是返回读取一次文本中内一行内容，这个方法的返回值是String</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.BufferedReaderAndBufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedReaderDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建字符缓冲输入流BufferedReader对象</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dir/UFT-8文件.txt&quot;</span>)));</span><br><span class="line">        <span class="comment">//2.提供两种读取数据的方式</span></span><br><span class="line">        <span class="comment">//2.1 使用char数组的方式进行读取</span></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">            char[] buf = new char[1024];</span></span><br><span class="line"><span class="comment">            int len;</span></span><br><span class="line"><span class="comment">            while((len = br.read(buf))!=-1)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                System.out.println(new String(buf,0,len));</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//2.1 使用 readLine进行数据读取，一次读取文件中一行内容</span></span><br><span class="line">        <span class="comment">//2.1.1 提供一个String类型变量接收读取到数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            readLine方法读取文件中每一个行内容时，一共有两种数据返回形态</span></span><br><span class="line"><span class="comment">            读取到数据就返回String类型字符串读，取到文件末尾就返回null值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">while</span>((content = br.readLine()) != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//可以在这个循环中对content得到String字符串数据即文件中读取到内容进行操作</span></span><br><span class="line">            System.out.println(content);</span><br><span class="line">        &#125; </span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（3）BufferedWriter缓冲字符输出流"><a href="#（3）BufferedWriter缓冲字符输出流" class="headerlink" title="（3）BufferedWriter缓冲字符输出流"></a>（3）BufferedWriter缓冲字符输出流</h3><p>BufferedWritrer缓冲字符输出流是Writer字符输出流子类，并且提供一个默认缓冲区大小为8192K，提供给包装普通字符输出流对象使用对字符输出流操作</p><h4 id="常用构造方法"><a href="#常用构造方法" class="headerlink" title="常用构造方法"></a>常用构造方法</h4><table><thead><tr><th align="center">常用构造方法</th></tr></thead><tbody><tr><td align="center">BufferedWriter(Writer out) 创建一个使用默认大小输出缓冲区的缓冲字符输出流</td></tr><tr><td align="center">BufferedWriter(Writer out, int sz) 创建一个新的缓冲字符输出流，该流使用给定大小的输出缓冲区</td></tr></tbody></table><p>PS：BufferedWriter缓冲字符输出流是包装一个字符输出流对象，所以参数需要一个字符出流对象进行传入创建，并且可以设置默认缓冲区的大小，不建议低于8192K大小，提供设置默认值时要是1024的倍数</p><h4 id="常用API方法"><a href="#常用API方法" class="headerlink" title="常用API方法"></a>常用API方法</h4><table><thead><tr><th align="center">void</th><th align="center">write(String str) 写一个字符串【这个方法是专门应对readLine方法写出的】</th></tr></thead><tbody><tr><td align="center">void</td><td align="center">newLine() 写行分隔符</td></tr></tbody></table><p>说明：</p><ol><li>BufferedWriter提供字符缓冲输出流操作，所以支持flush和close方法</li><li>BufferedWriter提供数据写出操作，提供两种方式应对BufferedReader的操作</li></ol><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;2.1 如果BufferedReader使用是char类型数组进行数据读取操作BufferedWriter就提 ·writer(char[] buf,int off,int len)将数据写出</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;2.2 如果BufferedReader使用是readLine这个方法进行数据读取操作者BufferedWriter就提供 write(String str) 将数据写出</p><p><strong>PS: 使用write(String str) 将数据写出时需要配合使用newLine()这个方法以保证写出文件正确格式</strong></p><p>需求： 使用缓冲字符输入输出流对象进行数据拷贝操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyFileDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span></span><br><span class="line">Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供缓冲字符输入输出流对象</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dir/UFT-8文件.txt&quot;</span>)));</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;desc/file文件.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//1.提供char数组方式进行写入写出操作</span></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">            char[] buf = new char[1024];</span></span><br><span class="line"><span class="comment">            int len;</span></span><br><span class="line"><span class="comment">            while((len = br.read(buf))!=-1)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                bw.write(buf,0,len);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//2.使用newLine来进行数据写入写出操作</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>((str = br.readLine()) != <span class="literal">null</span>)    <span class="comment">//readLine这个方式不读取换行操作，不读取回车&quot;\n&quot;</span></span><br><span class="line">        &#123;</span><br><span class="line">        </span><br><span class="line">            bw.write(str);</span><br><span class="line">            <span class="comment">//所以为了保证写出数据的格式完整性</span></span><br><span class="line">            bw.newLine(); <span class="comment">//添加换行操作即添加&quot;\n&quot;</span></span><br><span class="line">        &#125; </span><br><span class="line">        bw.flush();</span><br><span class="line">        bw.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结:</p><p>&ensp;&ensp;&ensp;&ensp;Java中提供缓冲流的效率是远远高于普通（原始）流，因为缓冲流提供缓冲区操作，<strong>缓冲字节输入输出流针对是二进制文件【视频、音频、图片、压缩包】等等，缓冲字符输入输出流针对的是文本文件，主要完成就是将内存中数据写入到文件中，将文件中数据在读取会内容，提供这个操作</strong></p><p>案例：使用字符输入流从控台读取数据【不用Scanner】，写入到文件中【默认记录聊天数据】，写出数据时使用</p><p>System.out打印到文件中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.BufferedReaderAndBufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadScannerToFile</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//不使用Scanner进行数据操作</span></span><br><span class="line">        <span class="comment">//可以提供字符缓冲输入流进行控制台数据读取</span></span><br><span class="line">        <span class="comment">//之所以可以在控制台获取到数据主要是因为使用标准字节输入流--》System.in</span></span><br><span class="line">        <span class="comment">//如果使用这种方法获取数据方式很单一只有readLine</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            使用System这个类中 setOut方法改变打印数据流向--》标准输出流重定向</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//需要提供一个字节打印流对象，提供流输出数据位置</span></span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;desc/聊天记录.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//修改打印流的流向</span></span><br><span class="line">        System.setOut(ps);</span><br><span class="line">        <span class="comment">//提供循环进行数据获取</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyyMM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//提供一个Date对象获取当前时间</span></span><br><span class="line">            <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">            <span class="comment">//读取控制台数据</span></span><br><span class="line">            content = br.readLine();</span><br><span class="line">            <span class="comment">//约定如果输入886结束程序</span></span><br><span class="line">            <span class="keyword">if</span>(content.equals(<span class="string">&quot;886&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//就将数据写入到文件中</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">time</span> <span class="operator">=</span> sdf.format(date);</span><br><span class="line">            <span class="comment">//System.out.println(time);</span></span><br><span class="line">            System.out.println(content);</span><br><span class="line">        &#125; </span><br><span class="line">        br.close();</span><br><span class="line">        ps.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//ps:已经将System.out的输出指定到文件中，如果需要将输出在指定会控制台打印如何做？</span></span><br></pre></td></tr></table></figure><h2 id="3、资源文件Properties"><a href="#3、资源文件Properties" class="headerlink" title="3、资源文件Properties"></a><center>3、资源文件Properties</center></h2><p>Properties文件是继承与Hashtable，Properties文件中存储数据方式就是以【key-value键值对】进行，对这个文件操作是将需要使用数据存储在value中，提供key可以访问外界访问到key获取到需要value值</p><p>Properties文件是可以通过代码进行创建，也可以在外界直接创建这个文件但是文件后缀名必须【.properties】这个文件被称之为资源文件，可以向这个文件中提供一些常用的配置信息【JDBC链接信息，Spring的配置信息、SpringBoot配置信息】等等，这个文件默认编码集是ISO-8859-1，所以不支持使用代码的形式创建文件中出现中文，如果出现中文是以Unicode码进行展示的。直接创建文件是支持写入中文但是要以注释形式存在</p><p><strong>案例：使用流方式来创建Properties文件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesFileDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//在控制台上获取一些数据，存储在properties文件中</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="comment">//文件后缀名字必须是.properties</span></span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;dir/config.properties&quot;</span>));</span><br><span class="line">        <span class="comment">//1.提供Properties对象的创建</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">//循环获取到控制台输入的数据</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入key值：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">            <span class="comment">//当key值获取到over的时候停止循环操作</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;over&quot;</span>.equals(key))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            System.out.println(<span class="string">&quot;请输入value值：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">            <span class="comment">//调用Properties中方法将key-value键值对存储到 Properties对象中</span></span><br><span class="line">            p.setProperty(key,value);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//将存储在Properties对象中数据写入到文件中，properties文件中 #号是注释的意思</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            store方法需要传递输出流对象【字符或字节都可以】</span></span><br><span class="line"><span class="comment">            第二个参数是 注释--》通过代码写出文件中文是无法正确展示的，所以建议使用英文</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        p.store(bw,<span class="string">&quot;我是注释!!!&quot;</span>);</span><br><span class="line">        bw.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>案例：使用流读取Properties文件【常用】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="comment">//读取资源文件的工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesUtil</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.提供一个私有静态Properties对象获取文件中数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Properties properties;</span><br><span class="line">    <span class="comment">//2.加载文件操作一般都会提前加载，而不是当用户使用到时候在加载</span></span><br><span class="line">    <span class="keyword">static</span>    <span class="comment">//使用静态代码块进行资源加载，只会执行一次不会出现重复加载问题</span></span><br><span class="line">    &#123; </span><br><span class="line">        </span><br><span class="line">        properties = <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            调用load方法加载资源文件，将资源文件中内容读取到properties对象中</span></span><br><span class="line"><span class="comment">            这个方法参数既可以是字节流也可以是字符流</span></span><br><span class="line"><span class="comment">            这个操作会存在编译时异常，static静态代码块中是不能throws，只能try-catch</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;dir/config.properties&quot;</span>));</span><br><span class="line">        &#125; </span><br><span class="line">            <span class="keyword">catch</span> (IOException e) </span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;资源文件加载失败，无法加载：&quot;</span>+e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        提供一个方法可以获取Properties资源文件中值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getValue</span><span class="params">(String key)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//通过key值获取到vlaue值        </span></span><br><span class="line">        <span class="keyword">return</span> properties.getProperty(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;获取用户名字请输入username:&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> input.next();</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> PropertiesUtil.getValue(username);</span><br><span class="line">        System.out.println(<span class="string">&quot;用户名：&quot;</span>+value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结Properties核心方法：</p><ol><li>创建对象—》new Properties();</li><li>存储key和value键值对 —》setProperty(key,value)</li><li>创建Properties文件 —》 store(字节或字符输出流对象，”文件内容注释”)</li><li>读取Properties文件 —》 load(字节或字符输入流对象)</li><li>获取value值 —》 getProperty(key)</li></ol><h2 id="4、序列化和反序列化【对象流】"><a href="#4、序列化和反序列化【对象流】" class="headerlink" title="4、序列化和反序列化【对象流】"></a><center>4、序列化和反序列化【对象流】</center></h2><p>序列化和反序列化？</p><p>&ensp;&ensp;&ensp;&ensp;<strong>对象序列化</strong> : <strong>把一个【对象转换二进制数据】这种方式称之为序列化</strong>，序列化之后对象可以方便实现对象【<strong>存储与传输</strong>】</p><p><strong>&ensp;&ensp;&ensp;&ensp;对象反序列化</strong>：<strong>把一个【二进制数据转换成对象】这种方式称之为反序列化</strong>,通过反序列化操作就可以得到存储在文件中对象内的数据了</p><p><strong>Serializable接口</strong></p><p>&ensp;&ensp;&ensp;&ensp;如果需要将某个对象进行序列化操作，那么这个对象描述类就需要实现<strong>Serializable接口</strong>，这样才可以允许对当前对象进行序列化和反序列化</p><p>&ensp;&ensp;&ensp;&ensp;API文档中对Serializable接口的说明： 类通过实现java.io.Serializable 接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。可序列化类的所有子类型本身都是可序列化的。序列化接口没有方法或字段，仅用于标识可序列化的语义</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012018417.png" alt="兼容问题" style="zoom:50%;"><h3 id="（1）对象字节输入输出流"><a href="#（1）对象字节输入输出流" class="headerlink" title="（1）对象字节输入输出流"></a>（1）对象字节输入输出流</h3><p>使用对象字节输入流读取文件称之为【反序列化】，从磁盘文件中将对象读取到内存使用是【ObjectInputStream】</p><p>使用对象字节输出流写出文件称之为【序列化】，从内存将对象写入到文件中使用是【ObjectOutputStream】</p><p><strong>ObjectOutputStream常用构造方法和常用方法</strong></p><table><thead><tr><th align="center"></th><th align="center">常用构造方法</th></tr></thead><tbody><tr><td align="center">public</td><td align="center">ObjectOutputStream(OutputStream out)创建一个对象写入到指定的输出流，参数需要是一个字节输出流对象</td></tr></tbody></table><table><thead><tr><th align="center"></th><th align="center">常用方法</th></tr></thead><tbody><tr><td align="center">void</td><td align="center">writeObject(Object obj) 将对象写入到对象流中【对象的序列化】</td></tr></tbody></table><p>因为需要将对象序列化到文件中所以构造方法中需要提供字节输出流对象，配套使用是FileOutputStream，核心方法就是序列化对象，所以使用writeObject方法，还支持很多其他的写入方法，但是使用较少，支持关闭和刷新流</p><p><strong>ObjectInputStream常用的构造方法和常用方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">常用构造方法</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ObjectInputStream</span><span class="params">(InputStream in)</span></span><br><span class="line">创建一个对象输入流读取从指定的输入流，参数需要一个字节输入流对象</span><br><span class="line">常用方法</span><br><span class="line">Object <span class="title function_">readObject</span><span class="params">()</span> 从对象输入流读取对象【反序列化】 </span><br><span class="line">读取的是文件中内容，所以参数需要一个字节输入流对象，匹配使用是FileInputStream，核心方法就是反序列化对象，</span><br><span class="line">所以使用readObject这个方法，特别注意返回值类型时Object，这个流也需要关闭</span><br></pre></td></tr></table></figure><p>案例：单个对象序列和反序列化操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">        <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">        <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">        <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//java.io.NotSerializableException: com.qfedu.serializable.Student</span></span><br><span class="line">        <span class="comment">//出现这个异常原因是因为没有实现：Serializable接口</span></span><br><span class="line">        <span class="comment">// Student student = new Student(&quot;成龙&quot;,68);</span></span><br><span class="line">        <span class="comment">// serializableObject(student);</span></span><br><span class="line">        deSerializableObject();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">        对象序列化操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serializableObject</span><span class="params">(Student student)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建序列化对象的流对象</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;dir/序列化单个对象的文件&quot;</span>));</span><br><span class="line">        <span class="comment">//2.代用writeObject方法进行序列化操作</span></span><br><span class="line">        oos.writeObject(student);</span><br><span class="line">        System.out.println(<span class="string">&quot;序列化成功！&quot;</span>);</span><br><span class="line">        oos.close();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">        对象反序列化操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deSerializableObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供反序列化流对象</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;dir/序列化单个对象的文件&quot;</span>));</span><br><span class="line">        <span class="comment">//2.调用readObject方法反序列化操作</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> ois.readObject();    <span class="comment">//这个方法返回值是Boject类型，如果需要对数据进行具体化操作需要对象向下转型</span></span><br><span class="line">        System.out.println(<span class="string">&quot;验证o对象是否是Student类型：&quot;</span>+(o <span class="keyword">instanceof</span> Student));</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>案例：多个对象序列化和反序列化【创建5个Student对象进行序列化和反序列化操作要求在同一个文件中（一个文件5个对象）】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">//多个对象序列化与反序列化操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;Student&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三1&quot;</span>,<span class="number">19</span>),<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三2&quot;</span>,<span class="number">20</span>), <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三3&quot;</span>,<span class="number">21</span>),</span><br><span class="line">                           <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三4&quot;</span>,<span class="number">22</span>), <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三5&quot;</span>,<span class="number">23</span>),<span class="literal">null</span>);<span class="comment">//追加null就是结尾证明没有数据了</span></span><br><span class="line">        <span class="comment">//serializableMoreObject(list);</span></span><br><span class="line">        <span class="comment">//deSerializableMoreObject();</span></span><br><span class="line">        <span class="comment">// --------------------------------------------------</span></span><br><span class="line">        <span class="comment">//serializableMoreObject2(list);</span></span><br><span class="line">        deSerializableMoreObject2();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//提供第一个处理方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serializableMoreObject</span><span class="params">(List&lt;Student&gt; list)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;dir/多个对象序列化文件&quot;</span>));</span><br><span class="line">        <span class="comment">//此时要序列化操作，但是现在所有的对象都是存在List集合中，所以直接序列化集合即可</span></span><br><span class="line">        <span class="comment">//这个操作只是取巧，不是多个对象序列化， 只是序列化了一个List集合对象</span></span><br><span class="line">        oos.writeObject(list);</span><br><span class="line">        oos.flush();</span><br><span class="line">        oos.close();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deSerializableMoreObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;dir/多个对象序列化文件&quot;</span>));</span><br><span class="line">        <span class="comment">//readObject这个方法的返回值是Object类型，所以需要操作数据时需要向下转型</span></span><br><span class="line">        List&lt;Student&gt; stus = ((List&lt;Student&gt;)ois.readObject());</span><br><span class="line">        <span class="keyword">for</span> (Student student : stus) </span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(student);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//----------------------------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">//第二种序列化和反序列化方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serializableMoreObject2</span><span class="params">(List&lt;Student&gt; list)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;dir/多个对象序列化文件2&quot;</span>));</span><br><span class="line">        <span class="comment">//此时要序列化操作，但是现在所有的对象都是存在List集合中，需要从集合中获取所有对象</span></span><br><span class="line">        <span class="keyword">for</span> (Student student : list) </span><br><span class="line">        &#123;</span><br><span class="line">            oos.writeObject(student); <span class="comment">//这样才是5对象序列化</span></span><br><span class="line">        &#125; </span><br><span class="line">        oos.flush();</span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deSerializableMoreObject2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;dir/多个对象序列化文件2&quot;</span>));</span><br><span class="line">        <span class="comment">//提供一个集合存储读取对象数据</span></span><br><span class="line">        List&lt;Student&gt; stus = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            readObject这个方法的返回值是Object类型，所以需要操作数据时需要向下转型</span></span><br><span class="line"><span class="comment">            因为文件中存储的5个对象，如果对象么有值使用什么代表--》null值</span></span><br><span class="line"><span class="comment">            利用这个原则进行数据读取操作</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            使用这种读取方式readObject提示一个EOFException含义</span></span><br><span class="line"><span class="comment">            此异常主要被数据输入流用来表明到达流的末尾</span></span><br><span class="line"><span class="comment">            证明是争取读取到文件中每一个数据并且读取到文件末尾，才会出现这个异常</span></span><br><span class="line"><span class="comment">            在while循环中提供判断是无法生效，它是无法获取到文件末尾的null，即没有这个null</span></span><br><span class="line"><span class="comment">            只能以异常形式停止，所以如何处理这个问题，会在集合存储的最后一个位置添加一个null作为结尾</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">while</span>((obj = ois.readObject())!=<span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            stus.add(((Student)obj));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">            while(true)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                try </span></span><br><span class="line"><span class="comment">                &#123;</span></span><br><span class="line"><span class="comment">                    obj = ois.readObject();</span></span><br><span class="line"><span class="comment">                    stus.add(((Student)obj));</span></span><br><span class="line"><span class="comment">                &#125; </span></span><br><span class="line"><span class="comment">                catch (EOFException e) </span></span><br><span class="line"><span class="comment">                &#123;</span></span><br><span class="line"><span class="comment">                    break;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        ois.close();</span><br><span class="line">        stus.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;知识点一：概念&quot;&gt;&lt;a href=&quot;#知识点一：概念&quot; class=&quot;headerlink&quot; title=&quot;知识点一：概念&quot;&gt;&lt;/a&gt;&lt;center&gt;知识点一：概念&lt;/center&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;PS：IO很简单主要记忆的就是IO中进行文件读写操</summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>22.File类和递归</title>
    <link href="http://example.com/post/8f9052f9.html"/>
    <id>http://example.com/post/8f9052f9.html</id>
    <published>2023-12-30T05:10:44.000Z</published>
    <updated>2024-03-01T11:40:12.142Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识点一：File类"><a href="#知识点一：File类" class="headerlink" title="知识点一：File类"></a><center>知识点一：File类</center></h1><p>File类是Java中专门提供给代码进行对文件系统中【操作系统】文件夹或文件进行操作的类，这个File类中提供【创建、删除、重命名、判断文件状态、检查文件的属性】等等功能，就可以通过File对象将系统中文件或文件夹以，面向对象的方式进行操作，File类只能对文件进行管理操作，对于文件内容存储数据File类是无法进行操作</p><p>File类就是Java中表示系统文件或系统文件夹的一个抽象，可以提供一个【路径】将路径所描述文件或文件夹具体化，并且提供File类中给提供方法对文件或文件进行操作</p><p>PS：建议尽量不在C盘判断进行操作，极少部分电脑对C盘操作是需要</p><p>权限【管理员权限】</p><p>文件和文件夹路径和问题？</p><p>操作系统中文件或文件夹的路径分为两种**”绝对路径”和”相对路径”**</p><p>PS:这里以windows系统为例：</p><p><strong>绝对路径： 是从系统盘符开始路径是绝对路径</strong>【在开发尽量少用】</p><p>windows系统中对绝对路径的路径分隔符号是【\】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\File类\笔记 --》绝对路径</span><br></pre></td></tr></table></figure><p>这里问题在于，在Java代码中【\】是转义字符，针对\后的字母进行转义操作，所以为了避免提供绝路径出现歧义在编写代码的时候如果提供绝对路径，路径分隔符要写成【\】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\\File类\\笔记 --》这样代码才可以读取这个绝对路径</span><br></pre></td></tr></table></figure><p>Java为了减少程序猿书写路径麻烦，Java会仿照Unix或Linux系统中提供路径分隔符进行路径分隔操作，提供是【&#x2F;】 –》 得到路径是 –》&#x2F;Users&#x2F;jkmaster，即将绝对路径修改为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:/File类/笔记 --》这样代码才可以读取这个绝对路径 此时【/】 等价于 【\\】</span><br></pre></td></tr></table></figure><p>PS：windows系统是可以兼容使用Unix或Liunx路径分隔符号，但是Unix或Liunx是不兼容windows的路径分隔符号</p><p>例如： 提供一个Linux文件系统根路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/Users/jkmaster/app/File类/笔记 ---》 Linux路径但是不可以这样写</span><br><span class="line">\\Users\\jkmaster\\app\\File类\\笔记 ---&gt;错误无法读取</span><br></pre></td></tr></table></figure><p><strong>相对路径：主要针对的服务器或IDEA编译工具的路径作为参考路径，从而形成路径就是相对路径</strong></p><p>PS: 相对路径是不区分操作系统</p><p>以工程中类文件作为参考进行文件路径拷贝操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">绝对路径--》C:\IdeaProjects\File\src\com\qfedu\FileAPI\FileAPIDemo.java</span><br></pre></td></tr></table></figure><p>以工程中类文件作为参数进行文件路径的拷贝操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">相对路径：src/com/qfedu/FileAPI/FileAPIDemo.java</span><br></pre></td></tr></table></figure><p>相对路径的提供必须有一个路径参考存在，不能随意提供相对路径，相对路径参考必须是一个真实存在路径，相对路径是在有绝对路径前提下提供，所以必须提供一个参考，<strong>在IDEA编译器工程中提供相对路径参考就是IDEA工程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">不可以在代码中这样提供相对路径</span><br><span class="line">提供一个绝对的路径：</span><br><span class="line"><span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;C:\\abc\123\\456&quot;</span>;    <span class="comment">//不是真实的路径</span></span><br><span class="line"><span class="type">String</span> <span class="variable">path2</span> <span class="operator">=</span> <span class="string">&quot;file.txt&quot;</span>; <span class="comment">//file.txt参考是path路径，这样完全错误</span></span><br></pre></td></tr></table></figure><p><strong>相对路径在什么位置提供针对的就是谁在进行参考</strong></p><p>PS：项目中是可以读取绝对路径，但是针对网络中读取本地的【视频或音频文件或图片】</p><p>&ensp;&ensp;&ensp;&ensp;本地读取文件【操作系统】使用盘符，但是从服务端读取  <a href="http://IP地址：端口号/文件路径">http://IP地址：端口号/文件路径</a></p><h2 id="1、File类中常用方法"><a href="#1、File类中常用方法" class="headerlink" title="1、File类中常用方法"></a><center>1、File类中常用方法</center></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileAPIDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//提供文件路径【文件路径分隔符号】</span></span><br><span class="line">        separator();</span><br><span class="line">        <span class="comment">//通过封装File对象获取文件或文件夹路径</span></span><br><span class="line">        showPath();</span><br><span class="line">        <span class="comment">//检查文件或文件夹的状态</span></span><br><span class="line">        checkFileState();</span><br><span class="line">        <span class="comment">//文件操作[记住]</span></span><br><span class="line">        operationFile();</span><br><span class="line">        <span class="comment">//文件夹操作[记录]</span></span><br><span class="line">        operationDirectory();</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">operationDirectory</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\123\\456\\789&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;判断file对象中是否存在文件夹：&quot;</span>+file.exists());</span><br><span class="line">        System.out.println(<span class="string">&quot;判断file是否是文件夹：&quot;</span>+file.isDirectory());</span><br><span class="line">        <span class="comment">//file.mkdir(); //创建文件夹【只能创建一个】</span></span><br><span class="line">        file.mkdirs();    <span class="comment">//同时创建多个文件夹</span></span><br><span class="line">        <span class="comment">//获取文件夹下所有文件或文件夹路径【String类型路径】</span></span><br><span class="line">        String[] list = file.list();</span><br><span class="line">        <span class="comment">//获取文件夹下所有文件或文件夹路径【File类型对象】</span></span><br><span class="line">        File[] files = file.listFiles();</span><br><span class="line">        <span class="comment">//提供系统所有盘符</span></span><br><span class="line">        File[] files1 = File.listRoots();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">operationFile</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//File对象另外的创建方式</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            提供父子路径进行拼接操作</span></span><br><span class="line"><span class="comment">            第一个参数是 父路径 ---》 一般是一个文件夹路径</span></span><br><span class="line"><span class="comment">            参数类型可以是一个File对象，也可以是String类型对象</span></span><br><span class="line"><span class="comment">            第二个参数是 子路径 ---》 一般是文件或文件夹路径</span></span><br><span class="line"><span class="comment">            参数类型可以是一个File对象，也可以是String类型对象</span></span><br><span class="line"><span class="comment">            子路径是不需要提供开始路径分隔符号：即 456.txt即可 无需</span></span><br><span class="line"><span class="comment">            \\456.txt</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\abc\\xxx\\123&quot;</span>,<span class="string">&quot;456.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//1. 判断file对象是否是文件</span></span><br><span class="line">        System.out.println(file.isFile());</span><br><span class="line">        <span class="comment">//2. 判断文件或文件夹是否存在</span></span><br><span class="line">        System.out.println(file.exists());</span><br><span class="line">        <span class="comment">//提供一个判断操作，判断文件是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(!file.exists())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                file.createNewFile();<span class="comment">//创建新的文件</span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (IOException e) </span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;文件创建失败：&quot;</span>+e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//删除文件</span></span><br><span class="line">            file.delete();</span><br><span class="line">            <span class="comment">//集【移动复制剪切粘贴重命名】与一身的方法</span></span><br><span class="line">            <span class="comment">// file.renameTo(new File(&quot;需要将文件或文件夹到什么</span></span><br><span class="line">            位置路径【移动路径中可以修改文件名字】<span class="string">&quot;));</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125; </span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    private static void checkFileState() </span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        //File对象中是一个文件</span></span><br><span class="line"><span class="string">        File file = new</span></span><br><span class="line"><span class="string">        File(&quot;</span>C:\\abc\\xxx\\<span class="number">123</span>\\<span class="number">456.</span>txt<span class="string">&quot;);</span></span><br><span class="line"><span class="string">        System.out.println(&quot;</span>文件是否可读：<span class="string">&quot;+file.canRead());</span></span><br><span class="line"><span class="string">        System.out.println(&quot;</span>文件是否可写：<span class="string">&quot;+file.canWrite());</span></span><br><span class="line"><span class="string">        //这个方法主要是针对Linux和Unix系统文件 --》 系统文件是有三个符号表文件状态 r【读】w【写】x【执行】</span></span><br><span class="line"><span class="string">        //在windows中效果不是很明显</span></span><br><span class="line"><span class="string">        System.out.println(&quot;</span>文件是否可执行：<span class="string">&quot;+file.canExecute());</span></span><br><span class="line"><span class="string">        System.out.println(&quot;</span>判断文件是否是隐藏文件：<span class="string">&quot;+file.isHidden());</span></span><br><span class="line"><span class="string">        System.out.println(&quot;</span>获取文件最后修改时间：<span class="string">&quot; + new Date(file.lastModified()));</span></span><br><span class="line"><span class="string">        //文件大小是根据存储内容大小决定</span></span><br><span class="line"><span class="string">        System.out.println(&quot;</span>文件的大小：<span class="string">&quot; + file.length() + &quot;</span>字节<span class="string">&quot;);</span></span><br><span class="line"><span class="string">    &#125; </span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    private static void showPath() </span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        //1. File类创建对象的方式，以字符串为参数进行路径传入即可</span></span><br><span class="line"><span class="string">        【绝对路径或相对路径】</span></span><br><span class="line"><span class="string">        //通过文件路径将456.txt这个文件封装到File这个对象中，通过</span></span><br><span class="line"><span class="string">        File对象就可以对这个文件进行操作</span></span><br><span class="line"><span class="string">        File file = new File(&quot;</span>C:\\abc\\xxx\\<span class="number">123</span>\\<span class="number">456.</span>txt<span class="string">&quot;);</span></span><br><span class="line"><span class="string">        System.out.println(file);    //重写toString方法打印的是存储的路径</span></span><br><span class="line"><span class="string">        //(了解) ---&gt; 获取文件绝对路径【返回值类型时File】</span></span><br><span class="line"><span class="string">        System.out.println(file.getAbsoluteFile());</span></span><br><span class="line"><span class="string">        //(了解) ---&gt; 获取文件绝对路径【返回值类型是String】</span></span><br><span class="line"><span class="string">        System.out.println(file.getAbsolutePath());</span></span><br><span class="line"><span class="string">        //(了解) ---&gt; 获取当前路径的上一级路径【返回值类型是 String】</span></span><br><span class="line"><span class="string">        System.out.println(file.getParent());</span></span><br><span class="line"><span class="string">        //(了解) ---&gt; 获取当前路径的上一级路径【返回值类型是File】</span></span><br><span class="line"><span class="string">        System.out.println(file.getParentFile());</span></span><br><span class="line"><span class="string">        //(知道) ---&gt; 获取文件路径</span></span><br><span class="line"><span class="string">        System.out.println(file.getPath());</span></span><br><span class="line"><span class="string">        // (记住) ---&gt; 获取文件的名字</span></span><br><span class="line"><span class="string">        System.out.println(file.getName());</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    private static void separator()</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        //除了数据类型一样之外，剩下完全相同根据不同操作系统动态变化分隔符号</span></span><br><span class="line"><span class="string">        System.out.println(File.separator);    //String类型分隔符号</span></span><br><span class="line"><span class="string">        System.out.println(File.separatorChar);    //char类型分隔符号</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="知识点二：递归"><a href="#知识点二：递归" class="headerlink" title="知识点二：递归"></a><center>知识点二：递归</center></h1><p>递归是方法一种【自身调用自身的一种方式】</p><p>递归调用时是一种特殊的调用形式，是方法自己调用自己即一个方法内部调用方法本身，这种方式被称之为递归，方法递归包含了一个隐式循环，它会重复执行某段代码，但是这个重复执行操作需要加以控制，否则就会出现”栈溢出错误</p><p>“递归的本身执行效率极高【在同时间内容所有资源都被递归所调用执行操作】，在开发中提供递归操作是需要特别注意</p><p>如何理解递归操作？</p><p>通俗：从前有座山，山里有座庙，庙里有一个老和尚和小和尚，老和尚在给小和尚讲故事，从前有座山，山里有座庙…..【小和尚睡着（递归的停止条件）】</p><p><strong>递归的必要原则：一定要提供一个递归的停止点，如何让递归正确停止下来</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//StackOverflowError show方法并没有正确停止方式，所以在栈中会堆积大量的show调用</span></span><br><span class="line">        <span class="comment">//必须注意正确停止递归，不要出现StackOverflowError错误停止递归【JVM虚拟机停止了】</span></span><br><span class="line">        show();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        show(); <span class="comment">//这就是递归【在show方法的内容调用自身show方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需求： 使用递归的方式计算1~5之间所有数据之和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.File;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDmo2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//正常解题</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        <span class="comment">//既然可以这样计算，也可以提供循环</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">5</span>; i &gt;= <span class="number">1</span>; i--) </span><br><span class="line">        &#123;</span><br><span class="line">            sum1 += i;</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(sum1);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ToSum(<span class="number">5</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">&#125; </span><br><span class="line">    <span class="comment">//当我们需要计算1~某个数字之间所有数据之和的时候1是确定值，也就是计算的最后一个位置也是开始的位置</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        提供一个方法，方法可以帮组累加计算 参数num就是需要累加到数据位置</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ToSum</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;    <span class="comment">//当得到1的时候，证明计算到最后一个值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> num + ToSum(num - <span class="number">1</span>);    <span class="comment">//形成递归</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                第一次调用ToSum方法时 ，参数是 5 执行 num == 1 不等于 执行 num+ToSum(num-1);</span></span><br><span class="line"><span class="comment">                即 5+ ToSum(5-1) 再次触发 ToSum调用</span></span><br><span class="line"><span class="comment">                第二次调用ToSum方法时 ，参数是(5-1) 执行 num == 1不等于 执行 num+ToSum(num-1)</span></span><br><span class="line"><span class="comment">                即 4+ToSum(4-1) 再次触发 ToSum调用</span></span><br><span class="line"><span class="comment">                第三次调用ToSum方法时 ，参数是(4-1) 执行 num == 1不等于 执行 num+ToSum(num-1)</span></span><br><span class="line"><span class="comment">                即 3+ToSum(3-1) 再次触发 ToSum调用</span></span><br><span class="line"><span class="comment">                第四次调用ToSum方法时 ，参数是(3-1) 执行 num == 1不等于 执行 num+ToSum(num-1)</span></span><br><span class="line"><span class="comment">                即 2+ToSum(2-1) 再次触发 ToSum调用</span></span><br><span class="line"><span class="comment">                第五次调用ToSum方法时 ，参数是(2-1) 执行 num == 1等于 方法执行return 1</span></span><br><span class="line"><span class="comment">                就会返回给第四次调用 2+ToSum(2-1) 作为ToSum方法的返回值获取 即 2+1 = 3</span></span><br><span class="line"><span class="comment">                3这个结果值就会返回第三调用3+ToSum(3-1)作为ToSum方法的返回值获取 即3+3 = 6</span></span><br><span class="line"><span class="comment">                6这个结果值就会返回第二调用4+ToSum(4-1)作为ToSum方法的返回值获取 即4+6 = 10</span></span><br><span class="line"><span class="comment">                10这个结果值就会返回第一次调用5+ToSum(5-1)作为ToSum方法的返回值获取 即 5+10 = 15</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需求: 有6个人， 第6个人说 比 第5个人大3岁，第5个人说 比 第4个人大3岁，第4个人说 比 第3个人大3岁，第3个人说 比 第2个人大3岁，第2个人说 比 第1个人大3岁，第1个人说自己13岁，问第6个人多大</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提供一个计算年龄递归方法，参数是int类型，n代表的是人数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sumAge</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)    <span class="comment">//最后一个人的时候年龄是13</span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">13</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> sumAge(n-<span class="number">1</span>)+<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="1、总结"><a href="#1、总结" class="headerlink" title="1、总结"></a><center>1、总结</center></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;1. 写递归必须要有结束点【递归的停止】，否则会出现</span></span><br><span class="line"><span class="string">StackOverflowError栈溢出错误【终止递归】&quot;</span></span><br><span class="line"><span class="string">&quot;2. 明确这个方法的重复做什么事情，是否有重复做事情的条件，是否可</span></span><br><span class="line"><span class="string">以重复做到事情&quot;</span></span><br><span class="line"><span class="string">&quot;3. 简单递归都是使用【循环解决】，但是深层次的递归是无法使用循环</span></span><br><span class="line"><span class="string">替代的&quot;</span></span><br><span class="line"><span class="string">&quot;4. 一般项目中书写递归一定要慎重，一般递归出现在于无法使用循环解</span></span><br><span class="line"><span class="string">决操作或是进行执行效率优化时&quot;</span></span><br></pre></td></tr></table></figure><p>进阶案例演示：遍历操作系统中某个盘符，获取判断中所有文件夹和文件夹信息，打印层级</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="comment">//使用递归遍历盘符下所有信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileLoopDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供一个File对象进行路径封装</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\&quot;</span>);</span><br><span class="line">        showLayers(file,<span class="number">0</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 提供遍历盘符方法</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> file 封装盘符的对象</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> level 等级</span></span><br><span class="line"><span class="comment">    * 0是最高级别，依次递增，主要是为了提供层级拼接效果使用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showLayers</span><span class="params">(File file, <span class="type">int</span> level)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建一个字符串构建器进行层级拼接</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">bs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;|--&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;level;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            bs.insert(<span class="number">0</span>,<span class="string">&quot;|&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.判断是文件夹还是文件，如果是文件就停止访问</span></span><br><span class="line">        File[] files = file.listFiles();</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(files))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//判断 files数组中存储的是文件还是文件夹</span></span><br><span class="line">        <span class="keyword">for</span> (File tempFile : files)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//先获取名字然后再进行判断操作</span></span><br><span class="line">            System.out.println(bs.toString().concat(tempFile.getName()));</span><br><span class="line">            <span class="comment">//如果是目录，继续查找目录中数据</span></span><br><span class="line">            <span class="keyword">if</span>(tempFile.isDirectory())</span><br><span class="line">            &#123;</span><br><span class="line">                showLayers(tempFile,level+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;知识点一：File类&quot;&gt;&lt;a href=&quot;#知识点一：File类&quot; class=&quot;headerlink&quot; title=&quot;知识点一：File类&quot;&gt;&lt;/a&gt;&lt;center&gt;知识点一：File类&lt;/center&gt;&lt;/h1&gt;&lt;p&gt;File类是Java中专门提供给代码进行对</summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>21.异常</title>
    <link href="http://example.com/post/a24af109.html"/>
    <id>http://example.com/post/a24af109.html</id>
    <published>2023-12-30T05:10:22.000Z</published>
    <updated>2024-03-01T11:33:25.642Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识点一：概念"><a href="#知识点一：概念" class="headerlink" title="知识点一：概念"></a><center>知识点一：概念</center></h1><p>程序在运行的过程出现的错误，称之为异常</p><h1 id="知识点二：异常处理的重要性"><a href="#知识点二：异常处理的重要性" class="headerlink" title="知识点二：异常处理的重要性"></a><center>知识点二：异常处理的重要性</center></h1><p>如果异常不处理，那么就会终止java虚拟机的运行。意味着出现异常后面的代码就不会再执行了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序出现异常，但是没有处理</span></span><br><span class="line">System.out.println(<span class="number">10</span>/<span class="number">0</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;处理了么&quot;</span>);     <span class="comment">//不会运行</span></span><br></pre></td></tr></table></figure><h1 id="知识点三：异常的分类"><a href="#知识点三：异常的分类" class="headerlink" title="知识点三：异常的分类"></a><center>知识点三：异常的分类</center></h1><ul><li>Throwable (异常的父类)<ul><li>Error(错误) 内存溢出、硬件等等(程序员无法通过程序解决)</li><li><strong>Exception</strong>(异常)需要程序处理<ul><li><strong>运行期</strong>异常(未检查) 程序运行期间出现的异常<strong>RuntimeException</strong></li><li><strong>不是必须处理</strong><ul><li>举例：空指针异常、类转换异常、数组下标越界异常、输入异常、下标越界异常等</li></ul></li><li><strong>编译期</strong>异常 (受检)程序在编译期间出现的异常<strong>Exception</strong></li><li><strong>必须处理</strong><ul><li>举例：ParseException InterruptedException等</li></ul></li></ul></li></ul></li></ul><h1 id="知识点四：异常处理"><a href="#知识点四：异常处理" class="headerlink" title="知识点四：异常处理"></a><center>知识点四：异常处理</center></h1><h2 id="1、捕获异常-主动处理"><a href="#1、捕获异常-主动处理" class="headerlink" title="1、捕获异常(主动处理)"></a><center>1、捕获异常(主动处理)</center></h2><p>try、catch、finally</p><p><strong>语法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    可能会出现异常的代码</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(要捕获的异常类型<span class="number">1</span> 变量名)</span><br><span class="line">&#123;</span><br><span class="line">    如果出现对应异常所执行的代码</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(要捕获的异常类型<span class="number">2</span> 变量名 )</span><br><span class="line">&#123;</span><br><span class="line">    如果出现对应异常所执行的代码</span><br><span class="line">&#125;...</span><br></pre></td></tr></table></figure><p>catch需要注意的点</p><p>&ensp;&ensp;&ensp;&ensp;（1）catch中捕获的异常类型必须要与出现异常的类型要一致(大于等于)，否则相当于没有处理异常</p><p>&ensp;&ensp;&ensp;&ensp;（2）catch中的异常类型可以捕获多个,注意：捕获异常的顺序是从小到大</p><p>&ensp;&ensp;&ensp;&ensp;（3）捕获异常的时候，可以捕获最大的异常Exception</p><p>finally的特点</p><p>&ensp;&ensp;&ensp;&ensp;（1）无论代码是否出现异常，都会执行finally中的代码</p><p>&ensp;&ensp;&ensp;&ensp;（2） 一般在finally写释放资源的代码</p><p>&ensp;&ensp;&ensp;&ensp;（3）如果方法中出现return关键字，finally依旧会执行.（但是如果调用System.exit(0);那么finally不会再执行）</p><p>try catch finally使用语法</p><p>&ensp;&ensp;&ensp;&ensp;try{…}catch(){..} 一起使用</p><p>&ensp;&ensp;&ensp;&ensp;try{…}catch(){..}catch(){..} 一起使用</p><p>&ensp;&ensp;&ensp;&ensp;try{…}finally{….} 一起使用</p><p>&ensp;&ensp;&ensp;&ensp;try{…}catch(){..}catch(){..}finally{….} 一起使用</p><p>&ensp;&ensp;&ensp;&ensp;不能单独使用</p><p>捕获异常 代码执行的顺序</p><p>先执行try中的代码</p><p>&ensp;&ensp;&ensp;&ensp;（1）没有异常，正常执行完整个程序</p><p>&ensp;&ensp;&ensp;&ensp;（2）有异常 ,就会执行对应catch语句块。而try后面的代码就不会执行了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果要对不同异常要做不同处理，则用这种形式</span></span><br><span class="line"><span class="comment">//        try</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            //try中放可能会出现错误的代码</span></span><br><span class="line"><span class="comment">//            String[] names = &#123;&quot;jack&quot;,&quot;rose&quot;&#125;;</span></span><br><span class="line"><span class="comment">//            System.out.println(names[3]);</span></span><br><span class="line"><span class="comment">//            String s = null;</span></span><br><span class="line"><span class="comment">//            System.out.println(s.length());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        catch (NullPointerException e)</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            //一定一定记住!!!     无论如何要把错误信息打印出来</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();    //打印异常信息</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;当出现空指针异常的时候会执行这里代码&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        catch (ArrayIndexOutOfBoundsException e)</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;出现数组下标越界异常的时候会执行这里代码&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;这里代码会执行么？？？&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果不需要分别处理不同异常，则用这种形式</span></span><br><span class="line"><span class="comment">//        try</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            //try中放可能会出现错误的代码</span></span><br><span class="line"><span class="comment">//            String[] names = &#123;&quot;jack&quot;,&quot;rose&quot;&#125;;</span></span><br><span class="line"><span class="comment">//            System.out.println(names[3]);</span></span><br><span class="line"><span class="comment">//            String s = null;</span></span><br><span class="line"><span class="comment">//            System.out.println(s.length());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        //Exception:无论啥异常，都可以捕获那个最大异常</span></span><br><span class="line"><span class="comment">//        catch (Exception e)  //写异常时要从小异常写到大异常</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            //一定一定记住!!!     无论如何要把错误信息打印出来</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();    //打印异常信息</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;当出现异常的时候会执行这里代码&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;这里代码会执行么？？？&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//try中放可能会出现错误的代码</span></span><br><span class="line">            String[] names = &#123;<span class="string">&quot;jack&quot;</span>,<span class="string">&quot;rose&quot;</span>&#125;;</span><br><span class="line">            System.out.println(names[<span class="number">1</span>]);</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            System.out.println(s.length());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//一定一定记住!!!     无论如何要把错误信息打印出来</span></span><br><span class="line">            e.printStackTrace();    <span class="comment">//打印异常信息</span></span><br><span class="line">            System.out.println(<span class="string">&quot;当出现异常的时候会执行这里代码&quot;</span>);</span><br><span class="line">            <span class="comment">//return; //finally执行</span></span><br><span class="line">            System.exit(<span class="number">0</span>); <span class="comment">//jvm结束，finally不会执行</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span>     <span class="comment">//无论try、catch结构是否报错都会执行</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//一般用于写释放资源的代码</span></span><br><span class="line">            System.out.println(<span class="string">&quot;这是finally中的代码&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;这里代码会执行么？？？&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、抛出异常-被动处理"><a href="#2、抛出异常-被动处理" class="headerlink" title="2、抛出异常(被动处理)"></a><center>2、抛出异常(被动处理)</center></h2><h3 id="（1）在方法上声明-throws"><a href="#（1）在方法上声明-throws" class="headerlink" title="（1）在方法上声明 throws"></a>（1）在方法上声明 throws</h3><p>语法： public void show() throws 异常的类型1,异常的类型2{}</p><p>特点:</p><p>&ensp;&ensp;&ensp;&ensp;1）如果在方法上声明异常，那么方法的调用者就要进行处理</p><p>&ensp;&ensp;&ensp;&ensp;2）如果异常声明在了main方法上，实际上就是给jvm处理(那就是没有处理)</p><p>&ensp;&ensp;&ensp;&ensp;3）声明异常可以声明多个</p><p>场景：</p><p>&ensp;&ensp;&ensp;&ensp;1）当前无法对异常进行处理的时候，就可以把异常抛给方法的调用者。</p><p>&ensp;&ensp;&ensp;&ensp;2）现在如果代码出现异常(直接try、catch)</p><p>特殊案例：</p><p>&ensp;&ensp;&ensp;&ensp;如果在main方法上声明(抛出)异常,那么这个异常就叫给了main 方法的调用者。而main方法的调用者是jvm，所以这个异常并没有处理</p><h3 id="（2）在方法内部抛出-throw"><a href="#（2）在方法内部抛出-throw" class="headerlink" title="（2）在方法内部抛出 throw"></a>（2）在方法内部抛出 throw</h3><p>语法： throw 异常对象;</p><p>特点:</p><p>&ensp;&ensp;&ensp;&ensp;1）如果抛出运行期异常，那么直接抛出即可</p><p>&ensp;&ensp;&ensp;&ensp;2）如果抛出编译期异常，那么需要在方法上声明抛出</p><p>场景：</p><p>&ensp;&ensp;&ensp;&ensp;一般写框架的时候，设计</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionDemo02</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//调用者需要处理这个异常</span></span><br><span class="line"><span class="comment">//        m1();   //如果调用者继续抛出，则这个异常没有处理</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;这个代码会执行么？？&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用者</span></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            m2(<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;进入到首页&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;返回到登陆页面&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不知道怎么处理异常时</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> <span class="keyword">throws</span> ParseException   <span class="comment">//抛出异常</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyy-MM-dd&quot;</span>);</span><br><span class="line">        <span class="comment">//快捷方式：alt+enter</span></span><br><span class="line">        sdf.parse(<span class="string">&quot;2022/03/29&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一些大型框架都是抛出，让调用者解决异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">(String username,String passward)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!username.equals(<span class="string">&quot;admin&quot;</span>) || !passward.equals(<span class="string">&quot;123456&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//主动抛出异常</span></span><br><span class="line">            <span class="comment">//语法：throw 异常对象</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;用户或密码错误&quot;</span>); <span class="comment">//编译期异常</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><p>&ensp;&ensp;&ensp;&ensp;1）运行期异常，一般不需要处理，可以利用逻辑判断解决(避免)</p><p>&ensp;&ensp;&ensp;&ensp;2）编译期异常，必须要解决 现在如果代码出现异常(现阶段直接try、catch)</p><h2 id="3、自定义异常"><a href="#3、自定义异常" class="headerlink" title="3、自定义异常"></a><center>3、自定义异常</center></h2><p>（1）自定义运行时异常</p><p>&ensp;&ensp;&ensp;&ensp;写一个类继承自RuntimeException</p><p>&ensp;&ensp;&ensp;&ensp;编写有参和无参构造方法</p><p>（2）自定义编译期异常</p><p>&ensp;&ensp;&ensp;&ensp;写一个类继承自Exception</p><p>&ensp;&ensp;&ensp;&ensp;编写有参和无参构造方法</p><p>应用场景：</p><p>&ensp;&ensp;&ensp;&ensp;（1）一般在系统的异常无法满足自己公司需求的时候会自定义异常。</p><p>&ensp;&ensp;&ensp;&ensp;（2）自定义异常一般和throw抛出一起配合使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UsernameAndPasswardException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> <span class="comment">//编译期异常</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//构造一个无参和一个参数的函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UsernameAndPasswardException</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>();    <span class="comment">//调用父类</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UsernameAndPasswardException</span><span class="params">(String message)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionDemo02</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//调用者</span></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            m2(<span class="string">&quot;adm&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;进入到首页&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;返回到登陆页面&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">(String username,String passward)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!username.equals(<span class="string">&quot;admin&quot;</span>) || !passward.equals(<span class="string">&quot;123456&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//主动抛出异常</span></span><br><span class="line">            <span class="comment">//语法：throw 异常对象</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameAndPasswardException</span>(<span class="string">&quot;用户或密码错误&quot;</span>); <span class="comment">//编译期异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承中方法的重写</p><p>&ensp;&ensp;&ensp;&ensp;子类重写父类的方法，不能抛出比父类更大、更多的编译器异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> <span class="keyword">throws</span> ParseException</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子类不能抛出父类更多更大的编译期异常</span></span><br><span class="line"><span class="comment">     * 子类抛出的异常不能比父类的大，且抛出异常的个数不能超过父类抛出异常的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> <span class="keyword">throws</span> ParseException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyy-MM-dd&quot;</span>);</span><br><span class="line">        sdf.parse(<span class="string">&quot;2022-03-23&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、File类"><a href="#4、File类" class="headerlink" title="4、File类"></a><center>4、File类</center></h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>表示操作系统磁盘上的文件或者是文件夹</p><p>路径：</p><p>&ensp;&ensp;&ensp;&ensp;相对路径 （相对于当前工程的跟路径）</p><p>&ensp;&ensp;&ensp;&ensp;绝对路径 (在磁盘上的完整路径)</p><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建File对象</span></span><br><span class="line">        <span class="comment">//参数：文件或文件夹路径(绝对路径)，第一种构建方式</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\a.txt&quot;</span>); <span class="comment">//表示的是一个文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\zz&quot;</span>);    <span class="comment">//表示的是文件夹</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种构建方式</span></span><br><span class="line">        <span class="comment">//参数1：父目录的路径(字符串) 参数2：子目录的路径</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:&quot;</span>,<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三种构建方式</span></span><br><span class="line">        <span class="comment">//参数1：父目录(file对象) 参数2：子目录路径</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(file2,<span class="string">&quot;c.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//参数:文件或者文件夹(相对路径:相对于当前工程)</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h3><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>createNewFile()</td><td>创建一个新文件</td></tr><tr><td>mkdir()</td><td>创建一个新目录。如果父目录不存在，则无法创建</td></tr><tr><td>mkdirs()</td><td>创建一个新目录。如果父目录不存在，则一起创建</td></tr><tr><td>delete()</td><td>删除文件或空目录</td></tr><tr><td>exists()</td><td>判断File对象所对象所代表的对象是否存在</td></tr><tr><td>length()</td><td>获取文件(夹)的大小(字节)</td></tr><tr><td>getAbsolutePath()</td><td>获取文件的绝对路径</td></tr><tr><td>getAbsoluteFile()</td><td>获取文件(夹)的绝对路径:（返回File）</td></tr><tr><td>getName()</td><td>获取当前file对象的文件名或者是文件夹名</td></tr><tr><td>getParent()</td><td>获取当前file对象的父目录（返回String）</td></tr><tr><td>isDirectory()</td><td>是否是目录</td></tr><tr><td>isFile()</td><td>是否是文件</td></tr><tr><td>getPath()</td><td>获取文件(夹)的相对路径:（返回String）</td></tr><tr><td>listFiles()</td><td>列出目录中的所有内容</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemo02</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建文件</span></span><br><span class="line"><span class="comment">//        File file = new File(&quot;a.txt&quot;);</span></span><br><span class="line"><span class="comment">//        try</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            //创建文件</span></span><br><span class="line"><span class="comment">//            file.createNewFile();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        catch (IOException e)</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建文件夹</span></span><br><span class="line">        <span class="comment">//mkdirs(); 如果父目录不存在连同父目录一起创建</span></span><br><span class="line">        <span class="comment">//mkdir();  如果父目录不存在则创建不成功</span></span><br><span class="line"><span class="comment">//        File file = new File(&quot;d:\\zz&quot;);</span></span><br><span class="line"><span class="comment">//        file.mkdirs();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//在创建文件或者文件夹的时候，先判断文件或者文件夹是否存在</span></span><br><span class="line"><span class="comment">//        File file = new File(&quot;d:\\zz\\aa&quot;);</span></span><br><span class="line"><span class="comment">//        System.out.println(file.exists());</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        File file = new File(&quot;d:\\z\\aa&quot;);  //文件</span></span><br><span class="line"><span class="comment">//        //判断是否是文件</span></span><br><span class="line"><span class="comment">//        System.out.println(file.isFile());</span></span><br><span class="line"><span class="comment">//        //判断是否是文件夹</span></span><br><span class="line"><span class="comment">//        System.out.println(file.isDirectory());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//File file = new File(&quot;a.txt&quot;);</span></span><br><span class="line">        <span class="comment">//获取文件的绝对路径</span></span><br><span class="line"><span class="comment">//        System.out.println(file.getAbsolutePath()); //返回类型：String</span></span><br><span class="line"><span class="comment">//        System.out.println(file.getAbsoluteFile()); //返回类型：File</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取文件的父目录  如果写的是相对路径，则会按照相对路径去找父目录</span></span><br><span class="line"><span class="comment">//        System.out.println(file.getParent());</span></span><br><span class="line"><span class="comment">//        System.out.println(file.getParentFile());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除文件</span></span><br><span class="line">        <span class="comment">//如果file对象是一个文件则可以删除</span></span><br><span class="line">        <span class="comment">//如果file对象是一个空文件夹则可以删除，但是如果文件夹中有内容则无法删除</span></span><br><span class="line">        <span class="comment">//System.out.println(file.delete());  //成功返回true，失败返回false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取文件或文件夹的名称</span></span><br><span class="line">        <span class="comment">//System.out.println(file.getName());</span></span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\zz&quot;</span>);</span><br><span class="line">        <span class="comment">//获取当前文件夹下所有的文件或者文件夹名称</span></span><br><span class="line">        String[] a = file.list();</span><br><span class="line">        <span class="keyword">for</span> (String s : a)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;知识点一：概念&quot;&gt;&lt;a href=&quot;#知识点一：概念&quot; class=&quot;headerlink&quot; title=&quot;知识点一：概念&quot;&gt;&lt;/a&gt;&lt;center&gt;知识点一：概念&lt;/center&gt;&lt;/h1&gt;&lt;p&gt;程序在运行的过程出现的错误，称之为异常&lt;/p&gt;
&lt;h1 id=&quot;知</summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>20.集合</title>
    <link href="http://example.com/post/9e25cba9.html"/>
    <id>http://example.com/post/9e25cba9.html</id>
    <published>2023-12-30T05:09:59.000Z</published>
    <updated>2024-02-29T12:37:21.380Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识点一：集合框架"><a href="#知识点一：集合框架" class="headerlink" title="知识点一：集合框架"></a><center>知识点一：集合框架</center></h1><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a><center>1、概念</center></h2><p>&ensp;&ensp;&ensp;&ensp;如果处理一套通用逻辑就提供一个自定义封装处理数组的类，那么开发中可能会需要提供N这样类，问题在于需要自行完成操作，Java也发现这个问题，所有为了让程序猿可以更加的便捷的对数据进行操作，无需向数组一样提供【增删改查】的自定义实现，Java提供一个集合框架，便于程序猿对数据进行存储与管理操作</p><p>什么是集合框架？</p><p>&ensp;&ensp;&ensp;&ensp;Java中的集合框架其实就是对【数据结构】的封装，这个封装中提供了一些常用方法，可方便操作数据，无需程序猿自定定义操作，只需要调用封装方法就可以完成对存在集合中数据【增删改查】集合其实就是对数据结构一种封装，所以之前sun公司就把集合放置到一个统一包中进行管理【java.util】包</p><p>什么是数据结构？</p><p>&ensp;&ensp;&ensp;&ensp;数据结构其实就是计算机，组织和存储数据形式</p><p>&ensp;&ensp;&ensp;&ensp;数据结构是指相互之间存在一种或多种特定关系的数据集合</p><p>&ensp;&ensp;&ensp;&ensp;通常情况下，精心选择数据结构可以带来更加高效运行和存储效率，数据结构往往高效的原因在于【检索算法】和【索引计数】</p><p>&ensp;&ensp;&ensp;&ensp;常见数据结构：【数组、栈、链表(单向和双向)、哈希表、队列(单向和双向)、堆、树、图】</p><p>&ensp;&ensp;&ensp;&ensp;Java的集合框架其实就是对【数据结构实现】，我们需要掌握就是如何操作这个数据结构（即操作集合中方法），高效存储与处理数据</p><p>PS：根据不同数据结构，操作数据性能是不同（有地查询块、有的插入快、有地允许重复、有的不允许重复等等），在开发中只要选择合理数据结构即集合对数据存储与操作即可</p><p>推荐： 后期可以看一本书【大话数据结构】 —》兄弟 —-》【大话设计模式】</p><h2 id="2、集合架构"><a href="#2、集合架构" class="headerlink" title="2、集合架构"></a><center>2、集合架构</center></h2><p>PS：习惯性说Java中集合有三大框架【List、Set和Map】</p><p>如果详细说明的话应该2个框架3个实现：</p><p>&ensp;&ensp;&ensp;&ensp;2个框架： Collection 和 Map</p><p>&ensp;&ensp;&ensp;&ensp;3个实现 ：Collection这个集合下两个主要实现 List 和 set 所以称为三大集合List、set 和Map</p><p>集合和数组最大区别在于：</p><ol><li>集合中只能存储引用类型即对象</li><li>集合是一个变长容量，根据集合存储元素个数动态进行删减【扩容和减容】</li><li>数组是一个定长容器，创建大小数固定，无论存储多少数据长度都是唯一</li></ol><p>常见三大集合框架：</p><ol><li>List【列表】：集合中存储对象是按照索引位置进行存储，允许存储重复数据</li><li>Set【集】: 集合中存储对象不是按照特定方式进行存储，不允许出现重复数据</li><li>Map【映射】：集合中每一个存储元素都是以一种【键值对keyvalue】方式进行存储的，以一种key和value的形式存储的，key这个对象是不允许重复【唯一性】，value是允许重复</li></ol><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271930400.jpg" alt="列表、集合、映射图" style="zoom: 33%;"><p>无论什么时候都要先创建Collection对象</p><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271930293.jpg" alt="集合"></p><h2 id="3、List集合"><a href="#3、List集合" class="headerlink" title="3、List集合"></a><center>3、List集合</center></h2><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271930586.jpg" alt="List集合"></p><h1 id="知识点二：List集合之ArrayList集合"><a href="#知识点二：List集合之ArrayList集合" class="headerlink" title="知识点二：List集合之ArrayList集合"></a><center>知识点二：List集合之ArrayList集合</center></h1><h2 id="1、分析ArrayList的效率"><a href="#1、分析ArrayList的效率" class="headerlink" title="1、分析ArrayList的效率"></a><center>1、分析ArrayList的效率</center></h2><p>因为ArrayList使用是数组实现所以可以得到如下以下特点：</p><ol><li>保存操作：</li></ol><p>&ensp;&ensp;&ensp;&ensp;把一个数据保存到ArrayList中，最快的操作只要操作一次即可，最慢的操作可能操作N次</p><p>&ensp;&ensp;&ensp;&ensp;平均执行效率(N+1)&#x2F;2次 —》扩容问题</p><ol start="2"><li>删除操作:</li></ol><p>删除ArrayList中某个数据，最快的只要操作一次即可， 最慢的操作可能操作N次</p><p>平均执行效率(N+1)&#x2F;2次 —》减容问题</p><ol start="3"><li><p>修改操作: 操作一次即可</p></li><li><p>查询操作：根据索引一次即可。如果遍历查询使用【检索算法】做优化效率高度，如果遍历从到为【顺序查找】效率是低</p></li></ol><p>因为ArrayList使用是数组的形式进行存储数据操作，所以基于这样数据结构做查询和修改效率是高，但是做增加和删除效率是低【动态扩容和减容】</p><h2 id="2、语法"><a href="#2、语法" class="headerlink" title="2、语法"></a><center>2、语法</center></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;泛型&gt; 变量名 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><h2 id="3、常用方法"><a href="#3、常用方法" class="headerlink" title="3、常用方法"></a><center>3、常用方法</center></h2><p>1）向指定下标位置添加一个元素,下标范围：0~list.sizelist.size：有多少个元素</p><p>&ensp;&ensp;&ensp;&ensp;变量名.add(指定下标数,添加的元素);</p><p>2）移除指定下标位置的元素,下标范围：0~list.size-1</p><p>&ensp;&ensp;&ensp;&ensp;变量名.remove(指定下标数);</p><p>3）修改指定下标位置的元素,下标范围：0~list.size-1</p><p>&ensp;&ensp;&ensp;&ensp;变量名.set(指定下标数,修改元素内容);</p><p>4）获取指定下标位置上的元素，下标范围：0~list.size-1</p><p>&ensp;&ensp;&ensp;&ensp;变量名.get(指定下标数)</p><p>&ensp;&ensp;&ensp;&ensp;返回值为对应的数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">import</span> java.util.function.UnaryOperator;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayListAPIDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//提供ArrayList集合对象进行数据的存储操作</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1.ArrayList集合提供一个无参构造方法可以创建一个空的集合对象</span></span><br><span class="line"><span class="comment">            --&gt;空指定的是集合没有存储任何数据，但是集合引用是在的</span></span><br><span class="line"><span class="comment">            在Java7，使用new ArrayList无参构造方法创建对象，一个元素都不存储</span></span><br><span class="line"><span class="comment">            依旧会在堆中开辟一个大小为10的数据空间，并且数组的默认存储数据类型时Object</span></span><br><span class="line"><span class="comment">            在Java8中，Java开发人员发现，如果在使用ArrayList集合之前，如果使用无参构造方法</span></span><br><span class="line"><span class="comment">            创建ArrayList集合对象会出现一个10大小的堆中数组空间，这样会造成一定量的空间浪费</span></span><br><span class="line"><span class="comment">            所以在Java8中提供一个全新优化，使用 new ArrayList无参构造方法创建ArrayList对象时</span></span><br><span class="line"><span class="comment">            并不会创建一个大小为10数组在堆中进行存储，而是创建创建一个空的数组进行空间的开辟</span></span><br><span class="line"><span class="comment">            private static final Object[]</span></span><br><span class="line"><span class="comment">            DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span></span><br><span class="line"><span class="comment">            当通过集合对象调用集合集合中提供add方法时，此时才会真正的初始化数组空间</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="comment">//2.ArrayList集合使用其他的Collection集合对象中存储数据</span></span><br><span class="line">        作为新的集合中存储数据进行初始化</span><br><span class="line">        <span class="comment">//即将参数中Collection集合对象数据存储到新建ArrayList集</span></span><br><span class="line">        合中</span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(list);</span><br><span class="line">        <span class="comment">//3.自定义ArrayList集合的底层数组初始化容量 --》【使用较少】</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">//常用API</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.向集合对象中添加元素【存储数据】 ---》 集合只能存储引用</span></span><br><span class="line">        类型即对象</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            集合中只能存储引用类型 --&gt; 明显调用add时存储的是1,2,3,4,5 int类型数据</span></span><br><span class="line"><span class="comment">            可以存储的，因为向集合中存储基本数据类型时，完成自动转换操作 --》将基本数据类型 转换为对应 包装类</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        list.add(<span class="number">4</span>);</span><br><span class="line">        list.add(<span class="number">5</span>);</span><br><span class="line">        list.add(<span class="string">&quot;6&quot;</span>);</span><br><span class="line">        <span class="comment">//集合在没有使用泛型之前是可以存储任何引用类型对象,因为方法参数类型时Object</span></span><br><span class="line">        <span class="comment">//ArrayList集合重写toString，所以可以直接打印集合对象查看集合内容</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.向集合中指定位置添加元素数据【第一个参数是下标位置，第二个参数是存储的元素】</span></span><br><span class="line">        list.add(<span class="number">2</span>,<span class="number">100</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.向集合中添加参数集合中数据到集合中进行存储</span></span><br><span class="line">        <span class="comment">//PS：参数是一个Collection集合，所以只要是List或Set集合实现类都是传递到这个参数中</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list1_1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list1_1.add(<span class="number">1</span>);</span><br><span class="line">        list1_1.add(<span class="number">2</span>);</span><br><span class="line">        list.addAll(list1_1);    <span class="comment">//将list1_1集合里面的数据存储到list集合中</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//addAll有一个重载在指定位置中添加添加参数集合数据 addAll(下标, Collection集合对象);</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            特别注意： add 和 addAll的区别</span></span><br><span class="line"><span class="comment">            add这个方法是向集合中添加引用类型对象，即向集合集合添加地址</span></span><br><span class="line"><span class="comment">            addAll这个方法是向集合中添加参数中集合数据</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">arrayList1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">arrayList2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        arrayList1.add(<span class="number">1</span>);</span><br><span class="line">        arrayList1.add(<span class="number">2</span>);</span><br><span class="line">        System.out.println(arrayList1);</span><br><span class="line">        arrayList2.add(<span class="number">3</span>);</span><br><span class="line">        arrayList2.add(<span class="number">4</span>);</span><br><span class="line">        arrayList1.add(arrayList2);    <span class="comment">//相当于将arrayList2中引用存储到arrayList1这个集合中，存储是对象即地址</span></span><br><span class="line">        System.out.println(arrayList1);</span><br><span class="line">        arrayList1.addAll(arrayList2);    <span class="comment">//相当于将arrayList2中存储数据存储到arrayList1这个集合中，存储的是数据内容</span></span><br><span class="line">        System.out.println(arrayList1);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.清空集合中存储的数据，但是集合引用不会消失，消失的是集合数据</span></span><br><span class="line">        System.out.println(<span class="string">&quot;没有清空之前arrayList1中的数据是：&quot;</span>+arrayList1);</span><br><span class="line">        arrayList1.clear();</span><br><span class="line">        System.out.println(<span class="string">&quot;清空之后arrayList1中的数据是：&quot;</span>+arrayList1);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.判断集合否为空，即判断集合是都没有存储任何数据 [true空/false不空]</span></span><br><span class="line">        System.out.println(arrayList1.isEmpty());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//6.判断集合中是否存在指定元素【判断集合中是否存储在这个对象】 --&gt; true存在 false不存在</span></span><br><span class="line">        System.out.println(list.contains(<span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//7.判断集合中是否存在参数集合中数据 ---》这方法不是</span></span><br><span class="line">        ArrayList独有的而是List接口提供</span><br><span class="line">        System.out.println(list.containsAll(list1_1));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//8.通过集合中存储元素下标获取集合中元素 ---》【下标不要越界范围（0~集合存储元素个数-1）】</span></span><br><span class="line">        System.out.println(list.get(<span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//9.查询集合中是否存在指定元素并返回下标【只会返回第一次遇到元素的下标】</span></span><br><span class="line">        <span class="comment">// 找到了就是下标 找不到就是负数</span></span><br><span class="line">        System.out.println(list.indexOf(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">//list.lastIndexOf(查找的数据) --》查询集合中是否存在指定元素并返回下标【从后向前寻找】</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//10.集合是提供真正删除操作 ---&gt; 进行减容操作</span></span><br><span class="line">        <span class="comment">//10.1 根据数据删除集合中存在数据</span></span><br><span class="line">        list.remove(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>));</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//10.2 根据下标删除集合中数据</span></span><br><span class="line">        list.remove(<span class="number">6</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//10.3 List集合接口提供方法 removeAll</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list1_2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list1_2.add(<span class="number">2</span>);</span><br><span class="line">        list1_2.add(<span class="number">100</span>);</span><br><span class="line">        list1_2.add(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//根据参数集合提供数据在当前集合进行删除操作</span></span><br><span class="line">        list.removeAll(list1_2);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//10.4 List集合接口提供方法 retainAll</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list1_3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list1_3.add(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//根据参数集合提供数据保留当前集合中存储的数据，剩余的数据进行删除</span></span><br><span class="line">        list.retainAll(list1_3);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//10.5 在java8中ArrayList提供一个新的处理集合删除方法removeIf</span></span><br><span class="line">        <span class="comment">//这个方法参数支持 Lambda表达式 和 匿名内部类方式处理</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list1_4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list1_4.add(<span class="number">1</span>);</span><br><span class="line">        list1_4.add(<span class="number">2</span>);</span><br><span class="line">        list1_4.add(<span class="number">3</span>);</span><br><span class="line">        list1_4.add(<span class="number">5</span>);</span><br><span class="line">        list1_4.add(<span class="number">6</span>);</span><br><span class="line">        <span class="comment">//匿名内部类</span></span><br><span class="line">        list1_4.removeIf(<span class="keyword">new</span> <span class="title class_">Predicate</span>()&#123;</span><br><span class="line">        <span class="comment">//需要在这个方法方法执行删除规则 结果true就会进行删除操作</span></span><br><span class="line">        <span class="comment">//参数Object 中o会获取到集合每一个元素的值</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Object o)</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ((Integer)o)%<span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//lambda表达式</span></span><br><span class="line">        list1_4.removeIf(o-&gt; ((Integer)o)%<span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">        System.out.println(list1_4);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//11.Java8中提供一个全新的方法【支持lambda表达式和匿名内部类】</span></span><br><span class="line">        <span class="comment">//根据指定规则进行元素的替换操作</span></span><br><span class="line">        list1_4.replaceAll(<span class="keyword">new</span> <span class="title class_">UnaryOperator</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//指定当前替换规则的方法，方法参数Object中o会获取到所有集合中数据</span></span><br><span class="line">            <span class="comment">//需要在方法内部提供替换规则，返回的是替换之后需要存在集合中数据</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">apply</span><span class="params">(Object o)</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> o.equals(<span class="number">3</span>) ? <span class="number">30</span> : o;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        list1_4.replaceAll(o-&gt;o.equals(<span class="number">3</span>) ? <span class="number">30</span> : o);</span><br><span class="line">        System.out.println(list1_4);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//12. 修改【替换】集合中指定位置的数据 ---》第一个参数是下标，第二个参数修改数据</span></span><br><span class="line">        list1_4.set(<span class="number">0</span>,<span class="number">10000</span>);</span><br><span class="line">        System.out.println(list1_4);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//13.获取集合中存储元素个数【集合长度】</span></span><br><span class="line">        System.out.println(list1_4.size());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//14.将集合转换为数组</span></span><br><span class="line">        Object[] objects = list1_4.toArray();</span><br><span class="line">        <span class="comment">//PS：数组中也提供一个方法【Arrays】，将数组转换为List集合</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">objects1</span> <span class="operator">=</span> Arrays.asList(objects);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//15.【不太推荐】 截取指定范围内容集合数据得到一个新的集合</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">arrayList1_5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        arrayList1_5.add(<span class="number">1</span>);</span><br><span class="line">        arrayList1_5.add(<span class="number">2</span>);</span><br><span class="line">        arrayList1_5.add(<span class="number">3</span>);</span><br><span class="line">        arrayList1_5.add(<span class="number">4</span>);</span><br><span class="line">        arrayList1_5.add(<span class="number">5</span>);</span><br><span class="line">        arrayList1_5.add(<span class="number">6</span>);</span><br><span class="line">        arrayList1_5.add(<span class="number">7</span>);</span><br><span class="line">        arrayList1_5.add(<span class="number">8</span>);</span><br><span class="line">        <span class="comment">//包括前不包括后 包括开始位置，不包括结束位置，参数都是下标</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list1</span> <span class="operator">=</span> arrayList1_5.subList(<span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line">        System.out.println(list1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点三：List集合三种遍历方式"><a href="#知识点三：List集合三种遍历方式" class="headerlink" title="知识点三：List集合三种遍历方式"></a><center>知识点三：List集合三种遍历方式</center></h1><h2 id="普通for循环"><a href="#普通for循环" class="headerlink" title="普通for循环"></a><center>普通for循环</center></h2><p>PS：因为ArrayList的底层实现是数组，所以支持数组中提供下标进行</p><p>对ArrayList进行操作</p><p>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; 集合对象.size();i++)</span><br><span class="line">&#123;</span><br><span class="line">    循环变量i值就是ArrayList集合下标变量，<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> 定义下标初始值</span><br><span class="line">    ArrayList它获取集合长度使用 size() 方法</span><br><span class="line">    通过ArrayList集合提供get方法或set方法对集合数据进行</span><br><span class="line">取值与赋值操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：因为这里操作的是下标，所以可以利用下标对集合数据进行【增删改查】操作</p><h2 id="增强for循环【foreach循环】"><a href="#增强for循环【foreach循环】" class="headerlink" title="增强for循环【foreach循环】"></a><center>增强for循环【foreach循环】</center></h2><p>PS：因为ArrayList的底层实现是数组，所以支持数组中提供下标进行对ArrayList进行操作</p><p>语法格式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(集合中存储元素的类型 变量名 : 集合名)</span><br><span class="line">&#123;</span><br><span class="line">    通过操作局部变量就可以操作集合中数据了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：之前在学习数组的时候说过，数组遍历方式有两种一种普通for循环，一种是增强for循环，增强for循环只能使用在数组或集合中，在数组使用增强for循环它的实现原码是将数组值赋值给局部变量，所以对与增强for循环中局部变量修改是不会影响到数组，增强for循环适合简单数据运算、分支判断和打印数组中数据</p><p>特点：集合中增强for循环和数组中增强for循环同样效果，支持数组进行简单数据运算、分支判断和打印集合中数据，【但是不支持对集合中数据进行修改操作，也不允许在增强for循环中调用集合删除方法进行数据删除】，如果一旦删除就会出现一个【并发迭代修改异常 –》ConcurrentModificationException】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionForeach</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;jack&quot;</span>);    </span><br><span class="line">        list.add(<span class="string">&quot;rose&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;cxk&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;rose&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;尼古拉斯&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//List集合遍历方式1：使用迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.提供一个ArrayList集合对象</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        arrayList.add(<span class="number">1</span>);</span><br><span class="line">        arrayList.add(<span class="number">2</span>);</span><br><span class="line">        arrayList.add(<span class="number">3</span>);</span><br><span class="line">        arrayList.add(<span class="number">4</span>);</span><br><span class="line">        arrayList.add(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//提供一个普通for循环操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;arrayList.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//获取存储的数据</span></span><br><span class="line">            System.out.println(arrayList.get(i));</span><br><span class="line">            <span class="comment">// 通过下标对集合中数据进行修改</span></span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">2</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                arrayList.set(i, <span class="number">100</span>);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//通过下标进行数据删除操作 ---》 支持全套删除</span></span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                arrayList.remove(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(arrayList);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//增强for循环</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(Object obj : arrayList)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//obj中就会存储这个集合中所有数据</span></span><br><span class="line">            System.out.println(obj);<span class="comment">//打印集合数据</span></span><br><span class="line">            <span class="comment">//判断集合中数据做什么操作</span></span><br><span class="line">            <span class="keyword">if</span>(obj.equals(<span class="number">3</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//操作代码</span></span><br><span class="line">                System.out.println(obj);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//数据类型是可以做计算</span></span><br><span class="line">            sum += ((Integer)obj);</span><br><span class="line">            <span class="comment">//需要注意set方法无法使用，因为set第一个参数是下标</span></span><br><span class="line">            <span class="comment">//不能使用集合中删除方法，即在增强for循环中是不允许调用</span></span><br><span class="line">            删除方法的</span><br><span class="line">            <span class="keyword">if</span>(obj.equals(<span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                arrayList.remove(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(arrayList);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>提供增强for循环的原码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> arrayList.iterator();</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!iterator.hasNext())</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">    <span class="keyword">if</span> (obj.equals(Integer.valueOf(<span class="number">3</span>)))</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">    sum += ((Integer)obj).intValue();</span><br><span class="line">    <span class="keyword">if</span> (obj.equals(Integer.valueOf(<span class="number">1</span>)))</span><br><span class="line">    arrayList.remove(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>));</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"><span class="string">&quot;增强for循环之所以不可以删除,原因就是在于增强for循环即foreach底层实现就是一个迭代器，</span></span><br><span class="line"><span class="string">迭代器中是不允许使用集合中删除方法进行数据删除的，如果删除ConcurrentModificationException就出现这个异常&quot;</span></span><br></pre></td></tr></table></figure><h2 id="foreach方法遍历"><a href="#foreach方法遍历" class="headerlink" title="foreach方法遍历"></a><center>foreach方法遍历</center></h2><p>foreach是Java8中提供一个新增的方法，主要是以一个方法形态可以遍历打印集合中数据，因为这个方式Java8中提供，所以这个方法支持lambda表达式和匿名内部类实现</p><p>PS: 这个方法主要就是用于打印，其他方式较少</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java8ForArrayList</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供一个ArrayList集合对象</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        arrayList.add(<span class="number">1</span>);</span><br><span class="line">        arrayList.add(<span class="number">2</span>);</span><br><span class="line">        arrayList.add(<span class="number">3</span>);</span><br><span class="line">        arrayList.add(<span class="number">4</span>);</span><br><span class="line">        arrayList.add(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//方法内部可以指定打印效果</span></span><br><span class="line">        <span class="comment">//匿名内部类的形式</span></span><br><span class="line">        arrayList.forEach(<span class="keyword">new</span> <span class="title class_">Consumer</span>() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//这个方法中就是咱们打印集合中数据的形式</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Object o)</span> &#123;<span class="comment">//Object类型o参数</span></span><br><span class="line">            可以获取到集合每一个数据</span><br><span class="line">            System.out.println(o);</span><br><span class="line">            <span class="comment">//提供一些判断打印效果，根据具体需求来，这个方法没</span></span><br><span class="line">            有返回值，所以打印效果是不会影响实际存储数据的</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//Lambda表达式实现</span></span><br><span class="line">        arrayList.forEach(o -&gt; System.out.println(o));</span><br><span class="line">        <span class="comment">//提供Lambda中方法引用操作</span></span><br><span class="line">        arrayList.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点四：ArrayList底层实现原理"><a href="#知识点四：ArrayList底层实现原理" class="headerlink" title="知识点四：ArrayList底层实现原理"></a><center>知识点四：ArrayList底层实现原理</center></h1><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271931515.jpg" alt="ArrayList底层实现原理" style="zoom: 50%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayListDemo02</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1、构造方法初始化一个长度为0的Object数组</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * ArrayList底层的元素是数组</span></span><br><span class="line"><span class="comment">         * add方法的原理</span></span><br><span class="line"><span class="comment">         * 1、当第一次添加元素的时候，初始化一个长度为10的数组</span></span><br><span class="line"><span class="comment">         *  当添加元素超过数组的长度的时候，会对数组进行扩容，扩容到1.5倍</span></span><br><span class="line"><span class="comment">         * 2、将当前的元素添加到数组指定的下标位置上</span></span><br><span class="line"><span class="comment">         *    elementData[size++] = e;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *数组数据结构的特点：增删慢，查询快</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        list.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;rose&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点五：迭代器"><a href="#知识点五：迭代器" class="headerlink" title="知识点五：迭代器"></a><center>知识点五：迭代器</center></h1><p>Java中专门针对Collection集合提供了一种遍历方式，这种遍历方式是根据Iterable接口来决定，只要是Collection的集合接口在子接口基本上都会具备Iterable这个接口，这个接口中主要提供一个方法</p><table><thead><tr><th>Iterator</th><th>iterator() 返回按适当顺序在列表的元素上进行迭代的迭代器</th></tr></thead><tbody><tr><td></td><td>这个方法会返回一个按照集合顺序并存储集合数据的一个迭代器对象</td></tr></tbody></table><h2 id="1、迭代器原理"><a href="#1、迭代器原理" class="headerlink" title="1、迭代器原理"></a><center>1、迭代器原理</center></h2><p>迭代是重复反馈过程的活动,其目的通常是为了逼近所需目标或结果。每一次对过程的重复称为一次“迭代”,而每一次迭代得到的结果会作为下一次迭代的初始值</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291911167.jpg" alt="原理" style="zoom: 50%;"><h2 id="2、获取迭代器对象"><a href="#2、获取迭代器对象" class="headerlink" title="2、获取迭代器对象"></a><center>2、获取迭代器对象</center></h2><p>Iterator 变量名 &#x3D; Collection的变量名.iterator();</p><h2 id="3、迭代器的三个方法"><a href="#3、迭代器的三个方法" class="headerlink" title="3、迭代器的三个方法"></a><center>3、迭代器的三个方法</center></h2><p>（1）判断迭代器是否有下一个元素</p><p>&ensp;&ensp;&ensp;&ensp;变量名.hasNext();</p><p>&ensp;&ensp;&ensp;&ensp;返回值boolean类型</p><p>（2）获取当前游标对应元素并将游标向后移动一位</p><p>&ensp;&ensp;&ensp;&ensp;变量名.next()</p><p>&ensp;&ensp;&ensp;&ensp;返回迭代的下一个元素</p><p>（3）移除当前迭代器上对应的元素</p><p>&ensp;&ensp;&ensp;&ensp;变量名.remove();</p><p>&ensp;&ensp;&ensp;&ensp;说明：可以利用Iterator中提供三个核心方法操作迭代器影响集合中数据</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402292037504.png" alt="迭代器方法" style="zoom:50%;"><p>PS： 迭代器中在没有使用泛型之前，next方法的返回值类型都是统一Object，所以将方法中返回E看做是Object即可，迭代器提供自身remove方法，所以在迭代器中删除数据时要调用迭代器提供remove，而不是集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IteratorArrayList</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//基础迭代器</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        arrayList.add(<span class="number">1</span>);</span><br><span class="line">        arrayList.add(<span class="number">2</span>);</span><br><span class="line">        arrayList.add(<span class="number">3</span>);</span><br><span class="line">        arrayList.add(<span class="number">4</span>);</span><br><span class="line">        arrayList.add(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//需要使用ArrayList集合对象调用iterator方法获取迭代器对象</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> arrayList.iterator();</span><br><span class="line">        <span class="comment">//利用迭代器对象调用hasNext进行操作判断迭代器中是否还存在下一个元素</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        while(iterator.hasNext())</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            //通过next方法获取迭代器中数据</span></span><br><span class="line"><span class="comment">            System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//迭代器使用问题--》删除数据</span></span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> ((Integer) iterator.next());</span><br><span class="line">            <span class="keyword">if</span> (integer.equals(<span class="number">2</span>)) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//删除掉2这个值</span></span><br><span class="line">                <span class="comment">//iterator.remove();//使用迭代器中提供删除[删除迭代器中存储数据的同时会删除集合中对应数据]</span></span><br><span class="line">                <span class="comment">//千万不要调用集合中提供删除方法</span></span><br><span class="line">                <span class="comment">//ConcurrentModificationException --&gt; 就会出现并发迭代修改异常</span></span><br><span class="line">                </span><br><span class="line">                arrayList.remove(integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(arrayList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、强化迭代器"><a href="#4、强化迭代器" class="headerlink" title="4、强化迭代器"></a><center>4、强化迭代器</center></h2><p>强化迭代器只有List集合具备，专门为List集合提供一个增强迭代器，因为原始迭代器中只有三个方法，不利于对集合数据的操作，增强迭代器就新增多个方法进行迭代器操作</p><p>ListIterator是List集合在Iterator迭代器接口之上提供一个更多方法操作的迭代器，ListIterator在原始迭代器基础上增加，新增数据，修改数据，从后向前遍历【获取数据】的操作，还可以获取下标</p><table><thead><tr><th>void</th><th>add(E e) 将指定的元素插入列表（可选操作）</th></tr></thead><tbody><tr><td>boolean</td><td>hasNext() 以正向遍历列表时，如果列表迭代器有多个元素，则返回 true （换句话说，如果 next 返回一个元素而不是抛出异常，则返回 true ）</td></tr><tr><td>boolean</td><td>hasPrevious() 如果以逆向遍历列表，列表迭代器有多个元素，则返回 true</td></tr><tr><td>void</td><td>add(E e) 将指定的元素插入列表（可选操作）</td></tr><tr><td>E</td><td>next() 返回列表中的下一个元素</td></tr><tr><td>int</td><td>nextIndex() 返回对 next 的后续调用所返回元素的索引</td></tr><tr><td>E</td><td>previous() 返回列表中的前一个元素</td></tr><tr><td>int</td><td>previousIndex() 返回对 previous 的后续调用所返回元素的索引</td></tr><tr><td>void</td><td>remove() 从列表中移除由 next 或 previous 返回的最后一个元素（可选操作）</td></tr><tr><td>void</td><td>set(E e) 用指定元素替换 next 或 previous 返回的最后一个元素（可选操作）</td></tr></tbody></table><p>PS：在没有使用泛型之前，方法所有使用E的部分都看做是Object类型即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.ListIterator;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListIteratorArrayList</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//基础迭代器</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        arrayList.add(<span class="number">1</span>);</span><br><span class="line">        arrayList.add(<span class="number">2</span>);</span><br><span class="line">        arrayList.add(<span class="number">3</span>);</span><br><span class="line">        arrayList.add(<span class="number">4</span>);</span><br><span class="line">        arrayList.add(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//需要使用ArrayList集合对象调用listiterator方法获取迭代器对象</span></span><br><span class="line">        <span class="type">ListIterator</span> <span class="variable">iterator</span> <span class="operator">=</span> arrayList.listIterator();</span><br><span class="line">        <span class="comment">//如果你想调用逆向遍历操作时，需要现将光标向后移动才可以，光标最先开始是在第一个元素位置上</span></span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时对迭代器进行逆向遍历【从后向前】</span></span><br><span class="line">        <span class="keyword">while</span>(iterator.hasPrevious())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(iterator.previous());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">&quot;listIterator同样是遵守一个原则，不要再迭代器中使用后集合删除方法删除数据，要使用迭代器提供方法进行删除&quot;</span></span><br></pre></td></tr></table></figure><h2 id="5、迭代器注意事项"><a href="#5、迭代器注意事项" class="headerlink" title="5、迭代器注意事项"></a><center>5、迭代器注意事项</center></h2><p>（1）迭代器迭代完成之后，迭代器的位置在最后一位。 所以迭代器只能迭代一次</p><p>（2）迭代器在迭代的时候，不要调用多次next方法，可能会出错 NoSuchElementException</p><p>（3）在迭代器迭代的时候，不能向集合中添加或者删除元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionDemo03</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        coll.add(<span class="string">&quot;jeck&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;rose&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;马冬梅&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;Lisi&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、迭代器不能使用多次，如果要多次使用那么要多次获取</span></span><br><span class="line"><span class="comment">//        Iterator it = coll.iterator();</span></span><br><span class="line"><span class="comment">//        while (it.hasNext())</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(it.next());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        while (it.hasNext())</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(it.next());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、在同一次迭代中，不能多次使用next方法</span></span><br><span class="line"><span class="comment">//        Iterator it = coll.iterator();</span></span><br><span class="line"><span class="comment">//        while (it.hasNext())</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            //第一种</span></span><br><span class="line"><span class="comment">//            Object obj = it.next();</span></span><br><span class="line"><span class="comment">//            System.out.println(obj);</span></span><br><span class="line"><span class="comment">//            //第二种</span></span><br><span class="line"><span class="comment">//            System.out.println(it.next());</span></span><br><span class="line"><span class="comment">//            //不能这么多次使用</span></span><br><span class="line"><span class="comment">//            Object obj = it.next();</span></span><br><span class="line"><span class="comment">//            System.out.println(it.next());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、迭代器在迭代的过程中不能调用add或者remove方法</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            coll.add(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点六：List集合之LinkedList集合"><a href="#知识点六：List集合之LinkedList集合" class="headerlink" title="知识点六：List集合之LinkedList集合"></a><center>知识点六：List集合之LinkedList集合</center></h1><h2 id="1、说明"><a href="#1、说明" class="headerlink" title="1、说明"></a><center>1、说明</center></h2><p>LinkedList集合也是List集合接口中主要实现类，这个LinkedList的主要实现结构有【链表】，除了链表结构之外LinkeList还使用栈、 队列、数组，LinkedList是允许存重复数据化并且可以快速插入数据</p><p><strong>LinkedList中实现的数据结构</strong></p><p><strong>栈</strong>：stack,又称堆栈，它是运算受限的线性表，其限制是仅允许在表的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。</p><p>简单的说：采用该结构的集合，对元素的存取有如下的特点</p><p><strong>先进后出</strong>（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。例如，子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先弹出上面的子弹，然后才能弹出下面的子弹</p><p><strong>栈的入口、出口的都是栈的顶端位置</strong></p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291919875.png" alt="栈的位置" style="zoom:67%;"><p>这里两个名词需要注意：</p><p>&ensp;&ensp;&ensp;&ensp;<strong>压栈</strong>：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置</p><p>&ensp;&ensp;&ensp;&ensp;<strong>弹栈</strong>：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置</p><p><strong>队列</strong>：队列和栈有一些类似，也是一种受到限制的线性表，其限制是仅允许在表的一表进行插入，另外一段进行取出和删除，这样队列叫做单向队列【Queue】</p><p>队列是存在一个特点：先进先出</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291920090.png" alt="队列" style="zoom: 33%;"><p>队列：除了单向队列之外，还提供一种非受限制线性表，这表就是双端队列，依旧遵守先进先出原则，<strong>双端队列</strong>【Deque】</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291921569.png" alt="双端队列" style="zoom:33%;"><p>链表：链表属于一个线性表，线性表中包含了存储链接位置和数据的位置，利用链接位置进行相连接，使数据之间呈现一种链接状态，链表可以理解为：老鹰抓小鸡</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291921058.png" alt="链表" style="zoom:50%;"><p>链表和队列差不多，链表也分为单向和双向链表，类似于现实生活中的【火车】通过链接方式就可以获取得到链表中数据</p><p>单向链表和双向链表是有本质上区别的，单向链表包含两个区域【存储链接位置和数据存储位置】，通过【存储链接位置】让每一个单独链接节点进行相连，形成一个单向链表，即单向链表只能向一个方法进行遍历操作，双向链表包含是三个区域【2个存储链接位置和1个数据存储位置】 ，利用双向链表中两个存储链接的位置进行前后节点的链接，此时链表就形成了一个双向通道，即可以从头到尾，也可以从到头，允许直接在头尾两端进行操作</p><h2 id="2、分析LinkedList的执行效率"><a href="#2、分析LinkedList的执行效率" class="headerlink" title="2、分析LinkedList的执行效率"></a><center>2、分析LinkedList的执行效率</center></h2><p>主要实现方式是【双向链表】，所以使用LinkedList效果</p><ol><li><p>保存数据 ：只要执行一次即可【API中也提供 addFirst 和addLast】</p></li><li><p>删除操作： 只要执行一次即可【API中也提供 removeFirst 和removeLast】，就选中间节点(1+N)&#x2F;2</p></li><li><p>查询操作和修改操作：平均值(N+1)&#x2F;2</p></li></ol><p>结论：LinkedList增删执行效率是高的，但是查询和修改执行效率是低的</p><h2 id="3、常用方法-1"><a href="#3、常用方法-1" class="headerlink" title="3、常用方法"></a><center>3、常用方法</center></h2><p>常用的方法与ArrayList一致。自己独有一些向首尾添加移除等方法(可以模拟对列、堆栈等数据结构)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListAPIDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//因为LinkedList实现了List集合接口，所以具备所有List集合</span></span><br><span class="line">        操作方法</span><br><span class="line">        <span class="comment">//LinkedList中List方法操作完全参考ArrayList即可</span></span><br><span class="line">        <span class="comment">//LinkedList集合独有方法</span></span><br><span class="line">        <span class="comment">//1.创建LinkedList对象</span></span><br><span class="line">        <span class="comment">//1.1 创建一个空的LinkedList集合对象</span></span><br><span class="line">        <span class="type">LinkedList</span> <span class="variable">linkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">        <span class="comment">//1.2使用参数中Collection集合对象中存储数据初始化LinkedList集合对象</span></span><br><span class="line">        <span class="type">LinkedList</span> <span class="variable">linkedList1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>(linkedList);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//独有API        </span></span><br><span class="line">        <span class="comment">//1.向集合开头的位置添加元素</span></span><br><span class="line">        linkedList.addFirst(<span class="number">1</span>);</span><br><span class="line">        System.out.println(linkedList);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.向集合结尾的位置添加元素</span></span><br><span class="line">        linkedList.addLast(<span class="number">2</span>);</span><br><span class="line">        System.out.println(linkedList);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.获取集合第一个元素的数据【但是不删除集合数据】</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">element</span> <span class="operator">=</span> linkedList.element();</span><br><span class="line">        System.out.println(element);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.获取集合中第一个数据和最后一个数据【但是不删除集合数据】</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">first</span> <span class="operator">=</span> linkedList.getFirst();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">last</span> <span class="operator">=</span> linkedList.getLast();</span><br><span class="line">        <span class="comment">//PS： LinkedList允许使用下标形式进行数据获取</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> linkedList.get(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.添加元素到集合的末尾</span></span><br><span class="line">        linkedList.offer(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//添加到第一个位置offerFirst和最后一个位置offerLast</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//6.获取集合集合第一个元素但是【不删除集合数据】，有元素就返回，没有就是null</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">peek</span> <span class="operator">=</span> linkedList.peek();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> linkedList.peekFirst();</span><br><span class="line">        <span class="comment">//获取最后一个元素的值，有元素就返回，没有就是null</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> linkedList.peekLast();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//7.poll系列也是也可以获取集合中第一个和最后一个元素的【删除数据】</span></span><br><span class="line">        <span class="comment">//在获取数据的同时删除集合中数据</span></span><br><span class="line">        <span class="comment">// Object poll = linkedList.poll();</span></span><br><span class="line">        <span class="comment">// Object o3 = linkedList.pollFirst();</span></span><br><span class="line">        <span class="comment">// Object o4 = linkedList.pollLast();</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//8. 弹出集合中第一个数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">pop</span> <span class="operator">=</span> linkedList.pop();</span><br><span class="line">        <span class="comment">//向集合中添加数据</span></span><br><span class="line">        linkedList.push(<span class="number">4</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//9.删除集合中第一个或最后一个元素值</span></span><br><span class="line">        linkedList.removeFirst();</span><br><span class="line">        linkedList.removeLast();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//10.List集合特点就是允许存储重复数据，下面两个方法的作用就是遍历集合</span></span><br><span class="line">        <span class="comment">//First的方法从前之后 Last的方法从后向前</span></span><br><span class="line">        <span class="comment">//遇到第一个相同数据删除</span></span><br><span class="line">        linkedList.removeFirstOccurrence(<span class="number">1</span>);</span><br><span class="line">        linkedList.removeLastOccurrence(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//LinkedList有一个独有的迭代器，允许逆向的遍历迭代器中数据值</span></span><br><span class="line">        <span class="comment">//但是它的操作方式和iterator是一样</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> linkedList.descendingIterator();</span><br><span class="line">        <span class="comment">//它的方式只有三个 hasNext next 和 remove</span></span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//不同点在于：它的光标最先开始是放置在迭代器最后一个元素的位置，你hasNext是向前判断</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、LinkedList实现原理"><a href="#4、LinkedList实现原理" class="headerlink" title="4、LinkedList实现原理"></a><center>4、LinkedList实现原理</center></h2><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291923333.png" alt="实现原理" style="zoom:50%;"><h1 id="知识点七：List集合总结"><a href="#知识点七：List集合总结" class="headerlink" title="知识点七：List集合总结"></a><center>知识点七：List集合总结</center></h1><p>List集合是Collection集合子集合即List集合是继承与Collection集合，因为List集合是接口所以无法直接操作，Java就提供了两个可以便捷操作List集合实现类ArrayList和LinkedList</p><p>List集合的特点：允许存储重复数据并给存储数据是有顺序</p><p>在官方API文档中可以查看到：public interface List extends Collection</p><p>有序的 collection（也称为序列）。此接口的用户可以对列表中每个元素的插入位置进行精确地控制。用户可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素</p><p><strong>所有已知实现类</strong>： ArrayList 和 LinkedList</p><p><strong>所有超级接口</strong>： Collection 和 Iterable</p><p>因为也继承了Iterable所以List集合中是支持的迭代器【Iterator】</p><p>List接口中提供常用方法已经在ArrayList集合中完全进行演示，所以使用List集合时只要参考ArrayList提供方法演示就可以操作集合</p><p>ArrayList和LinkedList实现类是实现List接口，所以List相当于是他们的父类，所以List集合接口支持多态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">List集合接口允许这样这样创建对象</span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">或者</span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line"><span class="string">&quot;这样直接使用较少，多用于在方法中如果需要设置List集合参数，优先会</span></span><br><span class="line"><span class="string">将List作为参数类型，而不是实现类&quot;</span></span><br><span class="line"><span class="string">&quot;因为这样做可以接收ArrayList或LinkedList&quot;</span></span><br><span class="line"><span class="string">&quot;上面这种方式是不使用泛型，所以默认数据类型时Object，操作时就一定</span></span><br><span class="line"><span class="string">注意转换问题【对象的向下转型】&quot;</span></span><br><span class="line"><span class="string">&quot;Java中所有集合都是有泛型语法，所以可以使用泛型方式进行创建对象&quot;</span></span><br><span class="line">    List&lt;数据类型&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="string">&quot;泛型语法形式：&quot;</span></span><br><span class="line">    集合的数据类型&lt;数据类型&gt; 集合对象名字 = <span class="keyword">new</span> 集合数据类型&lt;&gt;();</span><br><span class="line"><span class="string">&quot;集合都是使用new关键字创建，所以它是引用类型&quot;</span></span><br><span class="line"><span class="string">&quot;现在学习ArrayList和LinkedList都是线程不安全的集合，在多线程操</span></span><br><span class="line"><span class="string">作前提下是不能使用这两个集合进行数据存储操作，这两个集合只适合在单线程下使用&quot;</span></span><br></pre></td></tr></table></figure><p>List集合接口还有一个<strong>实现类Vector</strong></p><p>Vector在JDK1.0的时候就已经存在，这个类其实是ArrayList集合类“前身”，在JDK1.2时候Java开始强调了集合框架概念，所以提供Collection集合框架，在Collection下面提供List和Set，Vector的实现也是数组，所以被归类到了List接口的实现类中，现在开发已经不在使用Vector这个类，主要使用ArrayList这个类</p><p>Vector和ArrayList之间相似点和区别在于什么？</p><p>相似点：都是List集合接口的实现类，都使用数组作为集合数据结构进行实现</p><p>不同点：Vector这个集合是线程安全的，但是效率低，提供较早并且使用率低</p><p>&ensp;&ensp;&ensp;&ensp;ArrayList这个集合是线程不安全，但是效率高，提供较晚并且使用率高</p><p>PS：就算Vector是线程安全的，但实际开发中也不会使用Vector，还是使用ArrayList</p><p>从Java5开始提供ArrayList和LinkeList线程安全处理模式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;集合中是存在一个工具类，这个类叫做Collections，这个工具类提供</span></span><br><span class="line"><span class="string">了如果将线程不安全集合转换为线程安装集合的方法&quot;</span></span><br><span class="line">Collections.synchronizedList(List集合对象); ---》可以将</span><br><span class="line">一个线程不安全集合转换为线程安全</span><br><span class="line"><span class="string">&quot;除了这种处理方式之外,现在主要处理方式可以使用Java在JDK1.5中提</span></span><br><span class="line"><span class="string">供的一个新包java.util.concurrent 并发工具包，</span></span><br><span class="line"><span class="string">这个包中提供大量的线程安全处理时可以使用的集合&quot;</span></span><br></pre></td></tr></table></figure><p>Stack(栈集合)和Queue、Deque(队列集合)</p><p>Stack是List集合的实现类，而Queue、Deque集合接口：有专门实现类来实现主要体现在于LinkedList</p><h1 id="知识点八：泛型基本使用"><a href="#知识点八：泛型基本使用" class="headerlink" title="知识点八：泛型基本使用"></a><center>知识点八：泛型基本使用</center></h1><h2 id="1、作用"><a href="#1、作用" class="headerlink" title="1、作用"></a><center>1、作用</center></h2><p>什么是泛型？</p><p>&ensp;&ensp;&ensp;&ensp;泛型是一个特殊类型，泛型是统称指代任何引用数据类型，泛型本身代表【通用类型含义】，在定义泛型时如果没有对泛型进行数据类型赋值之前，泛型本身是不具备任何含义，只有赋值为具体数据类型时，泛型才会真正意义</p><p>为什么要使用这个泛型?</p><p>&ensp;&ensp;&ensp;&ensp;泛型解决了集合中存储数据类型的问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CenericityList</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            在学习集合之前，是没有使用泛型，所以集合中默认类型就是Object</span></span><br><span class="line"><span class="comment">            我们面临的问题就是取出数据时，需要进行向下转型操作才可以</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        list.add(<span class="number">4</span>);</span><br><span class="line">        <span class="comment">//对集合存储的数据进行计算求和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span><span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(Object obj : list)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += ((Integer) obj);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//因为不使用泛型默认类型时Object类型所以和这个集合中就可以存储任何数据类型只要是Object子类</span></span><br><span class="line">        list.add(<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;7&quot;</span>);</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Student</span>());</span><br><span class="line">        list.add(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//如果你在不清楚集合中存储在什么样数据类型数据时，如果进行转换操作？代码就无形中增加开发成本</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            所以在这种情况下，集合建议使用泛型，来约束集合中存储数据</span></span><br><span class="line"><span class="comment">            一旦集合使用泛型就要可以约束集合只能 存储泛型中提供的数据类型对应数据，从而减少转换操作</span></span><br><span class="line"><span class="comment">            此时list1这个集合中只能存储Integer类型数据，使用泛型作为约束</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list1.add(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//list1.add(&quot;1&quot;);</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Integer i : list1)</span><br><span class="line">        &#123;</span><br><span class="line">            sum1+=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS： 如何定义泛型集合？</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">集合数据类型&lt;存储数据的数据类型&gt; 集合对象名 = <span class="keyword">new</span> 集合数据类型&lt;&gt;();</span><br></pre></td></tr></table></figure><p>此时就可以使用【存储数据的数据类型】约束集合中存储的数据了</p><p>PS：集合泛型你就可以理解为 就是创建数组是</p><p>数组中存储元素数据类型[] —》相当于 集合数据类型&lt;存储数据的数据类型&gt;只能引用数据类型</p><p>泛型解决通用性问题</p><p>编程原则：DRY【不要重复你自己（不要写重复性代码）】</p><p>需求： 求点中x和y的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer x;</span><br><span class="line">    <span class="keyword">private</span> Integer y;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Double x;</span><br><span class="line">    <span class="keyword">private</span> Double y;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Long x;</span><br><span class="line">    <span class="keyword">private</span> Long y;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point4</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String x;</span><br><span class="line">    <span class="keyword">private</span> String y;</span><br><span class="line">&#125; </span><br><span class="line">为了Point类型可以获得不同参数类型数据，需要提供大量相同逻辑类，此时就触发DRY原则，</span><br><span class="line">现有解决方案就是将数据类型替换成Object类型，但</span><br><span class="line">是我们需要面临数据类型转换和传递非计算类型问题，有没有什么方式可以</span><br><span class="line">动态决定类中x和y属性类型操作，根据外界传递类型来进行x和y的限制操作 ---》 可以使用<span class="string">&quot;泛型&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T x;</span><br><span class="line">    <span class="keyword">private</span> T y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、定义"><a href="#2、定义" class="headerlink" title="2、定义"></a><center>2、定义</center></h2><p>PS：泛型中会出现一个【占位符】的概念，这个占位符本身是没有任何意义，就是一个占位，对泛型进行赋值时，占位符才会有具体的意义</p><p>泛型的概念是Java5开始引入到Java中，它可以通过对泛型赋值进行对数据赋值约束，通过泛型动态决定数据类型时什么</p><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;占位符&gt;</span><br><span class="line">PS：这种语法在Java中叫做<span class="string">&quot;菱形语法&quot;</span>，这样语法与占位符组合就是成</span><br><span class="line">为<span class="string">&quot;泛型&quot;</span></span><br><span class="line">这个语法可以使用在 <span class="string">&quot;类、方法和接口&quot;</span>上</span><br><span class="line">占位符<span class="string">&quot;一般是一个大写字母[A~Z]&quot;</span>,不建议使用其他形式进行占位符定义</span><br><span class="line">习惯书写占位符是 <span class="string">&quot;T&quot;</span> --&gt; <span class="string">&quot;Type(类型)&quot;</span> ---&gt; &lt;T&gt; 泛型T</span><br><span class="line">占位符可以在一个语法存在多个需要使用<span class="string">&quot;,&quot;</span>分隔，使用占位符的多少就相</span><br><span class="line">当于你定义多个泛型</span><br><span class="line">泛型语法:只能存在在编译时期，一旦程序运行泛型就会自动消失<span class="string">&quot;称之为泛型擦除&quot;</span></span><br><span class="line">        定义的泛型在编译字节码文件中即[.class文件]看不到</span><br></pre></td></tr></table></figure><h2 id="3、泛型的使用之集合"><a href="#3、泛型的使用之集合" class="headerlink" title="3、泛型的使用之集合"></a><center>3、泛型的使用之集合</center></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CenericityList</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 集合的数据类型&lt;泛型赋值数据类型&gt; 集合对象名字 = new 集合的数据类型&lt;&gt;();</span></span><br><span class="line">        <span class="comment">// 声明的就是带有泛型集合，泛型可以作为集合类型一部分，可以出现在方法参数位置和返回值类型的位置</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list1.add(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//一旦集合使用泛型之后，集合只允许使用泛型定义数据类型，非泛型定义数据类型时无法存储到集合中</span></span><br><span class="line">        <span class="comment">//list1.add(&quot;1&quot;);</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//集合使用泛型之后，确定了集合中存储数据的数据类型，在集合中的数据就无需向下转型操作</span></span><br><span class="line">        <span class="keyword">for</span>(Integer i : list1)</span><br><span class="line">        &#123;</span><br><span class="line">            sum1+=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showList</span><span class="params">(ArrayList&lt;Integer&gt; list)</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title function_">showList</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、泛型的使用之泛型类"><a href="#4、泛型的使用之泛型类" class="headerlink" title="4、泛型的使用之泛型类"></a><center>4、泛型的使用之泛型类</center></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    当前类在没有使用任何其他修饰符之前【final 或 abstract】,没有使用泛</span></span><br><span class="line"><span class="comment">型语法之前 都是一个普通类</span></span><br><span class="line"><span class="comment">    public class CenericityClass </span></span><br><span class="line"><span class="comment">    &#123;&#125;</span></span><br><span class="line"><span class="comment">    利用泛型语法 &lt;占位符&gt; 可以将当前类变成泛型类</span></span><br><span class="line"><span class="comment">    语法：</span></span><br><span class="line"><span class="comment">        public class 类名&lt;占位符&gt;    //这个类就是泛型类</span></span><br><span class="line"><span class="comment">        &#123; </span></span><br><span class="line"><span class="comment">            此时这个泛型是定义在类上，所以在类中成员变量和成员方法都可以使用</span></span><br><span class="line"><span class="comment">            这个泛型</span></span><br><span class="line"><span class="comment">作为数据类型使用</span></span><br><span class="line"><span class="comment">        &#125; </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CenericityClass</span>&lt;T&gt; <span class="comment">// 使用泛型是 T 这个T现在是没有意义 只是一个占位符号</span></span><br><span class="line">&#123;     </span><br><span class="line">    <span class="comment">//此时这个T是没意义，为了保证语法不错误，占位使用</span></span><br><span class="line">    <span class="comment">//泛型T只有被赋值之后【数据类型（必须是引用数据类型）】 T才会有意义</span></span><br><span class="line">    <span class="keyword">private</span> T x;</span><br><span class="line">    <span class="keyword">public</span> T y;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CenericityClass</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CenericityClass</span><span class="params">(T x, T y)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//在类上定义泛型，如何确定泛型数据类型，只要在创建类的对象时对泛型进行赋值，泛型就有具体的数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 类名&lt;泛型赋值数据类型&gt; 对象名字 = new 类名&lt;&gt;();</span></span><br><span class="line">        CenericityClass&lt;Integer&gt; cc = <span class="keyword">new</span></span><br><span class="line">        <span class="title class_">CenericityClass</span>&lt;&gt;();</span><br><span class="line">        cc.y = <span class="number">1</span>;</span><br><span class="line">        cc.show(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//这样创建对象,创建泛型的同时不对泛型进行赋值操作</span></span><br><span class="line">        <span class="comment">//此时没有对泛型进行赋值，所以泛型类型默认使用Object</span></span><br><span class="line">        <span class="type">CenericityClass</span> <span class="variable">cc1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CenericityClass</span>();</span><br><span class="line">        cc1.y = <span class="number">1</span>;</span><br><span class="line">        cc1.y = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        cc1.show(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="string">PS：泛型在动态决定数据类型时什么的时候，不存在继承关系&quot;</span></span><br><span class="line"><span class="string">&quot;不要这样写，这个语法是错误，对泛型进行赋值什么数据类型时，就决定这个数类型，所不允许赋值为其他类&quot;</span></span><br><span class="line">CenericityClass&lt;Object&gt; cc = <span class="keyword">new</span></span><br><span class="line"><span class="title class_">CenericityClass</span>&lt;Integer&gt;();</span><br></pre></td></tr></table></figure><h2 id="5、泛型使用之泛型方法"><a href="#5、泛型使用之泛型方法" class="headerlink" title="5、泛型使用之泛型方法"></a><center>5、泛型使用之泛型方法</center></h2><p>泛型方法的定义主要是为了摆脱使用泛型类上或泛型接口上的泛型约束问题，就相当于方法向使用自己定义泛型作为类型操作，就可以定义为泛型方法</p><p>泛型类和泛型接口上定义泛型，不能在静态方法上使用，所以只能定义泛型方法对方法进行泛型使用修饰</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericityMethod</span>&lt;T&gt; <span class="comment">// 使用泛型是 T 这个T现在是没有意义 只是一个占位符号</span></span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个成员方法 泛型类上定义泛型就可以在方法中使用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//泛型类上定义泛型是不能在静态方法上使用</span></span><br><span class="line">    <span class="comment">//public static void showInfos(T t)&#123; &#125;</span></span><br><span class="line">    <span class="comment">//给方法添加泛型</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        泛型静态方法：</span></span><br><span class="line"><span class="comment">            访问权限修饰符 static&lt;占位符&gt; 返回值类型 方法名(参数列表)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                此时这个占位符可以使用在返回值类型上 和 参数列表定义中</span></span><br><span class="line"><span class="comment">            &#125; </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>&lt;E&gt; <span class="keyword">void</span> <span class="title function_">showInfos</span><span class="params">(E e)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//E a;// 方法上泛型主要是为了 返回值类型和参数类型而提供的，在内部就不在使用</span></span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">        泛型成员方法：</span></span><br><span class="line"><span class="comment">            访问权限修饰符&lt;占位符&gt; 返回值类型 方法名(参数列表)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                此时这个占位符可以使用在返回值类型上 和 参数列表定义中</span></span><br><span class="line"><span class="comment">            &#125; </span></span><br><span class="line"><span class="comment">        此时不仅可以使用泛型方法上定义泛型，也可以使用类上或接口上定义泛型</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span>&lt;F&gt; <span class="keyword">void</span> <span class="title function_">showInfoss</span><span class="params">(F f,T t)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//F a;// 方法上泛型主要是为了 返回值类型和参数类型而提供的，在内部就不在使用</span></span><br><span class="line">        System.out.println(f);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//定义泛型方法泛型，不能单独使用在方法返回值类型位置，需要配合使用参数列表定义</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>&lt;O&gt; O <span class="title function_">showInfosss</span><span class="params">(O o)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//静态方法可以这样操作，成员的不可以</span></span><br><span class="line">        <span class="comment">//return o;</span></span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如何给方法定义泛型进行赋值操作---》赋值数据类型</span></span><br><span class="line">        <span class="comment">//在调用方法对泛型定义参数列表赋值时，可以决定方法的泛型是什么，定义泛型方法时</span></span><br><span class="line">        <span class="comment">//一定要将泛型定义在参数列表中，以确定数据类型是什么</span></span><br><span class="line">        GenericityMethod.showInfos(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="type">GenericityMethod</span> <span class="variable">genericityMethod</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line">        <span class="title class_">GenericityMethod</span>();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> GenericityMethod.showInfosss(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、泛型使用之接口泛型"><a href="#6、泛型使用之接口泛型" class="headerlink" title="6、泛型使用之接口泛型"></a><center>6、泛型使用之接口泛型</center></h2><p>接口泛型和泛型类差不多，在接口上定义泛型，这个泛型可以在接口内部使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    public interface 接口名&lt;占位符&gt;</span></span><br><span class="line"><span class="comment">    &#123;&#125;泛型接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GenericityInterface</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在接口上定义泛型可以在接口内部使用</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(T t)</span>;</span><br><span class="line">    <span class="comment">//支持抽象方法自定义泛型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span>&lt;E&gt; <span class="keyword">void</span> <span class="title function_">show</span> <span class="params">(E e)</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//1. 在使用类实现接口时可以对泛型接口的泛型进行赋值，决定泛型类型是什么 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">implements</span> <span class="title class_">GenericityInterface</span>&lt;Integer&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在接口中定义方法使用泛型位置都会变成数据类型</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Integer integer)</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(E e)</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2. 使用泛型类实现泛型接口，使用泛型类中泛型作为接口中新泛型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo2</span>&lt;P&gt; <span class="keyword">implements</span> <span class="title class_">GenericityInterface</span>&lt;P&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在创建泛型类对象时可以决定泛型类型</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(P p)</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(E e)</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        GenericityInterface&lt;Double&gt; gi = <span class="keyword">new</span> <span class="title class_">Demo2</span>&lt;&gt;();</span><br><span class="line">        gi.run(<span class="number">1.0</span>);</span><br><span class="line">        Demo2&lt;String&gt; demo2 = <span class="keyword">new</span> <span class="title class_">Demo2</span>&lt;&gt;();</span><br><span class="line">        demo2.run(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="comment">//这种操作其实就是List集合中使用List集合创建对象的方式</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Long&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//3.直接使用匿名内部类的形似进行泛型接口上泛型的赋值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">GenericityInterface</span>&lt;Integer&gt;()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Integer integer)</span> </span><br><span class="line">            &#123;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(E e)</span> </span><br><span class="line">            &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、泛型的限定"><a href="#7、泛型的限定" class="headerlink" title="7、泛型的限定"></a><center>7、泛型的限定</center></h2><p>泛型限定其实就是定义泛型可以赋值哪些数据类型，只有满足限定要求的数据类型才可以进行定义赋值操作</p><p><strong>泛型通配符【?】</strong></p><p>?代表未知，可以作为通配符使用，但是不能作为参数类型单独使用，通配符多用于在泛型限定上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericityDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ? 是一个通配符</span></span><br><span class="line">        List&lt;?&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>); <span class="comment">// 这里是无法确定数据类型，无法单独使用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>&lt; ? extends 类&gt; 这是使用途径 此时 ？ 就代表着可以接收extends关键字后的相同类型或子类</strong></p><p><strong>&lt; ? super 类&gt; 这是使用途径 此时 ？ 就代表着可以接收super关键字后的相同类型或父类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericityDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//提供4个List集合对象</span></span><br><span class="line">        List&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Number&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Object&gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//调用泛型的上限操作，即参数类型使用的是List&lt;? extends Number&gt;进行限制</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            泛型限定必须是 Number类型或Number子类</span></span><br><span class="line"><span class="comment">            而list1是Integer类型即Number子类 list3是Number类型即</span></span><br><span class="line"><span class="comment">Number类型所以可以进行传递</span></span><br><span class="line"><span class="comment">            而list2和list4分别是String和Object，既不是Number类型也</span></span><br><span class="line"><span class="comment">不是Number子类，所以无法传递到方法中</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        doWork1(list1);</span><br><span class="line">        <span class="comment">//doWork1(list2);</span></span><br><span class="line">        doWork1(list3);</span><br><span class="line">        <span class="comment">//doWork1(list4);</span></span><br><span class="line">        <span class="comment">//调用泛型下限操作，即参数类型使用的是List&lt;? super Number&gt;进行限制</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            泛型限定必须是Number类型或Number父类</span></span><br><span class="line"><span class="comment">            而list1和list2分别是Integer和String，既不是Number类型也不是Number父类，所以无法传递到方法中</span></span><br><span class="line"><span class="comment">            list3和list4 分别是Number和Object 满足了必须是Number类型或Number父类，所以传递到方法中</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//doWork2(list1);</span></span><br><span class="line">        <span class="comment">//doWork2(list2);</span></span><br><span class="line">        doWork2(list3);</span><br><span class="line">        doWork2(list4);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//泛型的上限，此时的泛型中?(通配符) 必须是Number的类型或Number子类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doWork1</span><span class="params">(List&lt;? extends Number&gt; list)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//泛型的下限，此时的泛型中?(通配符) 必须是Number的类型或Number父类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doWork2</span><span class="params">(List&lt;? <span class="built_in">super</span> Number&gt; list)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8、特点"><a href="#8、特点" class="headerlink" title="8、特点"></a><center>8、特点</center></h2><p>（1）泛型集合在存储元素的时候，支持多态(不推荐使用)</p><p>（2）泛型定义的时候，不存在多态</p><p>&ensp;&ensp;&ensp;&ensp;Collection coll1 &#x3D; new ArrayList(); err</p><p>（3）泛型擦除</p><p>&ensp;&ensp;&ensp;&ensp;在JDK1.7之后，右边的&lt;&gt;中不需要定义泛型类型</p><p>&ensp;&ensp;&ensp;&ensp;集合的泛型不能是基本数据类型，要使用它们的包装类</p><p>CollectionDemo01类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionDemo01</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 泛型：参数化类型     JKD1.5之后</span></span><br><span class="line"><span class="comment">     * 泛型作用：因为在没有使用泛型之前，向集合中存储实际上是Object类型的数据，所以获取的时候也是Object类型</span></span><br><span class="line"><span class="comment">     *         如果想要使用这个对象，需要发生向下转型，那么在整个集合存储元素的时候，不停的发生向上和向下转型,可能会发生异常</span></span><br><span class="line"><span class="comment">     * 泛型的好处：类型转换的操作提前到了编译器</span></span><br><span class="line"><span class="comment">     *泛型特点：</span></span><br><span class="line"><span class="comment">     *      泛型集合在存储元素的时候，支持多态(不推荐使用)</span></span><br><span class="line"><span class="comment">     *      泛型定义的时候，不存在多态</span></span><br><span class="line"><span class="comment">     *         Collection&lt;Person&gt; coll1 = new ArrayList&lt;Student&gt;(); err</span></span><br><span class="line"><span class="comment">     *      泛型擦除</span></span><br><span class="line"><span class="comment">     *          在JDK1.7之后，右边的&lt;&gt;中不需要定义泛型类型</span></span><br><span class="line"><span class="comment">     *      集合的泛型不能是基本数据类型，要使用它们的包装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//        Collection coll = new ArrayList();</span></span><br><span class="line"><span class="comment">//        coll.add(new Student(&quot;jack&quot;,28));</span></span><br><span class="line"><span class="comment">//        coll.add(new Student(&quot;尼古拉斯&quot;,23));</span></span><br><span class="line"><span class="comment">//        coll.add(new Teacher(&quot;rose&quot;,32));</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        //遍历集合  迭代器</span></span><br><span class="line"><span class="comment">//        Iterator it = coll.iterator();</span></span><br><span class="line"><span class="comment">//        while (it.hasNext())</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            //没有向下转型时时Object类</span></span><br><span class="line"><span class="comment">//            //System.out.println(it.next().play());</span></span><br><span class="line"><span class="comment">//            Object obj = it.next();</span></span><br><span class="line"><span class="comment">//            Student stu = (Student) obj;</span></span><br><span class="line"><span class="comment">//            stu.play();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        Collection&lt;Student&gt; coll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        coll.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;jack&quot;</span>,<span class="number">23</span>));</span><br><span class="line">        coll.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;niu&quot;</span>,<span class="number">23</span>));</span><br><span class="line">        Iterator&lt;Student&gt; it = coll.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> it.next();</span><br><span class="line">            student.play();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//泛型集合在存储元素的时候，支持多态</span></span><br><span class="line">        Collection&lt;Person&gt; coll1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        coll1.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;jack&quot;</span>,<span class="number">23</span>));</span><br><span class="line">        coll1.add(<span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;sdf&quot;</span>,<span class="number">34</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不能用基本数据类型</span></span><br><span class="line">        <span class="comment">//Collection&lt;int&gt; coll2 = new ArrayList&lt;&gt;();</span></span><br><span class="line">        Collection&lt;Integer&gt; coll3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Student类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Student类中的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Student玩。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Teacher类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">(String name, <span class="type">int</span> age)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Teacher&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点九：Set集合的介绍"><a href="#知识点九：Set集合的介绍" class="headerlink" title="知识点九：Set集合的介绍"></a><center>知识点九：Set集合的介绍</center></h1><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291933362.png" alt="set集合"></p><h1 id="知识点十：Set集合实现类HashSet"><a href="#知识点十：Set集合实现类HashSet" class="headerlink" title="知识点十：Set集合实现类HashSet"></a><center>知识点十：Set集合实现类HashSet</center></h1><p>HashSet集合是Set集合主要实现类，也是日常开发使用最常用Set集合实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSet</span> <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, Serializable</span><br></pre></td></tr></table></figure><p>HashSet集合继承了Set集合的特点，向hashSet集合中存储数据时，是不允许出现重复数据，如果有存储重复数据HashSet集合会进行自动排重操作，<strong>HashSet集合的主要实现数据结构“Hash表”</strong>,存储数据顺序是无序，<strong>通过观察API文档发现HashSet集合的所有方法都是Set集合接口提供，本身没有任何特殊方法</strong></p><p>特点:</p><ul><li>无序 （插入顺序）</li><li>无下标</li><li>不可重复</li></ul><h2 id="1、Hash表"><a href="#1、Hash表" class="headerlink" title="1、Hash表"></a><center>1、Hash表</center></h2><p><strong>什么是hash表？</strong></p><p>&ensp;&ensp;&ensp;&ensp;Hash 一般被翻译为“散列”，也可以直接音译为“哈希”，它是基于【快速存取的角度而设计的一种存储结构】，而且是一个典型【空间换时间】的做法，利用Hash表的原理进行数据存储操作</p><p>&ensp;&ensp;&ensp;&ensp;Hash表其实就是【“数组+链表”】的组合形式，在Hash表数组起到作用提供存储位置，在Hash表链表起到作用提供数据存储结构</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291936873.png" alt="Hash表" style="zoom:50%;"><p>上图中是典型Hash表的结构，Hash表也别称之为【散列表(Hashtable)】，Hash表是根据键值对（Key-value）而直接进行访问的数据结构，也就是说【通过把key值映射到表中一个位置来记录访问位置】，以加快查找数据（这个操作就是确定数据在Hash表中存储的位置），这个操作也被称之为【散列函数】，通过散列函数计算出存储位置会后，会将存储数据以链表形似挂载在存储位置中，这种方式成为【桶】如果存储70个元素，但是存储70个元素时申请100个空间，70&#x2F;100 &#x3D; 0.7 ，这个0.7这个值就称之为“负载（加载）因子”，通过这个因子对hash表进行扩容操作</p><p>因为Hash表是基于【快速存取】的操作，所以Hash表会尽量的平均将数据分配到Hash表中进行存储，但是在存储过程中就会触发，在同一个存储空间中出现重复数据问题，此时Hash就会启动自动排重操作，原则就是equals比较，只要equals比较结果为true，就不在这个空间存储相同数据</p><p>假如：向上面Hash表中存储12这个数据如果进行存储计算</p><p>第一步：通过散列函数计算12需要存储的位置 –》hash(key)%len【散列函数】</p><p>hash(key) —》 key 是要存储数据 hash(key) —》<strong>计算key的hash值即Java中hashcode值</strong></p><p>len —》其实就是存储Hash表中数组长度，上图中数组长度为16所以散列函数计算效果</p><p>hash(12) % 16 —》 12%16 —-》 余数12 ，利用12这个值去数组中提供存储位置对别查找存</p><p><strong>Hash表的扩容机制？</strong></p><p>&ensp;&ensp;&ensp;&ensp;Hash表示一个自动扩容机制，<strong>当达到【加载因子】参数要求时，Hash表就会进行自动扩容</strong></p><p>&ensp;&ensp;&ensp;&ensp;Java中使用<strong>Hash表默认大小给16，加载因子0.75</strong>当16个存储位置发生了75%位置都存储了数据即16*0.75 &#x3D; 12，也就说12个下标位置中都存储数据，Hash表就会发生自动扩容，扩容机制就以2的幂次进行扩容【16是2^4】扩容之后2^5即hash表每次扩容之后都是原有容量一倍，就会从原有16扩容到32</p><p>&ensp;&ensp;&ensp;&ensp;在介绍HashSet时说过HashSet中存储数据不能保证存储位置永久不变，只要Hash表发生一次扩容，那么Hash表中存储的数据就要重新计算存储位置</p><p>原始数据28 存储在大小为16的hash表中 计算位置 28%16 –》 余数12</p><p>一旦扩容大小从16变成32 此时原始数据28可就要重新计算存储位置</p><p>在hash表 计算位置 28%32 —》 余数 28</p><p><strong>总结：Hash表数据存储和查找是非常优秀，但是一旦扩容就会降低Hash表的性能</strong></p><h2 id="2、HashSet基本使用"><a href="#2、HashSet基本使用" class="headerlink" title="2、HashSet基本使用"></a><center>2、HashSet基本使用</center></h2><h3 id="1）语法"><a href="#1）语法" class="headerlink" title="(1）语法"></a>(1）语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;泛型&gt; 变量名 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>HashSet是实现Set集合接口，查看API时可以发现HashSet中并没有任何特殊方法，所以知己使用Set接口提供方法就完成HashSet集合操作【<strong>HashSet集合中操作方法方式和ArrayList集合中介绍方式是一样的，只不过HashSet带有排重的效果，可以完全参考ArrayList集合中API使用在HashSet中进行使用</strong>】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSetAPI</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建HashSet集合对象</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            表面上代码操作是在创建一个HashSet集合，但是实际底层操作过程中是在创建HashMap集合</span></span><br><span class="line"><span class="comment">            向HashSet集合存储的数据其实就是在想HashMap中key的位置存储</span></span><br><span class="line"><span class="comment">数据，为什么要这样会做</span></span><br><span class="line"><span class="comment">            Hash表存储数据值是以【key-value】进行数据存储操作 --》</span></span><br><span class="line"><span class="comment">Java集合中可以提供Key-value形式存储只有Map集合</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//1.提供一个空的HashSet集合对象【默认容量16,加载因子0.75】</span></span><br><span class="line">        HashSet&lt;Integer&gt; hashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//PS：HashSet是Set集合的实现类，也就相当于是Set集合&quot;子类&quot;</span></span><br><span class="line">        <span class="comment">//利用Set集合接口使用多态形式创建Set集合对象</span></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//2.可以利用参数Collection集合对象中存储数据初始化HashSet集合对象</span></span><br><span class="line">        HashSet&lt;Integer&gt; hashSet1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;</span><br><span class="line">(hashSet);</span><br><span class="line">        <span class="comment">//3.指定HashSet集合初始化容量大小【使用默认加载因子0.75】</span></span><br><span class="line">        <span class="comment">//遵守大小原则是2次幂来定义的，但是不要小于16</span></span><br><span class="line">        HashSet&lt;Double&gt; hashSet2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;</span><br><span class="line">(((<span class="type">int</span>)Math.pow(<span class="number">2</span>,<span class="number">5</span>)));    <span class="comment">//2的5次幂(double类型)强转int</span></span><br><span class="line">        <span class="comment">//4.指定HashSet集合初始化容量大小和加载因子 第二参数加载因子是float类型</span></span><br><span class="line">        HashSet&lt;Character&gt; hashSet3 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt; (((<span class="type">int</span>)Math.pow(<span class="number">2</span>,<span class="number">5</span>)),<span class="number">0.85f</span>);</span><br><span class="line">        <span class="comment">//常用API</span></span><br><span class="line">        <span class="comment">//向集合中添加数据</span></span><br><span class="line">        hashSet.add(<span class="number">1</span>);</span><br><span class="line">        hashSet.add(<span class="number">20</span>);</span><br><span class="line">        hashSet.add(<span class="number">4</span>);</span><br><span class="line">        hashSet.add(<span class="number">9</span>);</span><br><span class="line">        hashSet.add(<span class="number">7</span>);</span><br><span class="line">        hashSet.add(<span class="number">17</span>);</span><br><span class="line">        <span class="comment">//hashSet是可以对存储在集合数据提供排重操作的</span></span><br><span class="line">        System.out.println(hashSet);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将参数集合对象中数据存储到当前HashSet中</span></span><br><span class="line">        <span class="comment">//addAll(Collection集合对象); </span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//清空HashSet集合中数据</span></span><br><span class="line">        <span class="comment">//hashSet.clear();</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断HashSet集合是否为空【指没有任何数据，而不是当前hashset地址为null】</span></span><br><span class="line">        <span class="comment">//isEmpty();</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断HashSet集合中是否存在指定元素</span></span><br><span class="line">        <span class="keyword">if</span>(hashSet.contains(<span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;返回true证明存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;返回false证明不存在&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//containsAll(Collection集合对象) 判断Collection集合对象中个存储数据是否存在在Hashset集合对象中</span></span><br><span class="line">        <span class="comment">//因为HashSet不存在下标的概念所以HashSet是不支持普通for循环的</span></span><br><span class="line">        <span class="comment">//HashSet支持循环方式有</span></span><br><span class="line">        <span class="comment">// 增强for循环</span></span><br><span class="line">        <span class="keyword">for</span>(Integer integer : hashSet)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(integer);</span><br><span class="line">            <span class="comment">//不要调用集合删除方法</span></span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// foreach方法</span></span><br><span class="line">        hashSet.forEach(System.out::println);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//普通迭代器(HashSet集合只支持普通迭代器，不支持增强迭代器即listIterator)</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = hashSet.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">            <span class="comment">//删除数据就调用 迭代器中remove</span></span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//删除集合中数据 参数是要删除的数据</span></span><br><span class="line">        hashSet.remove(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//删除参数结合提供提供数据所在HashSet集合对象中数据</span></span><br><span class="line">        <span class="comment">//removeAll(Collection集合对象);</span></span><br><span class="line">        <span class="comment">//保留参数集合对象中数据在HashSet集合中然后删除剩余HashSet集合中数据</span></span><br><span class="line">        <span class="comment">//retainAll(Collection集合对象);</span></span><br><span class="line">        hashSet.removeIf(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Integer&gt;() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Integer integer)</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> integer%<span class="number">2</span> ==<span class="number">0</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        hashSet.removeIf(integer -&gt; integer%<span class="number">2</span> ==<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取集合中存储元素的个数</span></span><br><span class="line">        System.out.println(hashSet.size());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//转换成数组</span></span><br><span class="line">        Object[] objects = hashSet.toArray();</span><br><span class="line">        Integer[] integers = hashSet.toArray(<span class="keyword">new</span> <span class="title class_">Integer</span>[hashSet.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-HashSet集合的排重操作"><a href="#2-HashSet集合的排重操作" class="headerlink" title="(2)HashSet集合的排重操作"></a>(2)HashSet集合的排重操作</h3><p>需求:创建一个Person对象，提供属性名字和年龄【按照标准JavaBean提供，提供toString重写】在提供PersonTest类型在类中创建两个Person对象，赋值为张三，18，存储在HashSet集合中，然后打印集合中数据，查看是否排重？如果没有排重如何处理？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">return</span> age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">        <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">        <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">        <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonTest</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        HashSet&lt;Person&gt; hashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        hashSet.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        hashSet.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        <span class="comment">//利用HashSet中存储机制【Hash表】可以存储重复数据进行排重操作</span></span><br><span class="line">        System.out.println(hashSet);</span><br><span class="line">        HashSet&lt;Integer&gt; hashSet1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        hashSet1.add(<span class="number">1</span>);</span><br><span class="line">        hashSet1.add(<span class="number">1</span>);</span><br><span class="line">        System.out.println(hashSet1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashSet底层实现是什么？—》</p><p>使用Hash表实现的，Hash表示如何进行数据存储的？ —》</p><p>使用Hash表提供散列函数，散列函数是什么？ —》</p><p>这是散列函数 hash(key)%len， hash(key)得到结果什么？len得到结果什么？ —》</p><p><strong>hash(key)计算存储数据所在内存中hashcoded地址值</strong></p><p>len是Hash表中容量的大小，默认是16 —》</p><p>利用散列函数【 hash(key)%len】 求得存储在Hash表中位置以进行数据的存储</p><p>Hash表的排重机制是：通过散列函数计算出数据存储的位置进行数据存储，如果出现同一个数据计算出位置相同，此时也会向存储位置进行插入存储，但是要进行equals比较，如果equals 比较结果为false就整存储位置中，没有与之相同数据，以链表存储，如果equals比较结果为true，证明这个存储位置有与之相同数据，此时就会放弃新添加的数据存，从而不会进行存储数据操作，那么些就是HashSet即Hash表排重机制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonTest</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        HashSet&lt;Person&gt; hashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        hashSet.add(p1);</span><br><span class="line">        hashSet.add(p2);</span><br><span class="line">        System.out.println(<span class="string">&quot;p1对象的hashcode值：&quot;</span>+ p1.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;p2对象的hashcode值:&quot;</span>+ p2.hashCode());</span><br><span class="line">        <span class="comment">//利用HashSet中存储机制【Hash表】可以存储重复数据进行排重操作</span></span><br><span class="line">        System.out.println(hashSet);</span><br><span class="line">        HashSet&lt;Integer&gt; hashSet1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        hashSet1.add(<span class="number">1</span>);</span><br><span class="line">        hashSet1.add(<span class="number">1</span>);</span><br><span class="line">        System.out.println(hashSet1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么存储自定类的对象到HashSet集合没有进行排重？</p><p>就是因为自动以类并没对对象提供同一个hashcode的实现并且在Person类中也没有一共equals方法的实现，所以我们根本没有提供排重操作的原则，所以向HashSet中存储自定义类的对象是无法排重</p><p><strong>如果需要向HashSet集合存储自定义类的对象并提供排重机制，那么自定义类必须提供equals和hashcode方法的重写</strong></p><p>从写hashcode的目的在于：</p><ol><li>在Java中认为两个对象相等是通过equals方决定，决定原则在于类中提供属性完全或部分相等，认为两个对象相等，既然两个对象已经相等了，那么他们的地址也要相等，但是Java语言是无法直接操作真实内存地址的，但是我们可以获取到真实内存地址映射hashcode值，所以将equals比较相等对象的hashcode修改为相等就间接的满足【真实内存地址相等】</li><li>当向HashSet集合存储数据时候，HashSet集合底层实现是Hash表，而Hash表有需要通过hashcode计算存数据位置，只有在hash表存储位置相同才可能出现相同数据，这样一来就需要提供相同对象hashcode地址是相同的，通过这个方法将对象计算到同一个存储位置，在通过equals方法计算相等操作触发Hash表排重机制</li></ol><p>综上所述：对Person这类提供equals和hashcode的重写操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Objects;</span><br><span class="line">public class Person </span><br><span class="line">&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    public Person() </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    public Person(String name, int age) </span><br><span class="line">    &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    public String getName() </span><br><span class="line">    &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125; </span><br><span class="line">    public void setName(String name) </span><br><span class="line">    &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    public int getAge() </span><br><span class="line">    &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125; </span><br><span class="line">    public void setAge(int age) </span><br><span class="line">    &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    @Override</span><br><span class="line">    public String toString() </span><br><span class="line">    &#123;</span><br><span class="line">        return &quot;Person&#123;&quot; +</span><br><span class="line">        &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">        &quot;, age=&quot; + age +</span><br><span class="line">        &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">        IDEA编译器提供两个版本的equals和hashcode的重写</span><br><span class="line">        这两个版本都是可以，只能二选一不能共存</span><br><span class="line">    */    </span><br><span class="line">    </span><br><span class="line">    //这个版本IDEA默认版本</span><br><span class="line">    /*</span><br><span class="line">        生成equals和hashcode方法是最后选项中有一个non-null</span><br><span class="line">        这里不建议勾选这个选中给提供属性，因为引用类型还是进行非null判断</span><br><span class="line">        如果你勾选在那么系统就默认认为引用类型时为null值</span><br><span class="line">        就会使用这个引用类型方法，如果此时你引用类型属性被赋值null，必</span><br><span class="line">出空指针异常</span><br><span class="line">    */</span><br><span class="line">    //勾选之后 non-null选项之后提供 equals实现</span><br><span class="line">    /* </span><br><span class="line">        @Override</span><br><span class="line">        public boolean equals(Object o) </span><br><span class="line">        &#123;</span><br><span class="line">            if (this == o) return true;</span><br><span class="line">            if (o == null || getClass() != o.getClass())</span><br><span class="line">            return false;</span><br><span class="line">            Person person = (Person) o;</span><br><span class="line">            if (age != person.age) return false;</span><br><span class="line">            return name.equals(person.name);</span><br><span class="line">        &#125;</span><br><span class="line">    */</span><br><span class="line">    </span><br><span class="line">    //没有勾选 non-null选项之后提供 equals实现</span><br><span class="line">    /* </span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) </span><br><span class="line">    &#123;</span><br><span class="line">        //比较了地址，这个地址是真实地址，如果真实地址都相等 必然是同一个对象</span><br><span class="line">        if (this == o) return true;</span><br><span class="line">        */</span><br><span class="line">        /*</span><br><span class="line">            如果输入对象引用地址null那么 必然对象不同一个</span><br><span class="line">getClass方法的作用是用过字节码文件[.class]文件进行对象获</span><br><span class="line">取</span><br><span class="line">            只要是同一个类创建对象，他们字节码文件都是同一个【唯一】</span><br><span class="line">            两个对象字节码文件都不一样必然不是同一个对象</span><br><span class="line">        */</span><br><span class="line">        /*</span><br><span class="line">            if (o == null || getClass() != o.getClass())</span><br><span class="line">            return false;</span><br><span class="line">            //多态向下转型操作</span><br><span class="line">            Person person = (Person) o;</span><br><span class="line">        */        </span><br><span class="line">        //如果当前对象age属性与传入对象的age属性不一致 返回false，</span><br><span class="line">如果相等就不做任何操作</span><br><span class="line">        /*</span><br><span class="line">        if (age != person.age) return false;</span><br><span class="line">        */</span><br><span class="line">        /*</span><br><span class="line">        提供引用类型非null判断</span><br><span class="line">只要当前对象的name属性值不为null 就通过name调用String类</span><br><span class="line">equals方法</span><br><span class="line">        与传入对象name进行比较 相等为true，不相等为false</span><br><span class="line">        如果对象的name属性为null 就判断传入对象的name属性是否为null</span><br><span class="line">        如果也为null 结果就是true 否则就是false</span><br><span class="line">        */</span><br><span class="line">        /*</span><br><span class="line">        return name != null ? name.equals(person.name) :</span><br><span class="line">        person.name == null;</span><br><span class="line">    &#125; </span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() </span><br><span class="line">    &#123;</span><br><span class="line">        //获取引用类hashcode值作为新的hashcode值计算</span><br><span class="line">        int result = name != null ? name.hashCode() : 0;</span><br><span class="line">        //使用31这个值 乘以 引用类型hashcode值 然后加上 值类型属性值 得到最终hashcode</span><br><span class="line">        //最大的限度保证hashcode不出现重复</span><br><span class="line">        result = 31 * result + age;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    */</span><br><span class="line">    </span><br><span class="line">    //这个版本IDEA使用Java7中提供Objects工具类</span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) </span><br><span class="line">    &#123;</span><br><span class="line">        if (this == o) return true;</span><br><span class="line">        if (o == null || getClass() != o.getClass())</span><br><span class="line">        return false;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        /*</span><br><span class="line">            变化现在使用:值类型比较融入到返回值比较结果中</span><br><span class="line">            调用了Objects工具类中equals方法进行 引用类型比较 --》原码实现</span><br><span class="line">            public static boolean equals(Object a, Object b)</span><br><span class="line">            &#123;</span><br><span class="line">            地址相等就是同一个对象或者判断 a 参数不为null 然后用a调用equals进行比较</span><br><span class="line">            return (a == b) || (a != null &amp;&amp; a.equals(b));</span><br><span class="line">            &#125; </span><br><span class="line">        */</span><br><span class="line">        return age == person.age &amp;&amp;</span><br><span class="line"> Objects.equals(name, person.name);</span><br><span class="line">    &#125; </span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() </span><br><span class="line">    &#123;</span><br><span class="line">        /*</span><br><span class="line">        Objects工具类中提供 hash方法 这个方法可以计算新的hashcode值</span><br><span class="line">        */</span><br><span class="line">        return Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-底层原理"><a href="#3-底层原理" class="headerlink" title="(3)底层原理"></a>(3)底层原理</h3><p>HashSet底层实现原理是HashMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSetDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; hashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        hashSet.add(<span class="number">3</span>);</span><br><span class="line">        hashSet.add(<span class="number">2</span>);</span><br><span class="line">        hashSet.add(<span class="number">1</span>);</span><br><span class="line">        hashSet.add(<span class="number">4</span>);</span><br><span class="line">        hashSet.add(<span class="number">4</span>);</span><br><span class="line">        System.out.println(hashSet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//HashSet没有特殊方法，它的方法与Collection中学的方法是一致的</span></span><br><span class="line">        <span class="comment">//Set集合的遍历方式(迭代器)</span></span><br><span class="line">        Iterator&lt;Integer&gt; it = hashSet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//foreach遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Integer integer :</span><br><span class="line">                hashSet)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(integer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//HashSet的底层实现原理：HashSet底层实现原理是HashMap</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点十一：LinkedHashSet类"><a href="#知识点十一：LinkedHashSet类" class="headerlink" title="知识点十一：LinkedHashSet类"></a><center>知识点十一：LinkedHashSet类</center></h1><p>特点：</p><ul><li>有序</li><li>无下标</li><li>不可重复</li></ul><p>与父类的方法(HashSet)一致,去重的原理，也与父类一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashSetDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 特点：</span></span><br><span class="line"><span class="comment">     *     1、有序（插入顺序）</span></span><br><span class="line"><span class="comment">     *     2、不重复</span></span><br><span class="line"><span class="comment">     *     3、无下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        LinkedHashSet&lt;String&gt; linkedHashSet = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">        linkedHashSet.add(<span class="string">&quot;rose&quot;</span>);</span><br><span class="line">        linkedHashSet.add(<span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line">        linkedHashSet.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        linkedHashSet.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        System.out.println(linkedHashSet);</span><br><span class="line">        <span class="comment">//1、底层实现 (LinkedHashMap)</span></span><br><span class="line">        <span class="comment">//2、去重原理 (与hashSet一致)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点十二：Set集合实现类TreeSet"><a href="#知识点十二：Set集合实现类TreeSet" class="headerlink" title="知识点十二：Set集合实现类TreeSet"></a><center>知识点十二：Set集合实现类TreeSet</center></h1><p>TreeSet是Set集合接口实现类之一，它是一个特殊集合【这个集合不仅可以排重而且可以对存储到集合中的数据提供升序排序】，在以往开发中可以利用TreeSet这个特性对需要排序数据进行操作</p><p>PS：从Java8开始List集合专门提供方法sort方法，List集合也可以调用集合提供Sort方法进行对数据排序操作，但是不能排重，所以学习TreeSet的目的为类接触可以排序接口</p><p>在API文档中有说明：基于 TreeMap 的 NavigableSet 实现。使用元素的 自然顺序Comparable 对元素进行排序，或者根据创建 set 时提供的 自定义排序Comparator 进行排序，具体取决于使用的构造方法</p><p>Set集合系列主要实现都是依赖于Map集合，HashSet底层实现是HashMap，TreeSet底层实现是TreeMap，在Java8之前TreeSet底层实现的结构【二叉树+Hash表】，从Java8开始之后将底层实现的结构【红黑树+Hash表】</p><p>TreeSet中的使用API可以完全参考Set集合即可，其余API文档中提供方法自行查看</p><p>提供一个基础的TreeSet使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSetDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//向TreeSet中存储系统提供数据类型</span></span><br><span class="line">        TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        set.add(<span class="number">100</span>);</span><br><span class="line">        set.add(<span class="number">20</span>);</span><br><span class="line">        set.add(<span class="number">17</span>);</span><br><span class="line">        set.add(<span class="number">1</span>);</span><br><span class="line">        set.add(<span class="number">6</span>);</span><br><span class="line">        set.add(<span class="number">88</span>);</span><br><span class="line">        set.add(<span class="number">66</span>);</span><br><span class="line">        set.add(<span class="number">33</span>);</span><br><span class="line">        set.add(<span class="number">77</span>);</span><br><span class="line">        set.add(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//存储数据中提供两个1进行存储 ---》 自动排重和排序操作【默认是升序】</span></span><br><span class="line">        System.out.println(set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向TreeSet中存储自定义类的对象Student，根据学生年龄进行排序操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> height;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> weight;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">int</span> height, <span class="type">int</span></span></span><br><span class="line"><span class="params"> weight)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHeight</span><span class="params">(<span class="type">int</span> height)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWeight</span><span class="params">(<span class="type">int</span> weight)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">        <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">        <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">        <span class="string">&quot;, height=&quot;</span> + height +</span><br><span class="line">        <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">        <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentTest</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供TreeSet集合对象用于存储Student类的对象</span></span><br><span class="line">        TreeSet&lt;Student&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">178</span>,<span class="number">100</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">20</span>,<span class="number">181</span>,<span class="number">200</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;王五&quot;</span>,<span class="number">16</span>,<span class="number">200</span>,<span class="number">10</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;赵六&quot;</span>,<span class="number">19</span>,<span class="number">145</span>,<span class="number">150</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;田七&quot;</span>,<span class="number">21</span>,<span class="number">190</span>,<span class="number">160</span>));</span><br><span class="line">        System.out.println(treeSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题：使用TreeSet存储系统提供数据类型时，可以对数据进行排重与排序操作，但是向TreeSet中添加自定义类对象时，并没有进行排重排序操作，出现了一个异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.ClassCastException:com.qfedu.TreeSet.</span><br><span class="line">    Student cannot be cast tojava.lang.Comparable</span><br></pre></td></tr></table></figure><p>问题原因所在：当用TreeSet的无参构造方法时创建Set集合对象，【该 set 根据其元素的自然顺序进行排序。插入该 set 的所有元素都必须实现 Comparable 接口】，刚刚插入到TreeSet集合中Student类的对象并没有实现Comparable接口，所以出现ClassCastException</p><h1 id="知识点十三：Comparable接口【自然排序接口】"><a href="#知识点十三：Comparable接口【自然排序接口】" class="headerlink" title="知识点十三：Comparable接口【自然排序接口】"></a><center>知识点十三：Comparable接口【自然排序接口】</center></h1><p>官方文档说明:此接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的 compareTo 方法被称为它的自然比较方法,【间接的说明Comparable接口是一个自然排序接口，对与实现接口类会提供排序操作，这个排序操作需要完成compareTo这个方法】</p><p>当前调用TreeSet集合的无参构造方法时，就要求向TreeSet中存储的数据必须实现Comparbale</p><p>实现Comparbale接口就需要实现接口中给提供方法</p><table><thead><tr><th>int</th><th>compareTo(T o) 比较此对象与指定对象的顺序</th></tr></thead><tbody><tr><td></td><td>compareTo这个方法使用接口上泛型作为方法参数泛型，所以在实现Comparable的时候需要指定接口中泛型是什么类型，这样可以避免不必要向下转型，泛型T如何赋值，Comparbale提供谁进行比较这个类型就是谁Comparable提供compareTo方法对数据进行比较时遵守的原则 比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。compareTo这个方法的返回值类型时int类型，这个方法返回值是一个数字</td></tr></tbody></table><p>PS：compareTo这个方法不建议理解为比较方法，理解为交换方法即通过这个方法的得到返回值决定如何进行数据交换【存储】</p><p>之前有接触过一些排序的操作，例如冒泡、选择这些手写排序，但是这些排序中都会有一个必要的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提供比较操作，进行数据交换</span></span><br><span class="line"><span class="keyword">if</span>(arr[i] &gt; arr[i+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[i+<span class="number">1</span>];</span><br><span class="line">    arr[i+<span class="number">1</span>] = tmp;</span><br><span class="line">&#125; </span><br><span class="line">-------------------------------------</span><br><span class="line"><span class="keyword">if</span>(arr[i] &lt; arr[i+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[i+<span class="number">1</span>];</span><br><span class="line">    arr[i+<span class="number">1</span>] = tmp;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//通过修改比较操作中 大于号 或 小于号 可以决定 排序顺序</span></span><br><span class="line"><span class="comment">//那么Comparable接口中compareTo得到的int类型数值就是决定数据如何排序</span></span><br></pre></td></tr></table></figure><p>需要对CompareTo方法进行深入的理解【万能公式】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;CompareTo这方法会返回三个值 正整数、 负整数 和 0&quot;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    一般来说自定义类中提供比较属性基本上都是系统类型，就可以通过两个数</span></span><br><span class="line"><span class="comment">据之间记性“差值计算”从而得到 正整数、 负整数 和 0</span></span><br><span class="line"><span class="comment">    Student类为例 需要比较是年龄 --》年龄的属性是 int类型</span></span><br><span class="line"><span class="comment">    用两个int类型进行相减 得到结果就是 正整数、 负整数 和 0 正好满</span></span><br><span class="line"><span class="comment">足了CompareTo方法需求</span></span><br><span class="line"><span class="comment">    谁减谁可以得到什么结果，如果不是基本数据类型时引用类型减也不能计</span></span><br><span class="line"><span class="comment">算？</span></span><br><span class="line"><span class="comment">    不用担心引用类型问题，基本上能用来比较的引用类型都实现了</span></span><br><span class="line"><span class="comment">Comparable，</span></span><br><span class="line"><span class="comment">    所以比较引用类型调用这个引用类型中对应CompareTo方</span></span><br><span class="line"><span class="comment">法就可以</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="string">&quot;需要区分当前对象和传入对象&quot;</span></span><br><span class="line"><span class="string">&quot;调用CompareTo方法的就是当前对象使用【this表示】&quot;</span></span><br><span class="line"><span class="string">&quot;对CmpareTo方法参数赋值的就是传入对象使用【other表示】&quot;</span></span><br><span class="line"><span class="string">&quot;由此就可以得到一个万能公式：</span></span><br><span class="line"><span class="string">&quot;</span>当前对象 - 传入对象 【得到排序结果就是升序】<span class="string">&quot; ---》 正整数</span></span><br><span class="line"><span class="string">&quot;</span>传入对象 - 当前对象 【得到排序结果就是降序】<span class="string">&quot; ---》 负整数</span></span><br><span class="line"><span class="string">&quot;</span>切记：TreeSet的排重机制并不是equals和HashCode，而是实现排序</span><br><span class="line">接口中CompareTo或Compare方法的返回值，只要返回值为<span class="number">0</span>，TreeSet</span><br><span class="line">就会认为是同一个对象，进行排重操作<span class="string">&quot;</span></span><br><span class="line"><span class="string">//当前使用万能公式做计算时，如果遇到得到0时，出现排重效果，建议在得到0时在提供一个排序条件操作，或者使用List中sort方法排序</span></span><br><span class="line"><span class="string">使用这个公式进行排序时会面临到问题：</span></span><br><span class="line"><span class="string">问题1：此时排序数据类型时自定义类Student</span></span><br><span class="line"><span class="string">我们是不能使用 Student - Student 也不可能</span></span><br><span class="line"><span class="string">Student.CompareTo(Student)</span></span><br><span class="line"><span class="string">对自定义对象排序时，排序时*自定义对象的属性*，将当前公式变形为</span></span><br><span class="line"><span class="string">&quot;</span>当前对象.属性 - 传入对象.属性 【得到排序结果就是升序】<span class="string">&quot; ---》正整数</span></span><br><span class="line"><span class="string">&quot;</span>传入对象.属性 - 当前对象.属性 【得到排序结果就是降序】<span class="string">&quot; ---》负整数</span></span><br><span class="line"><span class="string">问题2：此时排序数据类型时系统类型Integer</span></span><br><span class="line"><span class="string">&quot;</span>当前对象 - 传入对象 【得到排序结果就是升序】<span class="string">&quot; ---》 正整数</span></span><br><span class="line"><span class="string">&quot;</span>传入对象 - 当前对象 【得到排序结果就是降序】<span class="string">&quot; ---》 负整数</span></span><br><span class="line"><span class="string">问题3: 如果遇到是引用类型无法使用减号进行计算时</span></span><br><span class="line"><span class="string">&quot;</span>当前对象.compareTo(传入对象) 【得到排序结果就是升序】<span class="string">&quot; ---》正整数</span></span><br><span class="line"><span class="string">&quot;</span>传入对象.compareTo(当前对象) 【得到排序结果就是降序】<span class="string">&quot; ---》负整数</span></span><br></pre></td></tr></table></figure><p>修改Student类进行年龄属性排序操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.TreeSet;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> height;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> weight;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">int</span> height, <span class="type">int</span> weight)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125; </span><br><span class="line">    p</span><br><span class="line">ublic <span class="keyword">void</span> <span class="title function_">setHeight</span><span class="params">(<span class="type">int</span> height)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">    &#125; </span><br><span class="line">    p</span><br><span class="line">ublic <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWeight</span><span class="params">(<span class="type">int</span> weight)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">        <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">        <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">        <span class="string">&quot;, height=&quot;</span> + height +</span><br><span class="line">        <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">        <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student other)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//比较的是student类中age属性值 [升序排序]</span></span><br><span class="line">        <span class="comment">//return this.age - other.age;</span></span><br><span class="line">        <span class="comment">//比较的是student类中age属性值 [降序排序]</span></span><br><span class="line">        <span class="comment">//return other.age - this.age;</span></span><br><span class="line">        <span class="comment">//防止出现比较结果为0的时候怎么办？ ---&gt; 在提供一个比较数据即可</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age - other.age == <span class="number">0</span> ? <span class="built_in">this</span>.height - other.height : <span class="built_in">this</span>.age - other.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点十四：Comparator接口【自定义排序接口】"><a href="#知识点十四：Comparator接口【自定义排序接口】" class="headerlink" title="知识点十四：Comparator接口【自定义排序接口】"></a><center>知识点十四：Comparator接口【自定义排序接口】</center></h1><p>除了TreeSet集合中可以使用Comparable接口进行自然排序之外，还有一个更加灵活方便的接口Comparator，在系统API文档中说明：强行对某个对象 collection 进行整体排序 的比较函数。可以将Comparator 传递给 sort 方法（如 Collections.sort 或Arrays.sort ），从而允许在排序顺序上实现精确控制。还可以使用Comparator 来控制某些数据结构（如 有序 set 或 有序映射）的顺序，或者为那些没有 自然顺序的对象 collection 提供排序</p><p><strong>综上所述：Comparator接口不仅可以对TreeSet提供排序操作，而且可以针对Java系统API提供sort方法进行自定义排序操作</strong></p><p>Comparator接口中的核心比较方法</p><table><thead><tr><th>int</th><th>compare(T o1, T o2) 比较用来排序的两个参数</th></tr></thead><tbody><tr><td></td><td>compare这个方法和Comparable接口中compareTo方法是一个道理也是返回 正整数、负整数和0 代表对象 大于 小于和等于</td></tr></tbody></table><p>刚刚在Comparable中提供万能公式可以直接使用在Comparator</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="string">这里是需要注意的是：</span></span><br><span class="line"><span class="string">&quot;</span>Comparator接口中compare方法有两个参数,两个参数谁是当前对象，谁是传入对象<span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;</span>compare方法中第一个参数 即 o1 就是当前对象即<span class="built_in">this</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;</span>compare方法中第二个参数 即 o2 就是传入对象即other<span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;</span>由此就可以得到一个万能公式：</span><br><span class="line"><span class="string">&quot;当前对象 - 传入对象 【得到排序结果就是升序】&quot;</span> ---》 正整数</span><br><span class="line"><span class="string">&quot;传入对象 - 当前对象 【得到排序结果就是降序】&quot;</span> ---》 负整数</span><br><span class="line"><span class="string">&quot;切记：TreeSet的排重机制并不是equals和HashCode，而是实现排序</span></span><br><span class="line"><span class="string">接口中CompareTo或Compare方法的返回值，</span></span><br><span class="line"><span class="string">只要返回值为0，TreeSet就会认为是同一个对象，进行排重操作&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当前使用功能公式做计算时，如果遇到得到0时，出现排重效果，建议在</span></span><br><span class="line">得到<span class="number">0</span>时在提供一个排序条件操作，或者算着List中sort方法排序</span><br><span class="line">使用这个公式进行排序时会面临到问题：</span><br><span class="line">问题<span class="number">1</span>：此时排序数据类型时自定义类Student</span><br><span class="line">我们是不能使用 Student - Student 也不可能</span><br><span class="line"> Student.CompareTo(Student)</span><br><span class="line">对自定义对象排序时，排序时自定义对象的属性，将当前公式变形为</span><br><span class="line"><span class="string">&quot;当前对象.属性 - 传入对象.属性 【得到排序结果就是升序】&quot;</span> ---》正整数</span><br><span class="line"><span class="string">&quot;传入对象.属性 - 当前对象.属性 【得到排序结果就是降序】&quot;</span> ---》负整数</span><br><span class="line">问题<span class="number">2</span>：此时排序数据类型时系统类型Integer</span><br><span class="line"><span class="string">&quot;当前对象 - 传入对象 【得到排序结果就是升序】&quot;</span> ---》 正整数</span><br><span class="line"><span class="string">&quot;传入对象 - 当前对象 【得到排序结果就是降序】&quot;</span> ---》 负整数</span><br><span class="line">问题<span class="number">3</span>: 如果遇到是引用类型无法使用减号进行计算时</span><br><span class="line"><span class="string">&quot;当前对象.compareTo(传入对象) 【得到排序结果就是升序】&quot;</span> ---》正整数</span><br><span class="line"><span class="string">&quot;传入对象.compareTo(当前对象) 【得到排序结果就是降序】&quot;</span> ---》负整数</span><br></pre></td></tr></table></figure><p><strong>复制Student类创建Student2来进行Comparator接口操作</strong></p><p>Comparator接口对应的是TreeSet中有参构造方法，所以要使用Comparator进行排序就需要使用当前这个有参构造方法【传入实现Comparator接口的实现类对象】方可进行排序操作</p><p><strong>提供两种实现Comparator接口的方式</strong>:</p><p>&ensp;&ensp;&ensp;&ensp;第一种:提供一个比较原则类实现Comparator接口，实现compare方法定义排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> height;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> weight;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student2</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student2</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">int</span> height, <span class="type">int</span> weight)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHeight</span><span class="params">(<span class="type">int</span> height)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125; </span><br><span class="line">    p</span><br><span class="line">ublic <span class="keyword">void</span> <span class="title function_">setWeight</span><span class="params">(<span class="type">int</span> weight)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">        <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line"><span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">        <span class="string">&quot;, height=&quot;</span> + height +</span><br><span class="line">        <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">        <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="comment">//提供一个类实现Comparator接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortGZ</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Student2&gt; </span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student2 o1, Student2 o2)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> o2.getAge()-o1.getAge();</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentTest2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//调用TreeSet中具备Comparator接口方法,参数赋值就是实现Comparator接口的对象</span></span><br><span class="line">        TreeSet&lt;Student2&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">SortGZ</span>());</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">178</span>,<span class="number">100</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">20</span>,<span class="number">181</span>,<span class="number">200</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;王五&quot;</span>,<span class="number">16</span>,<span class="number">200</span>,<span class="number">10</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;赵六&quot;</span>,<span class="number">19</span>,<span class="number">145</span>,<span class="number">150</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;田七&quot;</span>,<span class="number">21</span>,<span class="number">190</span>,<span class="number">160</span>));</span><br><span class="line">        treeSet.forEach(System.out::println);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;&ensp;&ensp;第二种方式：就是使用匿名内部类或者lambda表达式实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentTest3</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//调用TreeSet中具备Comparator接口方法,参数赋值就是实现</span></span><br><span class="line">        Comparator接口的对象</span><br><span class="line">        <span class="comment">//匿名内部类版本</span></span><br><span class="line">        TreeSet&lt;Student2&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span></span><br><span class="line">        <span class="title class_">Comparator</span>&lt;Student2&gt;() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student2 o1, Student2 o2)</span> </span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.getAge() - o2.getAge();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">178</span>,<span class="number">100</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">20</span>,<span class="number">181</span>,<span class="number">200</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;王五&quot;</span>,<span class="number">16</span>,<span class="number">200</span>,<span class="number">10</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;赵六&quot;</span>,<span class="number">19</span>,<span class="number">145</span>,<span class="number">150</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;田七&quot;</span>,<span class="number">21</span>,<span class="number">190</span>,<span class="number">160</span>));</span><br><span class="line">        treeSet.forEach(System.out::println);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Lambda表达式</span></span><br><span class="line">        TreeSet&lt;Student2&gt; treeSet2 = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;((o1,o2) -&gt; o2.getAge()-o1.getAge());</span><br><span class="line">        treeSet2.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">178</span>,<span class="number">100</span>));</span><br><span class="line">        treeSet2.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">20</span>,<span class="number">181</span>,<span class="number">200</span>));</span><br><span class="line">        treeSet2.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;王五&quot;</span>,<span class="number">16</span>,<span class="number">200</span>,<span class="number">10</span>));</span><br><span class="line">        treeSet2.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;赵六&quot;</span>,<span class="number">19</span>,<span class="number">145</span>,<span class="number">150</span>));</span><br><span class="line">        treeSet2.add(<span class="keyword">new</span> <span class="title class_">Student2</span>(<span class="string">&quot;田七&quot;</span>,<span class="number">21</span>,<span class="number">190</span>,<span class="number">160</span>));</span><br><span class="line">        treeSet2.forEach(System.out::println);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结Comparable和Comparator接口"><a href="#总结Comparable和Comparator接口" class="headerlink" title="总结Comparable和Comparator接口"></a>总结Comparable和Comparator接口</h2><p>&ensp;&ensp;&ensp;&ensp;现在Java而言不仅只有TreeSet能排序，List集合也可以排序，Map集合也可以排序，合理规划使用排序即可，Comparable这个接口值专门针对TreeSet集合进行排序而设计一个接口，它的局限性在于它只适合自定义类存储在TreeSet进行使用，其他位置提供Sort方法是不使用Comparable作为参数，Comparator属于自定义排序接口，使用比较广泛，除了在TreeSet中可以使用之外，List集合中提供Sort和JavaAPI中提供其他Sort方法基本上都是使用Comparator参数类型，所以这两个接口建议优先掌握Comparator接口【使用广泛】，其次Comparable</p><h1 id="知识点十五：Set集合总结"><a href="#知识点十五：Set集合总结" class="headerlink" title="知识点十五：Set集合总结"></a><center>知识点十五：Set集合总结</center></h1><p>Set集合是一个接口继承与Collection接口和Iterable接口,Set集合本身具备排重功能和存储无序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Set</span> &lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt;</span><br></pre></td></tr></table></figure><p>Set集合集合主要的实现类有HashSet、LinkedHashSet和TreeSet，所以Set集合接口是支持多态创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">Set&lt;Integer&gt; set2 = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">Set&lt;Integer&gt; set3 = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>Set集合中提供可操作集合都是线程不安全，所以面临多线程处理数据的时候</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.synchronizedSet(Set集合的对象); --》将一个Set集合对象变成线程安全集合</span><br></pre></td></tr></table></figure><p>除了这种方式之外可以使用Java5开始提供java.util.concurrent包下提供线程集合完全类来进行操作</p><p><strong>HashSet它是Set集合主要实现类，也是实际开发中使用比较广泛的一个类</strong>，这个类的主要实现是Hash表，底层实现是创建一个HashMap对象作为HashSet的具体实现，并且向HashSet存储数据时，其实是向HashMap中key值的位置进行数据存储</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//添加数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashSet的默认容量是16，加载因子是0.75，扩容大小是原有一倍</p><p>在Java8之前HashSet底层主要实现是Hash表【数组+链表】形式，从Java8开始对底层存储进行优化，提供存储和查询效果将原有Hash表进行优化【数组+链表或红黑树】，向Hash表中如果存储数据，<strong>某个存储位置中链表长度大达到8的时候【存储了8个数据】，就将链表修改为红黑树，从而提高查询效率</strong></p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291950536.png" alt="红黑树" style="zoom:50%;"><p>HashSet存储自定义类对象时，如果需要进行排重操作，需要提供equals和hashcode重写</p><p>LinkedHashSet是HashSet子类，本身不具备任何特殊方法，所有都是来源于Set接口，唯一特点就是提供一个链表来记录存储顺序，开发中是几乎与不用，它操作可有完全仿照HashSet</p><p>TreeSet 是Set集合中一个排序排重的集合，这个集合使用 红黑树+Hash表，当使用TreeSet的无参构造方法创建对象时，向TreeSet集合存数据，这个存储的数据必须实现Comparable接口，也可使用TreeSet的有参构造方法，方法参数是Comparator类型，实现Comparator接口进行存储数据的自定义排序</p><p>PS:不是只有TreeSet才可以排序，List和Map集合都可以进行排序操作，但是这个俩个集合都会使用到Comparator</p><h1 id="知识点十六：Collection集合"><a href="#知识点十六：Collection集合" class="headerlink" title="知识点十六：Collection集合"></a><center>知识点十六：Collection集合</center></h1><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291950700.png" alt="Collection集合" style="zoom:50%;"><p>Collection集合接口是List和Set集合接口父接口，Collection集合接口继承Iterable接口，所以List和Set集合接口都是支持迭代器操作，因为List和Set集合接口都是Collection集合子接口，所以List和Set集合接口的实现了可以作为Collection集合接口的实现类使用，所以支持多态创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Collection集合接口创建对象</span></span><br><span class="line">Collection &lt;Integer&gt; c1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Collection &lt;Integer&gt; c2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">Collection &lt;Integer&gt; c3 = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">Collection &lt;Integer&gt; c4 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">Collection &lt;Integer&gt; c5 = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">Collection &lt;Integer&gt; c6 = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>因为Collection是集合接口，所以里面的方法都已经讲解完毕</p><p>PS：在实际开发中List集合接口中最常用类是ArrayList，Set集合接口中最常用类是HashSet</p><h1 id="知识点十七：Collections工具类"><a href="#知识点十七：Collections工具类" class="headerlink" title="知识点十七：Collections工具类"></a><center>知识点十七：Collections工具类</center></h1><p>将集合中的元素反转</p><p>&ensp;&ensp;&ensp;&ensp;Collections.reverse(List list)</p><p>将集合中的元素随机打乱</p><p>&ensp;&ensp;&ensp;&ensp;Collections.shuffle(List list)</p><p>将集合中的元素排序 （必须要实现Comparable接口）</p><p>&ensp;&ensp;&ensp;&ensp;Collections.sort(List list)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionsDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;大娃&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;二娃&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;rose&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;妖怪&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;蛇妖&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;蛇妖&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//按照字典顺序</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将集合元素进行翻转</span></span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将集合中的元素进行随机打乱</span></span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Arrays数组工具类 Collections集合工具类</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点十七：Map集合"><a href="#知识点十七：Map集合" class="headerlink" title="知识点十七：Map集合"></a><center>知识点十七：Map集合</center></h1><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291953280.png" alt="Map集合"></p><h2 id="1、Map集合介绍"><a href="#1、Map集合介绍" class="headerlink" title="1、Map集合介绍"></a><center>1、Map集合介绍</center></h2><p>&ensp;&ensp;&ensp;&ensp;Map集合是两大集合之一和Collection之间是并存关系，Map不是Collection的子类，Map一般会和List和Set这两个集合并称三大集合【List、Set和Map】，因为Map和Collection并没有什么关系，所以Map集合和Iterable接口也没有任何关系，所以Map集合是不提供迭代器操作</p><p>&ensp;&ensp;&ensp;&ensp;Map集合在Java提供一种存储数据方式，这种方式称之为“映射”【keyvalue键值对】，通过映射这种关系将将两个数据进行相连形成数据存储形式就是key-value键值对</p><p>PS：key和value值不要过分纠结，只要提供Map存储数据数据类型就可以决定key值存储什么value值存储什么，他们在底层存储形式是以一种键值对相连的【情侣】</p><p>&ensp;&ensp;&ensp;&ensp;映射的说明: 在数学中假设A，B两个非空集合，如果存在一个法则F，使用A集合中每一个元素按照法则F在B集合中有一个唯一对应，则成F为A到B集合映射关系</p><p>在做映射关系时：</p><p>&ensp;&ensp;&ensp;&ensp;提供key值要求是唯一的 ，A集合中相当于存储Key而<strong>Key是唯一</strong>的，所以可以想象存储key的集合其实就是Set集合提供vlaue值是可以不唯一的，B集合相当于存储Value而<strong>value是不唯一的</strong>，所以可以想象存储value的集合其实就是List集合</p><p>提供一个链接法则【链接原则】 让A集合key可以和B集合中value进行一个链接形成一个键值对，Map提供存储方式就是这个方法Entry(key-value),Map中存储大量Entry实体存储就是相当与键值对存储了</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291954387.png" alt="介绍" style="zoom:50%;"><h2 id="2、Map集合主要实现类HashMap"><a href="#2、Map集合主要实现类HashMap" class="headerlink" title="2、Map集合主要实现类HashMap"></a><center>2、Map集合主要实现类HashMap</center></h2><p>HashMap与Map接口之间关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;&ensp;&ensp;HashMap的主要实现接就是Map，HashMap也是Map接口的最主要实现类HashMap在官方文档中说明：基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外， HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变</p><p>&ensp;&ensp;&ensp;&ensp;说明：HashMap的主要实现使用Hash表，但是在Java7之前使用的是原始Hash表的形式即【数组+链表】形式存储数据，但是从Java8开始HashMap集合提供Hash表实现从【数组+链表】转换为【数组+链表或红黑树】，当前向HashMap中某个“桶节点【即存储位置】”，添加的数据达到8个时，就会将链表结构转换红黑树，8这个数字在链表中的查询效果是可以控制，因为链表的查询方式是线性查询【从前之后】，所以最快效率是1，最慢效率N，平均值(1+N)&#x2F;2,随着N值不断变大，这个查询效率会逐渐降低，所以在8节点时将链表转换为红黑树，就是为提高查询效率而是用，红黑树是平衡树，而且树的查询效率是【2倍效率】</p><p>HashMap集合是线程不安全集合，在多线程前提现可以使用</p><p>Hashtable【之前做法】，现在开发不在使用Hashtable，如何解决线程不安全问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Collections.synchronizedMap(<span class="keyword">new</span> <span class="title class_">HashMap</span>()); ---&gt; 得到一个线程安全集合或者</span><br><span class="line">                                                    使用线程安全Map集合---》ConcurrentHashMap集合</span><br></pre></td></tr></table></figure><p>HashMap是存储key-value键值对形式集合，所以创建HashMap对象时需要提供Key和Value的泛型的数据类型，HashMap毕竟底层是Hash表所以在Java中初始容量16,加载因子0.75，扩容方式是原有容量2倍，并且会重新计算所有存储在HashMap中数据存储位置即从新计算key的存储位置</p><p>HashMap在Java8之前和Java8之后API有很大的变化，将Java8之前API看做是基础API，将Java8提供API看做增强操作API即可</p><h2 id="3、HashMap常用方法-Java8之前"><a href="#3、HashMap常用方法-Java8之前" class="headerlink" title="3、HashMap常用方法(Java8之前)"></a><center>3、HashMap常用方法(Java8之前)</center></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.BiConsumer;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供HashMap的对象创建方式</span></span><br><span class="line">        <span class="comment">//1.1创建一个空HashMap集合对象【默认初始容量16，加载因子0.75】 ---&gt; 常用</span></span><br><span class="line">        HashMap&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//1.2创建一个提供初始容量大小的HashMap集合对象【加载因子0.75】</span></span><br><span class="line">        HashMap&lt;String,Integer&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">32</span>);</span><br><span class="line">        <span class="comment">//1.3创建一个提供初始容量大小和加载因子的HashMap对象---》提供的容量是16的倍数，加载因子不易过小</span></span><br><span class="line">        HashMap&lt;Character,Double&gt; map3 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt; (<span class="number">32</span>,<span class="number">0.5f</span>);</span><br><span class="line">        <span class="comment">//1.4将参数Map集合对象中存储数据赋值给当前HashMap集合对象进行存储 ---&gt; 偶尔</span></span><br><span class="line">        HashMap&lt;String, Integer&gt; map4 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt; (map);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//提供常用API;</span></span><br><span class="line">        <span class="comment">//1.向HashMap集合对象中添加数据 [第一个参数是存储的key值，第二个参数参数存储是value值]</span></span><br><span class="line">        map.put(<span class="string">&quot;1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        System.out.println(map);<span class="comment">//HashMap已经重写toString方法所以直接打印集合对象查看结果</span></span><br><span class="line">        <span class="comment">//PS：在使用put方法向map集合对象中添加 &quot;1&quot;,2 键值对</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1.向Map集合添加Key-value键值对时 key值必须是唯一的，又使用key = &quot;1&quot; 那么系统并没有</span></span><br><span class="line"><span class="comment">                提示任何语法错误信息和异常信息，是否会出现运行时异常呢？ ---》不会出现异常</span></span><br><span class="line"><span class="comment">            2.put方法的第二个作用：修改指定key对应value值</span></span><br><span class="line"><span class="comment">                当使用put方法提供一个已经在map集合对象中存在key时，将put操作认为是覆盖原有已经存在map集合中key-value</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        map.put(<span class="string">&quot;1&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//putAll(Map集合对象) --&gt; 将参数Map集合对象中存储的数据赋值给Map集合</span></span><br><span class="line">        <span class="comment">// clear() ---&gt; 将Map集合中存储数据清空，map对象的引用是保留</span></span><br><span class="line">        <span class="comment">// isEmpty() ---&gt;判断Map集合中是否有存储数据 存储数据返回false 没有存储返回true</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断Map集合中是否存在指定key值 --&gt; 存储返回true 不存在返回false</span></span><br><span class="line">        System.out.println(map.containsKey(<span class="string">&quot;1&quot;</span>));</span><br><span class="line">        <span class="comment">//判断Map集合中是否存在指定value值 --&gt;存储返回true 不存在返回false</span></span><br><span class="line">        System.out.println(map.containsValue(<span class="number">2</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取存储在Map集合value值时 ---》key存在会得到对应value，key不存在会得到null值</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> map.get(<span class="string">&quot;2&quot;</span>);    <span class="comment">//参数：key值</span></span><br><span class="line">        <span class="keyword">if</span>(Objects.nonNull(integer)) <span class="comment">//建议添加非null判断</span></span><br><span class="line">        &#123; </span><br><span class="line">            integer.intValue();</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将存储在Map集合中key-value键值对删除，条件是一个key值</span></span><br><span class="line">        map.remove(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;获取Map集合中存储元素的个数：&quot;</span>+map.size());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Map集合遍历方式比较麻烦，没有迭代器，不支持普通for循环遍历，不支持增强for</span></span><br><span class="line">        <span class="comment">//获取map集合中所有key的值存储在一个Set集合中</span></span><br><span class="line">        Set&lt;String&gt; strings = map.keySet(); <span class="comment">//通过这种方式获取到所有key</span></span><br><span class="line">        <span class="comment">//获取map集合中所有value的值存储在一个Collection集合中</span></span><br><span class="line">        Collection&lt;Integer&gt; values = map.values(); <span class="comment">//通过这种方式获取到所有value值</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Map提供了一种遍历方式entrySet方法 --&gt;返回值是一个Set集合</span></span><br><span class="line"><span class="comment">            Set集合存在一个泛型类型 Map.Entry ---》Set集合中存储的数据类型</span></span><br><span class="line"><span class="comment">            Map.Entry&lt;String,Integer&gt; --&gt; 相当Map.Entry类型中存储数据是 String类型key 和 Integer类型value</span></span><br><span class="line"><span class="comment">            通过entrySet这个方法，返回一个Set集合这个集合存储这个Entry的类型，Entry类型的内部存储的是key-value兼职对</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        HashMap&lt;String,Integer&gt; map5 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map5.put(<span class="string">&quot;key1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        map5.put(<span class="string">&quot;key2&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        map5.put(<span class="string">&quot;key3&quot;</span>,<span class="number">3</span>);</span><br><span class="line">        map5.put(<span class="string">&quot;key4&quot;</span>,<span class="number">4</span>);</span><br><span class="line">        map5.put(<span class="string">&quot;key5&quot;</span>,<span class="number">5</span>);</span><br><span class="line">        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map5.entrySet();</span><br><span class="line">        System.out.println(entries);</span><br><span class="line">        <span class="comment">//提供Set集合之增强for循环遍历</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String, Integer&gt; entry : entries)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//entry就得到了存储在Set集合中key-value键值对 即 key1=1</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Key的值是：&quot;</span>+entry.getKey());</span><br><span class="line">            System.out.println(<span class="string">&quot;Value的值是：&quot;</span>+entry.getValue());</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//在Java8中时提供一个foreach方法可以便捷遍历集合中key和value</span></span><br><span class="line">        map5.forEach(<span class="keyword">new</span> <span class="title class_">BiConsumer</span>&lt;String, Integer&gt;() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * </span></span><br><span class="line"><span class="comment">            * <span class="doctag">@param</span> s map集合中key值</span></span><br><span class="line"><span class="comment">            * <span class="doctag">@param</span> integer map集合汇总value</span></span><br><span class="line"><span class="comment">            * 这个方法被出触发时可以获取map集合中每一对：keyvalue</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s, Integer integer)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//这个可以进行操作但是只是打印的结果，不会影响最终map集合中的结果</span></span><br><span class="line">                System.out.println(s);</span><br><span class="line">                System.out.println(integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        map5.forEach((k,v)-&gt; System.out.println(k+<span class="string">&quot;=&quot;</span>+v));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、HashMap常用方法-Java8之后"><a href="#4、HashMap常用方法-Java8之后" class="headerlink" title="4、HashMap常用方法(Java8之后)"></a><center>4、HashMap常用方法(Java8之后)</center></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 提供HashMap基础API【Java8之后】</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapAPIDemo_2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供HashMap的对象创建方式</span></span><br><span class="line">        <span class="comment">//1.1创建一个空HashMap集合对象【默认初始容量16，加载因子0.75】 ---&gt; 常用</span></span><br><span class="line">        HashMap&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//新Java8中方法</span></span><br><span class="line">        <span class="comment">//1向map集合中添加数据 ---&gt;如果key已经存在则不添加，否则添加数据 【建议向Map集合存储数据使用】</span></span><br><span class="line">        map.putIfAbsent(<span class="string">&quot;1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        map.putIfAbsent(<span class="string">&quot;2&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        map.putIfAbsent(<span class="string">&quot;3&quot;</span>,<span class="number">3</span>);</span><br><span class="line">        map.putIfAbsent(<span class="string">&quot;1&quot;</span>,<span class="number">1000</span>);</span><br><span class="line">        map.putIfAbsent(<span class="string">&quot;1&quot;</span>,<span class="number">10000</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">//2.提供了一个全系列对map集合中k和v进行存储的方法 ---》computeXXX方法</span></span><br><span class="line">        <span class="comment">//2.1 map集合中指定key在map集合进行操作</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        执行原理:</span></span><br><span class="line"><span class="comment">            无论key是否存在都会执行参数中提供Lambda表达式</span></span><br><span class="line"><span class="comment">            1.如果key值存在，后面提供Lambda表达式就会取出key所对应value并在Lambda表达式中进行操作，然后修改原有k和v值</span></span><br><span class="line"><span class="comment">            2.如果key值不存在，后面提供Lambda表达式就会将key进行存到 map集合操作</span></span><br><span class="line"><span class="comment">                第一个参数就是key值，第二个参数就是提供操作key对应Lambda表达式</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        map.compute(<span class="string">&quot;3&quot;</span>,(k,v) -&gt; v == <span class="literal">null</span> ? <span class="number">0</span> : v+<span class="number">1</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        map.compute(<span class="string">&quot;4&quot;</span>,(k,v) -&gt; v == <span class="literal">null</span> ? <span class="number">0</span> : v+<span class="number">1</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">//2.2 判断map集合key是否存在提供对应操作</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        执行原理：</span></span><br><span class="line"><span class="comment">            1.如果key存在，后面提供Lambda表达式就不会执行，并返回key对应value值</span></span><br><span class="line"><span class="comment">            2.如果key不存储，后面提供Lambda表达式就会执行操作者并将Lambda表达式中处理</span></span><br><span class="line"><span class="comment">            之后value值与key一起存储到map集合中</span></span><br><span class="line"><span class="comment">            PS：Lambda表达式是你如何处理这个value操作 ，你自己决定</span></span><br><span class="line"><span class="comment">            但是一定要返回这个value即添加return</span></span><br><span class="line"><span class="comment">            第一个参数就是key值，第二个参数就是提供操作key对应Lambda表达式</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> map.computeIfAbsent(<span class="string">&quot;3&quot;</span>,key -&gt; <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">5</span>));</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        map.computeIfAbsent(<span class="string">&quot;5&quot;</span>,key -&gt; <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">5</span>));</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">//2.3 判断map集合key是否存在提供对应操作</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        执行原理：</span></span><br><span class="line"><span class="comment">            1.如果key存在，就执行后lambda表达式，并修改map集合key所对应value值</span></span><br><span class="line"><span class="comment">            2.如果key不存在，就不会执行后面lambda表达式，不会像Map集合中做任何操作，但是方法会返回一个null</span></span><br><span class="line"><span class="comment">            第一个参数就是key值，第二个参数就是提供操作key对应Lambda表达式</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        map.computeIfPresent(<span class="string">&quot;3&quot;</span>,(k,v) -&gt; v+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            相当于 你调用map.containsKey() --》 在调用 map.get()--》得到value之后进行操作</span></span><br><span class="line"><span class="comment">            在调用 ---&gt;map.put 这个存储回去</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.out.println(map);</span><br><span class="line">        map.computeIfPresent(<span class="string">&quot;6&quot;</span>,(k,v) -&gt; v+<span class="number">1</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            getOrDefault这个方法作用是通过key值获取对应value，这个方法根get方法最大区别在于</span></span><br><span class="line"><span class="comment">            这个方法提供一个默认值，如果key不存在则返回对应默认值， 存在则返回value值</span></span><br><span class="line"><span class="comment">            get方法在则返回value不在则返回null值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//第一个参数是key值 第二个参数是默认值</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">orDefault</span> <span class="operator">=</span> map.getOrDefault(<span class="string">&quot;7&quot;</span>, Integer.MAX_VALUE);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//merge(合并) --》方法含义 对存在在map集合中kv键值对进行更新操作【更新value值】</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            第一个参数 是map集合存在key值</span></span><br><span class="line"><span class="comment">            第二个参数 这个参数的作用是向Lambda表达式中提供方法参数中</span></span><br><span class="line"><span class="comment">            第二个参数赋值 即 newVal</span></span><br><span class="line"><span class="comment">            第三个参数 需要对存在在集合key所对应value所提供更新数据操作 --》 提供一个lambda</span></span><br><span class="line"><span class="comment">            lambda中第一个参数即oldVal是获取出提供key所对应的value值</span></span><br><span class="line"><span class="comment">            第二个参数即newVal或获取方法中第二个参数值</span></span><br><span class="line"><span class="comment">            提供这两个参数计算更新key所对应value值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        map.merge(<span class="string">&quot;1&quot;</span>,<span class="number">2</span>,(oldVal,newVal)-&gt;oldVal+newVal);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//删除方法--》根据提供k和v值进行删除，如果存在在map中删除成功返回true，如果不存在删除失败返回false</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">remove</span> <span class="operator">=</span> map.remove(<span class="string">&quot;1&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(remove);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Java8中提供一个操作，官方文档意思在于使用这个方法替代put方法修改操作</span></span><br><span class="line">        <span class="comment">//根据key值替换存储对应value值，如果key存在则替换，不存在则不替换</span></span><br><span class="line">        map.replace(<span class="string">&quot;2&quot;</span>,<span class="number">3</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">// 多参数版本 提供完整key-value键值对，进行替换操作 如果key和value匹配成功存在则替换，不存在则替换</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            第一个参数是 key值</span></span><br><span class="line"><span class="comment">            第二个参数是 key对应原理的value值</span></span><br><span class="line"><span class="comment">            第三个参数是 新替换value值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        map.replace(<span class="string">&quot;2&quot;</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">        <span class="comment">//只要满足lambda表达式提供替换条件，就会将value值进行替换</span></span><br><span class="line">        map.replaceAll((key,value)-&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//提供替换操作者条件</span></span><br><span class="line">            <span class="keyword">if</span>(key.length() &gt;= <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//提供替换操作</span></span><br><span class="line">                value = <span class="number">1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//需要将替换的value值提提供return返回</span></span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">// forEach打印方法</span></span><br><span class="line">        map.forEach((k,v)-&gt; System.out.println(k+<span class="string">&quot;=&quot;</span>+v));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap有一个子类LinkedHashMap这个集合 操作方式和HashMap是一样，只不过就是存储结构有所变化多了一个链表存储，Hashtable已经不在使用了，所以这个API执行查看和HashMap操作一样的</p><h2 id="5、Map集合之TreeMap集合"><a href="#5、Map集合之TreeMap集合" class="headerlink" title="5、Map集合之TreeMap集合"></a><center>5、Map集合之TreeMap集合</center></h2><p>TreeMap集合是Map集合实现类之一，TreeMap集合提供排序操作，TreeMap集合排序操作和TreeSet道理相同的，需要提供Comparator和Comaprable接口，根据使用TreeMap中构造方法决定说那个那个接口来实现排序操作</p><p>在官方的API文档中的介绍：基于红黑树（Red-Black tree）的NavigableMap 实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法</p><p>TreeMap集合的排序点在于存储的键值key，将要排序数据存储到key中就可以进行排序操作</p><p>当调用无参构造方法创建TreeMap对象时，使用Comparable进行的比较操作</p><p>TreeMap() 使用键的自然顺序构造一个新的、空的树映射</p><p>当调用有参构造方法创建TreeMap对象时，使用Comparator进行的比较操作</p><p>TreeMap(Comparator comparator) 构造一个新的、空的树映射，该映射根据给定比较器进行排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeMapDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        TreeMap&lt;Integer,String&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">        treeMap.putIfAbsent(<span class="number">10</span>,<span class="string">&quot;value10&quot;</span>);</span><br><span class="line">        treeMap.putIfAbsent(<span class="number">8</span>,<span class="string">&quot;value8&quot;</span>);</span><br><span class="line">        treeMap.putIfAbsent(<span class="number">15</span>,<span class="string">&quot;value15&quot;</span>);</span><br><span class="line">        treeMap.putIfAbsent(<span class="number">7</span>,<span class="string">&quot;value7&quot;</span>);</span><br><span class="line">        treeMap.putIfAbsent(<span class="number">1</span>,<span class="string">&quot;value1&quot;</span>);</span><br><span class="line">        treeMap.putIfAbsent(<span class="number">9</span>,<span class="string">&quot;value9&quot;</span>);</span><br><span class="line">        treeMap.putIfAbsent(<span class="number">20</span>,<span class="string">&quot;value20&quot;</span>);</span><br><span class="line">        treeMap.putIfAbsent(<span class="number">13</span>,<span class="string">&quot;value13&quot;</span>);</span><br><span class="line">        System.out.println(treeMap);</span><br><span class="line">        </span><br><span class="line">        TreeMap&lt;Integer,String&gt; treeMap2 = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt; (<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> </span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">return</span> o2 - o1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        treeMap2.putIfAbsent(<span class="number">10</span>,<span class="string">&quot;value10&quot;</span>);</span><br><span class="line">        treeMap2.putIfAbsent(<span class="number">8</span>,<span class="string">&quot;value8&quot;</span>);</span><br><span class="line">        treeMap2.putIfAbsent(<span class="number">15</span>,<span class="string">&quot;value15&quot;</span>);</span><br><span class="line">        treeMap2.putIfAbsent(<span class="number">7</span>,<span class="string">&quot;value7&quot;</span>);</span><br><span class="line">        treeMap2.putIfAbsent(<span class="number">1</span>,<span class="string">&quot;value1&quot;</span>);</span><br><span class="line">        treeMap2.putIfAbsent(<span class="number">9</span>,<span class="string">&quot;value9&quot;</span>);</span><br><span class="line">        treeMap2.putIfAbsent(<span class="number">20</span>,<span class="string">&quot;value20&quot;</span>);</span><br><span class="line">        treeMap2.putIfAbsent(<span class="number">13</span>,<span class="string">&quot;value13&quot;</span>);</span><br><span class="line">        System.out.println(treeMap2);</span><br><span class="line">        </span><br><span class="line">        TreeMap&lt;Integer,String&gt; treeMap3= <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt; ((o1,o2)-&gt;o2 - o1);</span><br><span class="line">        treeMap3.putIfAbsent(<span class="number">10</span>,<span class="string">&quot;value10&quot;</span>);</span><br><span class="line">        treeMap3.putIfAbsent(<span class="number">8</span>,<span class="string">&quot;value8&quot;</span>);</span><br><span class="line">        treeMap3.putIfAbsent(<span class="number">15</span>,<span class="string">&quot;value15&quot;</span>);</span><br><span class="line">        treeMap3.putIfAbsent(<span class="number">7</span>,<span class="string">&quot;value7&quot;</span>);</span><br><span class="line">        treeMap3.putIfAbsent(<span class="number">1</span>,<span class="string">&quot;value1&quot;</span>);</span><br><span class="line">        treeMap3.putIfAbsent(<span class="number">9</span>,<span class="string">&quot;value9&quot;</span>);</span><br><span class="line">        treeMap3.putIfAbsent(<span class="number">20</span>,<span class="string">&quot;value20&quot;</span>);</span><br><span class="line">        treeMap3.putIfAbsent(<span class="number">13</span>,<span class="string">&quot;value13&quot;</span>);</span><br><span class="line">        System.out.println(treeMap3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TreeMap集合排序的时候也是会对key值进行排重操作，这个排重操作依据是提供Comparable和Comparator接口中方法实现时，如果结果为0，就会进行排重操作</p><h2 id="6、Collections工具类"><a href="#6、Collections工具类" class="headerlink" title="6、Collections工具类"></a><center>6、Collections工具类</center></h2><p>Collections工具类类似于Arrays工具类，Collections工具类是为了给Collection集合提供便捷操作工具类，虽然Collection集合已经提供很多方法了，但是Collections工具类也提供一些操作方法，弥补开发时所需要自行定义方法</p><p>Collections工具类提供方法大部分都是给Collection集合使用，极少部分是给Map集合使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionsAPIDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.一次性向Collection集合对象中添加多个数据--》【推荐】</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//向集合中存这些数据：【 321,34,3,1,4,4231,4123,353,1】</span></span><br><span class="line">        list.add(<span class="number">321</span>);</span><br><span class="line">        list.add(<span class="number">34</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">4</span>);</span><br><span class="line">        list.add(<span class="number">4231</span>);</span><br><span class="line">        list.add(<span class="number">4123</span>);</span><br><span class="line">        list.add(<span class="number">353</span>);</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//不用上面这样麻烦操作了,直接使用addAll方法就可以了</span></span><br><span class="line">        <span class="comment">//这个方法的第一个参数是 Collection集合对象， 第二个参数就是要存储值使用【,】分隔即可</span></span><br><span class="line">        Collections.addAll(list,<span class="number">321</span>,<span class="number">34</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">4231</span>,<span class="number">4123</span>,<span class="number">353</span>,<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.提供Collection集合排序操作【针对是List集合】</span></span><br><span class="line">        Collections.sort(list); <span class="comment">//默认是升序排序操作【要去排序数据要么实现Comparable要么实现Comparator】</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//可以使用Collections工具类中提供静态方法进行降序排序【仅针对集合中存储系统引用类型有效】</span></span><br><span class="line">        Collections.sort(list,Collections.reverseOrder());</span><br><span class="line"></span><br><span class="line">        System.out.println(list); <span class="comment">//指针对系统类型</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//自定义排序操作</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> o1 - o2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Collections.sort(list,(o1,o2)-&gt;o2-o1);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//从Java8开始List集合接口提供sort方法，所以可以直接调用List集合的sort方法进行排序操作</span></span><br><span class="line">        list.sort(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> o1-o2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        list.sort((o1,o2)-&gt;o2-o1);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将List、set和Map集合转换为线程安全的集合</span></span><br><span class="line">        List&lt;Integer&gt; lists = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        Set&lt;String&gt; sets = Collections.synchronizedSet(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;());</span><br><span class="line">        Map&lt;String, Integer&gt; maps = Collections.synchronizedMap(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;());</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 提供二分查找【要排序数据】 找到 下标 找不到 负数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Collections.binarySearch(list, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//交换List集合存储元素的位置 位置参数是下标</span></span><br><span class="line">        Collections.swap(list,<span class="number">0</span>,list.size()-<span class="number">1</span>);<span class="comment">//第一个元素和最后一个元素互换</span></span><br><span class="line">        <span class="comment">//打乱List集合对象中存储数据的顺序【将有序存储数据打乱存储】</span></span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line">        <span class="comment">//向List集合中填充同一个数据</span></span><br><span class="line">        Collections.fill(list,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、Collection集合和Map集合的总结"><a href="#7、Collection集合和Map集合的总结" class="headerlink" title="7、Collection集合和Map集合的总结"></a><center>7、Collection集合和Map集合的总结</center></h2><p>Collection是Java集合框架中根接口也是List和Set集合的父接口，Collection集合接口也继承Iterable接口所有Collection系的集合都支持迭代器进行遍历操作，在Collection集合接口中常用的就是List和Set接口，List和Set接口中常用的实现类集合<strong>ArrayList【允许存储重复数据并且使用数组实现】和HashSet【不允许存储重复数据并且使用Hash表实现】</strong></p><p>Map集合本身没是不在Collection范围内容，它是一个独立的集合，Map提供一种【键值对】即key-value的形式进行数据存储操作，在存储数据时要求key值必须是唯一的，value值可以不唯一，<strong>在Map集合接口中主要使用实现类是HashMap</strong></p><p><strong>PS：List集合使用ArrayList 、Set集合使用HashSet、Map集合使用HashMap</strong></p><h2 id="8、HashMap应用"><a href="#8、HashMap应用" class="headerlink" title="8、HashMap应用"></a><center>8、HashMap应用</center></h2><ul><li>可以使用Map 表示一个实体类</li><li>可以使用List&gt; 表示一个实体类集合</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapDemo02</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在java一个用户对象</span></span><br><span class="line"><span class="comment">     *      一个用户对象</span></span><br><span class="line"><span class="comment">     *      public class user</span></span><br><span class="line"><span class="comment">     *      &#123;</span></span><br><span class="line"><span class="comment">     *          private String username;</span></span><br><span class="line"><span class="comment">     *          private String password;</span></span><br><span class="line"><span class="comment">     *          private int age;</span></span><br><span class="line"><span class="comment">     *          private String phone;</span></span><br><span class="line"><span class="comment">     *          private String address;</span></span><br><span class="line"><span class="comment">     *          ......</span></span><br><span class="line"><span class="comment">     *      &#125;</span></span><br><span class="line"><span class="comment">     *      User user = new User(&quot;admin&quot;,&quot;123&quot;,30);</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *      多个用户对象</span></span><br><span class="line"><span class="comment">     *      以前：User[]</span></span><br><span class="line"><span class="comment">     *      现在：List&lt;User&gt;</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     * 在实战开发中，如果这个类使用不多，那么这个时候就没有必要创建一个User类</span></span><br><span class="line"><span class="comment">     * 可以使用Map来代替</span></span><br><span class="line"><span class="comment">     *      一个用户对象</span></span><br><span class="line"><span class="comment">     *       HashMap&lt;String,Object&gt; map = new HashMap&lt;&gt;();</span></span><br><span class="line"><span class="comment">     *       map.put(&quot;username&quot;,&quot;admin&quot;);</span></span><br><span class="line"><span class="comment">     *       map.put(&quot;password&quot;,&quot;123&quot;);</span></span><br><span class="line"><span class="comment">     *       map.put(&quot;age&quot;,20);</span></span><br><span class="line"><span class="comment">     *       多个用户对象</span></span><br><span class="line"><span class="comment">     *       List&lt;Map&lt;String,Object&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9、HashMap底层实现原理"><a href="#9、HashMap底层实现原理" class="headerlink" title="9、HashMap底层实现原理"></a><center>9、HashMap底层实现原理</center></h2><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402292004683.png" alt="实现原理" style="zoom: 50%;"><h2 id="10、put的过程原码"><a href="#10、put的过程原码" class="headerlink" title="10、put的过程原码"></a><center>10、put的过程原码</center></h2><p>put流程</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402292004096.png" alt="put流程" style="zoom:50%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,<span class="type">boolean</span> evict)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//tab表示存放Node节点的数据 p表示当前节点 n表示长度 i表示节点在数组中的下标</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">//判断数组如果为空或者数组长度为0，那么就对数组进行扩容，数组默认初始大小为16</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//将数组的长度-1与hash值进行与运算(计算的结果一定是0~数组长度-1)得到元素应该存放的下标</span></span><br><span class="line">    <span class="comment">//如果当前下标位置为空，那么直接将Node节点存放在当前位置</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//如果当前位置不为空(分为三种情况)</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//情况1：要添加的元素与当前位置上的元素相同(hash(hashCode)、key(equals)一致),则直接替换</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//情况2:如果要添加的元素是红黑树节点，那么将其添加到红黑树上</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">//情况3:如果要添加的元素是链表，则需要遍历</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//将当前元素的下一个节点赋给e</span></span><br><span class="line">                <span class="comment">//如果e为空，则创建新的元素节点放在当前位置的下一个元素上，并退出循环</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">//如果链表的元素个数大于8个(且当数组中的元素个数大于64)，则将其转换成红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)     <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//要添加的元素与当前位置上的元素相同(hash(hashCode)、key(equals)一致),则直接退出循环</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125; </span><br><span class="line">          <span class="comment">//如果返回的e不为null</span></span><br><span class="line">          <span class="keyword">if</span> (e != <span class="literal">null</span>)</span><br><span class="line">          &#123; </span><br><span class="line">              <span class="comment">// existing mapping for key</span></span><br><span class="line">              <span class="comment">//将e的值赋给oldValue</span></span><br><span class="line">              <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">              <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                  e.value = value;afterNodeAccess(e);</span><br><span class="line">                  <span class="comment">//返回以前的值(当添加的元素已经存在返回的是以前的值)</span></span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//如果数组的元素个数大于阈值则进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11、resize过程原码"><a href="#11、resize过程原码" class="headerlink" title="11、resize过程原码"></a><center>11、resize过程原码</center></h2><p>扩容流程</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402292005741.png" alt="扩容时机" style="zoom:50%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//oldTab 表示原来数组(如果是第二次扩容：长度为16的那个)</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">//oldCap 表示原数组的容量(长度)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">//oldThr 表示数组原来的阈值 12</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="comment">//newCap 新数组的容量 newThr 新数组的阈值</span></span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY)</span><br><span class="line">        &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;<span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//新数组的容量扩大一半 newCap 32</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">        <span class="comment">//新阈值扩大老阈值的一半 newThr 24</span></span><br><span class="line">        newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)     <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">    newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?(<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//threshold 24</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    <span class="comment">//创建一个长度为32的数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    <span class="comment">//table指向新数组</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将原数组中的元素拷贝到新数组中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">//如果当前位置元素不为空</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">//情况1：当前位置上的下一个元素为空，则直接将这个元素拷贝到新数组中</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">//情况2：当前位置上的元素红黑树类型，则需要进行切割</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">//情况3：当前位置上的元素链表类型，则需要进行分散拷贝</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                             loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12、get的过程原码"><a href="#12、get的过程原码" class="headerlink" title="12、get的过程原码"></a><center>12、get的过程原码</center></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e;</span><br><span class="line">    <span class="type">int</span> n;K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;(first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当前first与要找到的hash和key都相等直接返回当前这个first元素</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">            <span class="comment">//如果当前first不为空(有两种情况)</span></span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//当前位置是一个红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">//根据hash、key从红黑树上找到对应的元素z</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="comment">//当前位置是一个链表</span></span><br><span class="line">                <span class="keyword">do</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//循环进行比较直到找到向的hash和key的元素，并返回</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">     &#125; </span><br><span class="line">    <span class="comment">//如果数组的为空、数组的长度为0、当前下标位置上的值为null,这三种情况都返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点十八：常见的集合面试面试题"><a href="#知识点十八：常见的集合面试面试题" class="headerlink" title="知识点十八：常见的集合面试面试题"></a><center>知识点十八：常见的集合面试面试题</center></h1><ul><li>1、简述：ArrayList、LinkedList、Vector的区别</li><li>2、简述：HashSet、TreeSet的去重原理</li><li>3、ArrayList、LinkedList底层实现</li><li>4、HashMap、HashTable的区别</li><li>5、HashMap底层实现原理</li><li>6、HashMap扩容机制</li><li>7、HashMap的数组容量为什么是2的次方数</li><li>8、HashMap的负载因子为什么是0.75</li><li>9、HashMap添加元素的过程</li><li>10、谈谈了解的数据结构</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;知识点一：集合框架&quot;&gt;&lt;a href=&quot;#知识点一：集合框架&quot; class=&quot;headerlink&quot; title=&quot;知识点一：集合框架&quot;&gt;&lt;/a&gt;&lt;center&gt;知识点一：集合框架&lt;/center&gt;&lt;/h1&gt;&lt;h2 id=&quot;1、概念&quot;&gt;&lt;a href=&quot;#1、概念</summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>19.常用工具类</title>
    <link href="http://example.com/post/a920af81.html"/>
    <id>http://example.com/post/a920af81.html</id>
    <published>2023-12-30T05:07:47.000Z</published>
    <updated>2024-02-29T12:30:38.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识点一：String类"><a href="#知识点一：String类" class="headerlink" title="知识点一：String类"></a><center>知识点一：String类</center></h1><h3 id="1、String的创建"><a href="#1、String的创建" class="headerlink" title="1、String的创建"></a><center>1、String的创建</center></h3><h3 id="1）直接赋值"><a href="#1）直接赋值" class="headerlink" title="1）直接赋值"></a>1）直接赋值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">System.out.println(s1);</span><br></pre></td></tr></table></figure><h3 id="2）通过构造方法"><a href="#2）通过构造方法" class="headerlink" title="2）通过构造方法"></a>2）通过构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String s2 = new String();   //相当于String s2 = &quot;&quot;;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;123&quot;</span>);  <span class="comment">//相当于String s2 = &quot;123&quot;;</span></span><br><span class="line">System.out.println(s2);</span><br><span class="line"><span class="comment">//3.将一个byte类型数组作为数据参数传递到字符串中进行存储</span></span><br><span class="line"><span class="comment">//ps:将byte数组中数据转换成对应ASCII码---》如果ASCII码范围就会转换为Unicode【万国码】</span></span><br><span class="line"><span class="comment">//Unicode对应中国文字编码 ---》 UTF-8</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;str2 = &quot;</span>+str2);</span><br><span class="line"><span class="comment">//4.将一个char类型数组作为数据参数传递到字符串中进行存储</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;str3 = &quot;</span>+str3)</span><br></pre></td></tr></table></figure><h3 id="3）通过字节数组创建对象"><a href="#3）通过字节数组创建对象" class="headerlink" title="3）通过字节数组创建对象"></a>3）通过字节数组创建对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> b [] = &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b,<span class="number">0</span>,<span class="number">3</span>);  <span class="comment">//括号里的参数 第一个数组名 第二个从数组中的起始位置 第三个获取的长度</span></span><br><span class="line">System.out.println(s3);</span><br></pre></td></tr></table></figure><h3 id="4）通过字符数组创建对象"><a href="#4）通过字符数组创建对象" class="headerlink" title="4）通过字符数组创建对象"></a>4）通过字符数组创建对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c [] = &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b,<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">System.out.println(s4);</span><br></pre></td></tr></table></figure><h2 id="2、String类常用方法"><a href="#2、String类常用方法" class="headerlink" title="2、String类常用方法"></a><center>2、String类常用方法</center></h2><h3 id="1）获取方法"><a href="#1）获取方法" class="headerlink" title="1）获取方法"></a>1）获取方法</h3><h4 id="获取字符"><a href="#获取字符" class="headerlink" title="获取字符"></a>获取字符</h4><p>获取字符串中指定下标对应的字符，返回值为char类型<br>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名.charAt(下标);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">sh</span> <span class="operator">=</span> str.charAt(<span class="number">1</span>);</span><br><span class="line">System.out.println(sh);</span><br></pre></td></tr></table></figure><h4 id="获取下标"><a href="#获取下标" class="headerlink" title="获取下标"></a>获取下标</h4><p>获取字符串中指定字符串对应的下标，返回值为int类型</p><p>如果有相同的字符串，那么返回值是第一个字符串对应的下标</p><p>如果没有指定字符串，那么返回-1</p><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数组名.indexOf(<span class="string">&quot;要指定的字符串&quot;</span>);从前往后找指定的字符串</span><br><span class="line">数组名.lastIndexOf(<span class="string">&quot;要指定的字符串&quot;</span>);从后往前找指定的字符串</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取下标</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;asdfrgx&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> str1.indexOf(<span class="string">&quot;d&quot;</span>);</span><br><span class="line"><span class="comment">//如果没有指定字符则返回-1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> str1.indexOf(<span class="string">&quot;re&quot;</span>);</span><br><span class="line">System.out.println(a);</span><br><span class="line">System.out.println(b);</span><br><span class="line"><span class="comment">//如果有相同的，取出最后面一个下标</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;abc,Java,de,Java,ga&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> str2.lastIndexOf(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">System.out.println(c);</span><br><span class="line"><span class="comment">//提供一个重载方法，在指定下标位置开始向后查找 ，包含指定位置</span></span><br><span class="line"><span class="comment">//只会返回第一次遇到该字符的位置 ，如果找不到就负数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> str5.indexOf(<span class="string">&#x27;f&#x27;</span>, <span class="number">5</span>);</span><br><span class="line">System.out.println(f);</span><br></pre></td></tr></table></figure><h4 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h4><p>返回值为int类型</p><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名.length();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取字符串长度</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;admin&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> str3.length();</span><br><span class="line"><span class="comment">//System.out.println(str3.length());</span></span><br><span class="line">System.out.println(d);</span><br></pre></td></tr></table></figure><h3 id="2）判断的方法"><a href="#2）判断的方法" class="headerlink" title="2）判断的方法"></a>2）判断的方法</h3><p>返回值都是boolean类型</p><p>判断两个字符串是否相等（<strong>区分大小写</strong>）</p><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名<span class="number">1.</span>equals(数组名<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>判断两个字符串是否相等（<strong>不区分大小写</strong>）</p><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名<span class="number">1.</span>equalsIgnoreCase(数组名<span class="number">2</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断两个字符串是否相等</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;Abc&quot;</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">a</span> <span class="operator">=</span> str1.equals(str2);  <span class="comment">//区分大小写</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> str1.equalsIgnoreCase(str2); <span class="comment">//不区分大小写</span></span><br><span class="line"><span class="comment">//System.out.println(str1.equals(str2));</span></span><br><span class="line">System.out.println(a);</span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure><h4 id="比较字符串大小"><a href="#比较字符串大小" class="headerlink" title="比较字符串大小"></a>比较字符串大小</h4><p>逐一对比两个字符串中对应位置的字符，并进行差值计算得到结果就是一个整数</p><p>&ensp;&ensp;&ensp;&ensp;结果 &gt; 0 当前字符串就大于传入字符串</p><p>&ensp;&ensp;&ensp;&ensp;结果 &#x3D;&#x3D; 0 当前字符串就等于传入字符串</p><p>&ensp;&ensp;&ensp;&ensp;结果 &lt; 0 当前字符串就小于传入字符串</p><p>调用方法字符串是 当前字符串 参数赋值字符串是 传入字符</p><p>只要有任何一对字符比较结果出现 &gt;0 或 &lt;0 的时候就返回结果值，否则就继续比较所有字符，直到一个字符为止</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str1_1</span> <span class="operator">=</span> <span class="string">&quot;ABC&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> str1.compareTo(str1_1);</span><br><span class="line">System.out.println(i);    <span class="comment">//结果是32大于0 就证明str1 大于str1_1</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">String str2 = &quot;你&quot;;</span></span><br><span class="line"><span class="comment">String str2_1 = &quot;您&quot;;</span></span><br><span class="line"><span class="comment">int i1 = str2.compareTo(str2_1);</span></span><br><span class="line"><span class="comment">System.out.println(i1);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="判断字符串是否以指定的字符串开头或结尾"><a href="#判断字符串是否以指定的字符串开头或结尾" class="headerlink" title="判断字符串是否以指定的字符串开头或结尾"></a>判断字符串是否以指定的字符串开头或结尾</h4><p>开头</p><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名.startsWith(<span class="string">&quot;指定的字符串&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;18660416463&quot;</span>;</span><br><span class="line">System.out.println(str.startsWith(<span class="string">&quot;186&quot;</span>));</span><br></pre></td></tr></table></figure><p>结尾</p><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名.endsWith(<span class="string">&quot;指定的字符串&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;hello.java&quot;</span>;</span><br><span class="line">System.out.println(str3.endsWith(<span class="string">&quot;.java&quot;</span>));</span><br></pre></td></tr></table></figure><h4 id="判断字符串中是否包含指定的字符串"><a href="#判断字符串中是否包含指定的字符串" class="headerlink" title="判断字符串中是否包含指定的字符串"></a>判断字符串中是否包含指定的字符串</h4><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名.contains(<span class="string">&quot;指定的字符串&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断字符串中是否包含指定的字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;java,WC&quot;</span>;</span><br><span class="line">System.out.println(str4.contains(<span class="string">&quot;WC&quot;</span>));</span><br></pre></td></tr></table></figure><h4 id="判断字符串是否为空"><a href="#判断字符串是否为空" class="headerlink" title="判断字符串是否为空"></a>判断字符串是否为空</h4><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名.isEmpty();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断字符串是否为空，长度是否为零</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="string">&quot; &quot;</span>;  <span class="comment">//里面有空格，不为空</span></span><br><span class="line">System.out.println(str5.isEmpty());</span><br></pre></td></tr></table></figure><h3 id="3）拼接方法"><a href="#3）拼接方法" class="headerlink" title="3）拼接方法"></a>3）拼接方法</h3><h4 id="字符串拼接方法"><a href="#字符串拼接方法" class="headerlink" title="字符串拼接方法"></a>字符串拼接方法</h4><p>使用 + 进行拼接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;hello &quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3_1</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="comment">//得到一个全新的字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> str3 + str3_1;</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure><p>concat 方法参数是要字符串,返回一个全新字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为方法返回的是一个全新字符串对象，所以可以继续的进行调用拼接</span></span><br><span class="line"><span class="type">String</span> <span class="variable">concat</span> <span class="operator">=</span> str3.concat(str3_1).concat(<span class="string">&quot;Java is &quot;</span>).concat(<span class="string">&quot;NO.1&quot;</span>);</span><br><span class="line">System.out.println(concat);</span><br></pre></td></tr></table></figure><h4 id="自定义拼接字符串"><a href="#自定义拼接字符串" class="headerlink" title="自定义拼接字符串"></a>自定义拼接字符串</h4><p>自定义拼接字符串方式【格式化字符串】 —》 静态方法</p><p>String.format</p><p>第一个参数是格式控制符 –》 %d 代表整数 %f 代表小数 %s代表字符串 %c代表字符</p><p>第二个参数是与格式化控制符与之对应的数据【一一对应】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> String.format(<span class="string">&quot;%f%s%c&quot;</span>, <span class="number">12.345</span>, <span class="string">&quot;字符串&quot;</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">System.out.println(format);</span><br><span class="line"><span class="comment">//Java中如何让小数保留小数点后几位 --》 使用使用%f 进行 %.几f ---》.几就是保留几位</span></span><br><span class="line"><span class="comment">//保留小数点后两位【支持四舍五入】</span></span><br><span class="line"><span class="type">String</span> <span class="variable">format1</span> <span class="operator">=</span> String.format(<span class="string">&quot;%.2f&quot;</span>, <span class="number">12.345</span>);</span><br><span class="line">System.out.println(format1);</span><br><span class="line"><span class="comment">//打印整数时候进行补位操作 ---》使用%d 进行 %0几d --》 不足几位就补几个0</span></span><br><span class="line"><span class="comment">//不足2位补0</span></span><br><span class="line"><span class="type">String</span> <span class="variable">format2</span> <span class="operator">=</span> String.format(<span class="string">&quot;%02d&quot;</span>, <span class="number">1</span>);</span><br><span class="line">System.out.println(format2);</span><br></pre></td></tr></table></figure><h3 id="4）其他方法"><a href="#4）其他方法" class="headerlink" title="4）其他方法"></a>4）其他方法</h3><h4 id="将字符串变成字节数组"><a href="#将字符串变成字节数组" class="headerlink" title="将字符串变成字节数组"></a>将字符串变成字节数组</h4><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名.getBytes();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将字符串变成字节数组</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">byte</span> a [] = str.getBytes();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="将字符串变成字符数组"><a href="#将字符串变成字符数组" class="headerlink" title="将字符串变成字符数组"></a>将字符串变成字符数组</h4><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名.toCharArray();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> ch [] = str1.toCharArray();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ch.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(ch[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="取出指定的字符串"><a href="#取出指定的字符串" class="headerlink" title="取出指定的字符串"></a>取出指定的字符串</h4><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名.substring(起始下标,结束下标);</span><br></pre></td></tr></table></figure><p>注意：String是一个字符串常量，一旦定义不能改变，一定要重新赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取出指定的字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;hello,java!!!&quot;</span>;</span><br><span class="line"><span class="comment">//参数1：起始下标 参数2：结束下标</span></span><br><span class="line">str2 = str2.substring(<span class="number">6</span>,<span class="number">10</span>);  <span class="comment">//在Java中区范围都是 左边闭区间，右边开区间</span></span><br><span class="line">System.out.println(str2);</span><br></pre></td></tr></table></figure><h4 id="将字符串中指定的部分字符串改成指定的字符串"><a href="#将字符串中指定的部分字符串改成指定的字符串" class="headerlink" title="将字符串中指定的部分字符串改成指定的字符串"></a>将字符串中指定的部分字符串改成指定的字符串</h4><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名.replace(<span class="string">&quot;原数组中指定的要更改的字符串&quot;</span>,<span class="string">&quot;新的字符串&quot;</span>);</span><br></pre></td></tr></table></figure><p>注意：String是一个字符串常量，一旦定义不能改变，一定要重新赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将指定的字符串改成指定的字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;hello,SB&quot;</span>;</span><br><span class="line">str3 = str3.replace(<span class="string">&quot;SB&quot;</span>,<span class="string">&quot;**&quot;</span>);</span><br><span class="line">System.out.println(str3);</span><br></pre></td></tr></table></figure><h4 id="按指定格式将字符串切割"><a href="#按指定格式将字符串切割" class="headerlink" title="按指定格式将字符串切割"></a>按指定格式将字符串切割</h4><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名.split(<span class="string">&quot;切割的格式&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;jack lin lida hdnpi&quot;</span>;</span><br><span class="line">String s [] = str4.split(<span class="string">&quot; &quot;</span>); <span class="comment">//按空格进行切割，切割完是一个字符串数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(s[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="将字符串中的字母变成大写"><a href="#将字符串中的字母变成大写" class="headerlink" title="将字符串中的字母变成大写"></a>将字符串中的字母变成大写</h4><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名.toUpperCase();</span><br></pre></td></tr></table></figure><p>返回值为String类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str6</span> <span class="operator">=</span> <span class="string">&quot;ABC好&quot;</span>;</span><br><span class="line">System.out.println(str6.toLowerCase());</span><br></pre></td></tr></table></figure><h4 id="去除字符串中前后的空格"><a href="#去除字符串中前后的空格" class="headerlink" title="去除字符串中前后的空格"></a>去除字符串中前后的空格</h4><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名.trim();</span><br></pre></td></tr></table></figure><p>注意：String是一个字符串常量，一旦定义不能改变，一定要重新赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str7</span> <span class="operator">=</span> <span class="string">&quot;hello java&quot;</span>;</span><br><span class="line">str7 = str7.trim();    <span class="comment">//str7指向了新的地址</span></span><br><span class="line">System.out.println(str7);</span><br></pre></td></tr></table></figure><h4 id="将其他类型数据转换成String类型数据"><a href="#将其他类型数据转换成String类型数据" class="headerlink" title="将其他类型数据转换成String类型数据"></a>将其他类型数据转换成String类型数据</h4><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String.valueOf(变量名);</span><br></pre></td></tr></table></figure><p>返回值为String类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str8</span> <span class="operator">=</span> String.valueOf(d);</span><br><span class="line">System.out.println(str8);</span><br></pre></td></tr></table></figure><p>方式二</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str9</span> <span class="operator">=</span> c + <span class="string">&quot;&quot;</span>;    <span class="comment">//自动转化成String类型</span></span><br><span class="line">System.out.println(str9);</span><br></pre></td></tr></table></figure><h2 id="3、正则表达式"><a href="#3、正则表达式" class="headerlink" title="3、正则表达式"></a><center>3、正则表达式</center></h2><p>&ensp;&ensp;&ensp;&ensp;正则表达式是一个特殊字符串，可以根据正则表达式的语法规则构建一个字符串，利用这个字符串就可以验证其他字符串是否合法</p><p>&ensp;&ensp;&ensp;&ensp;正则表达式其实就是提供字符串中内容约束，通过正则表达式就可以验证输入字符串是否满足指定需求。</p><p>例如： 注册页面—》用户名验证、密码验证、邮箱验证、手机号码验证等等</p><p>需求：在控制台上输入一个QQ 号码需要对QQ号码进行如下验证</p><p>&ensp;&ensp;&ensp;&ensp;QQ号码必须满足5~15之间、而且必须全部是数字、首位数字不可以是0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QQMatches</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        需求:在控制台上输入一个QQ 号码需要对QQ号码进行如下验证</span></span><br><span class="line"><span class="comment">            QQ号码必须满足5~15之间、而且必须全部是数字、首位数字不可以是0</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//1.在控制台上获取字符串</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//2.提供获取控制台数据操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入QQ号码：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">qq</span> <span class="operator">=</span> input.nextLine();</span><br><span class="line">        System.out.println(<span class="string">&quot;您输入的QQ是否合法?（true【合法】/false【不合法】）&quot;</span>+checkQQ(qq));</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkQQ</span><span class="params">(String qq)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.需要QQ号是5~15位之间【只要不在5~15之间就是不合法的】</span></span><br><span class="line">        <span class="keyword">if</span>(qq.length() &lt; <span class="number">5</span> || qq.length() &gt; <span class="number">15</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//2.需要QQ号码是全数字【只要输入有不是数字的就不合法】</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span> ; i&lt;qq.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(qq.charAt(i) &lt; <span class="string">&#x27;0&#x27;</span> || qq.charAt(i) &gt; <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//3.首位不可以是数字0</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> qq.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//证明通过验证</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在验证QQ号码时需要提供复杂的逻辑判断，但是如果使用正则表达式就可以简化这个操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkQQ2</span><span class="params">(String qq)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1。根据需求提供验证输入QQ号码的正则表达式</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;[1-9]\\d&#123;4,14&#125;&quot;</span>;<span class="comment">// --》正则表达式</span></span><br><span class="line">    <span class="keyword">return</span> qq.matches(regex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;&ensp;&ensp;正则表达式就是一个以特殊符号组合而成一个字符串，用这个字符串可以验证其他字符串是否合法【满足规则】即正则表达式其实就是一个匹配规则，用来替代验证字符串复杂的if结构判断</p><p><strong>&ensp;&ensp;&ensp;&ensp;在String类中提供一个方法matches，这个方法是用于接收一个正则表达式的字符串，验证调用方法的字符串是否满足正则表达式的条件，如果满足条件则返回true，否则返回false</strong></p><h3 id="正则表达式的基本使用"><a href="#正则表达式的基本使用" class="headerlink" title="正则表达式的基本使用"></a>正则表达式的基本使用</h3><p>&ensp;&ensp;&ensp;&ensp;提供一个语法规则： 使用[]中括号 匹配单个字符 –》在中括号中可以使用 【^ 取反 和 - 范围】就可以组合成如下效果：</p><p>&ensp;&ensp;&ensp;&ensp;<strong>1. [abc]代表a、或者b、或者c字符中任何一个</strong></p><p><strong>&ensp;&ensp;&ensp;&ensp;2. [ ^abc] 代表除a、b、c以为任意字符</strong></p><p><strong>&ensp;&ensp;&ensp;&ensp;3. [a-z] 代表a-z之间所有的小写字符中任意一个</strong></p><p>&ensp;&ensp;&ensp;&ensp;<strong>4. [A-Z] 代表A-Z之间所有的大写字符中任意一个</strong></p><p><strong>&ensp;&ensp;&ensp;&ensp;5.[0-9] 代表0-9之间所有数字中任意一个</strong></p><p>&ensp;&ensp;&ensp;&ensp;<strong>6.[a-zA-Z0-9] 代表a<del>z之间、A</del>Z之间、0-9之间任意一个字符</strong></p><p>&ensp;&ensp;&ensp;&ensp;<strong>自定义范围[a-dm-p]代表 a<del>d之间 m</del>p之间的任意一个字符</strong></p><p>案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexDemo1</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="comment">//不可以这样验证，这样是错误</span></span><br><span class="line">        System.out.println(str.matches(<span class="string">&quot;[abc]&quot;</span>));<span class="comment">//false判断某一个不是所有</span></span><br><span class="line">        <span class="comment">//这样操作是对的</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        System.out.println(str1.matches(<span class="string">&quot;[abc]&quot;</span>));<span class="comment">//true判断的是某一个字符</span></span><br><span class="line">        <span class="comment">//1.验证某个字符串是否以h开头，以d结尾。中间是[a、e、i、o、u]中的某个字符</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ead&quot;</span>.matches(<span class="string">&quot;h[aeiou]d&quot;</span>));<span class="comment">//false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;hed&quot;</span>.matches(<span class="string">&quot;h[aeiou]d&quot;</span>));<span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;head&quot;</span>.matches(<span class="string">&quot;h[aeiou]d&quot;</span>));<span class="comment">//false</span></span><br><span class="line">        <span class="comment">//2.验证某个字符串是否以a-z的任何一个小写字母开头，后缀ad</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Aad&quot;</span>.matches(<span class="string">&quot;[a-z]ad&quot;</span>)); <span class="comment">//false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;aad&quot;</span>.matches(<span class="string">&quot;[a-z]ad&quot;</span>));<span class="comment">// true</span></span><br><span class="line">        <span class="comment">//3.验证某个字符串是否以a-d或者m-p之间某个字符靠头，后缀ad</span></span><br><span class="line">        System.out.println(<span class="string">&quot;nad&quot;</span>.matches(<span class="string">&quot;[a-dm-p]ad&quot;</span>)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Mad&quot;</span>.matches(<span class="string">&quot;[a-dm-p]ad&quot;</span>));<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="正则表达式之逻辑运算符"><a href="#正则表达式之逻辑运算符" class="headerlink" title="正则表达式之逻辑运算符"></a>正则表达式之逻辑运算符</h3><p>可以在上面语法中增加逻辑运算符 ，正则表达式中逻辑运算符有【&amp;&amp;并且 、 | 或者】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexDemo2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//需求：判断某个字符串是小写辅音字母开头，后跟ab，剩余字母除aeiou之外，其他辅音字母</span></span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>.matches(<span class="string">&quot;[aeiou]ab[^aeiou]&quot;</span>));</span><br><span class="line">        <span class="comment">//需求：开头字母必须是a-z之间小写字母并且不在aeiou中</span></span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>.matches(<span class="string">&quot;[a-z&amp;&amp;[^aeiou]]&quot;</span>));</span><br><span class="line">        <span class="comment">//[]这个语法是存在或者含义 ---》[abc] --》得到结果是a或b或c中一个</span></span><br><span class="line">        <span class="comment">//需求：要求字符串首字母必须是aeiou中任意一个，后面ad</span></span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>.matches(<span class="string">&quot;[aeiou]ad&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>.matches(<span class="string">&quot;[a|e|i|o|u]ad&quot;</span>)); <span class="comment">//能表明含义</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="正在表达式之预定义字符【需要记住】"><a href="#正在表达式之预定义字符【需要记住】" class="headerlink" title="正在表达式之预定义字符【需要记住】"></a>正在表达式之预定义字符【需要记住】</h3><table><thead><tr><th align="center">“\d” 任何数字[0-9]的简写</th><th align="center">\s 任意空白字符[\t\n\x)B\f\r]简写</th></tr></thead><tbody><tr><td align="center">“\w单词字符[a-zA-Z0-9]简写”</td><td align="center">“\D” 任何非数字[ ^0-9]的简写</td></tr><tr><td align="center">\S 非空白字符 [ ^\s]简写</td><td align="center">“\W 非单词字符[\w]简写”</td></tr></tbody></table><p>特殊说明</p><ol><li>Java中单个 【\】代表的是转移字符 即 本身字母d是没有任何含义 配合使用 【\】就代表数字了，我们不能直接在字符串中使用 \d的形式 需要将\体现出来让 \d成为一个整体 而不是使用 \ 去转义d —》就需要使用到【\】 –》 即需使用【\d】</li><li>“.” 点在正则表达式中代表任意字符，如果必要表示一个字符点，那么需要使用【\.】</li></ol><p>案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexDemo3</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;判断9是否是数字：&quot;</span>+(<span class="string">&quot;9&quot;</span>.matches(<span class="string">&quot;[0-9]&quot;</span>)));</span><br><span class="line">        System.out.println(<span class="string">&quot;判断9是否是数字：&quot;</span>+(<span class="string">&quot;9&quot;</span>.matches(<span class="string">&quot;\\d&quot;</span>)));</span><br><span class="line">        System.out.println(<span class="string">&quot;判断258是否是数字：&quot;</span>+(<span class="string">&quot;258&quot;</span>.matches(<span class="string">&quot;[0-9][0-9][0-9]&quot;</span>)));</span><br><span class="line">        System.out.println(<span class="string">&quot;判断258是否是数字：&quot;</span>+(<span class="string">&quot;258&quot;</span>.matches(<span class="string">&quot;\\d\\d\\d&quot;</span>)));</span><br><span class="line">        System.out.println(<span class="string">&quot;判断字符串是否满足内容需求【h.d】&quot;</span>+ (<span class="string">&quot;h.d&quot;</span>.matches(<span class="string">&quot;h\\.d&quot;</span>)));</span><br><span class="line">        System.out.println(<span class="string">&quot;判断字符串是以h开头中间任意字符并且以d结尾&quot;</span>+ (<span class="string">&quot;h%d&quot;</span>.matches(<span class="string">&quot;h.d&quot;</span>)));</span><br><span class="line">        <span class="comment">//需求：--》 验证输入手机号是合法</span></span><br><span class="line">        <span class="comment">//手机号一般是由11位组成 ---》可以提供一个简单版本正则表达式---》提供 11个\\d</span></span><br><span class="line">        <span class="comment">//手机号第一位是1组成，第二位是由一定范围变换，除此之外剩余就是简单数字</span></span><br><span class="line">        System.out.println(<span class="string">&quot;13888888888&quot;</span>.matches(<span class="string">&quot;1[3|4|5|6|7|8|9]\\d\\d\\d\\d\\d\\d\\d\\d\\d&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="正则表达式之数量词"><a href="#正则表达式之数量词" class="headerlink" title="正则表达式之数量词"></a>正则表达式之数量词</h3><p>&ensp;&ensp;&ensp;&ensp;正则表达式中的数量词其实就是指定正则表达式出现的次数 –》X【代表单个正则表达式的条件</p><p>或者 可以代表组】</p><p>&ensp;&ensp;&ensp;&ensp;<strong>X?：0次或1次 —》 \d? –》代表当前数字可以出现0次或1次</strong></p><p><strong>&ensp;&ensp;&ensp;&ensp;X*：0次或多次 –》 \d* –》 代表当前数字可以出现0次或多次</strong></p><p><strong>&ensp;&ensp;&ensp;&ensp;X+：1次或多次 –》\d+ –》 代表当前数字可以出现1次或多次</strong></p><p>&ensp;&ensp;&ensp;&ensp;<strong>X{n}：正好n次–》\d{9} –》 代表当前数字可以出现9次</strong></p><p><strong>&ensp;&ensp;&ensp;&ensp;X{n,}：至少n次(包含n) –》 \d{9,} –》 代表当前数字至少出现9次或多次</strong></p><p>&ensp;&ensp;&ensp;&ensp;<strong>X{n，m}：至少n次<del>m次(n和m都是包含) –》 \d{4,14} –》代表当前数字出现4</del>14次</strong></p><p>案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexDemo4</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;258&quot;</span>;</span><br><span class="line">        <span class="comment">//验证str是否满足3位数字</span></span><br><span class="line">        System.out.println(str.matches(<span class="string">&quot;[0-9]&#123;3&#125;&quot;</span>));</span><br><span class="line">        System.out.println(str.matches(<span class="string">&quot;\\d&#123;3&#125;&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;a58&quot;</span>.matches(<span class="string">&quot;\\d&#123;3&#125;&quot;</span>));<span class="comment">//false</span></span><br><span class="line">        System.out.println(str.matches(<span class="string">&quot;\\d+&quot;</span>)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(str.matches(<span class="string">&quot;\\d?&quot;</span>)); <span class="comment">//false</span></span><br><span class="line">        System.out.println(str.matches(<span class="string">&quot;\\d*&quot;</span>)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(str.matches(<span class="string">&quot;\\d&#123;3,&#125;&quot;</span>));<span class="comment">//true</span></span><br><span class="line">        System.out.println(str.matches(<span class="string">&quot;\\d&#123;3,13&#125;&quot;</span>));<span class="comment">//true</span></span><br><span class="line">        <span class="comment">//需求：--》 验证输入手机号是合法</span></span><br><span class="line">        <span class="comment">//手机号一般是由11位组成 ---》可以提供一个简单版本正则表达式---》提供 11个\\d</span></span><br><span class="line">        <span class="comment">//手机号第一位是1组成，第二位是由一定范围变换，除此之外剩余就是简单数字</span></span><br><span class="line">        System.out.println(<span class="string">&quot;13888888888&quot;</span>.matches(<span class="string">&quot;1[3|4|5|6|7|8|9]\\d\\d\\d\\d\\d\\d\\d\\d\\d&quot;</span>));</span><br><span class="line">        <span class="comment">//修改</span></span><br><span class="line">        System.out.println(<span class="string">&quot;13888888888&quot;</span>.matches(<span class="string">&quot;1[3|4|5|6|7|8|9]\\d&#123;9&#125;&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="正则表达式值组"><a href="#正则表达式值组" class="headerlink" title="正则表达式值组"></a>正则表达式值组</h3><p><strong>组的出现可以将条件统一化，将多个条件捆绑到一起 —》 小括号()</strong></p><p>需求：提供一个字符串写出对应的正则表达式 –》“d0a3911a-a8e9-4e5e-b9e7-c2c53324d50d”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexDemo5</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        <span class="comment">//String str = &quot;d0a3911a-a8e9-4e5e-b9e7-c2c53324d50d&quot;;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;[a-z0-9]&#123;8&#125;-[a-z0-9]&#123;4&#125;-[a-z0-9]&#123;4&#125;-[a-z0-9]&#123;4&#125;-[a-z0-9]&#123;12&#125;&quot;</span>;</span><br><span class="line">        <span class="comment">//可以将上述正则表达式进行组的划分</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">regex2</span> <span class="operator">=</span> <span class="string">&quot;([a-z0-9]&#123;8&#125;)(-[a-z0-9]&#123;4&#125;)&#123;3&#125;(-[a-z0-9]&#123;12&#125;)&quot;</span>;</span><br><span class="line">        System.out.println(str.matches(regex2));</span><br><span class="line">        <span class="comment">//呵呵嘿嘿哈哈--》提供正则表达式与之匹配 ---》 点【.】可以匹配任意字符</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;呵呵嘿嘿哈哈&quot;</span>;</span><br><span class="line">        System.out.println(str2.matches(<span class="string">&quot;(.)&#123;2&#125;(.)&#123;2&#125;(.)&#123;2&#125;&quot;</span>));</span><br><span class="line">        System.out.println(str2.matches(<span class="string">&quot;((.)&#123;2&#125;)&#123;3&#125;&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;呵呵&quot;</span>;</span><br><span class="line">        System.out.println(str3.matches(<span class="string">&quot;(.)&#123;2&#125;&quot;</span>));</span><br><span class="line">        <span class="comment">//(.)代表第一组【一组条件】 \\1表示第一组在出现一次(.)\\1--》(.)(.)</span></span><br><span class="line">        System.out.println(str3.matches(<span class="string">&quot;(.)\\1&quot;</span>));</span><br><span class="line">        <span class="comment">//如何修改(.)\\2第二组的(.)在出现一次 (.)\\3第三组的(.)在出现一次</span></span><br><span class="line">        System.out.println(str2.matches(<span class="string">&quot;(.)\\1(.)\\2(.)\\3&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;高兴高兴&quot;</span>.matches(<span class="string">&quot;(..)\\1&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271928546.jpg" alt="转义符"></p><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271929293.jpg" alt="数量表示"></p><p>String类中匹配正则表达式作为参数方法一共有三个【常用】</p><p>&ensp;&ensp;&ensp;&ensp;matches()方法：根据方法的参数进行对字符串匹配操作，满足条件范围true，不满足返回false</p><p>&ensp;&ensp;&ensp;&ensp;split()方法:【拆分、切分、分割】字符串，根据参数中指定条件进行字符串拆分操作</p><p>&ensp;&ensp;&ensp;&ensp;replaceAll()方法: 根据方法中第一个参数的正则表达式条件，替换字符串中指定内容【替换的内容是第二个参数】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexDemo6</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//验证字符串是否合法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">phoneNumber</span> <span class="operator">=</span> <span class="string">&quot;13112345678&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;1[3|4|5|6|7|8|9]\\d&#123;9&#125;&quot;</span>;</span><br><span class="line">        System.out.println(phoneNumber.matches(regex));</span><br><span class="line">        <span class="comment">//根据条件进行字符串拆分，将拆分结果存储到一个String类型数组中并返回</span></span><br><span class="line">        <span class="comment">//这个方法比较常用，但是拆分不一定非要是正则表达式，只要满足拆条情况都是可以</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">time</span> <span class="operator">=</span> <span class="string">&quot;20:39:49&quot;</span>;</span><br><span class="line">        <span class="comment">//获取时间中 小时、分钟和秒</span></span><br><span class="line">        String[] split = time.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String t : split)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(t);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//这个方法主要是用于批量字符串替换，它是需要第一个参数提供正则条件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;43eh5hj34l4h23jh4233h42oru3ohfh3rihf3hf3hgf4568632485rewh34&quot;</span>;</span><br><span class="line">        <span class="comment">//需求：将字符串中所有的数字都替换成*</span></span><br><span class="line">        <span class="type">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i= <span class="number">0</span>; i&lt;chars.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Character.isDigit(chars[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                chars[i] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">        System.out.println(str2);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> str.replaceAll(<span class="string">&quot;\\d+&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、String的内存分配"><a href="#4、String的内存分配" class="headerlink" title="4、String的内存分配"></a><center>4、String的内存分配</center></h2><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271929031.jpg" alt="String的内存分配"></p><p>PS：字符串是引用类型，所以比较时候依旧使用equals进行比较内容，不要因为有池机制在就是用 &#x3D;&#x3D; 进行比较，受众面比较小</p><h2 id="5、StringBuffer、StringBuilder类"><a href="#5、StringBuffer、StringBuilder类" class="headerlink" title="5、StringBuffer、StringBuilder类"></a><center>5、StringBuffer、StringBuilder类</center></h2><p>&ensp;&ensp;&ensp;&ensp;String这个字符串是一个不可变字符串，不可以修改String中存储的内容，所以当我们调用大部分String方法的时候都会得到一个新String字符串</p><p>&ensp;&ensp;&ensp;&ensp;Java中提供两个可变的字符串StringBuffer和StringBuilder，这两字符串创建之后，任何的修改都会对字符串内容提供修改操作即直接修改字符串内容</p><p>&ensp;&ensp;&ensp;&ensp;PS：StringBuffer和StringBuilder本质上并不是字符串，它属于一个字符串“构建器”，允许将String中内容存储到这个“构建器”，进行修改从而得到修改之后的效果</p><p>&ensp;&ensp;&ensp;&ensp;StringBuffer和StringBuilder都可以提供对字符串操作，并且两个类API是完全相同的，</p><p>&ensp;&ensp;&ensp;&ensp;StringBuffer是线程安全【在多线程操作前提下可以保证字符串操作的正确性】但是效率低，</p><p>&ensp;&ensp;&ensp;&ensp;StringBuilder是线程不安全【在多线程操作前提下不可以保证字符串操作正确】但是效率高，大多数的情况下都是使用【单线程】在进行编程，所以建议优先使用StringBuilder，如果遇到多线程操作字符串时在修改为StringBuffer使用即可</p><p>StringBuffer的对象创建及常用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBuilderAPIDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.StringBuffer和StringBuilder本身并不是字符串，所以不可以使用String直接赋值方式进行创建</span></span><br><span class="line">        <span class="comment">//StringBuilder bs = &quot;abc&quot;;</span></span><br><span class="line">        <span class="comment">//2.需要使用StringBuilder的构造方法来创建StringBuilder对象进行字符串操作者处理</span></span><br><span class="line">        <span class="comment">//2.1 创建一个空的StringBuilder对象【没有存储任何字符串内容】</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            通过观察可以发现在调用StringBuilder无参构造创建StringBuilder对象是 会调用父类有参</span></span><br><span class="line"><span class="comment">            构造方法</span></span><br><span class="line"><span class="comment">            执行 value = new char[capacity];构建一个字符数组作为存储数据的依据</span></span><br><span class="line"><span class="comment">            capacity的值是 --》默认值为 16</span></span><br><span class="line"><span class="comment">            ---》在创建空的StringBuilder对象时，创建一个初始容量为16的字符数组进行数据存储操作</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">bs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            面试问题：在创建StringBuilder对象是默认会初始化一个大小为16的字节数组作为存储数据的方式</span></span><br><span class="line"><span class="comment">            那么如果存储数据超过16时，是否可以正常的存储数据值，还是截取多余数据值仅保留16个字符？</span></span><br><span class="line"><span class="comment">            答案：StringBuilder是可以正常存储数据的，为什么可以存储？</span></span><br><span class="line"><span class="comment">            就是因为StringBuilder的底层存储过程中会对value这个数组进行“动态扩容操作”，</span></span><br><span class="line"><span class="comment">            当到某个临街值的时候</span></span><br><span class="line"><span class="comment">            执行Arrays.copyOf这个方法将原来value中数据赋值到新创建的数组中，并且将新数据引用赋值给value</span></span><br><span class="line"><span class="comment">            这样一来给外界开发人员造成的感觉就是我们使用在操作同一个字符串</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        bs.append(<span class="string">&quot;12345678901234567890&quot;</span>);</span><br><span class="line">        System.out.println(bs);</span><br><span class="line">        <span class="comment">//2.2创建StringBuilder对象同时向StringBuilder中存String字符串</span></span><br><span class="line">        <span class="comment">//StringBuilder如果使用字符串进行初始化创建，会使用参数字符串的长度+16这个默认值作为初始容量value字符数组的大小</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">bs2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="comment">//2.3PS：这个构建方式是以前开发时常用的一种方式</span></span><br><span class="line">        <span class="comment">//自定义初始化数组容量【要创建一个空的StringBuilder对象必然使用这个方法】</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">bs3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">80</span>);</span><br><span class="line">        <span class="comment">//常用API</span></span><br><span class="line">        <span class="comment">//1.最常用的方法 append 追加---》向StringBuilder中追加存储内容</span></span><br><span class="line">        <span class="comment">// 没出使用append方法时都是向原有字符串末尾添加数据 --》这个方法十分强大基本上减容各种数据类型进行存储</span></span><br><span class="line">        bs2.append(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        bs2.append(<span class="string">&#x27;e&#x27;</span>);</span><br><span class="line">        <span class="comment">//append这个方法的特殊点在于，这个方法的中内部使用使用this关键字作为方法参数传递</span></span><br><span class="line">        <span class="comment">//因为这个方法返回的是调用方法的对象，所以可以使用多次[.]点的方式连续追加</span></span><br><span class="line">        <span class="comment">//Java管这种编程方式叫做“链式编程”--》他是StreamAPI【简称流式编程前身】</span></span><br><span class="line">        bs2.append(<span class="string">&quot;f&quot;</span>).append(<span class="string">&#x27;g&#x27;</span>);</span><br><span class="line">        System.out.println(bs2);</span><br><span class="line">        <span class="comment">//2.获取字符串长度</span></span><br><span class="line">        System.out.println(bs2.length());</span><br><span class="line">        <span class="comment">//3.删除字符串中指定位置字符串 ---&gt; 根据两个参数决定删除范围【下标】</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            第一个参数 是从什么位置开始删除（包含）</span></span><br><span class="line"><span class="comment">            第二个参数 到什么位置结束（不包含）</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        bs2.delete(<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">        System.out.println(bs2);</span><br><span class="line">        <span class="comment">//4.删除指定位置的字符【下标】</span></span><br><span class="line">        bs2.deleteCharAt(<span class="number">0</span>);</span><br><span class="line">        System.out.println(bs2);</span><br><span class="line">        <span class="comment">//5.在指定位置插入字符串【不能超出下标范围】，插入内容不受长度限制</span></span><br><span class="line">        bs2.insert(<span class="number">1</span>,<span class="string">&quot;漫威&quot;</span>);</span><br><span class="line">        System.out.println(bs2);</span><br><span class="line">        <span class="comment">//6.替换指定位置的字符串</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            第一个参数 从什么位置开始替换（包括）</span></span><br><span class="line"><span class="comment">            第二个参数 到什么位置结束（不包括）</span></span><br><span class="line"><span class="comment">            第三个参数 替换的字符串</span></span><br><span class="line"><span class="comment">            PS：替换的字符串长度不受替换位置大小限制的</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        bs2.replace(<span class="number">1</span>,<span class="number">3</span>,<span class="string">&quot;复仇者联盟5&quot;</span>);</span><br><span class="line">        System.out.println(bs2);</span><br><span class="line">        <span class="comment">//7.反转字符串</span></span><br><span class="line">        bs2.reverse();</span><br><span class="line">        System.out.println(bs2);</span><br><span class="line">        <span class="comment">//8.修改执行位置的字符</span></span><br><span class="line">        bs2.setCharAt(bs2.length()-<span class="number">1</span>,<span class="string">&#x27;♂&#x27;</span>);</span><br><span class="line">        System.out.println(bs2);</span><br><span class="line">        <span class="comment">//9.StringBuilder和String之间互相转换</span></span><br><span class="line">        <span class="comment">//将StringBuilder变成String</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> bs2.toString();</span><br><span class="line">        <span class="type">String</span> <span class="variable">string2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bs2);</span><br><span class="line">        <span class="comment">//将String变成StringBuilder</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">bs4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;ancd&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StringBuffer操作与上面同理，只需要将Builder变换为Buffer就可以了</p><h2 id="6、String、StringBuffer、StringBuilder区别"><a href="#6、String、StringBuffer、StringBuilder区别" class="headerlink" title="6、String、StringBuffer、StringBuilder区别"></a><center>6、String、StringBuffer、StringBuilder区别</center></h2><p>这三个类都可以用于表示字符串</p><p>&ensp;&ensp;&ensp;&ensp;1）String类是字符串常量类，一旦定义不能改变</p><p>&ensp;&ensp;&ensp;&ensp;2）StringBuffer、StringBuilder是可变的字符串,自带有缓冲区。默认缓冲区大小16个字符</p><p>&ensp;&ensp;&ensp;&ensp;3）StringBuffer是线程安全的，所以效率低 StringBuilder是线程不安全的，所以效率高</p><p>总结：实际开发中更常用的是String类型，但在大量的字符串拼接的时候，使用 StringBuffer、StringBuilder。而不考虑线程安全的时候，选择StringBuilder，否则选择StringBuffer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//需求：做100000次字符串拼接//获取当前系统时间的毫秒数 4918</span></span><br><span class="line">        <span class="comment">//记录一个开始时间</span></span><br><span class="line">        <span class="comment">//long start = System.currentTimeMillis();</span></span><br><span class="line">        <span class="comment">//String str = &quot;&quot;;</span></span><br><span class="line">        <span class="comment">//for (int i = 0; i &lt; 100000; i++)</span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">        <span class="comment">//    str = str + &quot;a&quot;;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//记录一个结束时间</span></span><br><span class="line">        <span class="comment">//long end = System.currentTimeMillis();</span></span><br><span class="line">        <span class="comment">//System.out.println(&quot;耗时&quot;+(end -start));</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//long start = System.currentTimeMillis();</span></span><br><span class="line">        <span class="comment">//StringBuffer sb = new StringBuffer();</span></span><br><span class="line">        <span class="comment">//for (int i = 0; i &lt; 10000000; i++)</span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">        <span class="comment">//    sb.append(&quot;a&quot;);</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//long end = System.currentTimeMillis();</span></span><br><span class="line">        <span class="comment">// System.out.println(&quot;耗时&quot;+(end -start));   //239</span></span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时&quot;</span>+(end -start));    <span class="comment">//90</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、String和StringBuilder作为方法参数问题"><a href="#7、String和StringBuilder作为方法参数问题" class="headerlink" title="7、String和StringBuilder作为方法参数问题"></a><center>7、String和StringBuilder作为方法参数问题</center></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringMethodDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;没有修改str字符串之前的内容是：&quot;</span>+str);</span><br><span class="line">        changeString(str);</span><br><span class="line">        System.out.println(<span class="string">&quot;修改之后str字符串中内容是：&quot;</span>+str);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------处理修改方式--------------------------&quot;</span>);</span><br><span class="line">        str = changeString2(str);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------处理修改方式2--------------------------&quot;</span>);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(str);</span><br><span class="line">        changeString3(builder);</span><br><span class="line">        System.out.println(builder);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">            String是引用类型没有问题，但是是一个特殊的引用类型，平时在外界进行的修改是可以操作</span></span><br><span class="line"><span class="comment">            但是如果将String类型作为方法的参数，此时是无法通过方法内部对String类型参数进行修改影响到</span></span><br><span class="line"><span class="comment">传递参数</span></span><br><span class="line"><span class="comment">            主要是跟字符串的存储机制有关，一个值字符串字符串池机制和底层存储机制【private final char[] value】</span></span><br><span class="line"><span class="comment">            对String字符串进行操作时都等于重新创建一个新的String对象</span></span><br><span class="line"><span class="comment">            下面方法发生执行过程</span></span><br><span class="line"><span class="comment">            首先：通过外界main方法中调用changeString(str) 将 str赋值给方法参数str</span></span><br><span class="line"><span class="comment">            即执行 方法参数赋值过程 String str = str ---》 String str = &quot;abc&quot;</span></span><br><span class="line"><span class="comment">            参数str会得到字符串&quot;abc&quot;的引用地址</span></span><br><span class="line"><span class="comment">            然后：在方法的【内部对方法参数str进行了修改】将str修改为一个新的引用执行 &quot;bcd&quot;</span></span><br><span class="line"><span class="comment">            所有的修改过程都是对 方法参数空间引用str进行操作，是不会影响到外界str的</span></span><br><span class="line"><span class="comment">            这样就造成如果使用String类型作为方法参数时，是无法修改外界传递字符串数据</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">changeString</span><span class="params">(String str)</span> </span><br><span class="line">        &#123;</span><br><span class="line">            str = <span class="string">&quot;bcd&quot;</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//可以进行修改操作</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        第一种： 提供返回值，将方法内部修改之后地址赋值给外界字符串</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">changeString2</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        str = <span class="string">&quot;bcd&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">            第</span></span><br><span class="line"><span class="comment">二种： 存储在自定义类、数组或集合</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// private static void changeString3(这里的参数需要是存储String类型数据的【自定义类、数组或集合】) </span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">        <span class="comment">// 方法内部通过这个存储方式进行字符串修改操作</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            第三种：提供StringBuffer和StringBuilder作为方法参数</span></span><br><span class="line"><span class="comment">            StringBuilder是引用类型而且是一个可变字符串，底层存储【char[] value】,所以是一个可变操作</span></span><br><span class="line"><span class="comment">            对StringBuilder做到任何修改都是影响到其内部存储内容</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">changeString3</span><span class="params">(StringBuilder builder)</span> </span><br><span class="line">        &#123;</span><br><span class="line">            builder.replace(<span class="number">0</span>,builder.length(),<span class="string">&quot;bcd&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点二：Object类"><a href="#知识点二：Object类" class="headerlink" title="知识点二：Object类"></a><center>知识点二：Object类</center></h1><h2 id="1、含义"><a href="#1、含义" class="headerlink" title="1、含义"></a><center>1、含义</center></h2><p>在Java继承树上最顶层的父类</p><p>所有的类都是直接或者间接的继承自Object</p><p>所有的类型都有Object类提供的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;&#125; --》此时是默认继承Object这个类</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">Object</span>&#123;&#125; --》 显式继承与Object这个类，这样两种创建方式都是一样，就是语法区别</span><br></pre></td></tr></table></figure><p>PS：在API中Object类一共提供11个方法，这11方法中只有clone这个方法在开发中几乎与不使用</p><h2 id="2、常用方法"><a href="#2、常用方法" class="headerlink" title="2、常用方法"></a><center>2、常用方法</center></h2><h3 id="1）getClass"><a href="#1）getClass" class="headerlink" title="1）getClass()"></a>1）getClass()</h3><p>&ensp;&ensp;&ensp;&ensp;返回该对象的真实类型(运行期类型)</p><p>&ensp;&ensp;&ensp;&ensp;ObjectDemo类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="comment">//获取对象的真是类型（类对象）</span></span><br><span class="line">        System.out.println(student.getClass());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断str和tea是否同一个类型</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">tea</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">        System.out.println(str.getClass() == tea.getClass());</span><br><span class="line">        <span class="comment">//以前方法</span></span><br><span class="line">        <span class="keyword">if</span> (str <span class="keyword">instanceof</span> Student &amp;&amp; tea <span class="keyword">instanceof</span> Student</span><br><span class="line">            || str <span class="keyword">instanceof</span> Teacher &amp;&amp; tea <span class="keyword">instanceof</span> Teacher)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;同一个类型&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不同一个类型&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Student类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Teacher类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2）toString方法"><a href="#2）toString方法" class="headerlink" title="2）toString方法"></a>2）toString方法</h3><p>&ensp;&ensp;&ensp;&ensp;全限定名+@+十六进制的hash值(地址)如果直接输出一个对象，那么默认会调用这个对象的toString方法，而toString方法是Object类提供的，返回的是“对象的地址”。但是我们一般输出对象希望输出的是对象的属性信息，所以可以重写父类的toString方法</p><p>ObjectDemo2类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectDemo2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Student stu = new Student();</span></span><br><span class="line">        <span class="comment">//com.qf.object.Student@1b6d3586 对象的内存地址</span></span><br><span class="line">        <span class="comment">//如果直接输出一个对象，实际上是调用了这个对象的toString方法，输出的是这个对象的地址</span></span><br><span class="line">        <span class="comment">//System.out.println(stu);</span></span><br><span class="line">        <span class="comment">//但是通常情况下，我们输出对象就希望输出对象的属性信息，所以通常我们会重写Object的toString方法</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;jack&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        System.out.println(stu);    <span class="comment">//隐式调用toString方法,stu.toString()显式调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Student类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当进行toString方法重写的时候IDEA会默认提供一个toString实现的方式</span></span><br><span class="line"><span class="comment">    * 这个方式的实现就是 打印Person类型中所提供属性值</span></span><br><span class="line"><span class="comment">    * 在开发中可以根据个人的需求进行定制，无需使用IDEA提供默认实现，自行实现即可</span></span><br><span class="line"><span class="comment">    * 只要能得到一个字符串就可以</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3）hashCode方法"><a href="#3）hashCode方法" class="headerlink" title="3）hashCode方法"></a>3）hashCode方法</h3><p>hash值作用：</p><p>区分对象</p><p>&ensp;&ensp;&ensp;&ensp;1、返回该对象的十进制的哈希吗值</p><p>&ensp;&ensp;&ensp;&ensp;2、hash值是由hash算法通过对象的地址、对象中的字符串、数字等，计算出来的</p><p>&ensp;&ensp;&ensp;&ensp;3、相同的对象应当返回相同的哈希吗值，不同的对象尽量返回不同的哈希码值</p><p>&ensp;&ensp;&ensp;&ensp;不同的对象有可能会出现hash冲突</p><p>ObjectDemo03类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectDemo03</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;jack&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        System.out.println(stu1.hashCode());</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;jack&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        System.out.println(stu2.hashCode());</span><br><span class="line">        <span class="comment">//hash冲突</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;通话&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;重地&quot;</span>;</span><br><span class="line">        System.out.println(s1.hashCode());</span><br><span class="line">        System.out.println(s2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Student类和Person类与ObjectDemo2相同</p><h3 id="4）equals方法"><a href="#4）equals方法" class="headerlink" title="4）equals方法"></a>4）equals方法</h3><p>&ensp;&ensp;&ensp;&ensp;Object类的equals方法的作用是比较两个对象是否相等。默认比较的是内存地址。其底层代码的是&#x3D;&#x3D;如果不想比较内存地址，那么需要重写equals方法。系统默认重写过后的equals方法，只要属性一致，那么结构返回true</p><p>&ensp;&ensp;&ensp;&ensp;String类就重写父类equals，从而比较的是内容，所以String类中只要两个字符串内容相等，那么equals就返回true。</p><p>快捷方法：alt+INS &#x3D;&#x3D;&gt;equals()and hashCode() &#x3D;&#x3D;&gt;第一个界面需要打勾的 打勾第一个 &#x3D;&#x3D;&gt;剩下全部下一步</p><p>PS：如果遇到自定义类中所创建对象需要比较相等，那么就需要在这个自定义类中提供equals方法的重新操作，才可以进行比较。</p><p>重写equals的同时重写hashcode方法的原因</p><p>&ensp;&ensp;&ensp;&ensp;因为在Java中协定，只要两个对象使用equals比较相等，那么两个对象的hahsi值也必须相等</p><p>在HashSet等集合的底层去重原理? ( 如何比较两个对象是否相等? )</p><p>&ensp;&ensp;&ensp;&ensp;在java中会优先比较两个对象的hash值，如果hash值不一致，那么两个对象就不相同。</p><p>&ensp;&ensp;&ensp;&ensp;如果hash值一致，进而再比较equals，如果equals 方法也相等，那么这两个对象就等同。</p><p>训练提示</p><p>&ensp;&ensp;&ensp;&ensp;（1）提供一个公民类，属性有【姓名和ID】</p><p>&ensp;&ensp;&ensp;&ensp;（2）提供一个数据存储工具类，工具类中存储一下数据信息，提供一个方法可以获取到这些数据信息</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;姓名 ID</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;张学友, 9999</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;刘德华, 8888</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;郭富城, 7777</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;吴奇隆，6666</p><p>&ensp;&ensp;&ensp;&ensp;（3） 设计一个机场安检系统类，提供控制台输入姓名和ID的操作存储到公民对象中，提供操作完成公民信息与数据类中提供数据信息比较操作，如果信息一致则提示机场想起了警报，来了一群便衣将XXX带走了，否则祝XXX旅途愉快！</p><p>公民类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Citizen</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> ID;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Citizen</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Citizen</span><span class="params">(String name, <span class="type">int</span> ID)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.ID = ID;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getID</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ID;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setID</span><span class="params">(<span class="type">int</span> ID)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.ID = ID;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//提供一个toString重写打印公民类中的属性信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Citizen&#123;&quot;</span> +</span><br><span class="line">        <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">        <span class="string">&quot;, ID=&quot;</span> + ID +</span><br><span class="line">        <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公民信息存储工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CitizenDB</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.工具类是不会提供对象创建</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">CitizenDB</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="comment">//2.工具类中提供方法和属性都是静态的</span></span><br><span class="line">    <span class="comment">//2.1提供一个静态数组存储公民信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Citizen[] db = &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Citizen</span>(<span class="string">&quot;张学友&quot;</span>,<span class="number">9999</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Citizen</span>(<span class="string">&quot;刘德华&quot;</span>,<span class="number">8888</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Citizen</span>(<span class="string">&quot;郭富城&quot;</span>,<span class="number">7777</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Citizen</span>(<span class="string">&quot;吴奇隆&quot;</span>,<span class="number">6666</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//2.2 提供一个共有静态方法可以访问到这个数据数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Citizen[] getCitizenDB()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> db;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>机场安检系统</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AirPortSystem</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------欢迎进入机场安检系统-------------------------&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入您的姓名：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> input.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入您的ID：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ID</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            注意: 要比较信息数据是存储在公民数组中，公民数组中存储都是一个一个公民对象，每个公民对</span></span><br><span class="line"><span class="comment">象中存储就是具体数据信息</span></span><br><span class="line"><span class="comment">            所以需要将name和ID信息封装一个公民信息对象中，与公民数组中存储对象进行比较</span></span><br><span class="line"><span class="comment">            此时就需要使用到Object类中所提供equals方法进行对象的比较操作</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Citizen</span> <span class="variable">citizen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Citizen</span>(name,ID);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------请稍等，系统正在比对您的信息-------------------------&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>); <span class="comment">//为了让系统有一个卡顿的效果【模拟查找数据库】</span></span><br><span class="line">        <span class="keyword">if</span> (checkCitizenInfo(citizen))</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;机场想起了警报，来了一群便衣将：&quot;</span>+citizen+<span class="string">&quot;带走了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;祝:&quot;</span>+citizen+<span class="string">&quot;旅途愉快！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 检查公民信息的方法</span></span><br><span class="line"><span class="comment">    * 公民信息对象</span></span><br><span class="line"><span class="comment">    * 证明是要逮捕的人 false 证明就不是要逮捕人</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkCitizenInfo</span><span class="params">(Citizen citizen)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (Citizen citizen1 : CitizenDB.getCitizenDB())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//利用数据中每一个公民对象与传递进来公民对象进行比较操作</span></span><br><span class="line">            <span class="keyword">if</span> (citizen1.equals(citizen))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;&ensp;&ensp;通过上面代码执行我们可以发现Objcet类提供equals方法无法满足子类比较的需求，所以需要重新equals方法进行对象比较的操作</p><p>&ensp;&ensp;&ensp;&ensp;如果认为两个引用类型“相等“即equals比较值为true，认为只要引用类型中存储的数据内容是一致的就认为这个两个引用类型相等，即equals比较结果为true，否则equals比较结果为false</p><p>&ensp;&ensp;&ensp;&ensp;针对自定义类中创建对象使用equals进行比较时，重写equals方法中提供方式是即当前类中定义属性，根据需求，要么全部都相等 或者 部分相等</p><p>在公民类（Citizen）中重写equals方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//公民类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Citizen</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> ID;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Citizen</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Citizen</span><span class="params">(String name, <span class="type">int</span> ID)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.ID = ID;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getID</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ID;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setID</span><span class="params">(<span class="type">int</span> ID)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.ID = ID;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//提供一个toString重写打印公民类中的属性信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Citizen&#123;&quot;</span> +</span><br><span class="line">    <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">    <span class="string">&quot;, ID=&quot;</span> + ID +</span><br><span class="line">    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//提供equals方法的重写</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        观察这个方法时可以发现，方法的参数类型是Object类型，使用是父类类型作为方法的参数</span></span><br><span class="line"><span class="comment">        这样可以达到方法的最大通用性，任何类重写equals方法的时候可以满足类的需求---》这就是多态的</span></span><br><span class="line"><span class="comment">好处</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            在这个类中提供比较原则，使用this代表当前对象， other传入对象</span></span><br><span class="line"><span class="comment">            外界调用这个方法就是this，当做方法参数传递的就是other对象</span></span><br><span class="line"><span class="comment">            这个编程需求是需要比较类中所有全部相等，所以需要提供属性操作，又因为使用是父类Object类</span></span><br><span class="line"><span class="comment">                型作为方法参数【为了达到最通用性】</span></span><br><span class="line"><span class="comment">            但是传入到这个方法中对象会被执行【对象的向上转型】提升为Object类型，此时是无法调用子类</span></span><br><span class="line"><span class="comment">属性和方法</span></span><br><span class="line"><span class="comment">            需要将这个提升之后对象转换为原有的数据类型</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Citizen</span> <span class="variable">other</span> <span class="operator">=</span> (Citizen)o;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            类中属性的操作方式：如果类中属性是系统引用类型，直接调用equals方法即可【因为系统引用类</span></span><br><span class="line"><span class="comment">            型基本上都重写了Object类中equals方法】</span></span><br><span class="line"><span class="comment">            如果类中属性是基本数据类型，直接使用 == 比较即可</span></span><br><span class="line"><span class="comment">            name属性是String类型所以可以直接使用String类提供equals方法重写比较</span></span><br><span class="line"><span class="comment">            ID属性是int类型所以可以直接使用 == 进行比较操作</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name.equals(other.name) &amp;&amp; <span class="built_in">this</span>.ID == other.ID;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：&#x3D;&#x3D; 和 equals的区别</p><p>&ensp;&ensp;&ensp;&ensp;两个东西都是用于比较的</p><p>&ensp;&ensp;&ensp;&ensp;&#x3D;&#x3D; 可以用于基本类型和引用类型&#x3D;&#x3D;在基本类型的比较中，比较的值是否相等，如果相等返回true，否则返回false</p><p>&ensp;&ensp;&ensp;&ensp;&#x3D;&#x3D;在引用类型的比较中，比较的地址是否相等，如果相等返回true，否则返回false</p><p>&ensp;&ensp;&ensp;&ensp;equals只能用于引用类型的比较equals方法是Object类提供的方法，其底层实现是&#x3D;&#x3D;比较，所以在没有重写父类的equals方法时。比较的也是地址。如果希望两个对象的属性一样，就认为两个对象是相同的对象，那么需要重写equals方法，但是重写了equals的同时也需要重写hashcode方法，因为java中约定两个对象相等，那么两个对象的hash值也应该相等</p><h3 id="5）finalize方法"><a href="#5）finalize方法" class="headerlink" title="5）finalize方法"></a>5）finalize方法</h3><p>当垃圾回收器回收垃圾对象的时候，自动调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test5</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="comment">//手动将对象标记为垃圾对象</span></span><br><span class="line">        p = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//触发垃圾回收器，回收垃圾对象</span></span><br><span class="line">        System.gc();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>.finalize();<span class="comment">//不要删除</span></span><br><span class="line">        System.out.println(<span class="string">&quot;finalize方法执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点三：包装类"><a href="#知识点三：包装类" class="headerlink" title="知识点三：包装类"></a><center>知识点三：包装类</center></h1><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a><center>1、概念</center></h2><p>什么是包装类？</p><p>&ensp;&ensp;&ensp;&ensp;包装类就是【基本数据类型对应引用数据类型版本】，基本数据类型在网络数据传输时，效率是极低的，就是因为基本数据类型没有执行序列化接口，所以提供对应引用类型版本进行替换操作，提高基本数据类型在网络中传递效率</p><p>&ensp;&ensp;&ensp;&ensp;在后学习中我们会接触到一个更加便利的数据存储形式—》集合，集合中存储数据只能是引用类型，所以基本数据类型无法存储到集合中，所以就需要使用包装类即基本数据类型对应引用类型版本</p><p>&ensp;&ensp;&ensp;&ensp;基本数据类型只提供基础数据存储与定义操作，并没有提供任何对存储数据的操作方法,包装类就提供常用数据方法，字符串转换为整数，int类型就无法完成，就需要使用包装类Integer</p><p>PS：包装类是类，即引用类型【但是需要注意是一个“特殊”的引用类型】</p><h2 id="2、包装类的类型及定义"><a href="#2、包装类的类型及定义" class="headerlink" title="2、包装类的类型及定义"></a><center>2、包装类的类型及定义</center></h2><table><thead><tr><th align="center">基本类型</th><th align="center">作为属性默认值</th><th align="center">包装类型</th><th align="center">作为属性默认值</th></tr></thead><tbody><tr><td align="center">byte</td><td align="center">0</td><td align="center">Byte</td><td align="center">null</td></tr><tr><td align="center">short</td><td align="center">0</td><td align="center">Short</td><td align="center">null</td></tr><tr><td align="center">int</td><td align="center">0</td><td align="center">Integer</td><td align="center">null</td></tr><tr><td align="center">long</td><td align="center">0</td><td align="center">Long</td><td align="center">null</td></tr><tr><td align="center">float</td><td align="center">0.0</td><td align="center">Float</td><td align="center">null</td></tr><tr><td align="center">double</td><td align="center">0.0</td><td align="center">Double</td><td align="center">null</td></tr><tr><td align="center">char</td><td align="center">不可见空字符</td><td align="center">Character</td><td align="center">null</td></tr><tr><td align="center">boolean</td><td align="center">false</td><td align="center">Boolean</td><td align="center">null</td></tr></tbody></table><p>PS：基本数据类型中除了int和char类型之外，所有对应保证类都是首字母大写，而int对应包装类Integer，char对应包装类Character</p><p>以下操作者都已Integer类为主要操作，其余包装类与之操作是一样，就是改变类名而已</p><h2 id="3、拆箱和装箱"><a href="#3、拆箱和装箱" class="headerlink" title="3、拆箱和装箱"></a><center>3、拆箱和装箱</center></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntegerDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//以Integer为例讲解包装类 拆箱与装箱操作</span></span><br><span class="line">        <span class="comment">//什么是装箱？</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            装箱操作其实就是在形容: 将基本数据类型转换为对应包装类类型</span></span><br><span class="line"><span class="comment">            这个过程我们形容为【装箱操作】 ---》 装箱操作分为自动装箱和手动装箱</span></span><br><span class="line"><span class="comment">            手动装箱是Java5以前提供--》需要将基本数据类型转换为对应包装类类型</span></span><br><span class="line"><span class="comment">            包装类类型 对象名 = new 包装类类型(对象包装类的基本数据类型值)</span></span><br><span class="line"><span class="comment">            自动装箱是Java5以后提供 --》将基本数据类型转换为对应包装类类型是</span></span><br><span class="line"><span class="comment">            无需在使用new创建包装类对象，而是直接对包装类赋值即可</span></span><br><span class="line"><span class="comment">            包装类类型 对象名 = 对象包装类的基本数据类型值;</span></span><br><span class="line"><span class="comment">            Java5以后是支持自动和手动装箱操作</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//手动装箱</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">19</span>;</span><br><span class="line">        <span class="comment">//将int类型age变量转换为对应Integer类型进行存储</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(age);</span><br><span class="line">        <span class="comment">//自动装箱</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">age2</span> <span class="operator">=</span> <span class="number">19</span>;</span><br><span class="line">        <span class="comment">//将int类型age2变量转换为对应Integer类型进行存储</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer1</span> <span class="operator">=</span> age2;</span><br><span class="line">        <span class="comment">//这种两种方式创建的Integer对象存储的空间是不一样的，所以不要使用 == 比较</span></span><br><span class="line">        <span class="comment">//引用类型不要使用 == 比较比较是内存地址，要使用equals进行比较操作</span></span><br><span class="line">        System.out.println(integer == integer1);</span><br><span class="line">        System.out.println(integer.equals(integer1));</span><br><span class="line">        <span class="comment">//什么是拆箱操作？</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            拆箱操作其实就是在形容: 将包装类中存储的数据转换为对应基本数据类型进行存储</span></span><br><span class="line"><span class="comment">            这个过程我们形容为【拆箱操作】 ---》 拆箱操作分为自动拆箱和手动拆箱</span></span><br><span class="line"><span class="comment">            手动拆箱是Java5以前提供--》需要包装类类型对象调用包装类中提供XXXValue()方法，转换为对应基本数类型</span></span><br><span class="line"><span class="comment">            这个的XXX是包装类对象对应基本数据类型---》例如 Integer包装类 对应的就是 int类型 所以XX就是int</span></span><br><span class="line"><span class="comment">            对应转换包装类的基本数据类型 变量 = 包装类对象.XXXValue();</span></span><br><span class="line"><span class="comment">            自动拆箱是Java5以后提供 --》无需调用繁琐XXXValue()方法，只需要将包装类对象赋值给对应基本数据类型变量即可</span></span><br><span class="line"><span class="comment">            对应转换包装类的基本数据类型 变量 = 包装类对象;</span></span><br><span class="line"><span class="comment">            Java5以后是支持自动和手动拆箱操作</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//手动拆箱</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> integer.intValue();</span><br><span class="line">        System.out.println(<span class="string">&quot;拆箱之后的int类型数：&quot;</span>+i);</span><br><span class="line">        <span class="comment">//自动拆箱</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> integer1;</span><br><span class="line">        System.out.println(<span class="string">&quot;拆箱之后的int类型数：&quot;</span>+i2);</span><br><span class="line">        <span class="comment">//现在的开发使用包装类计算或在计算时自动拆箱</span></span><br><span class="line">        System.out.println(<span class="string">&quot;求存储在包装类对象integer和integer1中年龄和:&quot;</span>+</span><br><span class="line">(integer+integer1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、Number类"><a href="#4、Number类" class="headerlink" title="4、Number类"></a><center>4、Number类</center></h2><p>Number是Byte、Short、Integer、Long、Float、Double的父类</p><p>Number提供一组方法用于将其中某一种类型转换成其他类型 </p><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxxValue()方法</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Byte</span> <span class="variable">b</span> <span class="operator">=</span> a.byteValue();</span><br><span class="line"><span class="type">Short</span> <span class="variable">c</span> <span class="operator">=</span> a.shortValue();</span><br><span class="line"><span class="type">Long</span> <span class="variable">d</span> <span class="operator">=</span> a.longValue();</span><br><span class="line"><span class="type">Float</span> <span class="variable">e</span> <span class="operator">=</span> a.floatValue();</span><br><span class="line"><span class="type">Double</span> <span class="variable">f</span> <span class="operator">=</span> a.doubleValue();</span><br><span class="line"><span class="type">Integer</span> <span class="variable">g</span> <span class="operator">=</span> a.intValue();</span><br></pre></td></tr></table></figure><h2 id="5、常用包装类"><a href="#5、常用包装类" class="headerlink" title="5、常用包装类"></a><center>5、常用包装类</center></h2><p>开发中用的最多：Integer 、Double</p><p>定义方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Integer、Double的定义方式</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">ii1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">100</span>);</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">ii1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Double</span> <span class="variable">dd1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">100.2</span>);</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="type">Double</span> <span class="variable">dd1</span> <span class="operator">=</span> <span class="number">100.2</span>;</span><br></pre></td></tr></table></figure><h3 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Integer.MAX_VALUE);</span><br><span class="line">System.out.println(Integer.MIN_VALUE);</span><br><span class="line">System.out.println(Double.MAX_VALUE);</span><br><span class="line">System.out.println(Double.MIN_VALUE);</span><br></pre></td></tr></table></figure><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>前端传入后端的数据一般是字符串类型</p><p>所以需要将字符串类型的数值转换成int或者是double类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常用方法</span></span><br><span class="line"><span class="comment">//字符串转Integer</span></span><br><span class="line"><span class="comment">//第一种方法（常用）</span></span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;23&quot;</span>);</span><br><span class="line">System.out.println(number);</span><br><span class="line"><span class="comment">//第二种方法</span></span><br><span class="line"><span class="type">int</span> <span class="variable">number1</span> <span class="operator">=</span> Integer.valueOf(<span class="string">&quot;234&quot;</span>);</span><br><span class="line">System.out.println(number1);</span><br><span class="line"><span class="comment">//字符串转Double</span></span><br><span class="line"><span class="comment">//第一种方法(常用)</span></span><br><span class="line"><span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> Double.parseDouble(<span class="string">&quot;23.4&quot;</span>);</span><br><span class="line">System.out.println(price);</span><br><span class="line"><span class="comment">//第二种方法</span></span><br><span class="line"><span class="type">double</span> <span class="variable">price1</span> <span class="operator">=</span> Double.valueOf(<span class="string">&quot;23.45&quot;</span>);</span><br><span class="line">System.out.println(price1);</span><br></pre></td></tr></table></figure><h2 id="6、Integer缓冲区"><a href="#6、Integer缓冲区" class="headerlink" title="6、Integer缓冲区"></a><center>6、Integer缓冲区</center></h2><p>整数型的包装类定义缓冲区(-128~127)，如果定义的数在这个范围你之内，那么直接从缓存数组中获取，不需要new</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">/*** 面试题：整数型包装类缓冲区</span></span><br><span class="line"><span class="comment">        * 整数型的包装类定义缓冲区(-128~127)，如果定义的数在这个范围你之内，那么直接从缓存数组中获取，</span></span><br><span class="line"><span class="comment">        * 否则，重新new新的对象</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>);</span><br><span class="line">        System.out.println(i1 == i2); <span class="comment">//false</span></span><br><span class="line">        System.out.println(i1.equals(i2));<span class="comment">//true</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">1000</span>; <span class="comment">//Integer i3 = new Integer(1000);</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="number">1000</span>; <span class="comment">//Integer i3 = new Integer(1000);</span></span><br><span class="line">        System.out.println(i3 == i4); <span class="comment">//false</span></span><br><span class="line">        System.out.println(i3.equals(i4));<span class="comment">//true</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i5</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">//IntegerCache.cache[i + (-IntegerCache.low)]</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i6</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">//IntegerCache.cache[i + (-IntegerCache.low)]</span></span><br><span class="line">        System.out.println(i5 == i6);<span class="comment">//true</span></span><br><span class="line">        System.out.println(i5.equals(i6));<span class="comment">//true&#125;&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;&ensp;&ensp;Integer类内部实现的原则 —》【享元原则】它是Java中设计的一种优化，外部使用自动装箱进行Integer创建时，设计了一个范围 【-128~127】只要是这个范围内创建出来Integer对象，他们都会得到堆中相同地址，相当于Integer中出现一个缓存数据 Integer cache[] &#x3D; {-128，…. ,127} ,只要存储这个范围内的值就直接返回存储好地址，这样一来就说明了存储123时通过 &#x3D;&#x3D; 比较得到结果是true ，存储300时 &#x3D;&#x3D; 比较得到结果是false，因为300超出了Integer缓存范围，机会触发valueOf方法 new Integer，得到就是堆地址</p><h2 id="7、包装类作为方法参数类型"><a href="#7、包装类作为方法参数类型" class="headerlink" title="7、包装类作为方法参数类型"></a><center>7、包装类作为方法参数类型</center></h2><p>&ensp;&ensp;&ensp;&ensp;需求：提供给一个测试类，在main方法中提供一个Integer类型包装类对象存储数据1000【形式不限】，然后再测试类中提供static方法，将Integer设置为当前方法参数类型，并在方法内部将外界传递Integer数据【1000】，修改为99999，然后再mian方法中调用方法执行，打印修改之后的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//包装类作为方法参数类型时问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PackageClassMethod</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//包装类就是引用类型,但是是一个“特殊”引用类型</span></span><br><span class="line">        <span class="comment">//Integer i1 = null;</span></span><br><span class="line">        <span class="comment">//提供一个Integer类型的对象存储数据1000</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">//toHexString 将十进制转换为十六进制 toBinaryString 将十进制转换为二进制</span></span><br><span class="line">        <span class="comment">//toOctalString 将十进制转换为八进制</span></span><br><span class="line">        System.out.println(<span class="string">&quot;main方法中integer对象的内存地址是：&quot;</span>+Integer.toHexString(integer.hashCode()));</span><br><span class="line">        changeIntegerValue(integer);</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法调用changeIntegerValue方法之后integer对象的内存地</span></span><br><span class="line"><span class="string">            址是：&quot;</span>+Integer.toHexString(integer.hashCode()));</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">changeIntegerValue</span><span class="params">(Integer integer)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法中将integer对象存储的地址赋值给changeIntegerValue</span></span><br><span class="line"><span class="string">        方法参数integer的地址：&quot;</span>+Integer.toHexString(integer.hashCode()));</span><br><span class="line">        integer = <span class="number">99999</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;changeIntegerValue方法将Integer对象中存储数据修改之后的地</span></span><br><span class="line"><span class="string">            址是：&quot;</span>+Integer.toHexString(integer.hashCode()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包装类是一个特殊的引用类型，将包装类作为方法参数之后，在方法内部提供数据修改之后无法</p><p>得到修改之后的结果，原因在于其内部存储</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原码中Integer存储数据时做的操作</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    value就是Integer类型存储数据时的成员“变量（常量）”</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    调用构造方法创建Integer对象提供存储数据都是存储在value这个成员“变量”</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Integer</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;&ensp;&ensp;综上所属：包装类其实是一个特殊的引用类型，当在方法体进行操作时，相当于是“重新”创建了一个地址，所以的修改都不是在原有地址上执行，而是在这个新的地址执行，这样一来就造成了无法修改的问题，除此之外在原码中可以发现，存储数据是使用【 private final int value】，value是final修饰，所以每次对Integer赋值操作时，都是得到一个新的地址。</p><p>提供可以正常修改方案：</p><p>&ensp;&ensp;&ensp;&ensp;第一种方式：对方法添加返回值类型，利用return关键字将修改之后地址，返回出来，并让外界原来对象，存储这个新的地址，间接的修改了</p><p>&ensp;&ensp;&ensp;&ensp;第二种方式：使用自定义类，将Integer作为类的属性类型存在，修改Integer时，传递自定义类作为参数类型，在方法内部通过get和set进行修改，这样也可以改变</p><p>&ensp;&ensp;&ensp;&ensp;第三种方式：存储到数据结构中 —》数组或集合</p><p>包装类与包装类之间关系</p><p>&ensp;&ensp;&ensp;&ensp;基本数据类型除了boolean类型之外，都可以参与到数据类型转换过程中。但是包装类彼此之间</p><p>&ensp;&ensp;&ensp;&ensp;是互相独立，非要找一些关联化，数值类型【Byte、short、Integer、Long、Float和Double】</p><p>&ensp;&ensp;&ensp;&ensp;他们有一个共同父类是Number，除此之外包装类是存在在java.lang包中</p><h1 id="知识点四：Dete类"><a href="#知识点四：Dete类" class="headerlink" title="知识点四：Dete类"></a><center>知识点四：Dete类</center></h1><h2 id="1、含义-1"><a href="#1、含义-1" class="headerlink" title="1、含义"></a><center>1、含义</center></h2><p>表示日期</p><h2 id="2、创建"><a href="#2、创建" class="headerlink" title="2、创建"></a><center>2、创建</center></h2><p>创建java.util.Date对象</p><p>获取系统当前时间：Date date &#x3D; new Date();</p><p>自己定义时间：Date date &#x3D; new Date(定义年 - 1900,定义月-1,定义日);</p><p>获取时间戳：先new Date形式：变量名.getTime();</p><p>需要定义变量保存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">dateDemo01</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建java.util.Date对象</span></span><br><span class="line">        <span class="comment">//获取系统当前时间</span></span><br><span class="line">        <span class="comment">//Date date = new Date();</span></span><br><span class="line">        <span class="comment">//System.out.println(date);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * year：默认从1900年开始</span></span><br><span class="line"><span class="comment">         * moth：0-11</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//使用Date类表示指定时间</span></span><br><span class="line">        <span class="comment">//Date date = new Date(2020-1900,10-1,29);</span></span><br><span class="line">        <span class="comment">//System.out.println(date);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前Date对应时间的毫秒数（时间戳）</span></span><br><span class="line">        <span class="comment">//获取到的时间戳是从1970年开始计算</span></span><br><span class="line"><span class="comment">//        Date date = new Date();</span></span><br><span class="line"><span class="comment">//        long time = date.getTime();</span></span><br><span class="line"><span class="comment">//        System.out.println(time);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算活了多少天</span></span><br><span class="line">        <span class="comment">//1、获取当前系统时间</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="comment">//2、获取出生时间</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2000</span>-<span class="number">1900</span>,<span class="number">6</span>-<span class="number">1</span>,<span class="number">29</span>);</span><br><span class="line">        <span class="comment">//3、获取两个时间对应的时间戳相减</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> date.getTime() - date1.getTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;我活了&quot;</span>+ time/<span class="number">1000</span>/<span class="number">60</span>/<span class="number">60</span>/<span class="number">24</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点五：SimpleDateFormat类"><a href="#知识点五：SimpleDateFormat类" class="headerlink" title="知识点五：SimpleDateFormat类"></a><center>知识点五：SimpleDateFormat类</center></h1><h2 id="1、含义-2"><a href="#1、含义-2" class="headerlink" title="1、含义"></a><center>1、含义</center></h2><p>用于日期格式化</p><h2 id="2、作用"><a href="#2、作用" class="headerlink" title="2、作用"></a><center>2、作用</center></h2><p>1）将Date类转换成字符串类型</p><p>2）将字符串类型转换成Date类型</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271929805.jpg" alt="时间表达" style="zoom:67%;"><p>提供对应字符中常用主要有【y（年）、M（月）、d（日）、H（小时）、m（分钟）、s（秒）】</p><p>SimpleDateFormat常用方法</p><p>&ensp;&ensp;&ensp;&ensp;public String format(Date date): 根据提供日期格式将Date对象格式化成String对象</p><p>&ensp;&ensp;&ensp;&ensp;public Date parse(String source): 根据提供日期格式将String对象解析为Date对象</p><p>&ensp;&ensp;&ensp;&ensp;public void applyPattern(String pattern): 可以通过参数String类型字符串设置日期格式</p><p>ps：这个方法主要应对的是使用SimpleDateFormat无参的构造方法所创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleDateFormatDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将Date转换字符串</span></span><br><span class="line">        <span class="comment">//创建一个Date对象</span></span><br><span class="line"><span class="comment">//         Date date = new Date();</span></span><br><span class="line"><span class="comment">//         //创建日期格式化对象 2021年03月12日 14:15:30</span></span><br><span class="line"><span class="comment">//         SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);</span></span><br><span class="line"><span class="comment">//        String time = sdf.format(date);</span></span><br><span class="line"><span class="comment">//        System.out.println(time);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将字符串类型转换成Date类型</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">time</span> <span class="operator">=</span> <span class="string">&quot;2022-04-13 20:32:29&quot;</span>;</span><br><span class="line">        <span class="comment">//此时的格式必须要与字符串中的日期格式一致</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="comment">//转换</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> sdf.parse(time);</span><br><span class="line">        System.out.println(date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、Calender日历类"><a href="#3、Calender日历类" class="headerlink" title="3、Calender日历类"></a><center>3、Calender日历类</center></h2><p>&ensp;&ensp;&ensp;&ensp;Calender类是有Java提供用来代替Date类使用的一个日历类【PS：但是设计者脑残了，这个类存在一个缺陷】，这类所存在的包时java.util中，它是一个抽象类，不能创建对象，所以需要使用到它的子类GregorianCalendar类来完成，这个子类无需直接创建对象，只需要使用Calender类中getInstance()静态方法获取到子类对象即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalendarDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供Calendar对象创建</span></span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        <span class="comment">//不能像打印Date一样打印Calendar对象，因为Calendar对象中存储的是日历信息</span></span><br><span class="line">        System.out.println(c);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            java.util.GregorianCalendar[time=1637913526755,areFieldsSet=true,</span></span><br><span class="line"><span class="comment">            areAllFieldsSet=true,lenient=true,</span></span><br><span class="line"><span class="comment">            zone=sun.util.calendar.ZoneInfo[id=&quot;Asia/Irkutsk&quot;,</span></span><br><span class="line"><span class="comment">            offset=28800000,dstSavings=0,useDaylight=false,</span></span><br><span class="line"><span class="comment">            transitions=67,lastRule=null],firstDayOfWeek=1,</span></span><br><span class="line"><span class="comment">            minimalDaysInFirstWeek=1,ERA=1,YEAR=2021,MONTH=10,</span></span><br><span class="line"><span class="comment">            WEEK_OF_YEAR=48,WEEK_OF_MONTH=4,DAY_OF_MONTH=26,</span></span><br><span class="line"><span class="comment">            DAY_OF_YEAR=330,DAY_OF_WEEK=6,DAY_OF_WEEK_IN_MONTH=4,</span></span><br><span class="line"><span class="comment">            \AM_PM=1,HOUR=3,HOUR_OF_DAY=15,MINUTE=58,SECOND=46,</span></span><br><span class="line"><span class="comment">            MILLISECOND=755,ZONE_OFFSET=28800000,DST_OFFSET=0]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//这个日历类中操作时一定要注意月份问题，月份的基础范围【0~11】代表【1~12月】</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Calendar中打印存储的是日历信息，所以利用Calendar中提供一个方法</span></span><br><span class="line"><span class="comment">        public int get(int Field) --》参数是Calendar类中字段---》通过参数传入的字段获取</span></span><br><span class="line"><span class="comment">        当前日历类中数据</span></span><br><span class="line"><span class="comment">        提供一些常用字段：</span></span><br><span class="line"><span class="comment">            Calendar.YEAR : 年</span></span><br><span class="line"><span class="comment">            Calendar.MONTH ：月</span></span><br><span class="line"><span class="comment">            Calendar.DAY_OF_MONTH：月中的日期 --》还有一个字段可以获取 Calendar.DATE 月中的日期</span></span><br><span class="line"><span class="comment">            Calendar.HOUR：小时</span></span><br><span class="line"><span class="comment">            Calendar.MINUTE：分钟</span></span><br><span class="line"><span class="comment">            Calendar.SECOND：秒</span></span><br><span class="line"><span class="comment">            Calendar.DAY_OF_WEEK：星期</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.out.println(c.get(Calendar.YEAR)+<span class="string">&quot;年&quot;</span></span><br><span class="line">+(c.get(Calendar.MONTH)+<span class="number">1</span>)+<span class="string">&quot;月&quot;</span></span><br><span class="line">        +c.get(Calendar.DATE)+<span class="string">&quot;日&quot;</span></span><br><span class="line">+<span class="string">&quot; &quot;</span>+c.get(Calendar.HOUR)+<span class="string">&quot;时&quot;</span></span><br><span class="line">        +c.get(Calendar.MINUTE)+<span class="string">&quot;分&quot;</span></span><br><span class="line">+c.get(Calendar.SECOND)+<span class="string">&quot;秒&quot;</span>);</span><br><span class="line">        <span class="comment">//将Calendar对象转换为Date对象</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">time</span> <span class="operator">=</span> c.getTime();</span><br><span class="line">        <span class="comment">//可以通过Calendar中提供set方法进行指定的时间设置</span></span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">c1</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        <span class="comment">//可以通过这样方式进行时间设置，参数第一个是对应时间字段，第二个是对应的时间数据</span></span><br><span class="line">        <span class="comment">// c1.set(Calendar.YEAR,2021);</span></span><br><span class="line">        <span class="comment">//建议使用下面这个方法完成 ,上面执行操作太繁琐</span></span><br><span class="line">        <span class="comment">//设置月份的时候一定要-1操作【范围是0~11】</span></span><br><span class="line">        c1.set(<span class="number">2021</span>,<span class="number">10</span>,<span class="number">26</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;这是这一年的第：&quot;</span>+c1.get(Calendar.DAY_OF_YEAR)+<span class="string">&quot;天&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;这是这一年的第：&quot;</span>+c1.get(Calendar.WEEK_OF_YEAR)+<span class="string">&quot;周&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;这是这个月的第：&quot;</span>+c1.get(Calendar.DAY_OF_MONTH)+<span class="string">&quot;天&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日历类中存在的一些小问题：</p><ol><li>中国人的第一个天是星期一， 外国人第一天是星期日</li><li>日历类中的月份是从【0~11】结束</li></ol><h1 id="知识点六：System类"><a href="#知识点六：System类" class="headerlink" title="知识点六：System类"></a><center>知识点六：System类</center></h1><h2 id="1、含义-3"><a href="#1、含义-3" class="headerlink" title="1、含义"></a><center>1、含义</center></h2><p>系统类</p><h2 id="2、作用-1"><a href="#2、作用-1" class="headerlink" title="2、作用"></a><center>2、作用</center></h2><p>1）返回当前系统时间的毫秒数 从1970年开始计算</p><p>&ensp;&ensp;&ensp;&ensp;System.currentTimeMillis();</p><p>系统当前时间纳秒值</p><p>&ensp;&ensp;&ensp;&ensp;System.nanoTime();</p><p>2）终止Java虚拟机的运行 参数表示终止的状态 0表示正常退出，负数异常终止</p><p>&ensp;&ensp;&ensp;&ensp;System.exit(0);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemDemo01</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取当前时间的毫秒数    1970年开始</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(time);   <span class="comment">//时间戳</span></span><br><span class="line">        <span class="comment">//日期格式化类可以对long类型的毫秒数进行格式化</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        System.out.println(sdf.format(time));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//终止虚拟机运行  0表示正常退出 非0非正常关机</span></span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;会执行么&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//并不会直接使用垃圾回收器回收垃圾，只会将不用的对象主动添加到垃圾队列</span></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">//数组复制</span></span><br><span class="line">        <span class="type">int</span>[] src = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] des = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            第一个参数 是原数组即被要复制的数据</span></span><br><span class="line"><span class="comment">            第二个参数 从原数组中那个位置开始复制【下标】</span></span><br><span class="line"><span class="comment">            第三个参数 是目标数组即复制内容到那个数组中</span></span><br><span class="line"><span class="comment">            第四个参数 是目标数组的位置【下标】，从目标数组中什么位置开始写入数据</span></span><br><span class="line"><span class="comment">            第五个参数 被复制的长度</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.arraycopy(src,<span class="number">2</span>,des,<span class="number">5</span>,<span class="number">4</span>);</span><br><span class="line">        System.out.println(Arrays.toString(des));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点七：Math类"><a href="#知识点七：Math类" class="headerlink" title="知识点七：Math类"></a><center>知识点七：Math类</center></h1><h2 id="1、含义-4"><a href="#1、含义-4" class="headerlink" title="1、含义"></a><center>1、含义</center></h2><p>数学计算的工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//求a的b次方法 参数1：底数 参数2：幂数</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">num1</span> <span class="operator">=</span> Math.pow(<span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line">        System.out.println(num1);</span><br><span class="line">        <span class="comment">//求a平方根 参数1：要开方的数</span></span><br><span class="line">        System.out.println(Math.sqrt(<span class="number">100</span>));</span><br><span class="line">        <span class="comment">//求a立方根 参数1：要开立方的数</span></span><br><span class="line">        System.out.println(Math.cbrt(<span class="number">27</span>));</span><br><span class="line">        <span class="comment">//向上取整  10.1    11</span></span><br><span class="line">        System.out.println(Math.ceil(<span class="number">10.2</span>));</span><br><span class="line">        <span class="comment">//向下取整  10.6    10</span></span><br><span class="line">        System.out.println(Math.floor(<span class="number">10.9</span>));</span><br><span class="line">        <span class="comment">//四舍五入</span></span><br><span class="line">        System.out.println(Math.round(<span class="number">10.5</span>));</span><br><span class="line">        <span class="comment">//随机数 默认的范围[0,1)</span></span><br><span class="line">        System.out.println(Math.random());</span><br><span class="line">        <span class="comment">//需求：随机一个两位数 [0,1)*90   [0,90) + 10</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num8</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random()*<span class="number">90</span>+<span class="number">10</span>);</span><br><span class="line">        System.out.println(num8);</span><br><span class="line">        <span class="comment">//1.8API中提供新的方法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MAX_VALUE;<span class="comment">//获取int类型最大值存储到max中</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        System.out.println(max+i);<span class="comment">//最大值进行+1之后的到溢出结果不会报错，这样可能影响计算结果</span></span><br><span class="line">        <span class="comment">//正确计算整数之间求和 ---》 一旦超过了最大值范围就会抛出异常提示 --&gt; ArithmeticException: integer overflow</span></span><br><span class="line">        <span class="comment">//System.out.println(Math.addExact(max,i));</span></span><br><span class="line">        System.out.println(max);</span><br><span class="line">        <span class="comment">//安全的递减操作 ---》让数值-1 ，如果超过最小值范围 抛出异常提示</span></span><br><span class="line">        System.out.println(Math.decrementExact(max));</span><br><span class="line">        <span class="comment">//安全的递增操作 ---》 让数值+1，如果超过最大值范围 抛出异常提示</span></span><br><span class="line">        <span class="comment">// System.out.println(Math.incrementExact(max));</span></span><br><span class="line">        <span class="comment">//提供除法操作【都是安全】</span></span><br><span class="line">        System.out.println(Math.floorDiv(<span class="number">6</span>,<span class="number">3</span>));</span><br><span class="line">        <span class="comment">//提供取余操作【都是安全】</span></span><br><span class="line">        System.out.println(Math.floorMod(<span class="number">6</span>,<span class="number">3</span>));</span><br><span class="line">        <span class="comment">//提供一个安全乘法计算.如果超过范围 抛出异常提示</span></span><br><span class="line">        System.out.println(Math.multiplyExact(<span class="number">10</span>,<span class="number">10</span>));</span><br><span class="line">        <span class="comment">//提供一个安全相减操作.如果超过范围 抛出异常提示</span></span><br><span class="line">        System.out.println(Math.subtractExact(<span class="number">10</span>,<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点八：Random类"><a href="#知识点八：Random类" class="headerlink" title="知识点八：Random类"></a><center>知识点八：Random类</center></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Random是Java中提供随机数类，可以得到随机数</span></span><br><span class="line"><span class="comment">            但是这个随机数类是一个“伪随机数” --》Random如果使用相同“种子”创建对象，随机出来数据</span></span><br><span class="line"><span class="comment">就是相同</span></span><br><span class="line"><span class="comment">            Random中一共两个构造方法 --》 无参 和 有参</span></span><br><span class="line"><span class="comment">            开发时多数使用无参--》使用系统随机种子</span></span><br><span class="line"><span class="comment">            有参可以运行出伪随机效果 ---》 参数是一个种子值，但是不是随机范围</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//标准使用方式</span></span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="comment">//他们可以随机正数 --&gt; 参数是范围</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> random.nextInt(<span class="number">100</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//伪随机效果</span></span><br><span class="line">        <span class="type">Random</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">10</span>);</span><br><span class="line">        System.out.println(r1.nextBoolean());</span><br><span class="line">        System.out.println(r1.nextDouble());</span><br><span class="line">        System.out.println(r1.nextInt());</span><br><span class="line">        System.out.println(r1.nextInt(<span class="number">100</span>));</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">10</span>);</span><br><span class="line">        System.out.println(r2.nextBoolean());</span><br><span class="line">        System.out.println(r2.nextDouble());</span><br><span class="line">        System.out.println(r2.nextInt());</span><br><span class="line">        System.out.println(r2.nextInt(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建Random对象</span></span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="comment">//随机一个[0,100)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> random.nextInt(<span class="number">50</span>);</span><br><span class="line">        System.out.println(num);</span><br><span class="line"></span><br><span class="line">        System.out.println(randomCode());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//需求随机生成一个思维的验证码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">randomCode</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;</span>;</span><br><span class="line">        <span class="comment">//将字符串转换成char数组</span></span><br><span class="line">        <span class="type">char</span> ch [] = str.toCharArray();</span><br><span class="line">        <span class="comment">//2、产生4个随机数</span></span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> random.nextInt(str.length());</span><br><span class="line">            a.append(ch[index]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点九：BigDecimal类"><a href="#知识点九：BigDecimal类" class="headerlink" title="知识点九：BigDecimal类"></a><center>知识点九：BigDecimal类</center></h1><h2 id="1、为什么使用BigDecimal"><a href="#1、为什么使用BigDecimal" class="headerlink" title="1、为什么使用BigDecimal?"></a><center>1、为什么使用BigDecimal?</center></h2><p>以下的代码的错误原因是0.9在计算中中的二进制是一个无限循环的</p><p>double保存时近似值，所以计算的结果不精确</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Java中已经提供浮点（小数）数据类型 --》 float和double但是他们在日常计算中还是可以使用</span></span><br><span class="line"><span class="comment">    但对于数据的精度有要求操作时float和double就不可以的【金融、电信、电力完全禁用float和double】</span></span><br><span class="line"><span class="comment">    Java提供了一个超精度的小数BigDecimal，可以适用于【金融、电信、电力】，日常也可以使用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showBigDecimal</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//为什么double 和float被称之为不精准计算</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        计算出这个结果其实是一个“超精确的结果” 数学中提供一个悖论 1/3 = 0.33333333333</span></span><br><span class="line"><span class="comment">        数学中一个理论 0.333333*3 = 0.9999999 不等于1</span></span><br><span class="line"><span class="comment">        0.99999无限接近于1的所以 约等于</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    System.out.println(<span class="string">&quot;0.09+0.01=&quot;</span>+(<span class="number">0.09</span>+<span class="number">0.01</span>));<span class="comment">//0.1</span></span><br><span class="line">    System.out.println(<span class="string">&quot;1.0-0.33=&quot;</span>+(<span class="number">1.0</span>-<span class="number">0.33</span>));<span class="comment">//0.67</span></span><br><span class="line">    System.out.println(<span class="string">&quot;4.015*1000=&quot;</span>+(<span class="number">4.015</span>*<span class="number">1000</span>));<span class="comment">//4015</span></span><br><span class="line">    System.out.println(<span class="string">&quot;12.3/100=&quot;</span>+(<span class="number">12.3</span>/<span class="number">100</span>));<span class="comment">//0.123</span></span><br><span class="line">    <span class="comment">//建议使用 BigDecimal进行 计算操作</span></span><br><span class="line">    <span class="comment">// BigDecimal bigDecimal1 = new BigDecimal(0.09);</span></span><br><span class="line">    <span class="comment">// BigDecimal bigDecimal2 = new BigDecimal(0.01);</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        BigDecimal创建出来的是对象，所以不能使用算数运算符进行计算，不可能对象+对象</span></span><br><span class="line"><span class="comment">        BigDecimal提供一套计算方法</span></span><br><span class="line"><span class="comment">        使用BigDecimal计算之后数据得到</span></span><br><span class="line"><span class="comment">        0.1799999999999999933386618522490607574582099914550781250</span></span><br><span class="line"><span class="comment">        这个值比double计算更加离谱，这个不是离谱，这个叫做“超级精度”</span></span><br><span class="line"><span class="comment">        BigDecimal在计算时或精确计算小数点后128位置</span></span><br><span class="line"><span class="comment">        通过观察JavaAPI文件发现 ---》BigDecimal中调用参数double类型构造方法时，有一个明确</span></span><br><span class="line"><span class="comment">的说明</span></span><br><span class="line"><span class="comment">        此构造方法的结果有一定的不可预知性,如果向BigDecimal中存储0.1这个double类型的数据</span></span><br><span class="line"><span class="comment">        传入到构造方法的值不会正好等于 0.1（虽然表面上等于该值），原因在与Java中是无法精确表</span></span><br><span class="line"><span class="comment">示0.1这个值</span></span><br><span class="line"><span class="comment">        所以存储到BigDecimal中得到结果等于</span></span><br><span class="line"><span class="comment">        0.1000000000000000055511151231257827021181583404541015625</span></span><br><span class="line"><span class="comment">        所以计算时就会得到一个BigDecimal的精确计算，所以不能调用参数为double类型</span></span><br><span class="line"><span class="comment">        BigDecimal构造方法来创建</span></span><br><span class="line"><span class="comment">BigDecimal对象</span></span><br><span class="line"><span class="comment">        建议在创建BigDecimal对象是，如果需要将数据存储到BigDecimal中建议使用，参数为</span></span><br><span class="line"><span class="comment">String类型构造方法</span></span><br><span class="line"><span class="comment">        因为&quot;0.1&quot;字符串它是一个常量，并且可以精准表示这个数据</span></span><br><span class="line"><span class="comment">        写入 new BigDecimal(&quot;0.1&quot;) 将创建一个 BigDecimal，它正好 等于预期的 0.1</span></span><br><span class="line"><span class="comment">        开发中，官方的一个建议，优先使用包装类中Double.toString(double类型数据)，将数据转</span></span><br><span class="line"><span class="comment">换为String类型</span></span><br><span class="line"><span class="comment">        然后调用BigDecimal中String类型参数构造方法创建对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">0.09</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> Double.toString(d);</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">bigDecimal1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(string);</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">bigDecimal2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.01&quot;</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        add --&gt; 求和 subtract --&gt; 减法 multiply --&gt; 乘法 divide --&gt;除法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    System.out.println(bigDecimal1.add(bigDecimal2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、基本用法"><a href="#2、基本用法" class="headerlink" title="2、基本用法"></a><center>2、基本用法</center></h2><p>位置：java.math包中</p><p>作用：精确计算浮点数</p><p>创建方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal bd=<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(“<span class="number">1.0</span>”);</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">方法名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">要运算的数变量名1.add(要运算的数变量名2)</td><td align="center">加</td></tr><tr><td align="center">要运算的数变量名1.subtract(要运算的数变量名2)</td><td align="center">减</td></tr><tr><td align="center">要运算的数变量名1.multiply(要运算的数变量名2)</td><td align="center">乘</td></tr><tr><td align="center">要运算的数变量名1.divide(要运算的数变量名2)</td><td align="center">除</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigDecimalDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//演示情况</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="number">0.9</span>;</span><br><span class="line">        System.out.println(d1-d2);  <span class="comment">//0.09999999999999998</span></span><br><span class="line">        <span class="comment">//因为：java中的浮点型在保存小数的时候是近似存储，所以计算的结果不准确</span></span><br><span class="line">        <span class="comment">//1、创建BigDecimal对象</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line">        System.out.println(b1.subtract(b2));    <span class="comment">//减</span></span><br><span class="line">        System.out.println(b1.add(b2)); <span class="comment">//加</span></span><br><span class="line">        System.out.println(b1.multiply(b2)); <span class="comment">//乘</span></span><br><span class="line">        <span class="comment">//除法运算：要设置保留位数和模式</span></span><br><span class="line">        <span class="comment">//ArithmeticException 算术异常</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 参数说明：</span></span><br><span class="line"><span class="comment">        * 参数1：被除数</span></span><br><span class="line"><span class="comment">        * 参数2：保留小数位数</span></span><br><span class="line"><span class="comment">        * 参数3：舍入模式</span></span><br><span class="line"><span class="comment">        *     ROUND_CEILING 向上取整</span></span><br><span class="line"><span class="comment">        *     ROUND_FLOOR 向下取整</span></span><br><span class="line"><span class="comment">        *     ROUND_HALF_UP 四舍五入</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.out.println(b1.divide(b2,<span class="number">2</span>,BigDecimal.ROUND_HALF_UP));<span class="comment">//除</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点十：BigInteger类"><a href="#知识点十：BigInteger类" class="headerlink" title="知识点十：BigInteger类"></a><center>知识点十：BigInteger类</center></h1><p>主要应用场景在于当我们遇到long类型都无法存储整数数据时，可以使用这个类型来进行存储计算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showBigInteger</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//参数类型要使用Sting类型</span></span><br><span class="line">    <span class="type">BigInteger</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line"><span class="title class_">BigInteger</span>(<span class="string">&quot;7777777777777777777777777777777777777&quot;</span> +</span><br><span class="line">        <span class="string">&quot;7777777777777777777777777777777777777777777777777777777777777777777777&quot;</span> +</span><br><span class="line">        <span class="string">&quot;777777777777777777777777777777777777777777777777777777777777&quot;</span>);</span><br><span class="line">    <span class="comment">//可以调用BigInteger中提方法进行计算</span></span><br><span class="line">    <span class="comment">//mod这个方法是求余数</span></span><br><span class="line">    <span class="type">BigInteger</span> <span class="variable">mod</span> <span class="operator">=</span> integer.mod(<span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;7&quot;</span>));</span><br><span class="line">    System.out.println(mod);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> integer.intValue();</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点十一：Runtime类"><a href="#知识点十一：Runtime类" class="headerlink" title="知识点十一：Runtime类"></a><center>知识点十一：Runtime类</center></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    每个Java 应用程序都有一个 Runtime 类实例，</span></span><br><span class="line"><span class="comment">    使应用程序能够与其运行的环境相连接。可以通过 getRuntime 方法获取当前运行时。</span></span><br><span class="line"><span class="comment">    Runtime这个实例就相当于是虚拟机</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showRuntime</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.获取正在运行虚拟机对象</span></span><br><span class="line">    <span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">    System.out.println(<span class="string">&quot;JVM的核心数量：&quot;</span>+runtime.availableProcessors());</span><br><span class="line">    System.out.println(<span class="string">&quot;JVM的总内存大小：&quot;</span>+(runtime.totalMemory()/<span class="number">1024</span>/<span class="number">1024</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;JVM的空闲内存大小：&quot;</span>+(runtime.freeMemory()/<span class="number">1024</span>/<span class="number">1024</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;JVM的最大内存大小：&quot;</span>+(runtime.maxMemory()/<span class="number">1024</span>/<span class="number">1024</span>));</span><br><span class="line">    <span class="comment">//2.通过runtime这个对象加快GC的回收</span></span><br><span class="line">    runtime.gc(); <span class="comment">//只能是加快，但是不是立即</span></span><br><span class="line">    <span class="comment">//3.终止虚拟机 如果是负数就是异常终止 如果正数就是正常终止</span></span><br><span class="line">    <span class="comment">//这个效果只有虚拟机中有，外界无法查看</span></span><br><span class="line">    runtime.exit(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;如果没有关闭我必然执行&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;知识点一：String类&quot;&gt;&lt;a href=&quot;#知识点一：String类&quot; class=&quot;headerlink&quot; title=&quot;知识点一：String类&quot;&gt;&lt;/a&gt;&lt;center&gt;知识点一：String类&lt;/center&gt;&lt;/h1&gt;&lt;h3 id=&quot;1、String</summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>18.接口</title>
    <link href="http://example.com/post/fe7ab1f0.html"/>
    <id>http://example.com/post/fe7ab1f0.html</id>
    <published>2023-12-30T05:07:26.000Z</published>
    <updated>2024-02-29T12:30:32.379Z</updated>
    
    <content type="html"><![CDATA[<p>PS：接口是一个特殊的抽象父类</p><p>什么接口?</p><p>&ensp;&ensp;&ensp;&ensp;硬件接口：指的是两个硬件设备之间的链接方式,硬件接口即包括物理上接口，还包括逻辑上接口(数据传输协议)</p><p>&ensp;&ensp;&ensp;&ensp;软件接口：程序代码,特殊的抽象类，表示的是一种规范,是具有N个方法的特征的集合在封装的时候，手机大多会留有一个接口，这个接口就会出现充电和耳机要遵守的一些协议,,通过这些协议可以约束数据可以通过什么样的方式来进行数据的传输(多使用在硬件的方向)</p><p>&ensp;&ensp;&ensp;&ensp;在Java中，接口表示一种规范&#x2F;约束&#x2F;要求实现者必须遵守该规范,约束使用这该怎么做，Java中接口还可以解决一些非继承关系的问题例如：飞机是会飞的,鸟也是可以飞,这两个类有一个共同行为叫做飞，飞机和鸟能是一个共同的父类？不能，即想约束飞机和鸟必须存在飞的这个方法，又不提供继承的这种样式操作，接口就可以做到这个效果</p><p>&ensp;&ensp;&ensp;&ensp;接口无非就是在设计一套要遵守的行为规范，但是这个规范并没有强加联系(彼此之间不是强关联[继承关系])，而是约束关系,如果要象按照这个规则形式就必须实现接口</p><p>&ensp;&ensp;&ensp;&ensp;接口只是定义类应当遵守的规范，却不不关心这些类内部数据和其功能的具体实现细节,站在程序角度上接口只规定了类中必提供方法，从而分析了规范和实现,增强了可扩性和可维护性</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271927662.jpg" alt="接口分析" style="zoom: 50%;"><p>&ensp;&ensp;&ensp;&ensp;避开继承关系，又能约束子类必须实现某些方法，可以提供接口，接口中提供方法就是对类的约束【必须实现这些方法，否则无法使用】</p><h1 id="知识点一：基本语法"><a href="#知识点一：基本语法" class="headerlink" title="知识点一：基本语法"></a><center>知识点一：基本语法</center></h1><h2 id="1、语法"><a href="#1、语法" class="headerlink" title="1、语法"></a><center>1、语法</center></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java中现在接口可以分为两个版本：</span></span><br><span class="line">Java8之间版本【不包含Java8】</span><br><span class="line"><span class="keyword">public</span> interface 接口名字</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> 数据类型 常量名 = 值;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> 返回值类型 方法名(参数列表);</span><br><span class="line">&#125; </span><br><span class="line">Java8之后版本【包含Java8】</span><br><span class="line"><span class="keyword">public</span> interface 接口名字</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> 数据类型 常量名 = 值;    <span class="comment">//静态常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> 返回值类型 方法名(参数列表);   <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> 返回值类型 方法名(参数列表)<span class="comment">//它就是类中成员方法</span></span><br><span class="line">    &#123; </span><br><span class="line">        提供方法实现</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> 返回值类型 方法名(参数列表)    <span class="comment">//他就是类中静态方法</span></span><br><span class="line">    &#123; </span><br><span class="line">        提供方法实现</span><br><span class="line">        <span class="keyword">return</span>；</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">    PS：从Java9开始允许接口中定义 <span class="keyword">private</span> 方法</span><br><span class="line"><span class="comment">//实现接口：</span></span><br><span class="line"><span class="keyword">public</span> class 实现类(子类) implements 接口</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口中只能包含：</p><p>&ensp;&ensp;&ensp;&ensp;公开的静态常量</p><p>&ensp;&ensp;&ensp;&ensp;公开的抽象方法</p><p>&ensp;&ensp;&ensp;&ensp;不能有普通属性、构造方法、静态代码块</p><h2 id="2、特点"><a href="#2、特点" class="headerlink" title="2、特点"></a><center>2、特点</center></h2><ol><li>接口是没有构造方法的，所以接口就更不可能直接创建对象</li></ol><p>即 接口名 对象名 &#x3D; new 接口名(); —-》这种操作是不可实现</p><ol start="2"><li>上面语法中体现修饰符【public、static 、final、abstract】，都可以省略不写，接口是默认修饰原则，自动</li></ol><p>就添加了【static方法中static不可以省略，default方法中default不可以省略】</p><ol start="3"><li>接口本意是让类来实现约束使用，所以接口修饰必须是public</li><li>接口和类之间关系【实现关系】（其实这个关系就是隐式继承）</li></ol><p>&ensp;&ensp;&ensp;&ensp;可以将接口看做是父类 实现接口类是子类</p><ol start="5"><li>类与接口建立联系时使用的【实现关系】，所以使用关键字是【 implements】</li><li>因为接口与类之间是【实现关系（隐式继承）】，所以接口支持多态并且接口是引用类型</li></ol><p>7、接口中只能有抽象方法</p><p>8、接口中的抽象方法必须要被非抽象类重写</p><p>例：提供一个接口文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterfaceForJDK_8</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1. 可以在接口中定义静态全局常量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">NUM</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//接口是一个默认修饰原则 ---》等价于 --》 public static final int</span></span><br><span class="line">    NUM = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//2.提供抽象方法的定义</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;<span class="comment">//接口是一个默认修饰原则 ---》等价于 --》 public abstract void show();</span></span><br><span class="line">    <span class="comment">//3.允许接口中提供default方法【这个方法带有方法体（相当于是类中成员方法），实现接口子类可以重写这个方法】</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">showInfosDefault</span><span class="params">()</span><span class="comment">//接口是一个默认修饰原则 ---》等价于 --》 public</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">showInfosDefault</span><span class="params">()</span></span><br><span class="line">        System.out.println(<span class="string">&quot;接口中default方法&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//4.允许接口中提供static方法【这个方法带有方法体（相当于是类中静态方法），实现接口子类不可以重写这个方法】</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showInfosStatic</span><span class="params">()</span>    <span class="comment">//接口是一个默认修饰原则 ---》等价于--》public</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showInfosStatic</span><span class="params">()</span></span><br><span class="line">        System.out.println(<span class="string">&quot;接口中static方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>普通类如果实现接口，必须实现接口中所有抽象方法【接口利用抽象方法约束类进行方法实现操作】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">InterfaceForJDK_8</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;实现接口中show方法&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;可以在接口的实现类中调用接口中定义全局常量：&quot;</span>+NUM);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//选择向重写接口中提供default方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showInfosDefault</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这里就间接证明类与接口属于间接继承效果</span></span><br><span class="line">        <span class="comment">//InterfaceForJDK_8.super.showInfosDefault();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;重写接口中default方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.可以使用接口的实现类创建对象完成操作</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.show();</span><br><span class="line">        person.showInfosDefault();</span><br><span class="line">        <span class="comment">//接口与类之间虽然是实现关系，但是属于隐式继承，所以可以使用多态效果创建接口对象</span></span><br><span class="line">        <span class="type">InterfaceForJDK_8</span> <span class="variable">interfaceForJDK8</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        interfaceForJDK8.show();</span><br><span class="line">        interfaceForJDK8.showInfosDefault();</span><br><span class="line">        <span class="comment">//接口中静态方法与常量只能使用接口名调用</span></span><br><span class="line">        InterfaceForJDK_8.showInfosStatic();</span><br><span class="line">        System.out.println(InterfaceForJDK_8.NUM);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、接口使用时注意事项"><a href="#3、接口使用时注意事项" class="headerlink" title="3、接口使用时注意事项"></a><center>3、接口使用时注意事项</center></h2><ol><li>在开发中设计接口时，接口名字，都是以大写字母【I】开头，除非单词首字符是【I】除外，代表是一个接口，接口实现类命名在最后单词结尾要添加Impl，代表实现接口类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IPerson</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showInfosPerson</span><span class="params">()</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonImpl</span> <span class="keyword">implements</span> <span class="title class_">IPerson</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showInfosPerson</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>一类可以实现多个接口【相当于是多继承模拟】,接口名逗号分隔，并给还可以继承另外一个类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IPerson</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showInfosPerson</span><span class="params">()</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IStudent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showInfosStudent</span><span class="params">()</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Man</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OldMan</span> <span class="keyword">extends</span> <span class="title class_">Man</span> <span class="keyword">implements</span> <span class="title class_">IPerson</span>,IStudent&#123;&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>接口和接口之间存在继承关系，而且允许多继承【可以得到继承接口中所有操作】</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IPerson</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showInfosPerson</span><span class="params">()</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IStudent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showInfosStudent</span><span class="params">()</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IMan</span> <span class="keyword">extends</span> <span class="title class_">IPerson</span>,IStudent&#123;&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>可以使用抽象类实现接口，选择性实现接口中抽象方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IStudent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showInfosStudent</span><span class="params">()</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ManImpl</span> <span class="keyword">implements</span> <span class="title class_">IStudent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//抽象类可以选择性实现接口中抽象方法，也可以不实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点二：接口的作用"><a href="#知识点二：接口的作用" class="headerlink" title="知识点二：接口的作用"></a><center>知识点二：接口的作用</center></h1><h2 id="1、从微观上讲"><a href="#1、从微观上讲" class="headerlink" title="1、从微观上讲"></a><center>1、从微观上讲</center></h2><p>作用：扩充类的能力</p><p>原因：一个类只能继承一个父类，如果父类提供的方法不能满足子类的时候，这是我们可以通过实现接口的方式，为这个扩容功能。一个类可以实现多个接口</p><p>Animal类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> <span class="comment">//父类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;睡&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dog类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>,Swimming  <span class="comment">//子类 （Dog已经拥有两个能力(吃\睡)）</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//需要为Dog扩充跑的能力</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;跑...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//需要为Dog扩充游泳的能力</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swimm</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;游泳...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Runnable接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span>   <span class="comment">//能力</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//跑的方法  跑的能力</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Swimming接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Swimming</span>   <span class="comment">//能力</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//游泳能力</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swimm</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        dog.eat();  <span class="comment">//从父类继承而来</span></span><br><span class="line">        dog.sleep();    <span class="comment">//从父类继承而来</span></span><br><span class="line">        dog.run();  <span class="comment">//通过接口而扩展的能力</span></span><br><span class="line">        dog.swimm();    <span class="comment">//通过Swimming接口而扩展的能力</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、从宏观上讲"><a href="#2、从宏观上讲" class="headerlink" title="2、从宏观上讲"></a><center>2、从宏观上讲</center></h2><p>作用：定义类的约束</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271927680.jpg" alt="接口宏观1" style="zoom: 67%;"><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271928512.jpg" alt="接口宏观2" style="zoom:67%;"><p>Produact类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Produact</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> id; <span class="comment">//商品的id（唯一表示）</span></span><br><span class="line">      String name;   <span class="comment">//商品名称</span></span><br><span class="line">     <span class="type">double</span> price;   <span class="comment">//商品价格</span></span><br><span class="line">​</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Produact</span><span class="params">(<span class="type">int</span> id, String name, <span class="type">double</span> price)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Produact</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getPrice</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">double</span> price)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProductService接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个接口是在定义标准，定义规范，未来对于商品的操作，必须要按照一下标准进行编写</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductService</span>     <span class="comment">//增删改查</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//增加</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addProduct</span><span class="params">(Produact produact)</span>;</span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteProduct</span><span class="params">(<span class="type">int</span> id)</span>;    <span class="comment">//id是唯一的的，所以删除操作是按照id进行删除</span></span><br><span class="line">    <span class="comment">//修改</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">updateProduct</span><span class="params">(Produact produact)</span>;</span><br><span class="line">    <span class="comment">//查询</span></span><br><span class="line">    Produact[] selectProduct();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProductServiceImpl类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">ProductService</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addProduct</span><span class="params">(Produact produact)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteProduct</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateProduct</span><span class="params">(Produact produact)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Produact[] selectProduct()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Produact</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//面向接口编程，父类的引用指向子类对象（多态）</span></span><br><span class="line">        <span class="type">ProductService</span> <span class="variable">productService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProductServiceImpl</span>();</span><br><span class="line">        productService.addProduct(<span class="literal">null</span>);</span><br><span class="line">        productService.updateProduct(<span class="literal">null</span>);</span><br><span class="line">        productService.deleteProduct(<span class="number">1</span>);</span><br><span class="line">        productService.selectProduct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点三：接口的关系"><a href="#知识点三：接口的关系" class="headerlink" title="知识点三：接口的关系"></a><center>知识点三：接口的关系</center></h1><h2 id="1、类与类的关系"><a href="#1、类与类的关系" class="headerlink" title="1、类与类的关系"></a><center>1、类与类的关系</center></h2><p>在Java中，类与类是继承关系，只能单继承（extends）</p><h2 id="2、类与接口的关系"><a href="#2、类与接口的关系" class="headerlink" title="2、类与接口的关系"></a><center>2、类与接口的关系</center></h2><p>在Java中，类与接口是实现，可以多实现（implements）</p><h2 id="3、接口与接口的关系"><a href="#3、接口与接口的关系" class="headerlink" title="3、接口与接口的关系"></a><center>3、接口与接口的关系</center></h2><p>在Java中，接口与接口是继承关系，接口与接口之间是多继承（extends）</p><h2 id="4、接口常量"><a href="#4、接口常量" class="headerlink" title="4、接口常量"></a><center>4、接口常量</center></h2><p>接口只有公开的静态常量（在接口中定义很多的静态常量（用于表示状态（已支付、未支付、支付未发货、已收货….）））</p><p>在以后开发中可以使用枚举来替代</p><h1 id="知识点四：接口回调"><a href="#知识点四：接口回调" class="headerlink" title="知识点四：接口回调"></a><center>知识点四：接口回调</center></h1><p>先有接口的使用者，后有接口的实现者</p><p>MyClass类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">MyInterface</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//后有接口的实现者</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isZS</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; num; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyInterface接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyInterface</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断一个数是否是质数</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isZS</span><span class="params">(<span class="type">int</span> num)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        gdbh(<span class="number">14</span>,<span class="keyword">new</span> <span class="title class_">MyClass</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先有接口的使用者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">gdbh</span><span class="params">(<span class="type">int</span> num,MyInterface myInterface)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(num &lt; <span class="number">6</span> || num % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;传入参数不合法&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= num/<span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (myInterface.isZS(i) &amp;&amp; myInterface.isZS(num-<span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(num + <span class="string">&quot;=&quot;</span> + i + <span class="string">&quot;+&quot;</span> + (num-i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点五：内部类"><a href="#知识点五：内部类" class="headerlink" title="知识点五：内部类"></a><center>知识点五：内部类</center></h1><p>PS:被称之为“万恶的内部类”，对于JavaEE开发 或 大数据开发而言，内部类近乎于不会在开发中出现，内部可以达到的效果可以完成一些数据结构的实现【链表 或 树等等】，在Android开发中内部会大量使用</p><p>Java中内部类分为以下4种：</p><ol><li>成员内部类, 内部类在定义时没有使用static修饰（知晓）</li><li>静态内部类，内部类在定义时使用static修饰【Java中唯一可以使用static修饰类的方法】（知晓）</li><li>局部内部类，内部类在定义时定义在方法体内部（了解）</li><li>匿名内部类，它属于局部类类的特殊形态（必须会用）</li></ol><p>内部类也是类，所以也会被JVM进行编译生成字节码文件【.class文件】</p><ol><li>成员内部类生成字节码文件： 外部类类名$成员内部类类名.class</li><li>静态内部类生成字节码文件： 外部类类名$静态内部类类名.class</li><li>局部内部类生成字节码文件： 外部类类名$数字局部内部类类名.class</li><li>匿名内部类生成字节码文件： 外部类类名$数字.class</li></ol><p>PS： 数字是从1开始逐渐递增【随着类的增加而增加】</p><h2 id="1、含义"><a href="#1、含义" class="headerlink" title="1、含义"></a><center>1、含义</center></h2><p>定义在一个类的里面的类为内部类，在外面的类成为外部类</p><h2 id="2、内部类的分类"><a href="#2、内部类的分类" class="headerlink" title="2、内部类的分类"></a><center>2、内部类的分类</center></h2><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>外部类可以使用权限修饰符为 public 和 默认的和abstract，成员内部类可以使用【4种权限修饰符和abstract修饰】，可以将<strong>成员内部类看做就是在类中声明成员变量或成员方法，所以成员内部类是属于对象的</strong></p><p>外部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outter</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//外部类中提供成员变量和方法、静态变量和方法</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;小白&quot;</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showInfos</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;外部类静态方法&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;外部类的成员方法&quot;</span>);</span><br><span class="line">        <span class="comment">//需要提供内部类对象创建，才可以使用成员内部类中所提供成员变量和成员方法</span></span><br><span class="line">        <span class="type">InnerClass</span> <span class="variable">innerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">        innerClass.name =<span class="string">&quot;z&quot;</span>;</span><br><span class="line">        innerClass.show();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提供成员内部类 ---》 成员内部类就是定义在类中类，可以使用任何修饰符除static外</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span>    <span class="comment">//成员内部类</span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">//可以在成员内部类中提供类的基础定义，但是不可以提供static修饰的属性和方法</span></span><br><span class="line">        <span class="comment">//static double PI = 3.14;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;小黑&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;成员内部类中成员方法&quot;</span>);</span><br><span class="line">            <span class="comment">//如果说在成员内部类中调用与外部类同名属性</span></span><br><span class="line">            <span class="comment">//this代表的是InnerClass对象，所以使用this.name</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.name);</span><br><span class="line">            <span class="comment">//这种方式访问外部类的成员变量</span></span><br><span class="line">            System.out.println(Outter.<span class="built_in">this</span>.name);</span><br><span class="line">            <span class="comment">//调用外部类的成员方法【如果没有重名的效果，就不需要使用，外部类类名.this.方式调用】</span></span><br><span class="line">            display();</span><br><span class="line">            System.out.println(PI);</span><br><span class="line">            <span class="comment">//成员内部类中是可以调用外部类静态属性和方法</span></span><br><span class="line">            System.out.println(age);</span><br><span class="line">            showInfos();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如何在外部创建成员内部类的对象</span></span><br><span class="line">        <span class="comment">//成员内部类是属于外部类所有的，所以提供方式就是</span></span><br><span class="line">        <span class="comment">// 外部类类名.内部类类名 内部类对象名 = new 外部类().new 成员内部类();</span></span><br><span class="line">        Outter.<span class="type">InnerClass</span> <span class="variable">innerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outter</span>().<span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">        innerClass.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结： 成员内部类是定义在类中，不使用static修饰，可以使用4种权限修饰符，可以使用abstract和final修饰，允许继承类与实现接口，成员内部类中不可以定义static修饰变量与方法，成员内部类是可以直接访问外部类定义属性和方法，<strong>如果成员内部类出现了与外部类属性重名，可以使用【this 和 外部类.this】进行区分</strong>，外部类要访问成员内部类的属性和行为时，提供成员内类的对象—》 </p><p><strong>外部类类名.内部类类名 内部类对象名 &#x3D; new 外部类().new 内部类();</strong></p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类和成员内部类几乎与是一样的，唯一不点在于静态内部类使用static进行了修饰</p><p>PS：这是Java中类唯一可以使用static修饰的形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//外部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//外部类中提供成员变量和方法、静态变量和方法</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;小白&quot;</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showInfos</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;外部类静态方法&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;外部类的成员方法&quot;</span>);</span><br><span class="line">        <span class="comment">//调用静态内部类中静态属性和方法 ---》 静态内部类类名.静态属性和静态方法即可</span></span><br><span class="line">        System.out.println(InnerClass.name);    <span class="comment">//如果要跨类调用，则需要前面加上外部类的类名</span></span><br><span class="line">        <span class="comment">//调用静态内部类中成员属性和方法 ---》 需要提供静态内部类的对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Outter</span>.InnerClass().show();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//提供静态成员内部类 ---》 静态内部类就是定义在类中类，可以使用static修饰符修饰</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span>    <span class="comment">//静态内部类</span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// 静态内部类可以提供普通类中所有可以提供操作【成员变量和方法、静态变脸和方法】</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.15</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;小黑&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//在静态内部类中是不用担心 属性重名问题</span></span><br><span class="line">            <span class="comment">//不是可以使用 外部类类名.this方法访问外部的属性【static中是不允许使用this和super关键字】</span></span><br><span class="line">            <span class="comment">//只能在静态内部类中创建外部类对象，才可以访问外部类成员变量和成员方法</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">Outter</span>().name);</span><br><span class="line">            <span class="comment">//调用外部类静态方法和静态属性 --&gt; 外部类类名.静态属性或静态方法即可</span></span><br><span class="line">            System.out.println(Outter.age);</span><br><span class="line">            Outter.showInfos();</span><br><span class="line">            <span class="comment">//静态内部类中的属性和方法直接调用即可</span></span><br><span class="line">            System.out.println(PI);</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//提供静态内部类对象创建</span></span><br><span class="line">        <span class="comment">//外部类类名.静态内部类类名 对象名 = new 外部类类名.静态内部类类名();</span></span><br><span class="line">        Outter.<span class="type">InnerClass</span> <span class="variable">innerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outter</span>.InnerClass();</span><br><span class="line">        innerClass.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结： 静态内部就是使用static修饰类【Java中只有这个类可以使用static修饰】，可以使用所有权限修饰符，abstract和final修饰，静态内部类和静态属性和静态方法是一样都属于类，静态内部类中是可以定义【成员变量和方法、静态变量和方法】，静态内部类中不允许明确访问方式获取外部类this对象即【外部类类名.this】,所以在静态内部类中访问外部类成员变量和成员方法，需要提供外部对象才可以，外部类静态变量和静态方法直接访问即可，如果有重名【外部类类名.静态变量&#x2F;静态方法】</p><p>静态内部类如果要创建对象</p><p>&ensp;&ensp;&ensp;&ensp;外部类类名.静态内部类类名 对象名 &#x3D; new 外部类类名.静态内部类类名();</p><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>这个内部类不允许使用任何修饰符，只能定义在方法内部与局部变量是平级关系，<strong>访问作用域仅限在方法的内部</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//外部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outter</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供一个成员方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//局部变量</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line">        <span class="comment">//提供局部内部类【局部变量是平级关系】</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">InnerClass</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//局部内部类中是不允许定义static修饰属性和方法</span></span><br><span class="line">            <span class="comment">//允许提供成员变量和成员方法</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">gender</span> <span class="operator">=</span> <span class="string">&quot;男&quot;</span>;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//在局部内部类中访问方法中局部变量</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    IDEA提供错误提示信息</span></span><br><span class="line"><span class="comment">                    Variable &#x27;age&#x27; is accessed from within inner class, needs to be</span></span><br><span class="line"><span class="comment">final or effectively final</span></span><br><span class="line"><span class="comment">                    如果局部内部类使用方法提供的局部变量，这个局部变量必须是final修饰</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                System.out.println(age);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//局部内部类只能在方法体的内部创建对象和使用，外界是无法访问到这个类中</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InnerClass</span>().display();</span><br><span class="line">        <span class="comment">//在此在方法体的内部修改成员变量</span></span><br><span class="line">        <span class="comment">// age = 20;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么，局部内部类访问局部变量之后需要使用final声明？</p><p>&ensp;&ensp;&ensp;&ensp;final修饰局部变量的存储空间会发生改变,存储不再是栈中，而是方法区中常用池，局部变量就会变成“引用”常量</p><p>&ensp;&ensp;&ensp;&ensp;局部内部类是声明在方法体内部，就会存在一个问题，局部内部类是随着方法而开始创建空间，随着方法消亡开始回收空间，如果在方法内声明局部变量存储空间是栈【随着方法开始而创建随着方法消亡会销毁】，如果局部内部类使用了这个局部变量，那么堆中地址就会和栈中位置产生一个联系，堆中局部内部类就会引用到栈中局部变量，如果发生方法执行完毕，栈中空间空间会进行立即回收，但是堆中局部内部类是不会被立即回收【GC机制】，就会出现堆栈存在一个“指向空”引用，内报错了，所以使用final修饰符将局部变量修改为局部常量，将存储从栈中移动到方法区中常量池，这样一来就算栈中空间被回收，但是方法区种空间还在，所以可以等待堆中局部内部正常回收之后断练习，保证不会出现引用错误</p><p>注意：局部内部类只能访问局部常量</p><p>&ensp;&ensp;&ensp;&ensp;原因：局部变量在方法结束之后就会被销毁，而局部内部类是由垃圾回收器回收进行销毁，由于垃圾回收器的销毁时间不确定有可能在方法结束之后还没被销毁，所以有可能对象还在变量早没了</p><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>&ensp;&ensp;&ensp;&ensp;匿名内部类是局部类型的一种特殊属性形式，<strong>匿名内部类主要的作用就是提供便捷接口实现</strong></p><p>&ensp;&ensp;&ensp;&ensp;在某些情况下，会使用接口作为方法参数存在，如果需要将接口实现类传递到这个方法中时，需要创建一个类并实现接口，通过当前类创建对象并将当前对象传递给当前方法参数进行赋值操作，这样一来方法内部就可以 操作接口对象【利用多态—》接口与类之间是隐式继承，可以将接口看做是类父类，实现类是接口子类】</p><p>&ensp;&ensp;&ensp;&ensp;但是，某些方法进行接口参数传递时，只会使用这一次接口操作【即调用方法的位置使用一次接口就结束】，创建类实现接口，在创建类对象传递到方法中操作就十分繁琐，而且类只会方法中使用一次，类的存在就没有太大意义，不便于管理，【<strong>所有在这种情况下，就可以利用匿名内部类方式完成对接口实现并传递到方法参数中</strong>】</p><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽烟接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ISmoking</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 抽烟方法</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name 抽烟的名字</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">smoke</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照以往的方法实现接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outter</span> <span class="keyword">implements</span> <span class="title class_">ISmoking</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">smoke</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在抽的烟是:&quot;</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//调用抽烟方法展示抽象操作</span></span><br><span class="line">        <span class="comment">//1.提供实现ISmoking接口对象</span></span><br><span class="line">        <span class="type">Outter</span> <span class="variable">outter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outter</span>();</span><br><span class="line">        <span class="comment">//2.通过outter对象调用smoke方法就可以执行抽烟操作</span></span><br><span class="line">        outter.smoke(<span class="string">&quot;华子&quot;</span>);</span><br><span class="line">        <span class="comment">//这个方法可以接收的对象必须是实现ISmoking接口的对象【利用就是面向兑现中多态】</span></span><br><span class="line">        showInfosSmokeName(outter);</span><br><span class="line">        <span class="comment">//但是，如果当前实现接口类只使用一次，不在重复使用了，这样创建方式就比较繁琐也不利于管理</span></span><br><span class="line">        <span class="comment">//所以Java就提供了一个更加便捷处理方式，提供匿名内部类作为接口的实现操作</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            第一种 主要是针对与方法参数为接口类型进行赋值操作 --》完全匿名内部类</span></span><br><span class="line"><span class="comment">            new 接口名()</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                提供接口中抽象方法的实现;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ISmoking</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">smoke</span><span class="params">(String name)</span> </span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;完全匿名内部类实现接口：&quot;</span>+name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.smoke(<span class="string">&quot;芙蓉王&quot;</span>); <span class="comment">//这种形式主要是针对方法参数赋值使用的</span></span><br><span class="line">        <span class="comment">//调用smoke方法而不是对于方法参数传递</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            第二种方式，针对匿名内部类所创建对象进行存储操作</span></span><br><span class="line"><span class="comment">            接口名 对象名 = new 接口名()</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                接口抽象方法的实现</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//smoking 存储的就是匿名内部类的引用【使用 new ISmoking的形式将后面的匿名内部类进</span></span><br><span class="line">        行对象向上转型】</span><br><span class="line">        <span class="type">ISmoking</span> <span class="variable">smoking</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ISmoking</span>() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">smoke</span><span class="params">(String name)</span> </span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;使用匿名内部类创建了接口对象：&quot;</span>+name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        smoking.smoke(<span class="string">&quot;煊赫门&quot;</span>);</span><br><span class="line">        <span class="comment">//可以使用匿名内部类的这种语法便捷的对方法中参数进行赋值操作</span></span><br><span class="line">        showInfosSmokeName(<span class="keyword">new</span> <span class="title class_">ISmoking</span>() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">smoke</span><span class="params">(String name)</span> </span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类对接口参数赋值：&quot;</span>+name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);    <span class="comment">// 使用匿名内部类形式对接口参数进行赋值操作</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//提供一个方法这个方法的参数类型是接口类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showInfosSmokeName</span><span class="params">(ISmoking smoking)</span></span><br><span class="line">    &#123;</span><br><span class="line">        smoking.smoke(<span class="string">&quot;小熊猫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;&ensp;&ensp;匿名内部类就是提供接口便捷实现方式，并赋值给方法中使用接口作为参数类型，但是接口实现不能太复杂，只会使用一次这样方式是最便捷的</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271928787.jpg" alt="接口例程结果" style="zoom: 50%;"><p>特点：</p><p>&ensp;&ensp;&ensp;&ensp;1）匿名内部类本身是一个对象</p><p>&ensp;&ensp;&ensp;&ensp;2）匿名内部类的父类通常是接口或者抽象（为了可以重写然后调用）</p><p>&ensp;&ensp;&ensp;&ensp;3）匿名内部类一般不会定义自己的属性和方法</p><p>&ensp;&ensp;&ensp;&ensp;4）匿名内部类最多场景就是在方法的参数为接口的时候使用</p><h1 id="知识点六：Lambda"><a href="#知识点六：Lambda" class="headerlink" title="知识点六：Lambda"></a><center>知识点六：Lambda</center></h1><h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a><center>1、介绍</center></h2><p>PS： λ（lambda符号）希腊文，Lambda是Java8中提供新特性【也是最值得学习的新特性之一】，Lambda的操作在其他语言中也别广泛的使用，Lambda是Java8中提供一个新特性而已</p><p>&ensp;&ensp;&ensp;&ensp;Lambda表达式的目的在Java中是为了解决匿名内部类繁琐实现</p><p>&ensp;&ensp;&ensp;&ensp;Lambda表达式的引入也代表着Java正式进入到【函数式编程】</p><p>PS:2014年【移动互联网结束Android和IOS】—》VR&#x2F;AR、人工智能、大数据【三个风口】人工智能（python –》【爬虫】）、大数据（Java【hadoop&#x2F;spark】)【二个风口】–》2021年元宇宙【新风口 —-》VR&#x2F;AR】 —》 后台【首选Java】</p><p>什么是函数式编程？</p><p>&ensp;&ensp;&ensp;&ensp;函数式编程被称为函数式程序设计，首先它是一个规范，它是将函数逻辑应用到电脑编程，将编程视为一个一个函数，它允许函数作为输入【引用】和输出【传出数据】操作，完成代码的编辑</p><p>Lambda表达式在作用</p><p>&ensp;&ensp;&ensp;&ensp;就是简化匿名内部类实现代码作为方法接口实现参数的传递</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaDemo1</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//lambda表达式于匿名内部类之间区别</span></span><br><span class="line">        <span class="comment">//提供一个Integer类型数据【Integer理解为int类型】</span></span><br><span class="line">        Integer[] arr = &#123;<span class="number">23</span>,<span class="number">4132</span>,<span class="number">2</span>,<span class="number">123</span>,<span class="number">512345</span>,<span class="number">2463</span>,<span class="number">2234</span>,<span class="number">343</span>&#125;;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            在Arrays工具类中有有一个排序方法，可以提供方给我们使用</span></span><br><span class="line"><span class="comment">            这个方法中有两个参数版本，这个版本中第二个参数就是接口，这个接口叫做Comparator</span></span><br><span class="line"><span class="comment">接口</span></span><br><span class="line"><span class="comment">            Comparator接口是一个比较接口，对接口进行实现来执行排序的方式</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Arrays.sort(arr, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> o2-o1; <span class="comment">//降序</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;arr数据排序之后：&quot;</span>+Arrays.toString(arr));</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            使用匿名内部类实现起来是比较繁琐的，代码太多了，看起来会比较繁琐</span></span><br><span class="line"><span class="comment">            此时就可以利用Lambda表达式代替匿名内部的实现进行方法中接口参数的传递操作</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Arrays.sort(arr,((o1,o2)-&gt;o2-o1));</span><br><span class="line">        System.out.println(<span class="string">&quot;lambda表达式的实现排序：&quot;</span>+Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：Lambda表达式的实现形式也是将来学习StreamAPI【流式编程】必备的语法</p><p>&ensp;&ensp;&ensp;&ensp;Lambda表达式与匿名内部类一样，适合一次使用的效果，多次重复使用Lambda表达式就不是很便捷【根匿名内部类一样】，但是Lambda表达式可以更加便捷实现，替换匿名内部类的繁琐实现</p><h2 id="2、语法"><a href="#2、语法" class="headerlink" title="2、语法"></a><center>2、语法</center></h2><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">()-&gt;&#123;&#125; 或者 (参数)-&gt;&#123;&#125;</span><br></pre></td></tr></table></figure><p>PS：Lambda语法对应不是接口【public interface 接口名】，Lambda对应是接口中抽象方法</p><p>&ensp;&ensp;&ensp;&ensp;<strong>所以将Lambda表达式理解为是接口中抽象方法实现</strong></p><p>&ensp;&ensp;&ensp;&ensp;Lambda表达式中 () 【小括号】对应就是 抽象方法的 ()【小括号】 –》抽象方法参数列表</p><p>&ensp;&ensp;&ensp;&ensp;你定义【实现】抽象方法有参数列表，使用Lambda表达式实现时候就需要添加参数</p><p>&ensp;&ensp;&ensp;&ensp;Lambda表达式可以根据实现抽象方法中参数列表态推断数数据类型，所以在Lambda表达式中定义参数时，可以省略数据类型，指定义参数名字即可</p><p>详细说明：</p><p>&ensp;&ensp;&ensp;&ensp;Lambda表达式中小括号【()】 : Lambda表达式中参数定义位置，它是与对应实现接口中抽象方法与之对应，抽象方法中有参数有什么Lambda中就有参数定义，抽象方法中没有参数那么Lambda中就没有参数定义，并且Lambda表达式可以省略参数数据类型【提供自动推断】</p><p>&ensp;&ensp;&ensp;&ensp;Lambda表达式中箭头指向【-&gt;】: 没有任何特殊意义，就是语法要求</p><p>PS：理解方法引用—》C语言 —-》函数指针【指针函数】</p><p>&ensp;&ensp;&ensp;&ensp;Lambda表达式中大括号【{}】：和方法中大括号是一个概念，代表方法的实现体，即的对抽象方法的具体实现，代表着Lambda表达式中对抽象方法的具体实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提供多个接口分别使用Lambda表达式实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterfaceA</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showA</span><span class="params">()</span>;<span class="comment">//定义一个无参的抽象方法</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">InterfaceB</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showB</span><span class="params">(<span class="type">int</span> b)</span>;<span class="comment">//定义一个有一个参数抽象方法</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">InterfaceC</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showB</span><span class="params">(<span class="type">int</span> c,<span class="type">int</span> d)</span>;<span class="comment">//定义一个有两个参数抽象方法</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">InterfaceD</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">showD</span><span class="params">(<span class="type">int</span> c,<span class="type">int</span> d)</span>;<span class="comment">//定义一个带有返回值和多个参数的方法</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在这个类中main中方法中使用Lambda表达式实现接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Lambda表达式对应的是接口中抽象方法 接口中抽象方法是如何定义的Lambda表达式就仿</span></span><br><span class="line">        照定义</span><br><span class="line">        <span class="comment">//1.使用Lambda表达式实现一个接口【抽象方法是无返回值无参的状态】</span></span><br><span class="line">        <span class="type">InterfaceA</span> <span class="variable">a1</span> <span class="operator">=</span> () -&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Lambda表达式实现接口中showA方法&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//调用接口中方法</span></span><br><span class="line">        a1.showA();</span><br><span class="line">        <span class="comment">//如果lambda表达式对抽象方法实现方式体只有一句代码可以省略大括号</span></span><br><span class="line">        <span class="type">InterfaceA</span> <span class="variable">a2</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;Lambda表达式实现接口中showA方法&quot;</span>);</span><br><span class="line">        <span class="comment">//2.使用Lambda表达式实现一个接口【抽象方法是无返回值有一个参数的状态】</span></span><br><span class="line">        <span class="type">InterfaceB</span> <span class="variable">b1</span> <span class="operator">=</span> (<span class="type">int</span> b) -&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Lambda表达式实现接口中showB方法：&quot;</span>+b);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//Lambda表达式可以对定义参数提供自动类型推断，省略参数中定义数据类型</span></span><br><span class="line">        <span class="type">InterfaceB</span> <span class="variable">b2</span> <span class="operator">=</span> (b) -&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Lambda表达式实现接口中showB方法：&quot;</span>+b);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//Lambda表达式实现抽象方法是一个参数的，可以省略数据类型和小括号</span></span><br><span class="line">        <span class="comment">//如果实现方法体只有一句代码可以省略大括号</span></span><br><span class="line">        <span class="type">InterfaceB</span> <span class="variable">b3</span> <span class="operator">=</span> b -&gt; System.out.println(<span class="string">&quot;Lambda表达式实现接口中showB方法：&quot;</span>+b);</span><br><span class="line">        <span class="comment">//3.使用Lambda表达式实现一个接口【抽象方法是无返回值有多个参数的状态】</span></span><br><span class="line">        <span class="comment">//直接利用上面所提供有些优化策略直接操作者【数据类型自定推断（省略参数类型）】</span></span><br><span class="line">        <span class="type">InterfaceC</span> <span class="variable">c1</span> <span class="operator">=</span> (c,d)-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Lambda表达式实现抽象方法showC&quot;</span>+(c+d));</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//4.使用Lambda表达式实现一个接口【抽象方法是有返回值有多个参数的状态】</span></span><br><span class="line">        <span class="comment">//如果实现抽象方法只有一句执行语句，此时return关键字可以省略不写【这个方法需要带有返回值才可以】</span></span><br><span class="line">        <span class="type">InterfaceD</span> <span class="variable">d1</span> <span class="operator">=</span> (c,d)-&gt;c + d;</span><br><span class="line">        <span class="comment">//如果需要在使用Lambda表达式实现时有多个条代码语句，就需要书写return关键字</span></span><br><span class="line">        <span class="type">InterfaceD</span> <span class="variable">d2</span> <span class="operator">=</span> (c,d)-&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(c &gt; d)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> c+d;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> d-c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>练习：提供一个接口InterfaceE，在接口中定义一个抽象方法 showE，并且有一个参数，带有返回，提供一个执行类在执行类中定义一个静态方法，方法参数类型时InterfaceE，并在静态方法调用接口中showE并执行效果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提供一个InterfaceE的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterfaceE</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">showE</span><span class="params">(<span class="type">boolean</span> b)</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//使用匿名内部类的实行使用方法的实现</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> result(<span class="keyword">new</span> <span class="title class_">InterfaceE</span>() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">showE</span><span class="params">(<span class="type">boolean</span> b)</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="literal">true</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;匿名内部类实现方法得到的返回值是：&quot;</span>+res);</span><br><span class="line">        <span class="comment">//使用Lambda表达式实现操作</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res2</span> <span class="operator">=</span> result(b -&gt; b, <span class="literal">false</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Lambda表达式实现方法得到的返回值是：&quot;</span>+res2);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//提供一个静态方法，这个方法参数列表中有InterfaceE这个接口类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">result</span><span class="params">(InterfaceE e,<span class="type">boolean</span> res)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> e.showE(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、Lambd表达式的局限性"><a href="#3、Lambd表达式的局限性" class="headerlink" title="3、Lambd表达式的局限性"></a><center>3、Lambd表达式的局限性</center></h2><p>需要注意Lambda表达式不是万能的，Lambda表达式不能替代所有的匿名内部类的操作，Java8中提供的这个新的特性Lambda表达式存在一个实现弊端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterfaceF</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//添加两个抽象方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showF</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showFF</span><span class="params">(<span class="type">int</span> f)</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//使用匿名内部类实现InterfaceF接口</span></span><br><span class="line">        <span class="type">InterfaceF</span> <span class="variable">interfaceF</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterfaceF</span>() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showF</span><span class="params">()</span> </span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类实现InterfaceF接口&quot;</span>);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showFF</span><span class="params">(<span class="type">int</span> f)</span> </span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类实现InterfaceF接口&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//使用Lambda表达式实现InterfaceF接口</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            IDEA中提供错误提示</span></span><br><span class="line"><span class="comment">            Multiple non-overriding abstract methods found in interface</span></span><br><span class="line"><span class="comment">            com.qfedu.lambda.InterfaceF</span></span><br><span class="line"><span class="comment">            这个就是Lambda表达式的局限性，Lambda表达式只能实现接口中只存在一个抽象方法</span></span><br><span class="line"><span class="comment">            Lambda表达式实现接口中，提供抽象方法有且仅能有一个</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">/* InterfaceF interfaceF1 = () -&gt;&#123;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;&quot;);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;&ensp;&ensp;Lambda表达式实现接口是有一个要求，接口中只能提供一个抽象方法，这样接口才适合Lambda做简便实现，无法实现接口中同时拥有多个抽象方法，这就是Lambda的弊端</p><p>&ensp;&ensp;&ensp;&ensp;所以Java为了保证Lambda表达式可以正确实现接口方法，Java对接口提供一个注解约束，约束接口中只能用一个抽象方法，那么我们称这样接口叫做函数式接口【专门提供给Lambda表达式实现】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加这样一个注解在接口上方，他会检查接口中是否提供多个抽象方法，如果提供多个抽象方法就会报错</span></span><br><span class="line"><span class="comment">//提供这样注解的接口就是专门对于Lambda提供实现操作的</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterfaceF</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//添加两个抽象方法 --》 这个接口中提供两个抽象方法就会出现错误</span></span><br><span class="line">    <span class="comment">/* void showF();</span></span><br><span class="line"><span class="comment">        void showFF(int f)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showF</span><span class="params">()</span>; <span class="comment">//仅提供一个抽象方法就不会报错了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解@FunctionalInterface就是为了满足Lambda可以正确实现接口而提供，如果你在定义接口时，此时接口可以使用Lambda表达式实现建议在接口上方法添加这个注解</p><p>PS：这个注解只限制接口中抽象方法的个数，不限制default和static方法的个数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;PS：接口是一个特殊的抽象父类&lt;/p&gt;
&lt;p&gt;什么接口?&lt;/p&gt;
&lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;硬件接口：指的是两个硬件设备之间的链接方式,硬件接口即包括物理上接口，还包括逻辑上接口(数据传输协议)&lt;/p&gt;
&lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;</summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>17.面向对象</title>
    <link href="http://example.com/post/76fa8c0d.html"/>
    <id>http://example.com/post/76fa8c0d.html</id>
    <published>2023-12-30T05:06:59.000Z</published>
    <updated>2024-02-29T12:30:26.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识点一：面向对象的编程思想"><a href="#知识点一：面向对象的编程思想" class="headerlink" title="知识点一：面向对象的编程思想"></a><center>知识点一：面向对象的编程思想</center></h1><p>面向对象程序设计(Object Oriented Programming) </p><p>什么是编程思想？</p><p>思想：其实思想就是你大脑中对某些事务的思维，通过思维完成这些事务</p><p>编程思想：就是你大脑中对代码中需要完成思维逻辑所提供一种思维，编程思想就是编程思路</p><p>在开发中我们接触比较经典编程思想一种面向过程和一种面向对象</p><p>PS：面向对象编程思想是从面向过程转变而来，所以面向对象中也会掺杂着面向过程</p><p>面向过程的编程思想：</p><p>强调的是过程，必须清楚每一个步骤，然后按照步骤一步一步去实现</p><p>面向对象的编程思想：</p><p>强调的是对象，通过调用对象的行为来实现功能，从而完成需求，面向对象并不是我们自己一步一步去操作实现</p><p>举例对比说明：</p><p>同样是处理洗衣服事物</p><p>&ensp;&ensp;&ensp;&ensp;面向过程角度而言：把衣服脱下来 –》找一个盆–》放点洗衣粉–》加点水–》浸泡10分钟–》揉一揉–》清洗衣服–》拧干–》晾起来</p><p>&ensp;&ensp;&ensp;&ensp;面向对象角度而言：把衣服托脱下来 –》找一个对象【女朋友&#x2F;男朋友】让他去完成【洗】</p><p>同样是要吃饭</p><p>&ensp;&ensp;&ensp;&ensp;面向过程角度而言：买菜–》洗菜–》炒菜–》吃</p><p>&ensp;&ensp;&ensp;&ensp;面向对象角度而言：找一个饭店&#x2F;点一份外卖 –》 付钱</p><p>从Java程序角度来思考：需求：打印数组中存储数据，打印格式为[元素1，元素2，元素3，….]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">printArray</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.先提供一个数据</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">67</span>&#125;;</span><br><span class="line">        <span class="comment">//以面相过程的角度而言，一步一步进行打印操作</span></span><br><span class="line">        System.out.print(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span> ; i&lt;arr.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i != arr.length-<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(arr[i]+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(arr[i]+<span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//以面向对象角度而言，只需要找到可以打印数组数据对象即可</span></span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>&ensp;&ensp;&ensp;&ensp;无论是面向过程还是面向对象都是一种编程思想【就是你编写代码的思维逻辑】，区别在于</p><p>&ensp;&ensp;&ensp;&ensp;面向过程：注重的是步骤，必须清楚每一个步骤，按照步骤一步一步去实现</p><p>&ensp;&ensp;&ensp;&ensp;面向对象：注重的是对象，无需清楚每一个步骤，只需要使用对象调用行为来完成需求即可</p><p>&ensp;&ensp;&ensp;&ensp;面向过程在之前学习知识点时候就已经慢慢的在学习使用，面向对象的这个编程思想，如何在代码中体现，如何在代码中写出自己的面向对象思想？—》如<strong>果在代码中要体现面向对象编程思想，需要提供类和对象，通过类对对象进行描述，在通过对象完成思维逻辑</strong></p><h1 id="知识点二：类和对象的概述"><a href="#知识点二：类和对象的概述" class="headerlink" title="知识点二：类和对象的概述"></a><center>知识点二：类和对象的概述</center></h1><h2 id="类的概述"><a href="#类的概述" class="headerlink" title="类的概述"></a><center>类的概述</center></h2><p>什么是类？</p><p>&ensp;&ensp;&ensp;&ensp;类是用来描述一类具有共同属性和行为事物的统称，所以其实类在客观现实世界中是不存在，是</p><p>抽象的，只是用来描述信息</p><p>例如：</p><p>&ensp;&ensp;&ensp;&ensp;人类 —》 描述人的 狗类 —》描述狗 手机类—》描述手机 动物类 —》 描述动物类提供描述使用的，这个描述要是共有属性和行为统称在一起—》称为类</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271923636.jpg" alt="类举例" style="zoom:33%;"><p>上图中所表述意义在于，每一个单独个体具备共有属性和行为，抽取出来，形成一个描述，这个描述就是就类， 上图中描述就是人类</p><p>属性和行为？</p><p>&ensp;&ensp;&ensp;&ensp;属性： 就是该事物的状态信息 –》人类：身高、体重、年龄、性别等等</p><p>&ensp;&ensp;&ensp;&ensp;行为：就是该事物能够做什么 –》 人类：说话、吃、喝、睡觉等等</p><p>总结：</p><p>&ensp;&ensp;&ensp;&ensp;需要将现实生活中描述类的操作转变为代码在编程中进行体现，，明确类是用来描述一群具有共</p><p>同属性和行为事物的统称，类是一个抽象的，看不见，摸不着，用来描述信息的操作</p><p>类的组成：</p><p>&ensp;&ensp;&ensp;&ensp;属性 —》 成员变量</p><p>&ensp;&ensp;&ensp;&ensp;行为 —》 成员方法</p><p>成员变量是什么？</p><p>&ensp;&ensp;&ensp;&ensp;它就是定义在类中用来描述现实生活中属性的，在代码中体现就是定义变量</p><p>成员方法是什么？</p><p>&ensp;&ensp;&ensp;&ensp;方法其实就是对某些事物的处理途径，将某些处理事物的代码放置到一个大括号中，然后对这个大括号起一个名字，外界只需要使用这个名字就要可以完成对事物的操作</p><p>&ensp;&ensp;&ensp;&ensp;方法就是对你实现功能代码进行一个封装操作，外界只需要调用方法名就可以完成处理事物逻辑</p><p>PS：在某些语言中将方法称之为函数，但是在Java中我们建议称之为方法，只有面向过程语言才称之为函数，而Java是面向对象语言称之为方法</p><p>只要在代码中定义一个类，并在类中提供属性和行为就可以进行现实生活中事物的描述</p><p>PS：成员方法就是不使用static进行修饰的方法类具备的操作就是描述操作，并不具备具体处理事物的能力，就需要将类具现化出来，所以提供对象来具现化类</p><h2 id="对象的概述"><a href="#对象的概述" class="headerlink" title="对象的概述"></a><center>对象的概述</center></h2><p>对象是类的一个实例【具体存在的例子】，具体存在的，看得见的摸得着，并且具备该类事物的属性和行为</p><p>对象的属性：对象的属性具有特定值</p><p>对象的行为：对象可以操作的行为</p><p>人类： 人的描述</p><p>&ensp;&ensp;&ensp;&ensp;提供对象进行具体的体现： 班班老师</p><p>狗类：狗的描述</p><p>&ensp;&ensp;&ensp;&ensp;提供对象进行具体的体现： 柯基狗狗</p><p>手机类：描述手机</p><p>&ensp;&ensp;&ensp;&ensp;提供对象进行具体的体现：华为手机</p><p>举例：</p><p>&ensp;&ensp;&ensp;&ensp;对象：你手上手机</p><p>&ensp;&ensp;&ensp;&ensp;属性: 华为，19999， 4核CPU ，256G内存 1TB存储空间 支持10G</p><p>&ensp;&ensp;&ensp;&ensp;对象属性就是具体的值，因为类描述的时候属性是没有具体数据值</p><p>&ensp;&ensp;&ensp;&ensp;行为： 可以打电话，上网，发短信等等。对象可以具体完成哪些操作</p><p>总结：</p><p>&ensp;&ensp;&ensp;&ensp;对象就是类的实例，具体存在的，看得见摸得着，对象属性具有具体数据值的，对象的行为其实就是可以使用的功能</p><p>&ensp;&ensp;&ensp;&ensp;Java中面向对象思想，就是需要你在代码中提供类和对象来完成是现实生活中的思维逻辑，类是对象的操作，对象是类的具现化来完成事物操作过程</p><h2 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a><center>类和对象的关系</center></h2><p>类是对一类具有共同属性和行为的事物统称，是抽象的</p><p>对象是一类事物的具体是实例，看得见，摸得着，真实存在的实体，是具体的</p><p>总结：类是对象的抽象，对象是类的实例化</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271923275.jpg" alt="类和对象的关系" style="zoom:50%;"><p>总结：</p><p>对象是根据类创建出来的，类可以看成是对象的【数据类型】，所以类是Java中引用类型</p><p>PS：现如今为止：引用类型：数组、类、Scanner</p><p>&ensp;&ensp;&ensp;&ensp;他们所创建出来的空间都是在“堆中的”</p><p>类中有什么属性和行为，对象就具备哪些属性和行为，因为类对对象描述</p><p>&ensp;&ensp;&ensp;&ensp;现在所说的这些都是概念性的东西，在现实生活中，对象是真实存在，如果要处理某些事物，只需要找到对应对象就可以完成这个事物【面向对象思想】，但是编写代码的程序是不具备这些类和对象，所以我们就需要用过上述这些概念，进行描述与操作</p><p>PS：从现在开始完后所有开发使用都是面向对象的思想来进行的，而且面向对象是最符合人类思维的一种途径，现在的编码结构也是以面向对象为切入点进行模块式的开发</p><h1 id="知识点三：类、对象"><a href="#知识点三：类、对象" class="headerlink" title="知识点三：类、对象"></a><center>知识点三：类、对象</center></h1><h2 id="1、类的定义"><a href="#1、类的定义" class="headerlink" title="1、类的定义"></a><center>1、类的定义</center></h2><p>类的是描述一群具有共同属性和行为的操作</p><p><strong>类的组成</strong></p><p>&ensp;&ensp;&ensp;&ensp;属性：该类事物的状态信息，在类中以成员变量形式来体现</p><p>&ensp;&ensp;&ensp;&ensp;行为：该类事物有什么功能，在类中提供成员方法来体现</p><p>现阶段在定义一个类来，描述事物就需要提供属性和行为即成员变量和成员成方法</p><p><strong>类的格式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供描述属性 ---》 属性在类中体现就是【成员变量（PS：就是在类中定义一个变量多个权限修饰符）】</span></span><br><span class="line">    访问权限修饰符 数据类型 变量名;</span><br><span class="line">    <span class="comment">//提供描述行为 ---》 行为在类中体现就是【成员方法（和之前学习方法定义是一样，只不多去掉了static关键字）】</span></span><br><span class="line">    访问权限修饰符 返回值类型 方法名(参数列表)</span><br><span class="line">    &#123;</span><br><span class="line">        执行代码【你要操作什么】</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码演示：需求：定义一个手机类，类名【phone】，类中属性有：品牌（brand）、价格（price）,类中行为有 打电话（call），发短信（sendMessage）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    从现在开始编写面向对象编程思想时候需要注意对创建类就存在分类操作</span></span><br><span class="line"><span class="comment">    在面向对象中类有两个基础分类：</span></span><br><span class="line"><span class="comment">    一个是叫做 “描述类” 这个类主要提供对对象描述使用类【提供描述中所需要定义操作】 </span></span><br><span class="line"><span class="comment">    这个类是不提供 main 方法</span></span><br><span class="line"><span class="comment">    一个是叫做 ”执行类“ 这个类主要数提供面向对象编程实现具体执行操作类，</span></span><br><span class="line"><span class="comment">    这个类会将描述类进行具现化提供对象</span></span><br><span class="line"><span class="comment">    来处理业务逻辑，所以这个类会提供 main 方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//这个phone这个类就是一个描述类，所以不提供main方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        在类中定义属性即成员变量是支持Java中全套的权限修饰符</span></span><br><span class="line"><span class="comment">        现阶段可以使用权限修饰符有 public【公有的】 default/package【默认的(不提供任何全新修饰符书写)】</span></span><br><span class="line"><span class="comment">        PS:因为在写面向对象时，会使用到一个描述操作，此时String类型就比较适合使用</span></span><br><span class="line"><span class="comment">        简单介绍String：String在Java中是一个类是引用类型的代表Java代码中所有字符串对象</span></span><br><span class="line"><span class="comment">        只要在代码中 使用 &quot;&quot; 提供操作 就是String类的对象</span></span><br><span class="line"><span class="comment">        如果成员变量使用String类型如何进行赋值操作</span></span><br><span class="line"><span class="comment">        例如： String brand = &quot;华为&quot;;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//需求：定义一个手机类，类名【phone】，类中属性有：品牌（brand）、价格（price）</span></span><br><span class="line">    <span class="keyword">public</span> String brand; <span class="comment">//这个成员变量就是public权限修饰符</span></span><br><span class="line">    <span class="type">int</span> price; <span class="comment">//这个成员变量就是默认权限修饰符</span></span><br><span class="line">    <span class="comment">// 类中行为有 打电话（call），发短信（sendMessage）</span></span><br><span class="line">    <span class="comment">//这个方法就是成员方法，不使用static修饰</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;手机可以打电话&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sendMessage</span><span class="params">(String content)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送的信息是:&quot;</span>+content);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;发送信息成功&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、对象的创建与使用"><a href="#2、对象的创建与使用" class="headerlink" title="2、对象的创建与使用"></a><center>2、对象的创建与使用</center></h2><h3 id="创建对象的语法："><a href="#创建对象的语法：" class="headerlink" title="创建对象的语法："></a>创建对象的语法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法：</span></span><br><span class="line">    类名 对象名 = <span class="keyword">new</span> 类名(); ---》类其实就是对象的数据类型，类是引用类型【佐证：使用<span class="keyword">new</span>关键字】</span><br><span class="line"><span class="comment">//例如：</span></span><br><span class="line">    <span class="type">Phone</span> <span class="variable">huawei</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>(); --》相当于创建Phone类的对象huawei，huawei对象数据类型是phoen</span><br><span class="line">    <span class="type">Dog</span> <span class="variable">xiaobia</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(); --》相当于创建Dog类的对象xiaobai，xiaobai对象数据类型是Dog</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in); --》 相当于创建Scanner类的对象</span><br><span class="line">input，input对象数据类型是Scanner</span><br><span class="line"><span class="comment">//类中提供对象所描述属性和行为，通过类创建对象之后，对象就可以使用类中所提供属性和行为即可以通过对象访问成员变量和成员方法</span></span><br><span class="line">    访问类中成员变量</span><br><span class="line">        获取成员变量的值 ---》 对象名.成员变量名;</span><br><span class="line">        对成员变量进行赋值 ---》 对象名.成员变量名 = 值;</span><br><span class="line">    访问类中成员方法</span><br><span class="line">        对象名.成员方法的名字(提供参数赋值);</span><br></pre></td></tr></table></figure><p>需求：创建Phone类对象，并对类中提供属性和行为进行操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个类主要就是提供Phone这个描述的操作使用的，所以这个类就是执行类，要添加main方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhoneTest</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建Phone这个类的对象</span></span><br><span class="line">        <span class="type">Phone</span> <span class="variable">huwei</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        <span class="comment">//对成员变量进行访问</span></span><br><span class="line">        System.out.println(<span class="string">&quot;手机的品牌：&quot;</span>+huwei.brand);</span><br><span class="line">        System.out.println(<span class="string">&quot;手机的价格：&quot;</span>+huwei.price);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            之前在学习中已经接触了局部变量，即定义在方法体内部变量就是局部变量</span></span><br><span class="line"><span class="comment">            但是在方法体内部定义局部变量，必须进行初始化之后才可以进行使用，作用域仅限在方法体内部</span></span><br><span class="line"><span class="comment">            成员变量是定义在类中的，声明在类中成员变量是存在默认值的即只提供定义操作没有提供赋值操作</span></span><br><span class="line"><span class="comment">            那么这个变量也可以使用并且有默认值存在</span></span><br><span class="line"><span class="comment">            成员变量的默认值会根据数据类型来决定</span></span><br><span class="line"><span class="comment">            整数类型【byte、short、int、long】 --》默认值:0</span></span><br><span class="line"><span class="comment">            小数类型【float 和 double】 ---》 默认值: 0.0</span></span><br><span class="line"><span class="comment">            字符类型【char】 ---》 默认值 一个不可见空字符</span></span><br><span class="line"><span class="comment">            布尔类型【boolean】 ---》 默认值 false</span></span><br><span class="line"><span class="comment">            引用类型【自定义类、数组、Scanner、String....】 ---》 默认值 null</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//对成员变量进行赋值操作</span></span><br><span class="line">        huwei.brand = <span class="string">&quot;华为&quot;</span>;</span><br><span class="line">        huwei.price = <span class="number">19999</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;手机的品牌：&quot;</span>+huwei.brand+<span class="string">&quot;手机的价格：&quot;</span>+ huwei.price);</span><br><span class="line">        <span class="comment">//使用对象对成员方法进行访问操作</span></span><br><span class="line">        huwei.call();</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> huwei.sendMessage(<span class="string">&quot;你好欢迎使用&quot;</span>);</span><br><span class="line">        System.out.println(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、单个对象在内存中存储"><a href="#3、单个对象在内存中存储" class="headerlink" title="3、单个对象在内存中存储"></a><center>3、单个对象在内存中存储</center></h2><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271924171.jpg" alt="单个对象在内存中存储"></p><p>总结：只要是创建对象【使用new关键字】，就会在堆中开辟一段空间</p><p>&ensp;&ensp;&ensp;&ensp;只要调用方法，就会在栈中开辟一段空间，用来执行该方法</p><p>&ensp;&ensp;&ensp;&ensp;栈中空间是系统回收操作，堆中空间是Java提供GC【垃圾回收机制】进行回收操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> </span><br><span class="line">&#123;</span><br><span class="line">    String name;<span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> age;<span class="comment">//年龄</span></span><br><span class="line">    <span class="comment">//行为 ---》 学习</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在努力的学习Java......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentTest</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1. 创建Student类的对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">xiaoming</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="comment">//2. 利用学生对象打印成员变量的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+xiaoming.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;年龄：&quot;</span>+xiaoming.age);</span><br><span class="line">        <span class="comment">//3. 利用学生对象对成员变量进行赋值操作</span></span><br><span class="line">        xiaoming.name = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">        xiaoming.age = <span class="number">18</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+xiaoming.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;年龄：&quot;</span>+xiaoming.age);</span><br><span class="line">        <span class="comment">//打印学生对象</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            打印学生对象方式 ---&gt; Student@1b6d3586 --&gt; 理解为学生对象地址【在堆中地址】</span></span><br><span class="line"><span class="comment">            Student ---&gt; 证明xiaoming这个对象时属于Student类的</span></span><br><span class="line"><span class="comment">            @ ---&gt; 没有任何意义就是一个连接符号</span></span><br><span class="line"><span class="comment">            1b6d3586 ---&gt; 学生对象记录的堆中开辟空间地址</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;学生对象：&quot;</span>+xiaoming);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、多个对象在内存中存储"><a href="#4、多个对象在内存中存储" class="headerlink" title="4、多个对象在内存中存储"></a><center>4、多个对象在内存中存储</center></h2><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271924816.jpg" alt="多个对象在内存中存储"></p><p>总结: 一个类是可以创建多个对象的，多个对象在堆中存储，都有不同内存划分【就是多个对象都使用new关键字创建】，<strong>成员变量是存储在各自的内存区域中，成员方法是多个对象共一份【类文件只有一个】</strong></p><p>&ensp;&ensp;&ensp;&ensp;凡是使用new关键字创建的对象都会在堆中开辟一段新的存储空间</p><p>&ensp;&ensp;&ensp;&ensp;对象和对象之的关系是相互独立的【只要是使用new关键字创建出来】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentTest2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1. 创建Student类的对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">xiaoming</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="comment">//2. 利用学生对象打印成员变量的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+xiaoming.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;年龄：&quot;</span>+xiaoming.age);</span><br><span class="line">        <span class="comment">//3. 利用学生对象对成员变量进行赋值操作</span></span><br><span class="line">        xiaoming.name = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">        xiaoming.age = <span class="number">18</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+xiaoming.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;年龄：&quot;</span>+xiaoming.age);</span><br><span class="line">        <span class="comment">//打印学生对象</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            打印学生对象方式 ---&gt; Student@1b6d3586 --&gt; 理解为学生对象地址【在堆中地址】</span></span><br><span class="line"><span class="comment">            Student ---&gt; 证明xiaoming这个对象时属于Student类的</span></span><br><span class="line"><span class="comment">            @ ---&gt; 没有任何意义就是一个连接符号</span></span><br><span class="line"><span class="comment">            1b6d3586 ---&gt; 学生对象记录的堆中开辟空间地址</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;学生对象：&quot;</span>+xiaoming);</span><br><span class="line">        xiaoming.study();</span><br><span class="line">        <span class="comment">//在利用Student类创建一个xiaohong对象，并访问成员变量</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">xiaohong</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+xiaohong.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;年龄：&quot;</span>+xiaohong.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、多个对象指向同一个对象在内存那种存储"><a href="#5、多个对象指向同一个对象在内存那种存储" class="headerlink" title="5、多个对象指向同一个对象在内存那种存储"></a><center>5、多个对象指向同一个对象在内存那种存储</center></h2><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271924888.jpg" alt="多个对象指向同一个对象在内存存储"></p><p>总结： 当多个对象的引用指向同一个内存空间时【对象所记录地址都是一样的】，只要有任何一个对象修改了内存中数据，随之无论使用哪一个对象进行数据获取，都是修改之后的数据</p><p>当创建多个对象时，如果你需要某个对象与另外一个对象的空间是一致，只需要将其中创建好的对象存储空间地址赋值给另外一个对象即可，此时引用就是同一个空间</p><p>当创建多个对象时，需要对象彼此之间互相独立不干扰，只需使用new关键字分别创建即可， 就可以在堆中开辟不同存储空间了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentTest3</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1. 创建Student类的对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">xiaoming</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="comment">//2. 利用学生对象打印成员变量的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+xiaoming.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;年龄：&quot;</span>+xiaoming.age);</span><br><span class="line">        <span class="comment">//3. 利用学生对象对成员变量进行赋值操作</span></span><br><span class="line">        xiaoming.name = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">        xiaoming.age = <span class="number">18</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+xiaoming.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;年龄：&quot;</span>+xiaoming.age);</span><br><span class="line">        <span class="comment">//打印学生对象</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            打印学生对象方式 ---&gt; Student@1b6d3586 --&gt; 理解为学生对象地址【在堆中地址】</span></span><br><span class="line"><span class="comment">            Student ---&gt; 证明xiaoming这个对象时属于Student类的</span></span><br><span class="line"><span class="comment">            @ ---&gt; 没有任何意义就是一个连接符号</span></span><br><span class="line"><span class="comment">            1b6d3586 ---&gt; 学生对象记录的堆中开辟空间地址</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;学生对象：&quot;</span>+xiaoming);</span><br><span class="line">        xiaoming.study();</span><br><span class="line">        <span class="comment">//不在使用Student类创建对象，而是使用创建xiaoming对象对另外一个xiaohong对象进行赋值</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">xiaohong</span> <span class="operator">=</span> xiaoming;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+xiaohong.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;年龄：&quot;</span>+xiaohong.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点四：成员变量和局部变量"><a href="#知识点四：成员变量和局部变量" class="headerlink" title="知识点四：成员变量和局部变量"></a><center>知识点四：成员变量和局部变量</center></h1><p>成员变量（实例变量）：定义在类的里面，方法的外面的变量称之为成员变量</p><p>局部变量：定义在方法内部的变量称为局部变量</p><p>成员变量和局部变量的区别：</p><p>&ensp;&ensp;&ensp;&ensp;1、位置不同</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;成员变量：在类中、方法外</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;局部变量：在方法内部</p><p>&ensp;&ensp;&ensp;&ensp;2、初始值不同（变量必须要初始化才能使用）</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;成员变量：系统会赋值默认值（与之前讲的数组一致）</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;局部变量：没有默认值</p><p>&ensp;&ensp;&ensp;&ensp;3、作用域不同</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;成员变量：在类中都可以使用</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;局部变量：只能在作用域中使用（在它所在的{ }中）</p><p>&ensp;&ensp;&ensp;&ensp;4、重名问题</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;成员变量不能重名，局部变量在不同作用域中是可以重名的</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;如果当局部变量和成员变量重名的时候，Java中遵循就近原则</p><p>&ensp;&ensp;&ensp;&ensp;5、生命周期不同</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;成员变量：变量会随着对象的销毁而销毁。对象什么时候销毁呢（Java中GC垃圾回收机制）</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;语句变量：当变量出了作用域就会被销毁</p><h1 id="知识点六：构造方法"><a href="#知识点六：构造方法" class="headerlink" title="知识点六：构造方法"></a><center>知识点六：构造方法</center></h1><h2 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a><center>1、定义</center></h2><p>&ensp;&ensp;&ensp;&ensp;构造方法是一个特殊的方法，主要是完成对象的创建和对象数据的初始化方法</p><p>&ensp;&ensp;&ensp;&ensp;构造方法的提供主要是为了可以保证对象可以正确创建，以及对成员变量的从初始化的操作，在不使用构造方法之前，对类中所提供成员变量进行赋值的，只能通过对象，一个一个的进行赋值，如果类中成员变量过多，这个操作是很繁琐，因为对象创建过程中，是需要进行内存开辟空间，构造方法可以保证类所创建对象可以正确创建出来</p><p>PS：在实际开发中构造方法主要有两类，一类被称之为“<strong>无参构造方法</strong>”和一类被称之为“<strong>有参构造方法</strong>”</p><h2 id="2、语法"><a href="#2、语法" class="headerlink" title="2、语法"></a><center>2、语法</center></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名</span><br><span class="line">&#123;</span><br><span class="line">    访问权限修饰符 数据类型 变量名; <span class="comment">//属性</span></span><br><span class="line">    访问权限修饰符 返回值类型 方法名(参数列表)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//行为</span></span><br><span class="line">        方法体 ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125; </span><br><span class="line">    访问权限修饰符 类名()    <span class="comment">//无参构造方法</span></span><br><span class="line">    &#123; </span><br><span class="line">    &#125; </span><br><span class="line">    访问权限修饰符 类名(参数列表)    <span class="comment">//有参构造方法</span></span><br><span class="line">    &#123;        </span><br><span class="line">        提供类中属性【成员变量】的初始化操作</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">        构造方法的说明：</span></span><br><span class="line"><span class="comment">        1.构造方法只能在类中定义，无法在其他位置提供定义</span></span><br><span class="line"><span class="comment">        2.构造方法使用权限修饰符【常用public】，除此之外在某些特殊情况下可以将构造方法使用private【私有的】进行修饰</span></span><br><span class="line"><span class="comment">        3.构造方法的方法名与类名必须是相同的</span></span><br><span class="line"><span class="comment">        4.构造反方没有返回值类型，甚至都不需要使用void进行表示，更不可能在构造方法中使用return关键字</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//无参构造方法的调用</span></span><br><span class="line">    类名 对象名 = <span class="keyword">new</span> 类名();</span><br><span class="line">    <span class="comment">//有参构造方法的调用</span></span><br><span class="line">    类名 对象名 = <span class="keyword">new</span> 类名(实参<span class="number">1</span>,实参<span class="number">2</span>,.....);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例：需求：提供一个Person类，属性【姓名，年龄，性别】，行为【吃】，在提供类中构造方法定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//属性描述</span></span><br><span class="line">    String name; <span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> age; <span class="comment">//年龄</span></span><br><span class="line">    String gender; <span class="comment">//性别</span></span><br><span class="line">    <span class="comment">//行为的描述</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            在同一个类中，成员方法是可以直接访问本类中提供成员变量和其他成员方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.out.println(name+<span class="string">&quot;正在吃饭...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//提供Person类的无参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>    <span class="comment">// 无参构造方法【方法的参数列表不做任何参数定义】</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            PS：在实际开发中，无参构造方法主要是定义的作用，基本上在构造方法体中很少进行初始操作</span></span><br><span class="line"><span class="comment">            如果在无参构造方法进行属性的初始化，所有调用无参构造方法创建对象都会都会具备这个属性值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//给属性进行初始化操作 --》 手动进行赋值</span></span><br><span class="line">        name = <span class="string">&quot;xiaoming&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提供Person类的有参构造方法</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Person的有参构造方法一定会提供参数列表？ 这个参数列表如何定义？</span></span><br><span class="line"><span class="comment">        给那些类中属性进行赋值【初始化】，参数列表就定义那些数据</span></span><br><span class="line"><span class="comment">        定义参数需要和类中属性数据类型是一直，这样方便进行赋值操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String n,<span class="type">int</span> a, String g)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这个操作就是使用参数对类中属性进行初始化赋值操作</span></span><br><span class="line">        name = n;</span><br><span class="line">        age = a;</span><br><span class="line">        gender = g;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PersonTest</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonTest</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//使用Person类中无参构造方法【分别构建两个对象】</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="comment">//调用Person类中提供name属性</span></span><br><span class="line">        System.out.println(<span class="string">&quot;person1对象中的name属性值：&quot;</span> + person1.name);    <span class="comment">//都是午餐构造里面的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;person2对象中的name属性值：&quot;</span> + person2.name);</span><br><span class="line">        <span class="comment">//使用Person类中有参构造方法在创建对象的同时对属性进行初始化</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小红&quot;</span>,<span class="number">18</span>,<span class="string">&quot;女&quot;</span>);<span class="comment">//小括号中提供具体数据，调用就是有参构造方法</span></span><br><span class="line">        <span class="comment">//打印person3对象中属性值</span></span><br><span class="line">        System.out.println(person3.name + <span class="string">&quot; &quot;</span> + person3.age + <span class="string">&quot; &quot;</span> + person3.gender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、注意的事项"><a href="#3、注意的事项" class="headerlink" title="3、注意的事项"></a><center>3、注意的事项</center></h2><p>1）如果在类中并没有明确提供构造方法的定义，此时<strong>系统将提供一个默认无参构造方法，让创建对象时使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Man</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Man这个类中并没有明确提供构造方法</span></span><br><span class="line">    String name;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//但是系统会为Man提供一个默认的无参构造方法</span></span><br><span class="line">        <span class="type">Man</span> <span class="variable">man</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）如果在类中<strong>明确提供了构造方法【无论是有参还无参】此时系统提供的默认构造方法将消失，不在提供对外操作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Man2</span> </span><br><span class="line">&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="comment">//明确提供一个有参构造方法【系统无参构造方法将无法在次调用，如果需要使用无参构造方法必须手动提供】</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Man2</span><span class="params">(String n)</span></span><br><span class="line">    &#123;</span><br><span class="line">        name = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//调用Man2这个类中无参构造方法进行对象创建</span></span><br><span class="line">        <span class="comment">//IDEA提供错误提示&quot;Man2(java.lang.String)&#x27; in &#x27;Man2&#x27; cannot be applied to&#x27;()&#x27;&quot;</span></span><br><span class="line">        <span class="comment">//Man2 man2 = new Man2();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）一个类中是可以提供多个构造方法，但是在同一个类中有一个要求，定义方法签名【方法名+参数列表】不能重复，那么为什么还可以提供一个无参构造方法和一个有参构造方法呢？</p><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p><strong>这里我们利用到一个方法的概念【特点】 —》 这个特点叫做方法的“重载【overload】”</strong></p><p>在同一个类中，定义方法签名是不允许重复，但是利用重载这个概念完成方法名相同操作【无参构造方法与有参构造方法的名字是相同，但是没有报错】，虽然名字相同，但是参数列表是不同就会触发重载操作</p><p>重载的要求，只要满足以下<strong>三者之一</strong>就可以成为重载</p><p>&ensp;&ensp;&ensp;&ensp;<strong>1.方法名相同但是参数列表不同，定义的顺序不同，就可以称之为重载</strong></p><p><strong>&ensp;&ensp;&ensp;&ensp;2.方法名相同但是参数列表不同，定义的数据类型不同，就可以称之为重载</strong></p><p><strong>&ensp;&ensp;&ensp;&ensp;3.方法名相同但是参数列表不同，定义的个数不同，就可以称之为重载</strong></p><p>所以，当前类中所提供的<strong>无参构造方法与有参构造方法就是方法的重载，可以利用这个特性提供多个方法</strong></p><p>4）构造方法必须与类同名，必须没有返回值类型，并且void也不可以，不可以使用return关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Man3</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        为了保证类与类之间继承关系，为了保证JavaBean合理定义</span></span><br><span class="line"><span class="comment">        一般会在一个描述类中提供一个有参和无参的构造方法</span></span><br><span class="line"><span class="comment">        有参构造方法，一般是针对类中所有属性记性初始化操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//类中基本提供方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Man3</span><span class="params">()</span></span><br><span class="line">    &#123; <span class="comment">//无参构造方法</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Man3</span><span class="params">(String n,<span class="type">int</span> a)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//有参构造方法</span></span><br><span class="line">        name = n;</span><br><span class="line">        age = a;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//还可以利用重载的特点，进行多个构造方法的提供【因人而异，因项目要求而异】</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Man3</span><span class="params">(String n)</span></span><br><span class="line">    &#123;</span><br><span class="line">        name = n;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Man3</span><span class="params">(<span class="type">int</span> a)</span></span><br><span class="line">    &#123;</span><br><span class="line">        age = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>PS：重载这个概念也适用于其他方法</strong></p><h1 id="知识点七：对象的内存分配"><a href="#知识点七：对象的内存分配" class="headerlink" title="知识点七：对象的内存分配"></a><center>知识点七：对象的内存分配</center></h1><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271925009.jpg" alt="对象内存分配" style="zoom: 50%;"><h1 id="知识点九：三大特征"><a href="#知识点九：三大特征" class="headerlink" title="知识点九：三大特征"></a><center>知识点九：三大特征</center></h1><p>面向对象这个编程思想是贴近与现实生活逻辑一种编程思想，在这个编程思想中利用三个特征完成面向对象的编程逻辑，面向对象中的三大特征：“<strong>封装、继承和多态</strong>”</p><p>这三者体现了什么？</p><p>封装性:封装就是一个事物包裹起来，使外界不了解它内部的情况，在面向对象中，封装就把相关的数据和代码结合成一个有机的整体，形成数据和代码操作的封装体，提供一个对外部暴露的接口，可以方便外界使用这个封装</p><p>继承性：从已有类中创建新类的过程，提供继承信息的被称之为父类，得到继承信息称之为子类，父子之间存在一个关系就是【继承】，继承可以使Java中类与类之间形成一个层次机构，利用这个继承简便的进行代码的开发。</p><p>多态性： 多态是允许程序中出现多种状态的对象。同一个事物被不同对象所触发，得到结果不同就称之为多态【主要体现就是对象的转型操作】</p><p>以上的三个特征会在编程中所有体现，从而完善面向对象编程</p><h2 id="1、封装"><a href="#1、封装" class="headerlink" title="1、封装"></a><center>1、封装</center></h2><p>需求：创建一个Cat类，对Cat类提供属性【姓名和年龄】，然后再执行类中创建Cat类对象对属性进行操作及打印</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> </span><br><span class="line">&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String n, <span class="type">int</span> a)</span></span><br><span class="line">    &#123;</span><br><span class="line">        name = n;</span><br><span class="line">        age = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CatTest</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        cat.age = <span class="number">1</span>;</span><br><span class="line">        cat.name = <span class="string">&quot;小花&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫的名字：&quot;</span>+cat.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;猫的年龄：&quot;</span>+cat.age);</span><br><span class="line">        <span class="comment">//但是 --&gt; 对age属性进行赋值操作</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            首先下面这个语法在开发中是没有问题，是可以对age属性进行负数赋值操作</span></span><br><span class="line"><span class="comment">            age属性是int数据类型 ，int数据类型可以存储数据范围【-21亿~21亿】之间</span></span><br><span class="line"><span class="comment">            赋值这个-1 很明显是满足这个存储范围操作的【语法是没有问题】</span></span><br><span class="line"><span class="comment">            在客观现实生活中，猫的年龄是绝对不可能出现 负数的</span></span><br><span class="line"><span class="comment">            如果在实际开发中，让外界可以直接对成员变量进行访问操作，是会存在安全隐患的</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        cat.age = -<span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫的年龄：&quot;</span>+cat.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在开发中如果我们直接访问成员变量，可能会出现安全隐患，在代码中age属性赋值操作就已经出</p><p>现问题，应该如何解决？</p><p>解决方式: 提供变量不对外直接访问的途径【即对属性进行封装操作】</p><p>&ensp;&ensp;&ensp;&ensp;在学习类的时候在定义属性【成员变量】时，可以对属性进行权限修饰符的使用，现在接触的权限修饰符主要所有【<strong>public（公有） 和 default&#x2F;package（默认&#x2F;包权限）</strong>】，使用他们修饰之后外界还是可以进行访问的，所以想让属性不在提供对方直接访问【使用封装概念来完成操作】 –》可<strong>以使用一个权限修饰符【private（私有）】，这权限修饰符是所有权限修饰符中在最低权限，利用private对成员变量的修饰以达到封装的目的</strong></p><p>解决方法：修改Cat类代码对属性提供private修饰</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> </span><br><span class="line">&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age; <span class="comment">//属性的私有化就是封装的体现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String n, <span class="type">int</span> a)</span></span><br><span class="line">    &#123;</span><br><span class="line">        name = n;</span><br><span class="line">        age = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;&ensp;&ensp;面向对象的封装其实就是一个编程的要求，将信息隐藏起来，把不需要外界知道的信息隐藏，尽可能隐藏对象功能实现细节，向外直接提供他可以访问方法，保证外界无法破坏原有内部信息，这就是封装特性</p><p>&ensp;&ensp;&ensp;&ensp;在写面向对象思想时，封装效果体现其实已经在，在写类的时候就已经是封装的效果，类就是将属性和方法封装在一个类中，除了这种体现方式之外，可以对属性进行私有化操作即使用private进行修饰，主要的目的是为了保证成员变量安全，所以<strong>private私有化成员变量只是封装特定一个体现而已</strong></p><p>&ensp;&ensp;&ensp;&ensp;封装确实可以保证age属性的安全性，外界无法直接破坏内部存储信息的途径，但是正常使用age属性时，也无法完成，所以封装中还有有一句话很重要“<strong>向外直接提供他可以访问方法</strong>”</p><h3 id="Getter和Setter方法"><a href="#Getter和Setter方法" class="headerlink" title="Getter和Setter方法"></a>Getter和Setter方法</h3><p>&ensp;&ensp;&ensp;&ensp;当对属性提供private权限修饰符时，确实让属性更加安全体现封装的一个特点，但是并不是完全封装特性展示，“<strong>封装细节之后还是要提供一种访问方式</strong>”</p><p>如果属性使用private进行修饰之后，就要对属性配套提供对应Getter和Setter方法</p><p>&ensp;&ensp;&ensp;&ensp;因为属性已经被private修饰了，提供Getter和Setter方法的目的是为了提供操作属性途径，所以这两方法必然使用public修饰</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Getter方法定义方式</span></span><br><span class="line"><span class="comment">    public 返回值类型 getXXX()</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        return 属性名;</span></span><br><span class="line"><span class="comment">    &#125; </span></span><br><span class="line"><span class="comment">解释说明：</span></span><br><span class="line"><span class="comment">    1. Getter方法主要的作用就是提供获取属性方法</span></span><br><span class="line"><span class="comment">    2. 这个方法必须有【返回值类型】，这个【返回值类型】如何定义？ --》 你提供get方法获取的</span></span><br><span class="line"><span class="comment">    是哪个属性值，这个方法的【返回值类型】就与属性的【属性类型】一致即可</span></span><br><span class="line"><span class="comment">    3. 方法名是固定的叫做【getXXX】---》get是固定代表是Getter方法获取属性值用---》</span></span><br><span class="line"><span class="comment">        XXX是你通过get获取哪个属性，这个XXX就是属性字</span></span><br><span class="line"><span class="comment">    外界使用get方法时，可以通过方法名得知使用是哪个属性</span></span><br><span class="line"><span class="comment">    4. 这个方法的参数列表定义是空的，没有任何参数定义</span></span><br><span class="line"><span class="comment">    5. 这个方法必须添加return关键字</span></span><br><span class="line"><span class="comment">        5.1 这个get方法是获取属性值，如果不return数据如何得到值</span></span><br><span class="line"><span class="comment">        5.2 这个方法定义返回值类型，所以方法必须添加return关键字对应操作</span></span><br><span class="line"><span class="comment">            return关键字后面跟值是什么？你获取的是哪个属性值， return就哪个属性</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Setter方法定义方式</span></span><br><span class="line"><span class="comment">    public void setXXX(参数列表)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        使用定义参数对属性进行赋值</span></span><br><span class="line"><span class="comment">    &#125; </span></span><br><span class="line"><span class="comment">解</span></span><br><span class="line"><span class="comment">释说明：</span></span><br><span class="line"><span class="comment">    1. Setter方法的主要作用就是对进行赋值操作</span></span><br><span class="line"><span class="comment">    2. 因为Set方法是对属性赋值，所以这个方法不需要返回值类型，所以方法使用void定义</span></span><br><span class="line"><span class="comment">    3. setXXX这个名字是固定的，set主要说明这个方法是Setter方法对属性赋值使用，XXX是针对堆</span></span><br><span class="line"><span class="comment">    那个属性赋值，XXX就是那个属性名字，这样一来外界调用这个方法时就可以得知对那个属性的操作</span></span><br><span class="line"><span class="comment">    4. 这里一定需要定义【参数列表】，因为set方法主要作用是赋值，所以需要通过方法参数对属性进</span></span><br><span class="line"><span class="comment">        行赋值操作，你对那个属性记性赋值 那么这个参数列表定义就与属性定义相同即可</span></span><br><span class="line"><span class="comment">    5. set方法体提供的是对属性的赋值操作【利用参数对属性赋值】</span></span><br><span class="line"><span class="comment">    6. 一定没有return关键字</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>修改Cat类提供Getter和Setter方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> </span><br><span class="line">&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age; <span class="comment">//属性的私有化就是封装的体现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String n, <span class="type">int</span> a)</span></span><br><span class="line">    &#123;</span><br><span class="line">        name = n;</span><br><span class="line">        age = a;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//提供private修饰属性的Getter和Setter方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span></span><br><span class="line">    &#123; <span class="comment">//获取属性值</span></span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> a)</span></span><br><span class="line">    &#123; <span class="comment">// 属性进行赋值操作</span></span><br><span class="line">    <span class="comment">//非法拦截</span></span><br><span class="line">        <span class="keyword">if</span>(a &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;您提供年龄不合法，无法赋值！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            age = a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CatTest</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        cat.setAge(<span class="number">1</span>);</span><br><span class="line">        cat.name = <span class="string">&quot;小花&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫的名字：&quot;</span>+cat.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;猫的年龄：&quot;</span>+cat.getAge());</span><br><span class="line">        </span><br><span class="line">        cat.setAge(-<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;猫的年龄：&quot;</span>+cat.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><p>&ensp;&ensp;&ensp;&ensp;需求：定义一个User类提供属性name和age并且私有化，提供有参无参构造方法，提供Getter和Setter方法，并且要求，在定义有参和Set方法是，定参数列表名需要和属性名一致，创建一个User对象，分别使用有参、无参构造方法完成，在调用set修改任何属性值，并提供get方法打印出来？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name ,<span class="type">int</span> age)</span></span><br><span class="line">    &#123;</span><br><span class="line">        name = name;</span><br><span class="line">        age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserTest</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.使用无参构造方法 ---》 创建User对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        <span class="comment">//通过user对象调用setName方法进行name属性赋值操作</span></span><br><span class="line">        user.setName(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user的姓名：&quot;</span>+user.getName());</span><br><span class="line">        <span class="comment">//2.使用有参构造方法 ---》创建User对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;小红&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user2的姓名：&quot;</span>+user2.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;user2的年龄：&quot;</span>+user2.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行完代码之后，打印属性值发现</p><p>&ensp;&ensp;&ensp;&ensp;user的姓名：null</p><p>&ensp;&ensp;&ensp;&ensp;user2的姓名：null</p><p>&ensp;&ensp;&ensp;&ensp;user2的年龄：0</p><p>打印出来属性值都是默认值，这是为什么呢？</p><p>&ensp;&ensp;&ensp;&ensp;在说这个问题之前，介绍一个【关键字this】，这个关键字可以在当前类中使用，主要使用在【构造方法和成员方法】中，this关键字在类中代表什么？【代表的是当前对象–》谁触发，谁就是this】</p><h4 id="1）调用本类属性"><a href="#1）调用本类属性" class="headerlink" title="1）调用本类属性"></a>1）调用本类属性</h4><p>在本类中调用本类的属性，this关键字可以省略，但是如果局部变量和成员变量同名时，若时 this.属性名  则是调用成员变量，若直接  属性名，则是调用局部变量（就近原则）</p><h4 id="2）调用本类方法"><a href="#2）调用本类方法" class="headerlink" title="2）调用本类方法"></a>2）调用本类方法</h4><p>在调用本类的方法的时候，this关键字完全可以省略不写</p><h4 id="3）调用本类的构造方法"><a href="#3）调用本类的构造方法" class="headerlink" title="3）调用本类的构造方法"></a>3）调用本类的构造方法</h4><p>在构造方法里调用另外一个构造方法</p><p>注意点：</p><p>&ensp;&ensp;&ensp;&ensp;a）在构造方法中用 this 再调用本类的其它构造方法的时候，这一行代码必须出现在构造方法的第一行</p><p>&ensp;&ensp;&ensp;&ensp;b）避免在构造方法中调用自身这个构造，这会出现无穷递归。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">this关键字的作用:</span><br><span class="line">    1. 可以通过this关键字访问当前类中成员变量进行操作 ---》 this.成员变量</span><br><span class="line">    2. 可以通过this关键字访问当前类中成员方法进行操作 ---》 this.成员方法（参数赋值）;</span><br><span class="line">    3. 可以通过this关键字在当前类中构造方法中访问其他的本类构造方法</span><br><span class="line">        ----》 this();【访问本类的无参构造方法】 ----》this(参数赋值);【访问本类的有参构造方法】</span><br><span class="line">        ----》 特别说明: 这个调用构造方法的方式只能在构造方法中使用，并且必须在构造方法体中第一句</span><br><span class="line">                不允许构造通过this关键字调用自身构造方法</span><br><span class="line">    4. 可以通过this关键字作为方法参数传递【代表当前对象】</span><br><span class="line">*/</span><br><span class="line">ps：上述的作用中只有一个对于我们开发是有用的，其余的都是已经很少使用甚至不用</span><br><span class="line">    ---》使用this关键字访问成员变量 ，在构造方法中和setter方法中区分成员变量和参数名字</span><br></pre></td></tr></table></figure><p>使用this关键字修改User类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//name = &quot;1&quot;;</span></span><br><span class="line">        <span class="comment">//在这个构造方法中使用this关键字调用本类的其他构造方法【很少使用】</span></span><br><span class="line">        <span class="comment">//this(); //不允许使用this关键字调用自身构造方法</span></span><br><span class="line">        <span class="comment">//必须在构造方法中第一行，不允许在它之前出现任何其他代码</span></span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;小白&quot;</span>,<span class="number">18</span>); <span class="comment">//不允许构造互相调用【不允许在无参中调用有参，在有参中调用无参】</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name ,<span class="type">int</span> age)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*原因就是出现在这个赋值操作过程中，Java中如何认定一个变量属于谁？</span></span><br><span class="line"><span class="comment">        使用是就近原则，name离谁最近name就是谁，name这个变量和参数列表中name是最近的</span></span><br><span class="line"><span class="comment">        所以这个赋值操作其实 就是在用参数name 对参数name进行赋值，根本就没有属性name进行赋值操作</span></span><br><span class="line"><span class="comment">        虽然这个name 与属性name是同名，但是根本就没有操作到，IDEA没有办法区分属性名与参数名相同时</span></span><br><span class="line"><span class="comment">        那个是属性，那个是参数 ---》出现了二义性</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//使用this关键字调用成员变量的方式区分 成员变量名字和参数的名字</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//提供两个成员方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show成员方法&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showInfos</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//使用this关键字访问本类中成员变量和成员方法</span></span><br><span class="line">    System.out.println(<span class="string">&quot;本类name属性：&quot;</span>+<span class="built_in">this</span>.name);</span><br><span class="line">    <span class="built_in">this</span>.show();</span><br><span class="line">    <span class="comment">//但是，实际开发中可以省略this不写 ，上下代码操作是完全一样</span></span><br><span class="line">    <span class="comment">//下面的操作属于上面操作的简化，实际在底层依旧是在执行 this.name 和 this.show()</span></span><br><span class="line">    System.out.println(<span class="string">&quot;本类name属性：&quot;</span>+name);</span><br><span class="line">    show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：this关键字使用方式是有很多的的，但是使用应用主要还是会使用【this.成员变量】方法进行与相同参数名的区分操作，其余的功能进本上很少在使用</p><h3 id="标准类的制作"><a href="#标准类的制作" class="headerlink" title="标准类的制作"></a>标准类的制作</h3><p>&ensp;&ensp;&ensp;&ensp;Java中我们要定义一个类是有一个标准，这个标准叫做JavaBean，JavaBean是Java语言编写类第一种规范，符合JavaBean的类，要求<strong>类必须是公有的</strong>，<strong>属性需要使用private修饰</strong>，并且<strong>提供有参和无参构造方法</strong>，还要提供<strong>成员变量的set和get方法</strong> —》 这样类就称之为JavaBean标准类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">     <span class="keyword">private</span> String name;</span><br><span class="line">     <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line">    <span class="comment">//进入后：选Constructor  + 选全部 + ok = 生成全参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Product</span><span class="params">(<span class="type">int</span> id, String name, <span class="type">double</span> price)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进入后：选Constructor + 不用选 + Select None = 生成无参构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Product</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进入后：选Getter and Setter + 选全部 + ok = 生成公共访问</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getPrice</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">double</span> price)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> 返回值类型 方法名(参数列表)</span><br><span class="line">    &#123;</span><br><span class="line">        方法体;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：在通过题意针对某些类进行定义时，尽量使用JavaBean标准类定义的要求【私有属性、有参无参构造方法、Getter和Setter方法】进行类的定义，剩余的可以根据实际需求动态在类中记性增删添加即可</p><h2 id="2、继承"><a href="#2、继承" class="headerlink" title="2、继承"></a><center>2、继承</center></h2><h3 id="1）含义"><a href="#1）含义" class="headerlink" title="1）含义"></a>1）含义</h3><p>&ensp;&ensp;&ensp;&ensp;继承是面向对象三大特征之一，也是面向对象编程中不可缺少的一个操作，继承是一个比较好理解的概念和现实生活中继承是相同</p><p>&ensp;&ensp;&ensp;&ensp;在Java中继承概念: 在Java中指的是“一个类”可以“继承自”另外一个类，“被继承的类”叫做“父类&#x2F;基类&#x2F;超类”，“继承其他类的类”叫做 “子类&#x2F;派生类”，继承之后“子类”中就拥有“父类”中所有【可见】的成员【成员变量和成员方法】，子类就不需要在重复定义了，不仅如此子类还可以提供自身独有的【成员变量和成员方法】提供继承概念可以最大限度提高代码之间复用性【减少代码冗余、相同代码重复利用】，并且可以让类与类之间产生关联</p><p>案例:西游记中角色定义:</p><p>&ensp;&ensp;&ensp;&ensp;唐僧: 姓名&#x2F;性别&#x2F;年龄&#x2F; 念经</p><p>&ensp;&ensp;&ensp;&ensp;悟空: 姓名&#x2F;性别&#x2F;年龄&#x2F; 七十二变, 打妖怪</p><p>&ensp;&ensp;&ensp;&ensp;八戒: 姓名&#x2F;性别&#x2F;年龄&#x2F; 三十六变, 调戏嫦娥</p><p>&ensp;&ensp;&ensp;&ensp;沙僧: 姓名&#x2F;性别&#x2F;年龄&#x2F; 挑担, 求救</p><p>&ensp;&ensp;&ensp;&ensp;白龙马:姓名&#x2F;性别&#x2F;年龄&#x2F; 走</p><p>提供创建类的分析：</p><ol><li>设计唐生类，属性有3个【姓名&#x2F;性别&#x2F;年龄】，定义成成员变量，行为念经定成方法</li><li>设计悟空类，属性有3个【 姓名&#x2F;性别&#x2F;年龄】，定义成成员变量，行为七十二变, 打妖怪</li><li>设计八戒类，属性有3个【 姓名&#x2F;性别&#x2F;年龄】，定义成成员变量 ，行为 三十六变, 调戏嫦娥</li><li>设计沙僧类，属性有3个【姓名&#x2F;性别&#x2F;年龄】，定义成成员变量 ，行为 挑担, 求救</li><li>设计白龙马类，属性有3个【姓名&#x2F;性别&#x2F;年龄】，定义成成员变量 ，行为走</li></ol><p>当前5个类中有相同的属性都是需要定义三个属性分贝为【姓名&#x2F;性别&#x2F;年龄】，只是当前每个类中行为不同而已</p><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271925657.jpg" alt="继承解析"></p><h3 id="2）语法"><a href="#2）语法" class="headerlink" title="2）语法"></a>2）语法</h3><p>在Java中需要完成继承操作，需要使用到一个关键字【extends】 表示继承</p><p>PS： extends关键字的本身含义是“扩展的意思”，但是为了复合国人学习编程习惯，所以翻译成继承</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提供继承信息的是父类 --》如何定义【你平时如何定义类就如何定义父类】</span></span><br><span class="line"><span class="keyword">public</span> class 父类名字&#123;</span><br><span class="line">    成员变量;</span><br><span class="line">    构造方法;</span><br><span class="line">    Getter和Setter方法;</span><br><span class="line">    成员方法 ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//得到继承信息的是子类 --》 如何定义</span></span><br><span class="line"><span class="keyword">public</span> class 子类名字 extends 父类名字&#123; </span><br><span class="line">    <span class="comment">//类与类之间继承</span></span><br><span class="line">    子类可以得到父类所有的可见属性和方法【不是用<span class="keyword">private</span>修饰】</span><br><span class="line">    从父类继承而来就无需重复定义，直接使用即可</span><br><span class="line">    除此之外，子类还可以提供子类自身定义的</span><br><span class="line">    成员变量;</span><br><span class="line">    构造方法;</span><br><span class="line">    Getter和Setter方法;</span><br><span class="line">    成员方法 ;</span><br><span class="line">&#125; </span><br><span class="line">    在开发中父类就是一个模板类，给所有子类提供一些基础信息【属性和行为】，所以父类基本上是不</span><br><span class="line">    会直接创建对象，子类是继承父类而来，所以子类会比父类更加强大，不仅可以得到父类提供【属性和</span><br><span class="line">    行为】，而且子类自身也可以继续定义【属性和行为】，在开发中多是以子类作为创建对象依据来进行操作</span><br><span class="line">    <span class="comment">//在Java中所有类与类之间关系都是【单一继承】，一个子类只能有一个直接父类</span></span><br><span class="line">    例如：这种定义在Java中不被允许的</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125; <span class="comment">//父类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span>&#123;&#125; <span class="comment">//父类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span>,B 或者 <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span> B</span><br><span class="line">    或者 <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">B</span> ---》 都是错误语法</span><br><span class="line">    <span class="comment">//Java中一个类是不允许直接继承多个父类的即多继承</span></span><br><span class="line">    <span class="comment">//虽然Java中类不存在多继承的这种效果，但是Java中类允【间接继承（多重或多层继承）】</span></span><br><span class="line">    例如：</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123;&#125;</span><br><span class="line">    语法说明： A类是父类，对于B类而言A是B类父类，B是A的子类</span><br><span class="line">    对于C类而言B是C类父类，C是B的子类</span><br><span class="line">    因为B类是继承与A类，而C类是继承与B类，所有A类是C的间接父类，C也是A类间接子类</span><br><span class="line">    通俗的看待：A类就是爷爷 B类就父亲 C类就是孙子</span><br><span class="line">    其实你在Java中所有开发了类基本上都是继承关系类，也会存在间接继承的问题，Java中提供了一</span><br><span class="line">    个超级（根）类【Object】，Java所有的类都是直接或间接的继承于Object</span><br><span class="line">    每当在项目中创建一个类的时候，此时Java都是隐式的继承与Object这个类</span><br><span class="line">    例如：</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125; <span class="comment">//定义了一个A类，虽然表面上看着就是一个A类，但是实际上它是等价于</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">Object</span>&#123;&#125;</span><br><span class="line">    Java中是没有多继承，那么如果编写代码时明确继承与某一个类，那么 <span class="keyword">extends</span> <span class="title class_">Object</span> 会发生什么 </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> </span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123;&#125; <span class="comment">//明确继承之后，原有继承Object类操作就会被覆盖，提供给父</span></span><br><span class="line">    类继承，形成间接继承效果，只要提供一个类都是要继承与Object类的，就选明确继承了某个类，但</span><br><span class="line">    是父类也是要继承与Object类，所以类都是直接或间接继承与Object</span><br></pre></td></tr></table></figure><p>PS:先写父类还是先写子类</p><p>&ensp;&ensp;&ensp;&ensp;一般的，在开发时都会对你开发程序予以设计，这个设计中就会确定父类与子类，只需要通过这设计方案提供父类与子类实现就可以完成操作</p><p>&ensp;&ensp;&ensp;&ensp;在开发中发现某些类之间存在一些联系和一些固定属性和行为，可以二次封装出父类个人开发建议：尽量根据需求分析出是否存在父类，如果存在就提供实现，如果不存在就正常开发就可以</p><h4 id="好处和特点"><a href="#好处和特点" class="headerlink" title="好处和特点"></a>好处和特点</h4><p>好处：实现代码的复用，避免代码的冗余</p><p>特点：</p><p>&ensp;&ensp;&ensp;&ensp;a）子类继承父类，子类可以继承父类中的属性和方法</p><p>&ensp;&ensp;&ensp;&ensp;b）子类可以拥有自己独有的属性和方法</p><p>&ensp;&ensp;&ensp;&ensp;c）单继承，即在java中一个子类只能继承一个父类，但一个父类可以拥有多个子类</p><p>&ensp;&ensp;&ensp;&ensp;d）多重继承，即一个父类还可以继承另外一个类，java中最大的父类的是Object（如果一个类没有显示的写出extends，那么这个继承Object类）</p><h4 id="不能被继承情况"><a href="#不能被继承情况" class="headerlink" title="不能被继承情况"></a>不能被继承情况</h4><p>&ensp;&ensp;&ensp;&ensp;a）使用 修饰的属性和方法不能被子类继承</p><p>&ensp;&ensp;&ensp;&ensp;b）构造方法不能被继承（构造方法是用来创建类的对象）</p><p>&ensp;&ensp;&ensp;&ensp;c）父类中使用默认的修饰符的修饰的属性和方法在不同包的子类中不能被继承 </p><h4 id="以继承角度完成练习："><a href="#以继承角度完成练习：" class="headerlink" title="以继承角度完成练习："></a>以继承角度完成练习：</h4><p>贵妇从宠物店购买了宠物狗、宠物猫，某天，家里举行聚会，向朋友介绍起自家豢养的宠物的情形。</p><p>训练提示</p><p>&ensp;&ensp;&ensp;&ensp;a）设计宠物狗类，属性有4个【姓名，性别，年龄，品种】，行为【吃、睡觉】</p><p>&ensp;&ensp;&ensp;&ensp;b）设计宠物狗类，属性有4个【姓名，性别，年龄，品种】，行为【吃、卖萌】</p><p>&ensp;&ensp;&ensp;&ensp;c）设计贵妇类，属性有姓名，思考是有可以将狗和猫作为贵妇的属性存在，如果作为属性，那么如何在贵妇中提供方法介绍自己的从宠物狗和宠物猫</p><p>&#x2F;&#x2F;父类宠物类，这个类中提供宠物狗和宠物猫共有属性和行为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pet</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//共有属性【姓名、性别、年龄、品种】</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String kind;</span><br><span class="line">    <span class="comment">//在Java代码中可以利用编译器快捷的生成 构造方法、Get和Set</span></span><br><span class="line">    <span class="comment">//快捷键 alt+Insert ---》帮组我们生成需要【构造方法、Get和Set】</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pet</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pet</span><span class="params">(String name, String gender, <span class="type">int</span> age, String kind)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.kind = kind;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGender</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGender</span><span class="params">(String gender)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getKind</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> kind;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setKind</span><span class="params">(String kind)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.kind = kind;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//所有宠物中都有一个吃的行为</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;正在吃&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>宠物猫类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PetCat</span> <span class="keyword">extends</span> <span class="title class_">Pet</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//无需再PetCat中在定义 属性和吃行为 【因为继承Pet，所以子类可以得到属性和行为】</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meng</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(getName()+<span class="string">&quot;吃饱之后正在卖萌....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>宠物狗子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PetDog</span> <span class="keyword">extends</span> <span class="title class_">Pet</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//无需再PetDog中在定义 属性和吃行为 【因为继承Pet，所以子类可以得到属性和行为】</span></span><br><span class="line">    <span class="comment">//提供一个咬人行为即可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bite</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(getName()+<span class="string">&quot;吃饱之后正准备咬人....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>贵妇类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    在一个类中使用另外一个类属性和行为时，如何处理？</span></span><br><span class="line"><span class="comment">    第一种： 在使用类中，将另外一个类作为本类属性存在</span></span><br><span class="line"><span class="comment">        好处：因为是属性所以在整个类中和类外都可以访问操作【使用范围广泛】</span></span><br><span class="line"><span class="comment">        坏处：需要满足一些客观现实规律</span></span><br><span class="line"><span class="comment">    第二种： 在使用类中， 提供一个方法【一般是成员方法】将另外一个类作为本方法的参数定义使用</span></span><br><span class="line"><span class="comment">        好处：可以不用受到一些客观现实规律约束</span></span><br><span class="line"><span class="comment">        坏处：使用范围仅限于方法的内部，在其他位置无法使用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lady</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Lady</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Lady</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        eturn name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//提供两个行为：介绍宠物猫和宠物狗</span></span><br><span class="line">    <span class="comment">//PetCat cat:是一个类类型(引用类型)，在mian方法中new对应的类再把new出来的对象名传进来，这里就相当于PetCat cat = new PetCat();     </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showInfosPetCat</span><span class="params">(PetCat cat)</span>    </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫的名字：&quot;</span>+cat.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;猫的性别：&quot;</span>+cat.getGender());</span><br><span class="line">        System.out.println(<span class="string">&quot;猫的年龄：&quot;</span>+cat.getAge());</span><br><span class="line">        System.out.println(<span class="string">&quot;猫的品种：&quot;</span>+cat.getKind());</span><br><span class="line">        cat.eat(); <span class="comment">//这个方法在PetCat类中并无定义，是从父类继承而来</span></span><br><span class="line">        cat.meng();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showInfosPetDog</span><span class="params">(PetDog dog)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫的名字：&quot;</span>+dog.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;猫的性别：&quot;</span>+dog.getGender());</span><br><span class="line">        System.out.println(<span class="string">&quot;猫的年龄：&quot;</span>+dog.getAge());</span><br><span class="line">        System.out.println(<span class="string">&quot;猫的品种：&quot;</span>+dog.getKind());</span><br><span class="line">        dog.eat(); <span class="comment">//这个方法在PetCat类中并无定义，是从父类继承而来</span></span><br><span class="line">        dog.bite();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">PetCat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PetCat</span>();</span><br><span class="line">        cat.setName(<span class="string">&quot;小花&quot;</span>);</span><br><span class="line">        cat.setAge(<span class="number">1</span>);</span><br><span class="line">        cat.setGender(<span class="string">&quot;母&quot;</span>);</span><br><span class="line">        cat.setKind(<span class="string">&quot;美短&quot;</span>);</span><br><span class="line">        <span class="type">PetDog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PetDog</span>();</span><br><span class="line">        dog.setName(<span class="string">&quot;小白&quot;</span>);</span><br><span class="line">        dog.setAge(<span class="number">1</span>);</span><br><span class="line">        dog.setGender(<span class="string">&quot;公&quot;</span>);</span><br><span class="line">        dog.setKind(<span class="string">&quot;柯基&quot;</span>);</span><br><span class="line">        <span class="type">Lady</span> <span class="variable">lady</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lady</span>();</span><br><span class="line">        lady.showInfosPetCat(cat);<span class="comment">//这里就把对应的对象名(引用类型)传过去</span></span><br><span class="line">        lady.showInfosPetDog(dog);<span class="comment">//这里就把对应的对象名(引用类型)传过去</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题:</p><p>&ensp;&ensp;&ensp;&ensp;a）子类中如果需要对属性初始化，如何提供构造方法，想在创建子类的同时就完成对属性初始化操作，如何完成？</p><p>&ensp;&ensp;&ensp;&ensp;b）父类中提供了一个吃的方法eat，但是狗与猫之间吃的东西是不同的，需要在狗类中描述狗吃肉，需要在猫类中描述猫吃鱼，父类提供的方法实现就不能满足子类需求了，子类如何处理继承而来方法不能满足子类需求？</p><h3 id="4）super关键字"><a href="#4）super关键字" class="headerlink" title="4）super关键字"></a>4）super关键字</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>super关键字，它只能在子类中使用，并且super关键字相当于是提供一个父类的引用</p><p>super关键字一共有三个功能：</p><p>&ensp;&ensp;&ensp;&ensp;在子类可以通过super关键字调用父类提供成员变量 —》super.父类定义成员变量名</p><p>&ensp;&ensp;&ensp;&ensp;在子类可以通过super关键字调用父类提供成员方法 —》 super.父类定义成员方法名(参数赋值);</p><p>&ensp;&ensp;&ensp;&ensp;PS：这个操作是最主要的途径</p><p>&ensp;&ensp;&ensp;&ensp;在子类的构造方法中调用父类的构造方法来进行属性初始化</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;—》super() 调用就是父类无参构造方法 </p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;—》super(参数赋值) 调用父类的有参构造方法</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;—》必须在子类构造方法的第一句</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>&ensp;&ensp;&ensp;&ensp;a）调用父类的属性</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;如果当子类和父类中没有重名属性时，那么super和this关键字表示的属性是一致的，都是调用父类的</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;如果当子类和父类中有重名属性时，那么 super.属性名 表示：父类的属性，this.属性名 表示：子类的属性</p><p>&ensp;&ensp;&ensp;&ensp;b）调用父类的方法</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;如果当子类和父类中没有重名方法时，那么super和this关键字表示的方法是一致的，都是调用父类的</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;如果当子类和父类中有重名方法时，那么 super.方法名 表示：父类的方法，this.方法名 表示：子类的方法</p><p>&ensp;&ensp;&ensp;&ensp;c）调用父类的构造方法</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;注意：创建子类对象之前，必须要先创建父类的对象</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;（a）super();调用的是父类的无参构造。是可以完全省略的，省不省略都会执行(建议：保留父类的无参构造)</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;（b）super调用父类的有参构造，要放到构造方法第一行。super和this不能同时出现 </p><p>父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="type">char</span> gender;</span><br><span class="line">    <span class="comment">//提供构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">char</span> gender)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//提供Get和Set方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">getGender</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGender</span><span class="params">(<span class="type">char</span> gender)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">extends</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        子类继承父类之后，可以得到父类中所有的可见属性和行为【非private】</span></span><br><span class="line"><span class="comment">        子类还可以提供自己独有属性和行为</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        发生继承之后 子类是不可以继承父类构造方法，所以子类需要提供自己的构造方法</span></span><br><span class="line"><span class="comment">        子类依旧要提供有参和无参构造方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Man</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        子类的有参构造方法如何提供，子类的构造方法一般会将从父类得到属性和子类的属性都进行创建对象</span></span><br><span class="line"><span class="comment">初始化</span></span><br><span class="line"><span class="comment">        所以建议在子类构造方法中 提供父类得到属性和子类的属性同一操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Man</span><span class="params">(String name, <span class="type">char</span> gender,<span class="type">int</span> age)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如何对父类初始化呢？ --&gt; 使用父类中提供set方法对父类属性初始化</span></span><br><span class="line">        <span class="comment">// setName(name); //问题在于 如果属性过多，子类构造方法就要大量调用set方法</span></span><br><span class="line">        <span class="comment">//此时就可以使用super关键字调用父类的构造方法来辅助子类初始化继承属性</span></span><br><span class="line">        <span class="comment">//super(); //调用无参构造方法</span></span><br><span class="line">        <span class="built_in">super</span>(name,gender);<span class="comment">// 调用父类的有参构造方法</span></span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            PS：非常推荐使用这种方式进行属性初始化操作，简便易懂其他开发人员如何查看你编写代码</span></span><br><span class="line"><span class="comment">            发现这个构造方法时，就可以知道那些属性是父类提供【super关键字初始化】，那些属性</span></span><br><span class="line"><span class="comment">是子类提供【使用this】</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125; </span><br><span class="line">        <span class="comment">//成员方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//调用父类中属性</span></span><br><span class="line">        System.out.println(<span class="built_in">super</span>.gender);</span><br><span class="line">        <span class="comment">//调用父类中成员方法</span></span><br><span class="line">        <span class="built_in">super</span>.getGender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：super关键字在子类中最大作用就是调用父类的构造方法，辅助子类完成属性初始化</p><p>this关键字与Super关键字的不同？</p><ol><li>this关键字可以使用在任何类中，并且可以作为方法参数传递</li><li>super关键字只能使用在子类中，并且不可以作为方法参数传递</li><li>this关键字代表的是当前对象， super关键字代表的是父类对象的引用</li></ol><h3 id="5）方法重写"><a href="#5）方法重写" class="headerlink" title="5）方法重写"></a>5）方法重写</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>&ensp;&ensp;&ensp;&ensp;当父类提供成员方法实现，无法满足子类需求时，子类可以在本类中提供父类成员方法重新实现的操作，子类中有与父类相同签名的方法 称之为 方法重写 </p><p>&ensp;&ensp;&ensp;&ensp;相同签名：方法名相同、参数相同、返回值相同、访问修饰符（子类要比父类更宽泛(看上面表格)）</p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>&ensp;&ensp;&ensp;&ensp;因为父类的方法无法满足子类的需求，所以需要重写父类的方法 </p><p>&ensp;&ensp;&ensp;&ensp;子类方法重写的格式：子类中出现重写父类方法操作是，父类方法如何定义，子类方法就如何定义，只是子类将原有方法的实现重新完成(重写方法名回车)</p><p>&ensp;&ensp;&ensp;&ensp;一旦子类发生重写父类方法之后，外界在调用方法必然执行子类重写之后的方法，无法在调用到父类原有方法</p><p>PS：非要看到父类方法的原有实现：</p><p>&ensp;&ensp;&ensp;&ensp;外界方式实现即在子类外部查看：提供父类对象创建，并使用父类对象调用方法【极少使用】</p><p>&ensp;&ensp;&ensp;&ensp;内界方法实现即在子类内部查看：使用super关键字调用父类原有方法即可</p><h4 id="注解：-Override"><a href="#注解：-Override" class="headerlink" title="注解：@Override"></a>注解：@Override</h4><p>&ensp;&ensp;&ensp;&ensp;建议在重写方法的时候，加上注解</p><p>&ensp;&ensp;&ensp;&ensp;作用：检测是否是满足方法重写。必须满足重写的要求，否则报错</p><p>&ensp;&ensp;&ensp;&ensp;注意：父类中的是私有方法，子类无法重写（私有方法不能被继承，所以不能被重写）</p><p>&ensp;&ensp;&ensp;&ensp;需求: 创建一个父类鸟类（Brid），父类就提供一个方法fly，在创建两个子类麻雀类和鸵鸟类</p><p>父类鸟类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bird</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供一个飞翔方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;可以飞翔&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类麻雀</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sparrow</span> <span class="keyword">extends</span> <span class="title class_">Bird</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//子类可以得到父类提供公有fly方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类鸵鸟</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ostich</span> <span class="keyword">extends</span> <span class="title class_">Bird</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//子类可以得到父类提供公有fly方法</span></span><br><span class="line">    <span class="comment">//提供对父类fly方法重写操作【最简单的原则，父类方法如何定义，</span></span><br><span class="line">    <span class="comment">// 子类重写时就如何定义，只要提供不同的实现即可】</span></span><br><span class="line">    <span class="comment">//这就是当前子类重写父类方法的操作定义</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//注解，作用就是提供给编译器说明子类有重写父类方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// super.fly(); ---》 这种方式就可以调用到父类方法的原有实现</span></span><br><span class="line">        <span class="comment">//只需要在这个方法中提供子类自己实现方式即可---》 重写</span></span><br><span class="line">        System.out.println(<span class="string">&quot;我不会飞，但是跑的很快！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Sparrow</span> <span class="variable">sparrow</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sparrow</span>();</span><br><span class="line">        <span class="type">Ostich</span> <span class="variable">ostich</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ostich</span>();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            麻雀可以飞翔是没问题的，但是鸵鸟是不会飞的，所以如果鸵鸟这个对象调用</span></span><br><span class="line"><span class="comment">            fly方法打印出可以“可以飞翔”和明显不符合要求的</span></span><br><span class="line"><span class="comment">            触发了一个原则，父类提供方法无法满足子类需求，子类可以重写父类方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        sparrow.fly();</span><br><span class="line">        <span class="comment">//子类一旦重写父类方法之后在调用方法，必然是子类重写之后的实现啊</span></span><br><span class="line">        ostich.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="重写完成要求："><a href="#重写完成要求：" class="headerlink" title="重写完成要求："></a>重写完成要求：</h4><ol><li><p>若<strong>父类的方法使用private、static或final修饰中任意一个修饰符修饰，那么子类都不可以重写这个方法</strong></p></li><li><p>重写方法必须所有继承关系，没有继承关系两个类是不可以重写对方方法</p></li><li><p>重写成员成员方法方法签名必须相同【方法签名&#x3D;方法名+参数列表】</p></li><li><p>子类重写父类方法是，提供原有父类方法返回值类型的子类类型或同类型</p></li><li><p>在重写时，子类提供方法访问权限修饰符要大于等于父类的方法权限修饰符</p></li><li><p>在重写时,父类的方法提供异常类抛出，子类提供异常类型必须相同类型或子类类型</p></li></ol><h4 id="方法重载与方法重写的区别"><a href="#方法重载与方法重写的区别" class="headerlink" title="方法重载与方法重写的区别"></a>方法重载与方法重写的区别</h4><table><thead><tr><th align="center"></th><th align="center">位置</th><th align="center">方法名</th><th align="center">返回值类型</th><th align="center">参数列表</th><th align="center">访问修饰符</th></tr></thead><tbody><tr><td align="center">方法重载</td><td align="center">本类</td><td align="center">一致</td><td align="center">无关</td><td align="center">不一致</td><td align="center">无关</td></tr><tr><td align="center">方法重写</td><td align="center">子类</td><td align="center">一致</td><td align="center">一致</td><td align="center">一致</td><td align="center">子类更宽</td></tr></tbody></table><h4 id="继承中子类实例化过程"><a href="#继承中子类实例化过程" class="headerlink" title="继承中子类实例化过程"></a>继承中子类实例化过程</h4><p>&ensp;&ensp;&ensp;&ensp;PS:在Java中继承实例化过程是遵守现实客观规律，现实生活中一定是先有你父亲再有你</p><p>父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;父类的无参构造方法调用&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类的有参构造方法调用&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供子类构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类的无参构造按方法被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//使用set方法对age进行</span></span><br><span class="line">        setAge(age);</span><br><span class="line">        System.out.println(<span class="string">&quot;子类的有参构造方法被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//分别使用子类的无参和有参构造方法创建对象</span></span><br><span class="line">        <span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">        <span class="type">Son</span> <span class="variable">son1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;&ensp;&ensp;发生子类继承父类之后，在创建子类对象过程时，<strong>是先调用父类无参构造方法，然后再调用子类的构造方法创建对象，先创建父类的对象，在创建子类对象，继承之后子类的实例化过程</strong></p><p><strong>&ensp;&ensp;&ensp;&ensp;子类的构造方法中【会默认调用父类无参构造方法】，所以父类要提供无参构造方法，让子类只可以正确的创建对象</strong></p><p>&ensp;&ensp;&ensp;&ensp;某些情况下缺失父类忘记了提供无参构造方法，但是提供其他的构造方法，是否可以辅助子类构造对象呢？ —》 可以，如果父类没有明确提供无参构造方法，但是<strong>提供其他的有参构造方法，子类只需要在本类中构造方法位置明确调用父类的构造方法即可—》使用super关键字</strong></p><p>&ensp;&ensp;&ensp;&ensp;子类实例化完整说明：子类在继承父类之后，<strong>子类中提供构造方法是默认调用父类无参构造方法来辅助创建对象，若父类没有明确提供无参构造方法，可以使用super关键调用父类其他的构造方法在子类构造方法中辅助创建对象，所以子类对象创建一定是先创建父类对象，在创建子类对象</strong></p><h4 id="子类继承父类之后内存存储"><a href="#子类继承父类之后内存存储" class="headerlink" title="子类继承父类之后内存存储"></a>子类继承父类之后内存存储</h4><p>&ensp;&ensp;&ensp;&ensp;继承体系内存图原理–》父类的空间优于子类对象产生</p><p>&ensp;&ensp;&ensp;&ensp;在每次创建子类对象时，先初始化父类空间，在创建其子类对象本身，目的在与子类对象中包含了其对应的父类空间，便可以包含父类的成员，如果父类成员非private修饰，则子类可以随意使用父类成员，代码体现在子类的构造方法调用时，是默认调用父类无参构造方法的</p><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271926956.jpg" alt="子类继承父类之后内存存储"></p><p>&ensp;&ensp;&ensp;&ensp;当子类调用方法的原则时，优先扫描子类中是否存在当前方法【定义和重写的】，如果子类存在这方法就调用子类方法，如果子类不存在次方法到调用父类方法</p><p>&ensp;&ensp;&ensp;&ensp;如果子类中出现与父类中重名属性，是不存在【属性重写概念】，对象执行调用时，优先扫描子类中所存在属性，如果子类定义类就获取子类属性，如果子类中没有扫描父类中继承而来属性</p><h2 id="3、多态"><a href="#3、多态" class="headerlink" title="3、多态"></a><center>3、多态</center></h2><h3 id="1）定义"><a href="#1）定义" class="headerlink" title="1）定义"></a>1）定义</h3><p>&ensp;&ensp;&ensp;&ensp;多态在Java中定义原则：同一个事物被不同对象所触发，得到结果不同就称之为多态</p><p>&ensp;&ensp;&ensp;&ensp;在生活中，比如跑的动作，小猫、小狗和大象，跑去起来都是不一样的，再比如飞的动作，昆虫、鸟和飞机，飞起来也是不一样的，所以可见，同一个行为，通过不同事物，可以体现出不同的行为，这就是多态的描述</p><p>在现实生活中家里饲养了一些宠物</p><p>&ensp;&ensp;&ensp;&ensp;养了宠物狗： 叫声 —-》 汪汪汪</p><p>&ensp;&ensp;&ensp;&ensp;养了宠物猫： 叫声 —-》 喵喵喵</p><p>在Java中将多态体现在代码中行为有哪些？</p><p>【方法多态】：方法多态的体现就是“重载”,同一个方法被不同参数所触发，得到方法的结果不同就是方法多态</p><p>【对象多态】：同一个方法，对不同对象触发可以得到不用表现形式</p><p><strong>&ensp;&ensp;&ensp;&ensp;发生对象多态有一个必要前提</strong>：<strong>必须存在【继承或实现】关系</strong>、需要有子类重写方法的实现【可以让多态先更加完善】</p><p>&ensp;&ensp;&ensp;&ensp;对象多态中对于我们开发而言最主要的就是【里氏代转换原则】，通过这个原则可以发挥多态最大效力</p><h3 id="里氏代转换原则"><a href="#里氏代转换原则" class="headerlink" title="里氏代转换原则"></a>里氏代转换原则</h3><p>&ensp;&ensp;&ensp;&ensp;里氏代转换原则在程序最主要体现就是提供了【子类与父类之间的转换操作】，这里这个操作就可以动态概念改变当前对象，从而满足不同开发需求</p><p>&ensp;&ensp;&ensp;&ensp;如果要体现里氏代转换原则，是有一个必要前提【需要存在【继承或实现】关系】</p><p>&ensp;&ensp;&ensp;&ensp;即类与类之间必须是继承关系 类与接口之间是实现关系</p><p>&ensp;&ensp;&ensp;&ensp;没有任何联系的类是无法完成这个操作</p><p>&ensp;&ensp;&ensp;&ensp;例如： 类Dog和类Person，这两两个类都是独立的，那么Dog类和Person了就不能完成里氏代转换原则</p><h3 id="2）特点"><a href="#2）特点" class="headerlink" title="2）特点"></a>2）特点</h3><p>&ensp;&ensp;&ensp;&ensp;编译看左边，运行看右边</p><p>&ensp;&ensp;&ensp;&ensp;如果发生多态，那么无法调用子类独有的方法（编译看左边（左边是父类））</p><p>&ensp;&ensp;&ensp;&ensp;如果发生多态，那么调用的一定是子类重写的方法（运行看右边）</p><h3 id="3）多态产生条件"><a href="#3）多态产生条件" class="headerlink" title="3）多态产生条件"></a>3）多态产生条件</h3><p>&ensp;&ensp;&ensp;&ensp;（1）必须要有继承</p><p>&ensp;&ensp;&ensp;&ensp;（2）必须要有方法重写</p><p>&ensp;&ensp;&ensp;&ensp;（3）必须要父类的引用指向子类的对象</p><h3 id="4）向上向下转型"><a href="#4）向上向下转型" class="headerlink" title="4）向上向下转型"></a>4）向上向下转型</h3><p><strong>&ensp;&ensp;&ensp;&ensp;向上转型</strong>：父类引用指向子类对象</p><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父类类型 对象名字 = <span class="keyword">new</span> 子类类型();</span><br></pre></td></tr></table></figure><p>此时这个类子类就会被默认提升为父类类型，当前对象只能调用父类中提供属性和行为，无法调用子类中提供自有属性和行为</p><p>PS：这也是开发中唯一创建父类对象一种方式，不会使用父类直接创建对象</p><p>【即 父类类型 对象名 &#x3D; new 父类类型();】</p><p><strong>&ensp;&ensp;&ensp;&ensp;向下转型</strong>：将父类引用强转成子类类型</p><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">子类类型 对象名 = (子类类型)提升为父类类型对象;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;&ensp;&ensp;此时这个对象就会被转换为原来子类类型，当前对象即可以调用父类中提供可见属性和行为，也可以调用子类自有属性和行为</p><p>&ensp;&ensp;&ensp;&ensp;如果发生多态，那么无法调用子类独有的方法。如果要调用子类独有的方法，那么必须发生向下转型，前提是先发生过向上转型，否则会报错</p><h3 id="5）instanceOf关键字"><a href="#5）instanceOf关键字" class="headerlink" title="5）instanceOf关键字"></a>5）instanceOf关键字</h3><p>&ensp;&ensp;&ensp;&ensp;可以利用instanceof这个关键字检查 提升之后对象是否是某一个子类类型对象即【当前提升之后对象是否属于某个子类类型】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">    提升之后对象 <span class="keyword">instanceof</span> 子类类型</span><br><span class="line">    </span><br><span class="line">上面这个表达式就会帮组你判断，提升之后对象是否属于但当前提供子类类型</span><br><span class="line">    返回值为 <span class="literal">true</span> 【证明当前对象是由当前子类类型提升而来】</span><br><span class="line">            <span class="literal">false</span> 【证明当前对象不是当前子类类型提升而来】</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类动物类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name, String gender)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGender</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGender</span><span class="params">(String gender)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//子类狗类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name,String gender,<span class="type">int</span> age)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(name,gender);</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//子类猫类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String kind;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String name, String gender, String kind)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(name,gender);</span><br><span class="line">        <span class="built_in">this</span>.kind = kind;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getKind</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> kind;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setKind</span><span class="params">(String kind)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.kind = kind;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供对象向上转型</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            父类引用可以接收一个子类的引用</span></span><br><span class="line"><span class="comment">            此时会将Dog类型对象提升为父类Animal类型</span></span><br><span class="line"><span class="comment">            此时只能调用父类中属性和行为，不能调用子类自己属性和行为</span></span><br><span class="line"><span class="comment">            如果子类重写父类的方法，提升之后对象调用方法执行时，依旧执行子类重写效果</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        animal.getName();</span><br><span class="line">        <span class="comment">//animal.getAge(); //getAge方法是子类自身的，并不是父类的</span></span><br><span class="line">        <span class="comment">//2.提供对象向下转型</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            将一个提升为父类类型对象转换为原有子类类型操作就叫做对象向下转型</span></span><br><span class="line"><span class="comment">            此时会将提升之后父类对象animal转换为原有子类类型Dog</span></span><br><span class="line"><span class="comment">            转型之后不仅可以调用子类的属性和方法，而且也可以调用父类属性和方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog)animal;</span><br><span class="line">        dog.getName();</span><br><span class="line">        dog.getAge();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对象向下转型会存在一个问题，如果转型失败会出现一个异常问题，而这个问题不会在编译阶段进行提示只能在运行时提示</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//此时明显animal是Dog类型提升的，并不是Cat，所以这个操作是有问题，但是编译阶段是不会提示错误</span></span><br><span class="line">        <span class="comment">//系统就会提示 ClassCastException --&gt; 强制类型转换异常</span></span><br><span class="line">        <span class="comment">// Cat cat = (Cat)animal;</span></span><br><span class="line">        <span class="comment">//所以为了避免这个问题发生，可以使用instanceof这个关键字进行转换对象判断</span></span><br><span class="line">        <span class="keyword">if</span>(animal <span class="keyword">instanceof</span> Cat)</span><br><span class="line">        &#123; <span class="comment">//判断animal对象是否是Cat类型对象 ---》 true 是 / false 不是</span></span><br><span class="line">            <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (Cat)animal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;animal不是Cat类型无法进行对象向下转型&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;&ensp;&ensp;综上所述：在进行对象向下转型时，为了保证对象可以正确转换到对应子类类型中，建议使用instanceof关键字进行，对象子类类型检查，在进行检查时会配合if语句使用，如果检查成功就会在if语句执行代码中进行向下转型操作，使用仅限在if大括号内部，提高范围使用就建议将对象声明定义在if语句外部</p><p>&ensp;&ensp;&ensp;&ensp;PS：在实际开发，如果你能确定子类类型是什么，那么就不写instanceof操作</p><p>&ensp;&ensp;&ensp;&ensp;以上这些就是多态的一些操作点和概念,多态主要就是提供可扩展和可维护性,好处就可以利用多态让方法使用起来更加高效(子类类型都可以),可以辅助抽象类和接口创建对象,弊端在于如果利用父类作为方法参数类型或返回值类型的时候,返回和接受的属性都会被向上转型为父类类型,子类的自己的属性和方法就不能调用,这样会牺牲一部分灵活性,如何弥补就是向下转型</p><h3 id="6）多态的引用场景"><a href="#6）多态的引用场景" class="headerlink" title="6）多态的引用场景"></a>6）多态的引用场景</h3><p>&ensp;&ensp;&ensp;&ensp;（1）方法的参数</p><p>&ensp;&ensp;&ensp;&ensp;（2）方法的返回值</p><p>例：</p><p>设计一个员工类，其中有计算员工薪水方法，根据不同的员工计算薪水的方法不同</p><p>&ensp;&ensp;&ensp;&ensp;员工类型 薪水构成</p><p>&ensp;&ensp;&ensp;&ensp; &#x3D;&#x3D; &#x3D;&#x3D; &#x3D;&#x3D; &#x3D;&#x3D; &#x3D;&#x3D; &#x3D;&#x3D; &#x3D;&#x3D; &#x3D;&#x3D; &#x3D;&#x3D; &#x3D;&#x3D;&#x3D;</p><p>&ensp;&ensp;&ensp;&ensp;经理 底薪+奖金</p><p>&ensp;&ensp;&ensp;&ensp;销售人员 底薪+提成</p><p>&ensp;&ensp;&ensp;&ensp;普通员工 底薪+补贴</p><p>设计一个测试类，场景如下，年终，领导找员工谈话，让员工介绍介绍自己的薪水</p><p>分析：</p><ol><li>在公司除了老板都是员工，经理、销售、普通员工都是员工</li><li>既然这三者【经理、销售、普通员工】都是员工，可以根据他们共有属性和行为提供一个统一父类</li><li>分别在使用这三者【经理、销售、普通员工】进行与父类至今继承关系从而到需要属性和行为</li><li>设一个方法年终领导让员工介绍自己，如果没有多态之前，三个员工就需要提供是三个自我介绍方法【公司员工暴增300人，又到一年年末自我介绍 —》提供300个方法（方法管理与维护都是十分麻烦）】，此时可以将方法提供为最大通用性，只提供一个方法进行员工介绍， 利用多态的特点，将参数设计为父类类型，这样一来只要继承父类员工类，都可以进入到这个方法中进行执行操作</li></ol><p>员工父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供共有的属性和行为</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> money; <span class="comment">//底薪</span></span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//员工姓名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(<span class="type">int</span> money, String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMoney</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoney</span><span class="params">(<span class="type">int</span> money)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">        经理、普通员工和销售都有自己计算薪水方法</span></span><br><span class="line"><span class="comment">        父类中提供一个方法，让子类来进行重写操作</span></span><br><span class="line"><span class="comment">        因为这个方法必然被子类重写，所以就不提供具体实现，由子类自己进行重写操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showMoney</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类经理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> jiangjin;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">(<span class="type">int</span> money, String name, <span class="type">int</span> jiangjin)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(money, name);</span><br><span class="line">        <span class="built_in">this</span>.jiangjin = jiangjin;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getJiangjin</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> jiangjin;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setJiangjin</span><span class="params">(<span class="type">int</span> jiangjin)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.jiangjin = jiangjin;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//提供介绍字节薪水的方式</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showMoney</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(getName()+<span class="string">&quot;是经理,底薪：&quot;</span> + getMoney()+<span class="string">&quot; 奖金：&quot;</span></span><br><span class="line">                        +jiangjin+<span class="string">&quot; 综合工资：&quot;</span>+</span><br><span class="line">(getMoney()+jiangjin));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类销售类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sales</span> <span class="keyword">extends</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> ticheng;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sales</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sales</span><span class="params">(<span class="type">int</span> money, String name, <span class="type">int</span> ticheng)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(money, name);</span><br><span class="line">        <span class="built_in">this</span>.ticheng = ticheng;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getticheng</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">return</span> ticheng;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setticheng</span><span class="params">(<span class="type">int</span> ticheng)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.ticheng = ticheng;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//提供介绍字节薪水的方式</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showMoney</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(getName()+<span class="string">&quot;是销售,底薪：&quot;</span></span><br><span class="line">        +getMoney()+<span class="string">&quot; 奖金：&quot;</span>+ticheng+<span class="string">&quot; 综合工资：&quot;</span>+(getMoney()+ticheng));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类普通员工类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Staff</span> <span class="keyword">extends</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> butie;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Staff</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Staff</span><span class="params">(<span class="type">int</span> money, String name, <span class="type">int</span> butie)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(money, name);</span><br><span class="line">        <span class="built_in">this</span>.butie = butie;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getbutie</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> butie;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setbutie</span><span class="params">(<span class="type">int</span> butie)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.butie = butie;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//提供介绍字节薪水的方式</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showMoney</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(getName()+<span class="string">&quot;是普通员工,底薪：&quot;</span></span><br><span class="line">            +getMoney()+<span class="string">&quot; 奖金：&quot;</span>+butie+<span class="string">&quot; 综合工资：&quot;</span>+(getMoney()+butie));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Boss测试类进行员工信息测试操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BossTest</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//提供老板、经理、销售和普通员工对象进行操作</span></span><br><span class="line">        <span class="type">BossTest</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BossTest</span>();</span><br><span class="line">        <span class="type">Manager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>(<span class="number">1000</span>,<span class="string">&quot;张三&quot;</span>,<span class="number">2000</span>);</span><br><span class="line">        <span class="type">Sales</span> <span class="variable">sales</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sales</span>(<span class="number">100</span>,<span class="string">&quot;大宝&quot;</span>,<span class="number">10000</span>);</span><br><span class="line">        <span class="type">Staff</span> <span class="variable">staff</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Staff</span>(<span class="number">10000</span>,<span class="string">&quot;李四&quot;</span>,<span class="number">200000</span>);</span><br><span class="line">        <span class="comment">//普通实现</span></span><br><span class="line">        <span class="comment">// boss.showInfosManager(manager);</span></span><br><span class="line">        <span class="comment">// boss.showInfosSales(sales);</span></span><br><span class="line">        <span class="comment">// boss.showInfosStaff(staff);</span></span><br><span class="line">        <span class="comment">//利用多态的对象向上转型操作，方法中参数是父类类型，他可以接收当前这个父类类型的所有子类引用</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时 方法参数类型是Employee父类类型 参数赋值是 子类类型manager</span></span><br><span class="line"><span class="comment">            所以参数赋值时就形成了 Employee employee = manager 即 Employee employee =</span></span><br><span class="line"><span class="comment">new Manager(1000,&quot;张三&quot;,2000);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        boss.showInfosEmployee(manager);</span><br><span class="line">        boss.showInfosEmployee(sales);</span><br><span class="line">        boss.showInfosEmployee(staff);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//在不使用多态的前提下【如果不使用多态就会面临一个问题，如果员工个数增加了，这里就需要添加多个方法】</span></span><br><span class="line">    <span class="comment">// 随着员工增加与删减，这样我们方法所在类就会被进行频繁的修改，这样并不利于方法管理与维护</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showInfosManager</span><span class="params">(Manager manager)</span></span><br><span class="line">    &#123;</span><br><span class="line">        manager.showMoney();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showInfosSales</span><span class="params">(Sales sales)</span></span><br><span class="line">    &#123;</span><br><span class="line">        sales.showMoney();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showInfosStaff</span><span class="params">(Staff sales)</span></span><br><span class="line">    &#123;</span><br><span class="line">        sales.showMoney();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">        多态的就出现了，可以利用多态的特点将多态进行方法参数或返回值类型设置，这样就可以提高代码的通</span></span><br><span class="line"><span class="comment">用性和重用性</span></span><br><span class="line"><span class="comment">        此时并不需要设置多个方法，只需要提供一个方法，方法参数设置为父类类型</span></span><br><span class="line"><span class="comment">        利用多态中对象向上转型操作，就可以得到具体实现</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showInfosEmployee</span><span class="params">(Employee employee)</span></span><br><span class="line">    &#123;</span><br><span class="line">        employee.showMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点十：三个修饰符"><a href="#知识点十：三个修饰符" class="headerlink" title="知识点十：三个修饰符"></a><center>知识点十：三个修饰符</center></h1><h2 id="1、abstract关键字"><a href="#1、abstract关键字" class="headerlink" title="1、abstract关键字"></a><center>1、abstract关键字</center></h2><h3 id="1）含义-1"><a href="#1）含义-1" class="headerlink" title="1）含义"></a>1）含义</h3><p>抽象的</p><h3 id="2）抽象类含义：被abstract修饰的类称之为抽象类"><a href="#2）抽象类含义：被abstract修饰的类称之为抽象类" class="headerlink" title="2）抽象类含义：被abstract修饰的类称之为抽象类"></a>2）抽象类含义：被abstract修饰的类称之为抽象类</h3><p>特点：</p><ol><li>抽象类不能直接创建对象，即不能通过new 抽象类类名()的方式完成，因为抽象类中会存在抽象方法，这个抽象方法没有方法体，如果抽象类可以使用new 抽象类类名()的方式完成，那么抽象类和抽象方法就没有存在的意义了</li><li>抽象类中是可以选择性包含抽象方法的，如果包含了抽象方法的抽象类被子类继承时，子类需要重写抽象父类中抽象方法【其他的成员方法也可以选择性重写】，如果没有包含抽象方法的抽象类被子类继承时，子类可以选择性重写其他方法</li><li>抽象类提供目的是为了保证父类的完成操作的前提下，让父类具备一些其他功能【抽象方法和防止直接创建对象】，所以抽象类需要提供构造方法</li><li>抽象类的提供就是为了让子类继承而提供的，所以抽象类是允许多态概念的使用</li></ol><p>作用：</p><p>&ensp;&ensp;&ensp;&ensp;抽象类定义方式其实就是父类的定义方法，会在抽象类中提供所有父类的操作，抽象类在类中主要的作用就是作为父类存在</p><p>PS:抽象类就是一个特殊父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法格式：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> class 类名    <span class="comment">//这个类就是抽象类</span></span><br><span class="line">&#123; </span><br><span class="line">    父类如何定义，抽象类的内部就如何定义</span><br><span class="line">    成员变量</span><br><span class="line">    构造方法</span><br><span class="line">    成员方法</span><br><span class="line">    静态变量</span><br><span class="line">    静态方法</span><br><span class="line">    方法重写</span><br><span class="line">    抽象方法</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//抽象类就是多了一个abstract关键字的父类</span></span><br></pre></td></tr></table></figure><p>PS：建议在以后开发中，<strong>如果确定这个类是一个父类就建议优先声明成“抽象类”</strong></p><p>&ensp;&ensp;&ensp;&ensp;抽象类可以像普通类一样使用可以继承，可以实现，可以定义类中所有定义的东西，但是就是不允许直接创建抽象类对象【即 抽象类类名 对象 &#x3D; new 抽象类类名();】,抽象类是它支持多态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建抽象类葵花宝典</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SunflowerBible</span> </span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3）抽象方法"><a href="#3）抽象方法" class="headerlink" title="3）抽象方法"></a>3）抽象方法</h3><p>含义：使用abstract关键字修饰并且没有方法体，存在在抽象类中叫做抽象方法</p><p>特点：</p><p>&ensp;&ensp;&ensp;&ensp;（1）抽象方法必须出现在抽象类中</p><p>&ensp;&ensp;&ensp;&ensp;（2）抽象方法不能有方法体（方法的实现{}）并且在小括号后面添加【;】</p><p>&ensp;&ensp;&ensp;&ensp;（3）抽象方法必须要在非抽象子类中重写</p><p>&ensp;&ensp;&ensp;&ensp;（4）抽象方法修饰符不能使用private、static和final，只要使用这三个修饰符，这个方法就无法在进行重写实现了，所以就失去抽象方法的目的了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象方法的格式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> 返回值类型 方法名(参数列表);</span><br></pre></td></tr></table></figure><p>抽象类和抽象方法什么时候用？</p><p>&ensp;&ensp;&ensp;&ensp;抽象类我们一般用比较少，未来更多是使用接口</p><p>&ensp;&ensp;&ensp;&ensp;在接口中全部都是抽象方法，抽象方法的作用就是为了让子类去重写</p><p>练习：</p><p>&ensp;&ensp;&ensp;&ensp;设计一个公司抽象类，具有抽象方法 – 营业，休息</p><p>&ensp;&ensp;&ensp;&ensp;设计一个快递公司类作为公司类的子类</p><p>&ensp;&ensp;&ensp;&ensp;设计一个顺丰快递类，作为快递类的子类</p><p>&ensp;&ensp;&ensp;&ensp;需求：实例化一个顺丰快递的对象，从控制台录入一个24以内的数据，如果数据在8~18点之间，顺丰营业。否则，顺丰快递公司休息</p><p>提供一个公司的抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Company</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String companyName;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Company</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Company</span><span class="params">(String companyName)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.companyName = companyName;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCompanyName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> companyName;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCompanyName</span><span class="params">(String companyName)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.companyName = companyName;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//营业的抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//休息的抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快递公司在需求中并没有做任何特殊说明</p><p>此时可以将这个类作为一个抽象类</p><p>使用一个抽象类继承与另外一个抽象类，当前这个抽象子类可以选择性实现或者不实现抽象父类中抽象方法</p><p>不是先父类抽象方法原因，是因为这个也是抽象类，也可以存储抽象方法所以抽象子类可以选择性实现抽象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CourierServicesCompany</span> <span class="keyword">extends</span> <span class="title class_">Company</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CourierServicesCompany</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CourierServicesCompany</span><span class="params">(String companyName)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(companyName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺丰快递公司子类</p><p>如果使用一个普通类继承与抽象类，必须实现抽象类中所提供抽象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SFCompany</span> <span class="keyword">extends</span> <span class="title class_">CourierServicesCompany</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SFCompany</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SFCompany</span><span class="params">(String companyName)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(companyName);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(getCompanyName()+<span class="string">&quot;正在营业，欢迎光临.....&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    System.out.println(getCompanyName()+<span class="string">&quot;下班休息，下次再来.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test类（测试类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入时间:&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">time</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">        <span class="type">SFCompany</span> <span class="variable">sfCompany</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SFCompany</span>(<span class="string">&quot;顺丰快递&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(time &gt;= <span class="number">8</span> &amp;&amp; time &lt;= <span class="number">18</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sfCompany.open();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            sfCompany.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、static关键字"><a href="#2、static关键字" class="headerlink" title="2、static关键字"></a><center>2、static关键字</center></h2><h3 id="1）含义-2"><a href="#1）含义-2" class="headerlink" title="1）含义"></a>1）含义</h3><p>静态的</p><h3 id="2）作用"><a href="#2）作用" class="headerlink" title="2）作用"></a>2）作用</h3><p>修饰：成员变量、成员方法、成员变量、代码块、内部类</p><h3 id="3）静态和成员之间的区别"><a href="#3）静态和成员之间的区别" class="headerlink" title="3）静态和成员之间的区别"></a>3）静态和成员之间的区别</h3><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271926050.jpg" alt="静态和成员之间的区别"></p><h3 id="4）static修饰成员变量"><a href="#4）static修饰成员变量" class="headerlink" title="4）static修饰成员变量"></a>4）static修饰成员变量</h3><p>&ensp;&ensp;&ensp;&ensp;当 static 关键字修饰成员变量时，该变量被称为静态变量【类变量】,该类的<strong>每个对象都对这个变量是共享的状态</strong>，任何对象都可以改变静态变量中存储的数据，改变之后其他对象将修改之后值，但可以在不创建该类对象化的前提下操作这个静态变量【这个才是正确操作方式】当 static 关键字修饰成员变量时，该变量被称为静态变量【类变量】,该类的每个对象都对这个变量是共享的状态，任何对象都可以改变静态变量中存储的数据，改变之后其他对象将修改之后值，但可以在不创建该类对象化的前提下操作这个静态变量【这个才是正确操作方式】</p><p>定义方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问权限修饰符 <span class="keyword">static</span> 数据类型 变量名;</span><br></pre></td></tr></table></figure><p>访问方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不推荐方式 ---》 对象.静态变量名</span><br><span class="line">推荐方式 ---》如果是在当前类中访问本类的静态变量 ---》静态变量名</span><br><span class="line">        ---》如果是在其他类中访问类的静态变量 ---》 类名.静态变量名</span><br></pre></td></tr></table></figure><p>演示案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChinesePeople</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供两个变量一个成员变量和静态变量</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">static</span> String country;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//在不同类中访问静态变量[静态变量是存在默认值]</span></span><br><span class="line">        System.out.println(ChinesePeople.country);</span><br><span class="line">        <span class="comment">// 所有静态变量存储在类所创建对象都是共享这个静态变量</span></span><br><span class="line">        <span class="type">ChinesePeople</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChinesePeople</span>();</span><br><span class="line">        p1.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            可以通过对象.静态变量方式访问静态变量的，但是推荐推荐</span></span><br><span class="line"><span class="comment">            IDEA提示的警告信息：</span></span><br><span class="line"><span class="comment">            Static member &#x27;com.qfedu.Static.ChinesePeople.country&#x27; accessed via</span></span><br><span class="line"><span class="comment">            instance reference</span></span><br><span class="line"><span class="comment">            不建议的</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        p1.country = <span class="string">&quot;中国&quot;</span>;</span><br><span class="line">        <span class="type">ChinesePeople</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChinesePeople</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;p2这个对象的国籍：&quot;</span>+p2.country);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5）static修饰成员方法"><a href="#5）static修饰成员方法" class="headerlink" title="5）static修饰成员方法"></a>5）static修饰成员方法</h3><p>&ensp;&ensp;&ensp;&ensp;被static修饰成员方法被称之为静态方法【类方法】，该静态方法可以使用类名直接调用</p><p>语法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">访问权限修饰符 <span class="keyword">static</span> 返回值类型 方法名(参数列表)</span><br><span class="line">&#123;</span><br><span class="line">    执行语句</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不推荐方式 ---》 对象.静态方法名字(参数赋值);</span><br><span class="line">推荐方式 ---》 如果在同一个类中，访问本类定义静态方法时 ---》 静态方法名字(参数赋值);</span><br><span class="line">        ---》 如果在其他类中，访问类中静态方法是 ---》 类名.静态方法名字(参数赋值);</span><br></pre></td></tr></table></figure><h4 id="静态方法被使用时注意事项"><a href="#静态方法被使用时注意事项" class="headerlink" title="静态方法被使用时注意事项"></a>静态方法被使用时注意事项</h4><ol><li>静态方法中不允许出现this关键字</li><li>静态方法中只能直接访问静态变量和其他的静态方法</li><li><strong>静态方法中是不可以直接访问成员变量和成员方法</strong></li></ol><p><strong>&ensp;&ensp;&ensp;&ensp;如果在静态方法中访问成员变量或成员方法，需要创建当前类的对象，通过对象才可以访问</strong></p><p>案例演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticMethod</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//演示类中静态方法</span></span><br><span class="line">    <span class="comment">//提供成员变量和成员方法</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//在成员方法中 访问 成员变量 和成员方法 还有静态变量和静态方法</span></span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(age);</span><br><span class="line">        display();</span><br><span class="line">        <span class="comment">//show(); ---》注释的原则是防止死递归</span></span><br><span class="line">        <span class="comment">//可以使用this和super关键字</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//提供静态变量和静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//在静态方法中 访问 成员变量 和成员方法 还有静态变量和静态方法</span></span><br><span class="line">        System.out.println(age);</span><br><span class="line">        <span class="comment">// display(); ---》注释的原则是防止死递归</span></span><br><span class="line">        <span class="comment">//在静态方法中是不可以直接访问成员变量和方法，不可以使用this和super关键字</span></span><br><span class="line">        <span class="comment">//如果要访问成员变量和成员方法，那么就必须创建对象</span></span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">            System.out.println(name);</span></span><br><span class="line"><span class="comment">            show();</span></span><br><span class="line"><span class="comment">        */</span>        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6）静态代码块"><a href="#6）静态代码块" class="headerlink" title="6）静态代码块"></a>6）静态代码块</h3><h4 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h4><p>&ensp;&ensp;&ensp;&ensp;static可以用于修饰代码块，称之为静态代码块</p><p>&ensp;&ensp;&ensp;&ensp;代码块：指的是在程序中出现的一个代码片段，直接使用{}包裹</p><p>&ensp;&ensp;&ensp;&ensp;静态代码块：指的是用static修饰的代码块</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>&ensp;&ensp;&ensp;&ensp;静态代码块在类加载的时候自动执行，无需手动调用，代码块会按照先后顺序一次执行，优先于代码块、构造方法执行，静态代码块只会在类加载的时候执行一次（初始化的时候使用）。</p><p>PS：利用static修饰代码块来执行一些“耗时的操作”，优先执行</p><p>类加载的触发时机</p><p>&ensp;&ensp;&ensp;&ensp;（1）创建类的对象时候（new）</p><p>&ensp;&ensp;&ensp;&ensp;（2）创建子类对象的时候（先要创建其父类对象）</p><p>&ensp;&ensp;&ensp;&ensp;（3）在调用类中的静态属性和静态方法的时候</p><p>&ensp;&ensp;&ensp;&ensp;（4）Class类中提供的静态方法 Class.forName() 方法的时候（放射）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticBlock</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StaticBlock</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参构造方法&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">StaticBlock</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">StaticBlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;&ensp;&ensp;在普通类定义操作的时候，是很少使用静态的方式来完成，在有开发项目中，通常会需要使用到一些“全局变量”和“全局方法”，这些全局变量和全局方法会被单独定义在一个类中，并且都使用static进行修饰，可以访问外界直接对变量和方法访问，这样类叫做工具类，在创建工具类需要提供一个包util，包中提供工具类的名字 XXXUtil 或 XXXTools</p><p>&ensp;&ensp;&ensp;&ensp;像：Arrays就是一个工具类，工具类的特点是类中变量必须是static修饰静态变量，类中方法必须是static修饰静态方法，而且这个类不提供对象创建，这样类就是工具类</p><h2 id="3、final关键字"><a href="#3、final关键字" class="headerlink" title="3、final关键字"></a><center>3、final关键字</center></h2><h3 id="1）含义-3"><a href="#1）含义-3" class="headerlink" title="1）含义"></a>1）含义</h3><p>&ensp;&ensp;&ensp;&ensp;不可变，不可改变，最终，不可以修改，修饰关键字主要可以用途修饰【类，变量和方法】</p><h3 id="2）作用-1"><a href="#2）作用-1" class="headerlink" title="2）作用"></a>2）作用</h3><p>修饰的类</p><p>&ensp;&ensp;&ensp;&ensp;特点：使用final修饰的类不能被继承（太监类）</p><p>修饰的方法</p><p>&ensp;&ensp;&ensp;&ensp;特点：使用final修饰的方法不能被重写，但是可以被继承</p><p>修饰的属性</p><p>&ensp;&ensp;&ensp;&ensp;称之为：常量</p><p>&ensp;&ensp;&ensp;&ensp;特点：</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1、常量必须要赋值</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;常量的最后赋值时机：</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;a、非静态常量（没有static修饰的）</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1)直接赋值</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;2)在代码块中赋值</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;3)在构造方法中赋值(注意：如果一个类有多个构造方法，那么必须在每一个构造方法中赋值)</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;b、静态常量（使用static修饰的）</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1)直接赋值</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;2)在静态代码块中赋值</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;2、常量不能修改</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;基本类型值不能改变</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;引用类型地址不能改变</p><h3 id="使用final修饰符修饰局部变量"><a href="#使用final修饰符修饰局部变量" class="headerlink" title="使用final修饰符修饰局部变量"></a>使用final修饰符修饰局部变量</h3><p>&ensp;&ensp;&ensp;&ensp;局部变量是定义在方法内部变量就是局部变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用final关键字修饰局部变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalVarDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            final修饰变量同时并赋值【此时就会定义常量，不可以被修改】</span></span><br><span class="line"><span class="comment">            语法： final 数据类型 变量名(这个变量名要大写代表是常量) = 值</span></span><br><span class="line"><span class="comment">       */</span>                        </span><br><span class="line">        <span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14</span>;</span><br><span class="line">        <span class="comment">//IDEA 错误提示 Cannot assign a value to final variable &#x27;PI&#x27;</span></span><br><span class="line">        <span class="comment">//不能修改使用final修饰PI</span></span><br><span class="line">        <span class="comment">//PI = 3.15;</span></span><br><span class="line">        <span class="comment">//final修饰变量先定义，在赋值【只能赋值一次】</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            final 数据类型 变量名(这个变量名要大写代表是常量);</span></span><br><span class="line"><span class="comment">            变量名(这个变量名要大写代表是常量) = 值;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> age;</span><br><span class="line">        age = <span class="number">18</span>;</span><br><span class="line">        <span class="comment">//IDEA的错误提示 Variable &#x27;age&#x27; might already have been assigned to</span></span><br><span class="line">        <span class="comment">//不允许进行二次赋值</span></span><br><span class="line">        <span class="comment">//age = 20;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用final修饰符修饰成员变量和静态变量"><a href="#使用final修饰符修饰成员变量和静态变量" class="headerlink" title="使用final修饰符修饰成员变量和静态变量"></a>使用final修饰符修饰成员变量和静态变量</h3><p>&ensp;&ensp;&ensp;&ensp;当使用final修饰符修饰完毕之后，就会形成常量，不允许再次修改存储数据</p><h3 id="final修饰成员变量"><a href="#final修饰成员变量" class="headerlink" title="final修饰成员变量"></a>final修饰成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalVarDemo2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用final修饰符修饰成员变量</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">FinalVarDemo2</span>().PI);</span><br><span class="line">        <span class="comment">//IDEA错误提示信息Cannot assign a value to final variable &#x27;PI&#x27; 不允许修改这个值</span></span><br><span class="line">        <span class="comment">//new FinalVarDemo2().PI = 3.15;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="final修饰静态变量"><a href="#final修饰静态变量" class="headerlink" title="final修饰静态变量"></a>final修饰静态变量</h3><p>&ensp;&ensp;&ensp;&ensp;这个中修饰方式是比较常见，在一些工具类中或者正常类中定义一个不可以改变量，并且所有对象共享，就可以使用这种方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalVarDemo3</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//final修饰静态变量会变成静态常量</span></span><br><span class="line">    <span class="comment">//一共有两种创建于赋值方式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14</span>;</span><br><span class="line">    <span class="comment">//先定义，在使用静态代码块进行赋值操作</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String STR;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        STR = <span class="string">&quot;字符串&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用final关键字修饰成员方法"><a href="#使用final关键字修饰成员方法" class="headerlink" title="使用final关键字修饰成员方法"></a>使用final关键字修饰成员方法</h3><p>&ensp;&ensp;&ensp;&ensp;使用final关键字修饰成员方法，此时这个方法会变成【最终方法】，此方法不可以被子类重写，但是子类可以继承</p><p>&ensp;&ensp;&ensp;&ensp;final关键字修饰成员方法的时机：父类只提供方法继承，但是不允许子类重写就可以使用final关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义一个final修饰的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类只能继承不能重写&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//IDEA的错误提示信息 cannot override &#x27;show()&#x27; in &#x27;com.qfedu.Final.Father&#x27;;</span></span><br><span class="line">        <span class="comment">// overridden method is final</span></span><br><span class="line">        <span class="comment">//提示这个方式使用final修饰无法重写，但是允许继承</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;知识点一：面向对象的编程思想&quot;&gt;&lt;a href=&quot;#知识点一：面向对象的编程思想&quot; class=&quot;headerlink&quot; title=&quot;知识点一：面向对象的编程思想&quot;&gt;&lt;/a&gt;&lt;center&gt;知识点一：面向对象的编程思想&lt;/center&gt;&lt;/h1&gt;&lt;p&gt;面向对象程</summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>16.数组</title>
    <link href="http://example.com/post/86a3300e.html"/>
    <id>http://example.com/post/86a3300e.html</id>
    <published>2023-12-30T05:06:39.000Z</published>
    <updated>2024-02-29T12:30:22.278Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识点一：数组的概念"><a href="#知识点一：数组的概念" class="headerlink" title="知识点一：数组的概念"></a><center>知识点一：数组的概念</center></h1><p>数组在内存中是一块 连续的空间，可以保存 相同类型 多个数据的容器 </p><h1 id="知识点二：数组的特点"><a href="#知识点二：数组的特点" class="headerlink" title="知识点二：数组的特点"></a><center>知识点二：数组的特点</center></h1><p>数组中保存数据必须是相同的数据类型</p><p>数组是定长的（数组一旦定义不能改变长度）</p><h1 id="知识点三：数组的创建"><a href="#知识点三：数组的创建" class="headerlink" title="知识点三：数组的创建"></a><center>知识点三：数组的创建</center></h1><h2 id="1、静态初始化语法"><a href="#1、静态初始化语法" class="headerlink" title="1、静态初始化语法"></a><center>1、静态初始化语法</center></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法<span class="number">1</span>：数据类型[] 数组名 = &#123;数据<span class="number">1</span>,数据<span class="number">2</span>,...&#125;;</span><br><span class="line"></span><br><span class="line">语法<span class="number">2</span>：数据类型 数组名[] = &#123;数据<span class="number">1</span>,数据<span class="number">2</span>,...&#125;;</span><br><span class="line"></span><br><span class="line">语法<span class="number">3</span>：数据类型[] 数组名 = <span class="keyword">new</span> 数据类型[]&#123;数据<span class="number">1</span>,数据<span class="number">2</span>,...&#125;;</span><br></pre></td></tr></table></figure><h2 id="2、动态初始化语法"><a href="#2、动态初始化语法" class="headerlink" title="2、动态初始化语法"></a><center>2、动态初始化语法</center></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法<span class="number">1</span>: 数据类型[] 数组名 = <span class="keyword">new</span> 数据类型[数组的长度];</span><br><span class="line">语法<span class="number">2</span>: 数据类型 数组名[] = <span class="keyword">new</span> 数据类型[数组的长度];</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line"><span class="comment">//存数据</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">22</span>;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">33</span>;</span><br><span class="line"><span class="comment">//取数据</span></span><br><span class="line">System.out.println(<span class="string">&quot;第二个元素为：&quot;</span>+arr[<span class="number">1</span>]);</span><br><span class="line">System.out.println(<span class="string">&quot;第三个元素为：&quot;</span>+arr[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">//获取数据的长度</span></span><br><span class="line">System.out.println(arr.length);</span><br><span class="line"><span class="comment">//错误：数组下标越界</span></span><br><span class="line">System.out.println(arr[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure><h2 id="3、数组的细节"><a href="#3、数组的细节" class="headerlink" title="3、数组的细节"></a><center>3、数组的细节</center></h2><p>1）数组中每一个数据称之为一个元素</p><p>2）数组的元素通过下标（索引）进行访问    数组名[下标]</p><p>3）数组下标范围为：0~数组长度-1</p><p>4）数组长度获取方式：</p><p>&ensp;&ensp;&ensp;&ensp;数组名.length  属性获取</p><p>5）数组在定义的时候就需要确定长度</p><p>&ensp;&ensp;&ensp;&ensp;数组的长度如果超出的边界会报错（ArrayIndexOutOfBoundsException数组下标越界异常） </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1、定义数组</span></span><br><span class="line">        <span class="comment">//int[] arr = &#123;12,13,14,2,3,4&#125;;</span></span><br><span class="line">        <span class="type">int</span> arr[] = &#123;<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="comment">//如果定义数组，直接输出数组那么输出的是数组地址（数组名是地址）</span></span><br><span class="line">        <span class="comment">//System.out.println(arr);</span></span><br><span class="line">        <span class="comment">//存值：静态初始化的数组，已经赋好值，如果再进行赋值，那么就会覆盖原来的数据</span></span><br><span class="line">        System.out.println(<span class="string">&quot;数组的第一个元素为：&quot;</span>+arr[<span class="number">0</span>]);</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">120</span>;</span><br><span class="line">        arr[<span class="number">2</span>] = <span class="number">1400</span>;</span><br><span class="line">        <span class="comment">//取值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;数组的第一个元素为：&quot;</span>+arr[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(<span class="string">&quot;数组的第一个元素为：&quot;</span>+arr[<span class="number">2</span>]);</span><br><span class="line">        <span class="comment">//获取数组的长度</span></span><br><span class="line">        System.out.println(<span class="string">&quot;数组的长度为:&quot;</span>+arr.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点四：数组在内存中存储与操作"><a href="#知识点四：数组在内存中存储与操作" class="headerlink" title="知识点四：数组在内存中存储与操作"></a><center>知识点四：数组在内存中存储与操作</center></h1><p>内存是计算中的重要组件，临时存储的区域，作为运行程序所使用的，我们编写的程序是存放在磁盘中，但是磁盘是不会运行程序，如果要运行程序就需要放置到内存中才可以运行，运行完毕会清空内存，Java中虚拟机[VM],必须要对内存进行空间分配与管理，才可以正常运行lava程序</p><p>JVM中对内存会划分为五个区域: 重点了解 “栈与堆[特别是堆区]，其实方法区，剩余了解即可“</p><table><thead><tr><th align="center">区域名称</th><th align="center">简要说明</th></tr></thead><tbody><tr><td align="center">程序计数器【寄存器】</td><td align="center">给cup使用，和我们开发无关</td></tr><tr><td align="center">本地方法栈</td><td align="center">JVM在使用操作系统功能的时候需要使用，和我们开发无关</td></tr><tr><td align="center">方法区</td><td align="center">存储课运行的class文件、常量、静态变量</td></tr><tr><td align="center">堆区</td><td align="center">存储对象或者数组的区域，它是通过代码中new创建出来，即使用new关键字创建的都是存在这个区域中，这个区域中存储数据叫做“引用类型”</td></tr><tr><td align="center">栈区</td><td align="center">方法运行时使用区域（包含了定义变量）这个区域是系统自行管理（栈区遵守先进后出的原则）</td></tr></tbody></table><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271922067.jpg" alt="数组在内存中存储与操作" style="zoom:67%;"><p>在创建数据时会根据数组定义的存储元素数据类型，来决定数组中默认值</p><ol><li>整数型数组默认值：0</li></ol><p>&ensp;&ensp;&ensp;&ensp;byte、short、int、long</p><ol start="2"><li><p>浮点型数组默认值：0.0</p></li><li><p>布尔类型数组默认值：false</p></li><li><p>字符型数组默认值：0 或者 ‘ ‘ 或者 ‘\u0000’</p></li><li><p>引用类型数组默认值：null</p></li></ol><p>&ensp;&ensp;&ensp;&ensp;null：一种特殊的值，表示当前对象在内存中没有指向任何地址</p><p>&ensp;&ensp;&ensp;&ensp;” “表示空字符串，在内存中有对应的内存地址 </p><p>Java中提供为了方便开发人员对数组中存储数据进行操作，提供一个操作概念，这个操作概念“下标”</p><h1 id="知识点五：数组的遍历"><a href="#知识点五：数组的遍历" class="headerlink" title="知识点五：数组的遍历"></a><center>知识点五：数组的遍历</center></h1><p>定义：将数组中的元素逐个获取、赋值的过程（数组的任何操作都要先遍历数组）</p><p>获取数组中存储的数据—-》数组名[下标值];</p><p>修改或添加数据到数组中存储0—-》数组名[下标值] &#x3D; 值;</p><p>获取数组的长度—-》数组名.length</p><p>数组下标从0开始到数组长度-1结束</p><p><strong>普通for循环遍历</strong></p><p>原理：循环变量代替数组下标进行使用，从而达到使用下标操作数据目的</p><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> 下标值 【默认值为<span class="number">0</span>】;i &lt; 数组长度;i++)&#123;</span><br><span class="line"></span><br><span class="line">    在<span class="keyword">for</span>循环中定义循环变量i就是数组下标从<span class="number">0</span>开始到数组长度-<span class="number">1</span>结束这个范围内，所以使用i变量就相当于在使用下标，就可以在循环体重复使用</span><br><span class="line"></span><br><span class="line">    数组名[循环变量] ---》间接的等于操作数组中值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：此循环是比较推荐日常使用，虽然比较繁琐【需要使用下标】，但是它可以完成对数据的所有【增删改查】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//提供一个数组</span></span><br><span class="line">        <span class="type">int</span> [] arr = &#123;<span class="number">32</span>,<span class="number">323</span>,<span class="number">32</span>,<span class="number">42</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">235</span>,<span class="number">353</span>,<span class="number">456323</span>,<span class="number">456</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="comment">//打印数组中每一个数据值</span></span><br><span class="line">        <span class="comment">//首先不可能使用打印数组名字方式进行打印</span></span><br><span class="line">        System.out.println(arr);    <span class="comment">//数组地址</span></span><br><span class="line">        <span class="comment">//其次这种方式也不可取，使用下标一个一个打印---》如果数组中存储数据特别多：1000个</span></span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(arr[<span class="number">1</span>]);</span><br><span class="line">        System.out.println(arr[<span class="number">2</span>]);</span><br><span class="line">        System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line">        System.out.println(arr[<span class="number">4</span>]);</span><br><span class="line">        System.out.println(arr[<span class="number">5</span>]);</span><br><span class="line">        System.out.println(arr[<span class="number">6</span>]);</span><br><span class="line">        System.out.println(arr[<span class="number">7</span>]);</span><br><span class="line">        System.out.println(arr[<span class="number">8</span>]);</span><br><span class="line">        System.out.println(arr[<span class="number">9</span>]);</span><br><span class="line">        System.out.println(arr[<span class="number">10</span>]);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//使用循环方式才是处理数组的真正方式</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//利用原理：i值这个循环变量，使用i这个循环变量变换范围，即 下标的范围从而进行数组的操作</span></span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>增强for循环遍历</strong></p><p>&ensp;&ensp;&ensp;&ensp;增强for循环是Java专门为了数组和集合而提供一个操作方式，它只能适用于数组或集合，其他的操作不能使用增强for循环</p><p><strong>快捷方式：</strong></p><p>&ensp;&ensp;&ensp;&ensp;<strong>数组名.for+回车</strong></p><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(数组中存储数据(元素)的数据类型 变量名 : 数组名字)&#123;</span><br><span class="line">    </span><br><span class="line">此时<span class="keyword">for</span>循环中小括号中定义变量会分别获取到数组每一个数据的值，可以在循环体内操作这个变量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>PS：增强for循环只适合简单打印和计算，不适合对数据中值进行改变操作（增删改查）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用增强for循环变量数组中每一个元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> a:arr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//a变量就会获取数组中每一个数据值</span></span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo06</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//遍历数组----&gt;取值</span></span><br><span class="line">        <span class="type">int</span> arr [] = &#123;<span class="number">12</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">12</span>,<span class="number">45</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)    <span class="comment">//i：代表数组的下标数</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历数组---&gt;存值</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> arr1[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr1.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入第&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;个数&quot;</span>);</span><br><span class="line">            <span class="comment">//给数组中每一个元素赋值</span></span><br><span class="line">            arr1[i] = sr.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历数组进行输出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr1.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(arr1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点六：数组的使用问题"><a href="#知识点六：数组的使用问题" class="headerlink" title="知识点六：数组的使用问题"></a><center>知识点六：数组的使用问题</center></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 数组是引用类型，因为使用new关键字创建数组，在堆会开辟中间存储数组中数据</span></span><br><span class="line"><span class="comment">         * 在Java中有一个数据可以专门针对引用类型进行赋值----》null 【空】</span></span><br><span class="line"><span class="comment">         * null会代表引用类型在堆中没有开辟空间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//定义一个int类型数组arr，使用null进行赋值操作</span></span><br><span class="line">        <span class="type">int</span> [] arr = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 一定要注意：因为使用null作为arr数组初始化操作，所以证明在堆中并没有堆arr数组进行空间开开辟</span></span><br><span class="line"><span class="comment">         *          所以这样数组千万别使用，否则就会出现，空指针异常问题NullPointerException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//System.out.println(&quot;获取数组中第一个元素的值：&quot;+ arr[1]);</span></span><br><span class="line">        <span class="comment">//System.out.println(arr); //null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个int类型数组，可以存储10个元素</span></span><br><span class="line">        <span class="type">int</span> [] arr2 = <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">10</span>];</span><br><span class="line">        <span class="comment">//此时证明数组在堆中开辟了10个存储空间可以存储10个数据</span></span><br><span class="line">        System.out.println(<span class="string">&quot;获取数组中第一个元素的值：&quot;</span>+ arr2[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        arr2 = <span class="literal">null</span>;<span class="comment">//因为arr2是引用类型，所以被赋值为null值，这样赋值相当于将arr2与堆中地址切断联系</span></span><br><span class="line">        <span class="comment">//此时arr2就不能再进行操作了，因为已经没有堆中地址，如果进行操作就会出现 空指针异常问题NullPointerException</span></span><br><span class="line">        <span class="comment">//System.out.println(arr2[2]);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点七：数组的应用"><a href="#知识点七：数组的应用" class="headerlink" title="知识点七：数组的应用"></a><center>知识点七：数组的应用</center></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> nums [] = &#123;<span class="number">23</span>,<span class="number">345</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">45</span>,<span class="number">63</span>,<span class="number">23</span>&#125;;</span><br><span class="line">        System.out.print(<span class="string">&quot;最大值为：&quot;</span>);</span><br><span class="line">        System.out.println(max(nums));</span><br><span class="line">        System.out.print(<span class="string">&quot;最小值为：&quot;</span>);</span><br><span class="line">        System.out.println(min(nums));</span><br><span class="line">        System.out.print(<span class="string">&quot;平均值为：&quot;</span>);</span><br><span class="line">        System.out.println(mean(nums)/nums.length);</span><br><span class="line">        System.out.println(<span class="string">&quot;结果为：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">34</span>;</span><br><span class="line">        System.out.println(same(nums,num));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最大值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> nums1[])</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max1</span> <span class="operator">=</span> nums1[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(max1 &lt; nums1[i])</span><br><span class="line">            &#123;</span><br><span class="line">                max1 = nums1[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最小值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">min</span> <span class="params">(<span class="type">int</span> nums2[])</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min1</span> <span class="operator">=</span> nums2[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums2.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (min1 &gt; nums2[i])</span><br><span class="line">            &#123;</span><br><span class="line">                min1 = nums2[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//平均值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">mean</span><span class="params">(<span class="type">int</span> nums3[])</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums3.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums3[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//给定一个数组，传入一个数字，如果在数组中存在这个数字，输出这个数字在数组中的下标，否则输出-1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">same</span> <span class="params">(<span class="type">int</span> nums4[],<span class="type">int</span> nums5)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums4.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums5 == nums4[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点八：数组的扩容与缩容"><a href="#知识点八：数组的扩容与缩容" class="headerlink" title="知识点八：数组的扩容与缩容"></a><center>知识点八：数组的扩容与缩容</center></h1><p>步骤1：定义一个新数组，新数组的长度比原数组长（扩）、短（缩）</p><p>步骤2：将原来数组的元素拷贝到新数组中</p><p>步骤3：将数组名指向新数组的地址</p><p>扩容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> arr [] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        num (arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">num</span><span class="params">(<span class="type">int</span> arr1[])</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//定义一个新数组</span></span><br><span class="line">        <span class="type">int</span> newArr[] = <span class="keyword">new</span> <span class="title class_">int</span>[arr1.length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr1.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//将老数组的元素拷贝到新数组中</span></span><br><span class="line">            newArr [i] = arr1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数组名指向新数组的地址</span></span><br><span class="line">        arr1 = newArr;</span><br><span class="line">        <span class="comment">//验证</span></span><br><span class="line">        arr1[<span class="number">3</span>] = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr1.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(arr1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缩容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义原数组</span></span><br><span class="line"><span class="type">int</span>[] arr1 = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">46</span>,<span class="number">22</span>,<span class="number">11</span>&#125;;</span><br><span class="line"><span class="comment">//1、定义新数组</span></span><br><span class="line"><span class="type">int</span>[] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[arr1.length-<span class="number">1</span>];</span><br><span class="line"><span class="comment">//2、数组拷贝</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr2.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    arr2[i] = arr1[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3、将原数组的变量指向新数组</span></span><br><span class="line">arr1 = arr2;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr2.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(arr1[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点九：数组拷贝"><a href="#知识点九：数组拷贝" class="headerlink" title="知识点九：数组拷贝"></a><center>知识点九：数组拷贝</center></h1><h2 id="1、通过自定义循环将原数组中的元素拷贝到新数组中"><a href="#1、通过自定义循环将原数组中的元素拷贝到新数组中" class="headerlink" title="1、通过自定义循环将原数组中的元素拷贝到新数组中"></a><center>1、通过自定义循环将原数组中的元素拷贝到新数组中</center></h2><h2 id="2、System类提供数组拷贝方法"><a href="#2、System类提供数组拷贝方法" class="headerlink" title="2、System类提供数组拷贝方法"></a><center>2、System类提供数组拷贝方法</center></h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">System.arraycopy(src,srcPos,dest,destPos,length);</span><br><span class="line">参数说明：</span><br><span class="line">    src：原数组</span><br><span class="line">    srcPos：指定原数组的起始地址</span><br><span class="line">    dest：目标数组</span><br><span class="line">    destPos：目标起始位置</span><br><span class="line">length：拷贝元素的个数</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> arr[] = &#123;<span class="number">11</span>,<span class="number">33</span>,<span class="number">66</span>&#125;;</span><br><span class="line">        <span class="type">int</span> newArr[] = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length+<span class="number">5</span>];</span><br><span class="line">        System.arraycopy(arr,<span class="number">1</span>,newArr,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; newArr.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(newArr[i]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、Arrays类提供数组拷贝方法"><a href="#3、Arrays类提供数组拷贝方法" class="headerlink" title="3、Arrays类提供数组拷贝方法"></a><center>3、Arrays类提供数组拷贝方法</center></h2><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">新数组类型 新数组名 = Arrays.copyOf(original,newLength);</span><br><span class="line">参数说明：</span><br><span class="line">    original：原数组</span><br><span class="line">    newLength：新数组的长度</span><br><span class="line">    返回值：返回新数组</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> arr[] = &#123;<span class="number">11</span>,<span class="number">33</span>,<span class="number">66</span>&#125;;</span><br><span class="line">        <span class="type">int</span> newArr[] = Arrays.copyOf(arr,arr.length+<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; newArr.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(newArr[i]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点十：数组中的增删改查操作"><a href="#知识点十：数组中的增删改查操作" class="headerlink" title="知识点十：数组中的增删改查操作"></a><center>知识点十：数组中的增删改查操作</center></h1><h2 id="1、增加数据"><a href="#1、增加数据" class="headerlink" title="1、增加数据"></a><center>1、增加数据</center></h2><p>数组对于开发而言最主要作用就是对数据存储操作，存储数据化必然需要向数据中增加数据操作</p><p>向数组中添加数据:可以使用方式有很多“文件、数据库、键盘输入、随机数等等”</p><p>既然是增加数据分为两种添加方式“一种叫做静态添加和一种叫做动态添加”</p><p>一般静态添加使用较少，它的操作还就是在数组的时候，直接数组中存储数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] arr2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br></pre></td></tr></table></figure><p>多使用动态添加，键盘输入数据、随机数、文件读取内容之后存储、数据库操作之后存储</p><p>现在而言可以使用基本上‘“键盘输入和随机数据”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//定义一个int类型数组，数组的长度为10</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">//1.随机数赋值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;arr.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = (<span class="type">int</span>)(Math.random()*<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//或者</span></span><br><span class="line">        <span class="comment">//2.通过控制台输入</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;arr.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">           arr[i] = input.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、查找和修改数据"><a href="#2、查找和修改数据" class="headerlink" title="2、查找和修改数据"></a><center>2、查找和修改数据</center></h2><p>数组中查找某个元素是否存在，一共有两种方式“线性（顺序）查找 和 二分（折半）查找”</p><p>单从效率而言“二分查找远远高于线性查找”，从书写代码而言“线性查找要远远简单于二分查找”</p><p>线性（顺序）查找执行原理：就是从数组第一个元素逐一向后查找每一个元素</p><p>线性查找最优解 1次 【数组第一个元素就是要查找的元素】</p><p>线性查找最坏解 数组长度次数 【数组最后一个元素是要查找的元素】</p><p>线性查找最大有点就是简单易用，效率确实不高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDemo2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供一个int类型数组，数组长度10</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">//2.通过随机数向数组中进行赋值操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;arr.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = (<span class="type">int</span>) (Math.random() * <span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;arr数组中存储数据是:[&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span> ; i&lt;arr.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i != arr.length-<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(arr[i]+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(arr[i]+<span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入您要在arr数组中要查找的数据：&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">        <span class="comment">//提供线性(顺序)查找，判断要查找数据是否存在在当前的数组中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i&lt;arr.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] == num)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//提供修改</span></span><br><span class="line">                <span class="comment">// arr[i] = 10000;</span></span><br><span class="line">                <span class="comment">//提示找到了数据</span></span><br><span class="line">                System.out.println(<span class="string">&quot;您输入数据是在数组中存储的下标为：&quot;</span>+i);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;没有找到数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、删除数据"><a href="#3、删除数据" class="headerlink" title="3、删除数据"></a><center>3、删除数据</center></h2><p>在没有使用数组的“减容”之前，数组中是没有真正删除的</p><p>什么时“减容”？根据删除元素个数动态缩小数组容量（大小&#x2F;长度）</p><p>如何在数组中执行删除操作？</p><p>根据中存储元素类型来决定，如果数组中存储的是基本数据类型，采用后一个数据覆盖前一位数据的方式进行删除，并记录删除个数以便在打印时，可以不输出多余数据【这个操作不是”减容“，数组长度不会改变】，如果数组中存储的是引用数据类型，依旧会采用后一个数据覆盖前一个数据方式，会在最后一个数据位置添加 null值，或者直接要删除的赋值为null，并记录删除个数以便在打印中，不输出多余的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDemo3</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供一个int类型数存储10个元素</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">10</span>];</span><br><span class="line">        <span class="comment">//2.提供动态赋值同时打印数组中数据</span></span><br><span class="line">        System.out.print(<span class="string">&quot;arr数组中存储的数据[&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;arr.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = (<span class="type">int</span>)(Math.random()*<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">if</span>(i != arr.length-<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(arr[i]+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(arr[i]+<span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(<span class="string">&quot;删除之前arr数组的长度：&quot;</span>+arr.length);</span><br><span class="line">        <span class="comment">//3.提供外界输入的数据进行删除操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入您要删除的数据:&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">        <span class="comment">//提供一个变量存储删除数据的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//3.1提供一个循环遍历数组寻找要删除数据</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;arr.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] == num)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//如果if语句成立就证明数组中是存在要删除的数据的</span></span><br><span class="line">                <span class="comment">//3.2在提供一个循环使用删除数据位置的后一个数据向前覆盖操作</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;j&lt;arr.length-<span class="number">1</span>;j++)&#123;</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//循环结束之后就证明删除完成，统计计数</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//真删除【减容】</span></span><br><span class="line">        <span class="comment">//在创建一个数组存储删除之后的数据</span></span><br><span class="line">        <span class="comment">/* int[] temp = new int[arr.length-count];</span></span><br><span class="line"><span class="comment">        for(int i = 0 ; i&lt;arr.length-count;i++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            temp[i] = arr[i];</span></span><br><span class="line"><span class="comment">        &#125; </span></span><br><span class="line"><span class="comment">        //将存储着真删除数据的数据引用赋值给arr</span></span><br><span class="line"><span class="comment">        arr = temp;</span></span><br><span class="line"><span class="comment">        temp = null; //删除temp与堆中关联</span></span><br><span class="line"><span class="comment">        //在打印arr数组就是真删除，长度也改变了</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;真删除之后arr数组的长度：&quot;+arr.length);*/</span></span><br><span class="line">        <span class="comment">//4.提供打印操作</span></span><br><span class="line">        System.out.print(<span class="string">&quot;删除数组中数之后arr数组中元素：[&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;arr.length-count;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i != arr.length-<span class="number">1</span>-count)</span><br><span class="line">            &#123;</span><br><span class="line">               System.out.print(arr[i]+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(arr[i]+<span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(<span class="string">&quot;删除之后arr数组的长度：&quot;</span>+arr.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点十一：数组的排序"><a href="#知识点十一：数组的排序" class="headerlink" title="知识点十一：数组的排序"></a><center>知识点十一：数组的排序</center></h1><p>数组的排序主要的目的是为了让数组中存储数据有一定顺序（升序或降序），在对数组中数据进行排序时提供很多种算”冒泡、选择、插入、快速、归并和堆排序“</p><p>PS：这里提供排序的目的是为了让大家掌握一种对数组中数据操作方式，除此之外就是为了应该笔试操作，在实际开发中基本你上Java都是使用系统提供好的排序方法，除非你开发公司要求，排序操作需要个人实现，否则都会使用是系统提供排序，因为系统排序简单而且效率高</p><h2 id="1、冒泡排序"><a href="#1、冒泡排序" class="headerlink" title="1、冒泡排序"></a><center>1、冒泡排序</center></h2><p>冒泡排序的规则：将数组中相邻的两个元素进行比较，如果前一个元素大于后一个元素，交换当前两个元素的位置，这个逻辑依次执行，直到所有元素都执行比较操作之后，就会有一个数据放置到数组中正确位置上</p><p>PS：<strong>在没有强调使用排序时是升序还是降序的前提下，默认所有排序都是升序</strong></p><p>升序是指从小到大的一个排序 降序是指从大到小一个排序</p><p>模拟一轮冒泡排序对数组的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">*假设数组中存储数据是【<span class="number">6</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>】 使用冒泡对数组中数据进行排序操作：原则就相邻数据进行比较*</span><br><span class="line">*第一次首先执行是<span class="number">6</span>和<span class="number">9</span>之间元素的比较，如果<span class="number">6</span>&gt;<span class="number">9</span>成立，交换两个元素的位置，否则不交换*</span><br><span class="line">*第一次执行完毕的结果是【<span class="number">6</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>】*</span><br><span class="line">*第二次执行<span class="number">9</span>和<span class="number">1</span>之间元素的比较，如果<span class="number">9</span>&gt;<span class="number">1</span>成立，交换两个元素的位置，否则不交换*</span><br><span class="line">*第二次执行完毕的结果是【<span class="number">6</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">5</span>】*</span><br><span class="line">*第三次执行<span class="number">9</span>和<span class="number">3</span>之间元素的比较，如果<span class="number">9</span>&gt;<span class="number">3</span>成立，交换两个元素的位置，否则不交换*</span><br><span class="line">*第三次执行完毕的结果是【<span class="number">6</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">5</span>】*</span><br><span class="line">*第四次执行<span class="number">9</span>和<span class="number">5</span>之间元素的比较，如果<span class="number">9</span>&gt;<span class="number">5</span>成立，交换两个元素的位置，否则不交换*</span><br><span class="line">*第四次执行完毕的结果是【<span class="number">6</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>】*</span><br><span class="line">此时经过冒泡的一轮排序之后，数组中存储的数据<span class="number">9</span>，出现在了正确位置上，冒泡排序在进行排序时，</span><br><span class="line">是先将数据中最大值放置到正确位置，类似于“水中出现气泡都要上浮，按照身高站排”</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDemo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//提供一个int类型数组，存储10个元素</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">//随机向int数组进行赋值操作</span></span><br><span class="line">        System.out.print(<span class="string">&quot;arr数组在没有排序之前数组中数据[&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span> ; i&lt;arr.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = (<span class="type">int</span>)(Math.random()*<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">if</span>(i != arr.length-<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(arr[i]+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(arr[i]+<span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(<span class="string">&quot;-----------使用冒泡排序对数据进行排序-----------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span> ;i&lt;arr.length;i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//冒泡排序核心代码执行多次，原则就是有多少个数据就执行多少次核心</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span>; j++) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//交换两个元素的位置</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.print(<span class="string">&quot;arr数组在排序之后数组中数据[&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span> ; i&lt;arr.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i != arr.length-<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(arr[i]+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(arr[i]+<span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、选择排序"><a href="#2、选择排序" class="headerlink" title="2、选择排序"></a><center>2、选择排序</center></h2><p>选择排序的规则：选择排序会固定一个位置，依次和后面每一个数据进行比较，如果固定位置值大于后续位置数据，交换两个位置值，然就重复上述的操作，直到一轮结束之后，会有一个数据放到正确的位置上</p><p>PS：在没有强调使用排序时时升序还是降序的前提下，默认所有排序都是升序</p><p>升序是指从小到大的一个排序 降序是指从大到小一个排序</p><p>利用选择排序执行一轮操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">*假设数组中存储数据是【<span class="number">6</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>】 使用选择对数组中数据进行排序操作：原则就固定位置数据</span><br><span class="line">与后续数据进行比较，起始固定值就是数组中第一个元素的位置，固定数据位置依次和后续数据进行比较*</span><br><span class="line">*第一次固定位置数据是<span class="number">6</span>与后续数据<span class="number">9</span>进行比较操作 如果 <span class="number">6</span>&gt;<span class="number">9</span> 交换两个元素的位置，否则不交换*</span><br><span class="line">*第一次比较操作之后的结果是：【<span class="number">6</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>】*</span><br><span class="line">*第二次固定位置数据是<span class="number">6</span>与后续数据<span class="number">1</span>进行比较操作，如果 <span class="number">6</span>&gt;<span class="number">1</span> 交换两个元素的位置，否则不交换*</span><br><span class="line">*第二次比较操作之后的结果是：【<span class="number">1</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>】*</span><br><span class="line">*第三次固定位置数据是<span class="number">1</span>与后续数据<span class="number">3</span>进行比较操作，如果 <span class="number">1</span>&gt;<span class="number">3</span> 交换两个元素的位置，否则不交换*</span><br><span class="line">*第三次比较操作者之后的结果是：【<span class="number">1</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>】*</span><br><span class="line">*第四次固定位置数据是<span class="number">1</span>与后续数据<span class="number">5</span>进行比较操作，如果 <span class="number">1</span>&gt;<span class="number">5</span> 交换两个元素的位置，否则不交换*</span><br><span class="line">*第四次比较操作者之后的结果是：【<span class="number">1</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>】*</span><br><span class="line">选择排序执行完一轮操作之后，有一个数据放置到正确的位置上，对于选择排序而言，先排序出正确位</span><br><span class="line">置的数据是最小值</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDemo5</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//提供一个int类型数组，存储10个元素</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">//随机向int数组进行赋值操作</span></span><br><span class="line">        System.out.print(<span class="string">&quot;arr数组在没有排序之前数组中数据[&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span> ; i&lt;arr.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = (<span class="type">int</span>)(Math.random()*<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">if</span>(i != arr.length-<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(arr[i]+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(arr[i]+<span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(<span class="string">&quot;-----------使用选择排序对数据进行排序------------&quot;</span>);</span><br><span class="line">        <span class="comment">//选择排序的核心操作，比较排序数组中数据的原则就是数组中有多少个数据就排序多少次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;arr.length;i++)</span><br><span class="line">        &#123; <span class="comment">//这个循环是排序次数</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            选择排序的固定数据位置如何提供？ 外层循环执行一次内层循环执行多次，</span></span><br><span class="line"><span class="comment">            外层循环的循环变量在没有内层循环执行完毕之前，不会进行自增操作的，可以 利用外层的</span></span><br><span class="line"><span class="comment">            循环变量作为固定位置</span></span><br><span class="line"><span class="comment">            内层的循环操作与循环变量作为后续每一个数据进行比较操作</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>;j&lt;arr.length;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i] &gt; arr[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">                    arr[i] = arr[j];</span><br><span class="line">                    arr[j] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.print(<span class="string">&quot;arr数组在排序之后数组中数据[&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span> ; i&lt;arr.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i != arr.length-<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(arr[i]+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(arr[i]+<span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、折半查找法"><a href="#3、折半查找法" class="headerlink" title="3、折半查找法"></a><center>3、折半查找法</center></h2><p>二分查找也是数组中查找数据一种算法，比线性（顺序）查找效率高很多，每次查找数据的时候，都是当前查找数据量一半，这样可以大大减少无用数据比较查找，但是二分查找书写比线性查找要复杂，除此之外二分查找有一个必须要实现的规则“数组中数据必须进行排序”，二分查找虽然效率高但是实现复杂要求多</p><p><strong>我们要实现二分查找数据之前，必须对数组中的数据进行排序操作</strong></p><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271922077.jpg" alt="折半查找法解析"></p><p>条件：要排序好的数据</p><p>思路：</p><p>&ensp;&ensp;&ensp;&ensp;首先找到数组中的中间的元素，与要查找元素进行比较，如果相等，那么就直接找到了</p><p>&ensp;&ensp;&ensp;&ensp;如果比中间的元素大，那么表示查找元素在中间值的右边。所以最小值的下标等于中间值的下标+1</p><p>&ensp;&ensp;&ensp;&ensp;如果比中间的元素小，那么表示查找元素在中间值的左边。所以最大值的下标等于中间值的下标-1 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDemo6</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供一个int类型数组，存储数据10个</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">//2.随机向数组中填充数据</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;arr.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = (<span class="type">int</span>)(Math.random()*<span class="number">100</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//对数组中数据提供排序操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i= <span class="number">0</span> ;i&lt;arr.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>;j&lt;arr.length;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i] &gt; arr[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">                    arr[i] = arr[j];</span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.print(<span class="string">&quot;arr数组排序之后结果是:[&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;arr.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i != arr.length-<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(arr[i]+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(arr[i]+<span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(<span class="string">&quot;请输入您要查找的数据：&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">        <span class="comment">//提供二分查找的核心代码</span></span><br><span class="line">        <span class="comment">//提供开始值和结束值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">beginIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">endIndex</span> <span class="operator">=</span> arr.length-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//提供中间值计算</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">middleIndex</span> <span class="operator">=</span> (beginIndex+endIndex)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//因为我们也不能确定执行多少次循环可以将数据查找到，所以可以提供一个死循环</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果查找的数据 &gt; 中间值获取的数据</span></span><br><span class="line">            <span class="keyword">if</span>(num &gt; arr[middleIndex])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//移动beginIndex的值</span></span><br><span class="line">                beginIndex = middleIndex+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num &lt; arr[middleIndex])    <span class="comment">//如果查找的数据 &lt; 中间值获取的数据</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//移动endIndex的值</span></span><br><span class="line">                endIndex = middleIndex -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//说明查找的数据是 == 中间值获取的数据【找到了】</span></span><br><span class="line">                System.out.println(<span class="string">&quot;要查找的数据在数组中下标的位置：&quot;</span>+middleIndex);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//只要不执行 else操作 就证明 数据没有找到并且移动了beginIndex 或 endIndex的值 所以要重新计算middleIndex</span></span><br><span class="line">            middleIndex = (beginIndex+endIndex)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//还需要提供一个判断，移动了beginIndex和endIndex之后需要判断是否</span></span><br><span class="line">            beginIndex&gt;endIndex来决定不需要在查找</span><br><span class="line">            <span class="keyword">if</span>(beginIndex &gt; endIndex)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;要查找的数据不在数组中！！！&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、Arrays工具类排序"><a href="#4、Arrays工具类排序" class="headerlink" title="4、Arrays工具类排序"></a><center>4、Arrays工具类排序</center></h2><p>什么是工具类?</p><p>&ensp;&ensp;&ensp;&ensp;工具类是当前项目中大量使用到的一些常用方法被统一的封装到一个类中进行管理,通过这类就可以调用类中所提供方法进行操作完成需要需求,这样类就叫做工具类</p><p>&ensp;&ensp;&ensp;&ensp;而在JavaAPI中有大量工具类,是Java原码开发人员为了方便Java程序猿在开发程序时,使用到一些普遍的方法进行了统一的实现,提供给程序猿使用,程序猿无需二次实现,只需要调用方法就可以完成处理逻辑需求.</p><p>&ensp;&ensp;&ensp;&ensp;现在学习数组结构并不是非常方便,因为我们需要对数组进行增删改查操作时候需要自身手动完成代码还有一些排序等操作,在这种情况下Java开发人员为了方便我们使用个数组专门提供这个样一个工具类,类中封装了一些常用方法,以便我们使用数组进行开发</p><h4 id="API的使用"><a href="#API的使用" class="headerlink" title="API的使用"></a>API的使用</h4><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271923503.jpg" alt="API的使用" style="zoom: 50%;"><p>String的排序规则是：每一个字符在Unicode码表中都对应有一个数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Arrays工具类的使用【常用方法】</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArraysDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1. toString方法 ---》 可以将数组中内容转换为字符串形式可以方便打印查看</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        PS:刚刚观察API中可以发现Arrays工具类中方法都是使用static修饰的</span></span><br><span class="line"><span class="comment">        如果使用static修饰方法在同一个类中（文件）调用是可以直接使用方法名方式进行调用</span></span><br><span class="line"><span class="comment">        如果使用static修饰方法在不同类中（文件）调用此时就需要明确这个方法出自于那个类所以</span></span><br><span class="line"><span class="comment">        提供调用方式</span></span><br><span class="line"><span class="comment">        类名.静态方法(参数赋值操作);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//提供一个int类型数组，数组中存储了一些数据</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;arr.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = (<span class="type">int</span>)(Math.random()*<span class="number">100</span>);    <span class="comment">//强转int Math.random：产生随机数</span></span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(<span class="string">&quot;数组中存储的数据是：&quot;</span>+Arrays.toString(arr));</span><br><span class="line">        <span class="comment">//2.对数组中数据提供排序操作 参数就是排序的数组</span></span><br><span class="line">        Arrays.sort(arr); <span class="comment">//默认是升序</span></span><br><span class="line">        System.out.println(<span class="string">&quot;排序之后数组中数据是：&quot;</span>+Arrays.toString(arr));</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            这个方法是可以降序的，但是以现在所学暂时做不到，所以降序排序还是需要提供【选择或冒泡】</span></span><br><span class="line"><span class="comment">排序</span></span><br><span class="line"><span class="comment">            如果使用这个方法进行降序排序，需要实现一个Comparator接口指定排序规则才可以降序操作</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            3.提供二分查找【使用这个方法之前必须对数组进行排序操作，如果在数组中找到数据则返回对应</span></span><br><span class="line"><span class="comment">            数据下标</span></span><br><span class="line"><span class="comment">            如果找不到数据就返回一个负数】</span></span><br><span class="line"><span class="comment">            方法的第一个参数是 要查找的数组</span></span><br><span class="line"><span class="comment">            方法的第二个参数是 要在数组中查找的数据</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(arr, <span class="number">55</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;55这个数据是否存在arr数组中？&quot;</span>+(index &gt;= <span class="number">0</span>));</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            4. 可以使用这个方法更加便捷进行数组的扩容 和 减容操作</span></span><br><span class="line"><span class="comment">            copyOf 提供一个可以对数据进行复制（数组中内容）的方法，并且这个方法会得到一个返回</span></span><br><span class="line"><span class="comment">            值【新的数组】</span></span><br><span class="line"><span class="comment">            第一个参数是要复制的数组</span></span><br><span class="line"><span class="comment">            第二个参数是要新数组长度</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">int</span>[] ints = Arrays.copyOf(arr, <span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;复制arr数组之后的全新数组ints中的内容：&quot;</span>+Arrays.toString(ints));</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            5. 可以使用这个方法对数据中某个范围数据进行复制并生成一个全新数组</span></span><br><span class="line"><span class="comment">            PS:复制位置是数据下标位置</span></span><br><span class="line"><span class="comment">            第一个参数是复制的数组</span></span><br><span class="line"><span class="comment">            第二个参数是从那个下标位置开始复制（这个位置是包含在内）</span></span><br><span class="line"><span class="comment">            第三个参数是到那个下标位置结束复制（这个位置是不包含在内）</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">int</span>[] ints1 = Arrays.copyOfRange(arr, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">        System.out.println(Arrays.toString(ints1));</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            6. 如何判断两个数组是相等的</span></span><br><span class="line"><span class="comment">            数组是引用类型，所以判断引用类型是否相等是不可以使用 基本数据类型中使用 == 进行比较操</span></span><br><span class="line"><span class="comment">作</span></span><br><span class="line"><span class="comment">            如果使用 == 比较两个引用类型，那么比较就是引用类型【实际在内存中地址】</span></span><br><span class="line"><span class="comment">            如果两个引用类型都是new出来，地址是不会相等，所有引用类型是不可以使用 == 进行比较作</span></span><br><span class="line"><span class="comment">            所以需要比较两个引用类型是否相等，就需要使用到Java中所提供equals方法</span></span><br><span class="line"><span class="comment">            这个方法是Java专门针对引用类型所提供比较方法，它主要的比较的是引用类型中存储数据是否相等</span></span><br><span class="line"><span class="comment">            即如果两个数组中存储数据 个数和内容是完全一样，那么equals方法就会认为这两个数组是相等</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">int</span>[] arr1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] arr2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用 == 比较arr1和arr2是否相等？&quot;</span>+ (arr1 == arr2));</span><br><span class="line">        System.out.println(<span class="string">&quot;使用equals方法比较arr1和arr2是否相</span></span><br><span class="line"><span class="string">等？&quot;</span>+Arrays.equals(arr1,arr2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点十二：二维数组"><a href="#知识点十二：二维数组" class="headerlink" title="知识点十二：二维数组"></a><center>知识点十二：二维数组</center></h1><h2 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a><center>1、定义</center></h2><p>一维数组中的每一个元素，存储的是一个数据</p><p>二维数组中的每一个元素，存储的是一个一维数组</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#125;,&#123;&#125;,&#123;&#125;&#125;，里面的大括号就是一个二维数组数，打括号里面打括号里面的元素个数就是一维数组的个数</span><br></pre></td></tr></table></figure><h2 id="2、创建二维数组"><a href="#2、创建二维数组" class="headerlink" title="2、创建二维数组"></a><center>2、创建二维数组</center></h2><h3 id="（1）静态初始化语法"><a href="#（1）静态初始化语法" class="headerlink" title="（1）静态初始化语法"></a>（1）静态初始化语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法<span class="number">1</span>：数据类型 数组名 = &#123;&#123;元素<span class="number">1</span>,元素<span class="number">2</span>,...&#125;,&#123;元素<span class="number">1</span>,元素<span class="number">2</span>,...&#125;,.....&#125;;</span><br><span class="line">语法<span class="number">2</span>：数据类型 数组名 = <span class="keyword">new</span> 数据类型&#123;&#123;元素<span class="number">1</span>,元素<span class="number">2</span>,...&#125;,&#123;元素<span class="number">1</span>,元素<span class="number">2</span>,...&#125;,.....&#125;;</span><br></pre></td></tr></table></figure><h3 id="（2）动态初始化语法"><a href="#（2）动态初始化语法" class="headerlink" title="（2）动态初始化语法"></a>（2）动态初始化语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：数据类型 数组名 = <span class="keyword">new</span> 数据类型  [二维数组的长度][一维数组长度];</span><br><span class="line">注意：二维数组的长度必须要定义，一维数组的长度可以暂时不定义 </span><br></pre></td></tr></table></figure><h2 id="3、二维数组的使用"><a href="#3、二维数组的使用" class="headerlink" title="3、二维数组的使用"></a><center>3、二维数组的使用</center></h2><p>注意：</p><p>&ensp;&ensp;&ensp;&ensp;1）在定义二维数组的时候，一维数组可以暂时不用定义，等使用的时候再定义，如果定义就表示每一个一维数组的长度是一样的了。</p><p>&ensp;&ensp;&ensp;&ensp;2）第一个为行数，第二个为列数</p><p>&ensp;&ensp;&ensp;&ensp;3）二维数组的长度是二维数组中有几个一维数组长度就是多少</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//静态初始化</span></span><br><span class="line">        <span class="type">int</span> arr[][] = &#123;&#123;<span class="number">13</span>,<span class="number">42</span>,<span class="number">42</span>&#125;,&#123;<span class="number">34</span>,<span class="number">16</span>,<span class="number">34</span>,<span class="number">2</span>&#125;,&#123;<span class="number">42</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="comment">//使用数组</span></span><br><span class="line">        System.out.println(<span class="string">&quot;二维数组中第一个一维数组中的第一个元素：&quot;</span>+arr[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">        System.out.println(<span class="string">&quot;二维数组中第二个一维数组中的第三个元素：&quot;</span>+arr[<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">        System.out.println(<span class="string">&quot;二维数组的长度：&quot;</span>+arr.length);</span><br><span class="line">        <span class="comment">//动态初始化</span></span><br><span class="line">        <span class="type">int</span> arr1 [][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">32</span>][];</span><br><span class="line">        <span class="comment">//此时，arr1[0](一维数组长度)这个数组还没有定义</span></span><br><span class="line">        arr1 [<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">2</span>];</span><br><span class="line">        arr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">        arr1[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">22</span>;</span><br><span class="line">        arr1[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line">        arr[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">88</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;二维数组中第一个一维数组中的第一个元素：&quot;</span>+arr1[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">        System.out.println(<span class="string">&quot;二维数组中第二个一维数组中的第一个元素：&quot;</span>+arr1[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        System.out.println(arr1.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、二维数组遍历"><a href="#4、二维数组遍历" class="headerlink" title="4、二维数组遍历"></a><center>4、二维数组遍历</center></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) <span class="comment">//遍历遍历出每一个一维数组（行数）</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr[i].length; j++) <span class="comment">//遍历出每一个一维数组中的元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print(arr[i][j]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、二维数组的应用"><a href="#5、二维数组的应用" class="headerlink" title="5、二维数组的应用"></a><center>5、二维数组的应用</center></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo06</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>[][] yhArr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>][];</span><br><span class="line">        <span class="comment">//二维数组遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; yhArr.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//yhArr[i] 表示每一个一维数组，暂未初始化</span></span><br><span class="line">            yhArr[i] = <span class="keyword">new</span> <span class="title class_">int</span>[i+<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//遍历一维数组进行赋值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; yhArr[i].length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span> || i == j)</span><br><span class="line">                &#123;</span><br><span class="line">                    yhArr[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    yhArr[i][j] = yhArr[i-<span class="number">1</span>][j-<span class="number">1</span>] + yhArr[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;yhArr.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j&lt;yhArr[i].length;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(yhArr[i][j]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点十三：可变参数"><a href="#知识点十三：可变参数" class="headerlink" title="知识点十三：可变参数"></a><center>知识点十三：可变参数</center></h1><p>可变参数是专门用于设计方法中参数而提供一种方式，使用在参数列表的，可变参数的好处在于，允许在对参数进行赋值时，可以不进行任何操作，也可以接收多个值</p><p>将方法参数列表中设计了可变参数，可变参数是可以接收任意个数据，也可以接收一个数组【一维数组（即数组只有一个中括号）】，<strong>解决了如果方法实则参数为数组类型时，在调用方法时，不需要传递数组，但是因为数组是引用类型，如果不需要传递必须赋值为null，如果赋值为null值在方法内部使用，容易出现“NullPointerException”</strong></p><h2 id="1、定义-1"><a href="#1、定义-1" class="headerlink" title="1、定义"></a><center>1、定义</center></h2><p>参数的个数是动态的，可有可没有，可以多个</p><h2 id="2、语法"><a href="#2、语法" class="headerlink" title="2、语法"></a><center>2、语法</center></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型... 参数名 </span><br></pre></td></tr></table></figure><h2 id="3、特点"><a href="#3、特点" class="headerlink" title="3、特点"></a><center>3、特点</center></h2><p>1）可变参数，在调用的时候，可以传递0~N个参数</p><p>2）可变参数，可以直接当做是一个数组来使用（可变参数不能等同于数组）</p><p>3）可变参数，必须放在参数列表末尾（即一个方法只能有一个可变参数）</p><p>使用：定义方法求和，参数个数不确定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDemo7</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当调用showInfosIntArray这个方法时，不需要传递int类型数据对arr赋值</span></span><br><span class="line">        <span class="comment">//showInfosIntArray(null);    //err：NullPointerException</span></span><br><span class="line">        <span class="comment">//外界调用可变参数方法时：</span></span><br><span class="line">        showInfosIntArray2(<span class="literal">true</span>); <span class="comment">//可变参数不赋值</span></span><br><span class="line">        showInfosIntArray2(<span class="literal">false</span>,<span class="number">1</span>);<span class="comment">//赋值一个参数</span></span><br><span class="line">        showInfosIntArray2(<span class="literal">true</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>);<span class="comment">//赋值多个</span></span><br><span class="line">        showInfosIntArray2(<span class="literal">false</span>,<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;); <span class="comment">//允许赋值数组</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//提供一个方法 方法参数类型是一个int类型数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showInfosIntArray</span><span class="params">(<span class="type">int</span>[] arr)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;arr.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//利用更加便捷方式设置方法参数--》就是使用可变参数</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        在方法中使用可变参数需要注意：</span></span><br><span class="line"><span class="comment">        1. 一个方法中参数列表只允许定义一个可变参数</span></span><br><span class="line"><span class="comment">        2. 定义可变参数必须在参数列表中 定义的最后一个位置</span></span><br><span class="line"><span class="comment">        3. 可变参数定义语法: 数据类型... 变量名</span></span><br><span class="line"><span class="comment">        4. 可变参数即代表可变的状态，可变参数可以接收N个数据，也可以一个都不接收</span></span><br><span class="line"><span class="comment">        允许使用一维数组进行赋值操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showInfosIntArray2</span><span class="params">(<span class="type">boolean</span> res,<span class="type">int</span>... arr)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//可变参数在方法内部的操作就是数组操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;arr.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点十四：值传递和引用传递"><a href="#知识点十四：值传递和引用传递" class="headerlink" title="知识点十四：值传递和引用传递"></a><center>知识点十四：值传递和引用传递</center></h1><p>值传递：传递的是值本身，对原来变量的值本身没有影响，所有的基本类型（栈）+String（常量区）都属于值传递</p><p>引用传递：传递的是地址，对原来变量是有影响，所有的引用数据类型都属于引用传递</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo08</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//通过方法形式的传递</span></span><br><span class="line">        <span class="comment">// int a = 10;</span></span><br><span class="line">        <span class="comment">// System.out.println(&quot;传递之前a的值为：&quot;+a);</span></span><br><span class="line">        <span class="comment">// m1(a);</span></span><br><span class="line">        <span class="comment">// System.out.println(&quot;传递之后a的值为：&quot;+a);</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// String s = &quot;hello&quot;;</span></span><br><span class="line">        <span class="comment">// System.out.println(&quot;传递之前s的值为：&quot;+s);</span></span><br><span class="line">        <span class="comment">// m2(s);</span></span><br><span class="line">        <span class="comment">// System.out.println(&quot;传递之后s的值为：&quot;+s);</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// double[] d = &#123;1,2,3&#125;;</span></span><br><span class="line">        <span class="comment">// System.out.println(&quot;传递之前d[0]的值为：&quot;+d[0]);</span></span><br><span class="line">        <span class="comment">// m3(d);</span></span><br><span class="line">        <span class="comment">// System.out.println(&quot;传递之后d[0]的值为：&quot;+d[0]);</span></span><br><span class="line">        <span class="comment">//通过变量形式的传递</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a;</span><br><span class="line">        b = <span class="number">20</span>;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> s;</span><br><span class="line">        s1 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="type">int</span>[] arr1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] arr2 = arr1;</span><br><span class="line">        arr2[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">        System.out.println(arr1[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">(<span class="type">int</span> a)</span></span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">(String s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        s = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">(<span class="type">double</span>[] d)</span></span><br><span class="line">    &#123;</span><br><span class="line">        d[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;知识点一：数组的概念&quot;&gt;&lt;a href=&quot;#知识点一：数组的概念&quot; class=&quot;headerlink&quot; title=&quot;知识点一：数组的概念&quot;&gt;&lt;/a&gt;&lt;center&gt;知识点一：数组的概念&lt;/center&gt;&lt;/h1&gt;&lt;p&gt;数组在内存中是一块 连续的空间，可以保存 </summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>15.方法（函数）</title>
    <link href="http://example.com/post/6749388c.html"/>
    <id>http://example.com/post/6749388c.html</id>
    <published>2023-12-30T05:06:10.000Z</published>
    <updated>2024-02-29T12:30:18.822Z</updated>
    
    <content type="html"><![CDATA[<p>之前学习了循环结构【while 、do-while、for】，学习循环的目的解决一些重复性执行的操作代码，但是循环解决的重复性从操作是有要求：【解决重复问题（操作代码）是有一定次数要求（有规律），语法格式近乎与是相同（循环变量赋初值、循环条件、循环变量的自增或自减、重复操作的语句【重复执行的代码】）】，循环是否可以解决所有的重复性问题？</p><p>例如：开发一款游戏，游戏“坦克大战”，这里必然有一个操作“发射炮弹”【玩游戏的时候，炮弹发射是一直执行】，坦克大战是分为“玩家”和“电脑”，也就意味着“玩家“和“电脑”的坦克都要发射炮弹，如果让两者都来完成这个操作呢？ —》可以将发射炮弹的操作分别对“玩家”和“电脑”提供发射炮弹的实现【同样发射炮弹的代码要实现两遍】</p><p><strong>PS：方法：其实就是一段功能代码封装，只要利用方法中提供名字，就可以在任意位置执行一段功能代码</strong></p><p>将一段功能代码写入到一个代码块中【大括号括起来就是代码块】，这个代码块有一个名字，每次要执行这段功能代码的时候只需要写入这个名字，就可以完成代码的执行 —》这个就是方法</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271920306.jpg" alt="方法" style="zoom:67%;"><p><strong>PS：方法与函数的关系</strong></p><p>在某些语言中，对于上述概念所描述封装的操作叫做“函数”，在Java中我们是不区分函数和方法的名称，所以方法就是函数，函数就是方法。但是，因为Java是一门面向对象的语言所以建议称之为“方法”，“函数”的叫法偏向于面向过程</p><h1 id="知识点一：方法的定义和组成"><a href="#知识点一：方法的定义和组成" class="headerlink" title="知识点一：方法的定义和组成"></a><center>知识点一：方法的定义和组成</center></h1><h2 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a><center>1、定义</center></h2><p>方法：封装了一些为了解决某个问题而编写的代码片段称之为一个方法。可以反复使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">通用语法：</span><br><span class="line">访问权限修饰符 [其他修饰符] 返回值类型 方法名(参数列表)</span><br><span class="line">&#123;</span><br><span class="line">    方法体【方法可以执行的操作】</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>对应的含义：</p><ol><li>访问权限修饰符：作用当前这个方法谁可以调用，在Java中权限修饰符一共有4个，这4个修饰符都可以用于修饰方法，“<strong>这里我们先固定使用一个修饰 public【公有的】</strong>”</li><li>其他修饰符：可以在通用语法中可以看到，使用中括号将其他修饰符括起来，代表意思是可以省略不写，从Java8开始其他修饰符一共有4个【其中包含接口中1个】，“这里我们先<strong>固定</strong>使用一个修饰符 <strong>static</strong>【静态的】”</li><li>返回值类型：作用外界调用【触发】这个方法之后可以得到一个什么样的结果返回值类型在方法中一共有三种:”<strong>基本数据类型、引用类型和void</strong>【无返回值类型（方法专用）】”这三种类型将决定可以得到一个什么样的结果</li></ol><p>&ensp;&ensp;&ensp;&ensp;PS：这个返回值类型与方法内部中return关键字有很大的关联</p><ol start="4"><li>方法名： 就是方法名字，方便记忆与调用，但是需要遵守某些规则【基础规则：满足标识符命名规则，进阶规则：不要使用拼音、拼音缩写、不要写中文，英文单词（有意义），单词组成要遵守小驼峰的规则（首个单词首字母小写，后续每个单词首字母大写 —》getStudentAge）】</li><li>参数列表: 作用提供方法从外界获取到数据在方法内部使用（参数列表写法就是在定义变量，<strong>每个变量之间都使用【 , 】逗号分隔</strong>）在定义方法时，方法的参数列表一共有两种定义形态：</li></ol><p>&ensp;&ensp;&ensp;&ensp;5.1 如果方法中没有使用外界传递数据在方法内部使用，此时可以不定义参数列表，直接使用空的小括号()</p><p>&ensp;&ensp;&ensp;&ensp;5.2 如果方法中使用外界传递数据在方法内适用，必须定义与传递数据类型一致的变量进行接收，有多少个数据传递进来就可以定义多少个变量，但是变量与变量之间必须使用逗号分隔</p><ol start="6"><li>{ }大括号：方法的主体，提供方法内部实现代码就写在这个大括号中</li><li>在方法体中机大括号中，可以使用到一个关键字return这个关键具备两个意义</li></ol><p>&ensp;&ensp;&ensp;&ensp;return关键字的作用是：结束一个方法或结束一个方法并带回一个返回值</p><p>&ensp;&ensp;&ensp;&ensp;return关键字的使用跟返回值类型有关：</p><p>&ensp;&ensp;&ensp;&ensp;如果方法的返回值类型使用void，此时方法中可以使用return关键字也可以不使用，但是如果使用绝对不允许带有返回值</p><p>&ensp;&ensp;&ensp;&ensp;如果方法返回值类型使用基本数据类型或引用数据类中的一种，方法必须使用return关键字，return关键字带回的返回值需要和返回值类型一致并且有一个值</p><p>方法在类文件中书写的位置</p><ol><li>Java中最小的程序单元是类不是方法</li><li>Java中所有方法都是平级关系，不允许出现方法嵌套方法的定义</li><li>Java中定义方法不存在先后顺序，影响方法的顺序是方法调用的</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    /</span><br><span class="line">/方法定义操作</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    访问权限修饰符 [其他修饰符] 返回值类型 方法名(参数列表)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        方法体</span></span><br><span class="line"><span class="comment">        return;</span></span><br><span class="line"><span class="comment">    &#125; </span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">/</span></span><br><span class="line"><span class="comment">    //方法与方法之间是平级关系，所以定义方法的时候需要定义在main方法的外部</span></span><br><span class="line"><span class="comment">    /*</span></span><br><span class="line"><span class="comment">    如果这个方法提供操作代码并不参与其他运算中，此时这个方法就可以定义为void返回值类型</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">isLeapYear</span><span class="params">(<span class="type">int</span> year)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//在这个方法内部提供方法的实现即可</span></span><br><span class="line">        <span class="keyword">if</span>((year%<span class="number">4</span>==<span class="number">0</span> &amp;&amp; year%<span class="number">100</span>!=<span class="number">0</span>) ||(year%<span class="number">400</span>==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;是闰年：&quot;</span>+year);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不是闰年：&quot;</span>+year);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /</span><br><span class="line">* 加入</span><br><span class="line">    计算闰年的这个方法会参与到其他发的运算之中时，那么就需要提供返回值类型</span><br><span class="line">    表示是否是闰年方法最好的返回值类型就是 <span class="type">boolean</span>类型【<span class="literal">true</span>代表是闰年 <span class="literal">false</span>代表不是闰年】</span><br><span class="line">    PS：在同一个类文件中方法是不可以出现重名，方法名字必须是唯一</span><br><span class="line">    */</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isLeapYear2</span><span class="params">(<span class="type">int</span> year)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//一个方法中可以存在多个return语句，但是需要使用分支或循环语句进行分隔</span></span><br><span class="line">        <span class="comment">//计算方法中有多个return语句存在，但是只会有一个return执行</span></span><br><span class="line">        <span class="keyword">if</span>((year%<span class="number">4</span>==<span class="number">0</span> &amp;&amp; year%<span class="number">100</span>!=<span class="number">0</span>) ||(year%<span class="number">400</span>==<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点二：方法的定义和调用"><a href="#知识点二：方法的定义和调用" class="headerlink" title="知识点二：方法的定义和调用"></a><center>知识点二：方法的定义和调用</center></h1><h2 id="1、无参无返回值"><a href="#1、无参无返回值" class="headerlink" title="1、无参无返回值"></a><center>1、无参无返回值</center></h2><h3 id="1）定义形式"><a href="#1）定义形式" class="headerlink" title="1）定义形式"></a>1）定义形式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> 形参名()&#123;</span><br><span class="line">    </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="2）调用形式"><a href="#2）调用形式" class="headerlink" title="2）调用形式"></a>2）调用形式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">形参名( );</span><br></pre></td></tr></table></figure><p>案例：定义一个方法，实现关门</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//调用</span></span><br><span class="line">        closeDoor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeDoor</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关门...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、有参无返回值"><a href="#2、有参无返回值" class="headerlink" title="2、有参无返回值"></a><center>2、有参无返回值</center></h2><h3 id="1）定义形式-1"><a href="#1）定义形式-1" class="headerlink" title="1）定义形式"></a>1）定义形式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> 形参名(数据类型 参数名,数据类型 形参名,...)&#123;</span><br><span class="line">    </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="2）调用形式-1"><a href="#2）调用形式-1" class="headerlink" title="2）调用形式"></a>2）调用形式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">形参名(实参);</span><br></pre></td></tr></table></figure><p>注意：调用有参方法的时候，要保证形参和实参一致（个数一致，顺序一致，类型一致）</p><p>案例：定义一个方法，打印三角形（三角形行数由调用者来确定，而且三角形打印的字符由调用者来定）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        printSjx1(<span class="number">5</span>,<span class="string">&#x27;&gt;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printSjx1</span><span class="params">(<span class="type">int</span> num,<span class="type">char</span> c)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= num; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i ; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、无参有返回值"><a href="#3、无参有返回值" class="headerlink" title="3、无参有返回值"></a><center>3、无参有返回值</center></h2><h3 id="1）定义形式-2"><a href="#1）定义形式-2" class="headerlink" title="1）定义形式"></a>1）定义形式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回值数据类型 形参名()&#123;</span><br><span class="line">    </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="2）调用形式-2"><a href="#2）调用形式-2" class="headerlink" title="2）调用形式"></a>2）调用形式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 变量名 = 形参名(); </span><br><span class="line">System.out.println(形参名); </span><br></pre></td></tr></table></figure><p>案例：定义一个方法，求100质数的个数 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> count();</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j &lt; <span class="number">100</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//定义一个信号量表示是否是质数，true表示是质数</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">/*质数：只有被1或本身整除的数，也就是循环判断除了1或本身以外的数能否被整除，如果有一能</span></span><br><span class="line"><span class="comment">            则不是质数 */</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span> ; i &lt; j ; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j % i == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//这个数不是质数</span></span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//等循环结束，如果没有走进过if语句，那么可以证明这个数是一个质数</span></span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//计算有几个质数</span></span><br><span class="line">                count++;</span><br><span class="line">                System.out.println(<span class="string">&quot;质数：&quot;</span>+j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回质数的个数</span></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、有参有返回值"><a href="#4、有参有返回值" class="headerlink" title="4、有参有返回值"></a><center>4、有参有返回值</center></h2><h3 id="定义形式"><a href="#定义形式" class="headerlink" title="定义形式"></a>定义形式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回值数据类型 方法名(数据类型 形参名,...)&#123;</span><br><span class="line">    </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="调用形式"><a href="#调用形式" class="headerlink" title="调用形式"></a>调用形式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 变量名 = 形参名(实参);</span><br><span class="line">System.out.println(形参名);</span><br></pre></td></tr></table></figure><p>案例：定义一个方法，求1-n的阶乘</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">jc</span> <span class="operator">=</span> jc(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//System.out.println(jc);</span></span><br><span class="line">        <span class="comment">//如果一个方法的返回值，而且想输出方法返回值的结果，或将返回值作为另一个方法的参数，那么可以写在方法的参数上。</span></span><br><span class="line">        System.out.println(jc(<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">jc</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//定义一个变量保存乘积的结果（注意不能默认值为0）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">jc</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            jc *= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点三：方法的调用"><a href="#知识点三：方法的调用" class="headerlink" title="知识点三：方法的调用"></a><center>知识点三：方法的调用</center></h1><p>只需要在使用方法的位置使用语法： 方法名(赋值参数);</p><p>说明：</p><ol><li>赋值参数的提供需要和调用方法时，<strong>方法是否提供的参数列表的定义决定</strong></li></ol><p>如果方法在定义时提供了方法参数列表，调用方法时就必须对参数列表赋值</p><p>如果方法在定义时没有提供方法参数列表，调用方法时就必须不能对参数列赋值</p><ol start="2"><li>如果方法提供返回值类型定义，调用方法时允许接收方法得到结果，不仅如此还可以参与到表达式中，还可以参与到其他方法调用时的赋值操作，无论是接收、参与表达式计算、参与其他方法调用赋值，必须与返回值类型时一致的</li><li>如果方法没有提供返回值类型定义即使用void关键字，调用方法时是不允许接收结果，不允许参与到表达式中和对其他方法调用尽心赋值操作</li></ol><p>PS：在定义方法时方法定义顺序是没有任何影响，但是方法调用遵守的是基础的顺序执行所以谁先调用谁先执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">p</span><br><span class="line">ublic <span class="keyword">class</span> <span class="title class_">MethodDemo1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            调用方法的原则，必须在方法内部调用其他方法</span></span><br><span class="line"><span class="comment">            调用格式 方法名(参数赋值);</span></span><br><span class="line"><span class="comment">            调用原则 如果有返回值接收返回值，参与计算，参与到其他赋值操作</span></span><br><span class="line"><span class="comment">            如果没有返回值即使用void声明方法，不允许进行任何接收操作也不允许参与计算和赋值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//1.调用无返回值类型判断闰年的方法</span></span><br><span class="line">        <span class="comment">//给方法参数中定义的变量赋值，既可以是常量，也可以是变量</span></span><br><span class="line">        isLeapYear(<span class="number">2000</span>); <span class="comment">//无返回值的方法多用与打印语句操作【在方法内部使用打印语句输出效果】</span></span><br><span class="line">        <span class="comment">//2.调用有返回值类型判断闰年的放方法</span></span><br><span class="line">        <span class="comment">// 给方法参数中定义的变量赋值，既可以是常量，也可以是变量</span></span><br><span class="line">        <span class="comment">//可以接收方法得到返回值，但是必须提供与方法定义返回值类型一样变量进行接收</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> isLeapYear2(<span class="number">1999</span>);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">        <span class="comment">//还可以参与到计算中---》因为这个方法的返回值是boolean类型所以可以使用if分支语句判断中</span></span><br><span class="line">        <span class="keyword">if</span>(isLeapYear2(<span class="number">2000</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;输入的数据是闰年&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;输入的数据不是闰年&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//有返回值类型的方法可以使用在打印语句中</span></span><br><span class="line">        System.out.println(<span class="string">&quot;2021年是否是闰年?&quot;</span>+isLeapYear2(<span class="number">2021</span>));</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//方法定义操作</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        访问权限修饰符 [其他修饰符] 返回值类型 方法名(参数列表)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            方法体</span></span><br><span class="line"><span class="comment">            return;</span></span><br><span class="line"><span class="comment">        &#125; </span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="comment">//方法与方法之间是平级关系，所以定义方法的时候需要定义在main方法的外部</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如果这个方法提供操作代码并不参与其他运算中，此时这个方法就可以定义为void返回值类型</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">isLeapYear</span><span class="params">(<span class="type">int</span> year)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//在这个方法内部提供方法的实现即可</span></span><br><span class="line">        <span class="keyword">if</span>((year%<span class="number">4</span>==<span class="number">0</span> &amp;&amp; year%<span class="number">100</span>!=<span class="number">0</span>) ||(year%<span class="number">400</span>==<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;是闰年：&quot;</span>+year);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不是闰年：&quot;</span>+year);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/* 加入</span></span><br><span class="line"><span class="comment">    计算闰年的这个方法会参与到其他发的运算之中时，那么就需要提供返回值类型</span></span><br><span class="line"><span class="comment">    表示是否是闰年方法最好的返回值类型就是 boolean类型【true代表是闰年 false代表不是闰年】</span></span><br><span class="line"><span class="comment">    PS：在同一个类文件中方法是不可以出现重名，方法名字必须是唯一</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isLeapYear2</span><span class="params">(<span class="type">int</span> year)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//一个方法中可以存在多个return语句，但是需要使用分支或循环语句进行分隔</span></span><br><span class="line">        <span class="comment">//计算方法中有多个return语句存在，但是只会有一个return执行</span></span><br><span class="line">        <span class="keyword">if</span>((year%<span class="number">4</span>==<span class="number">0</span> &amp;&amp; year%<span class="number">100</span>!=<span class="number">0</span>) ||(year%<span class="number">400</span>==<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点四：方法使用注意细节"><a href="#知识点四：方法使用注意细节" class="headerlink" title="知识点四：方法使用注意细节"></a><center>知识点四：方法使用注意细节</center></h1><p>1、在Java中，方法不予许被嵌套（方法不能定义在另一个方法中，方法要定义在类里面，其他方法的外面）..</p><p>2、一个方法定义没有调用，不会执行</p><p>3、调用有参的方法的时候，我们要保证形参和实参一致（个数一致，顺序一致，类型一致）</p><p>4、如果一个方法有返回值，那么这个方法必须要有return 值，而且值的类型必须要与定义返回值类型保持一致（允许自动类型转换）</p><p>5、如果一个方法有返回值，可以不接收方法的返回值，也可以正常的调用方法</p><p>6、如果一个方法有返回值，那么在方法内部的每一个分支下都需要有返回值</p><h1 id="知识点五：return关键字"><a href="#知识点五：return关键字" class="headerlink" title="知识点五：return关键字"></a><center>知识点五：return关键字</center></h1><p>return关键字的作用：表示结束当前方法</p><p>return可以用在有返回值的方法中：</p><p>&ensp;&ensp;&ensp;&ensp;表示方法返回值(必须)：return 值，一个方法只能有一个返回值</p><p>return也可以用在没有返回值的方法中：</p><p>&ensp;&ensp;&ensp;&ensp;表示结束方法： return;</p><p>在return的后面不能直接写任何代码，因为不可能执行的到</p><p>没有返回值的方法可以写return，有返回值的方法必须要写return 返回值</p><h1 id="知识点六：方法的重载"><a href="#知识点六：方法的重载" class="headerlink" title="知识点六：方法的重载"></a><center>知识点六：方法的重载</center></h1><h2 id="1、引入"><a href="#1、引入" class="headerlink" title="1、引入"></a><center>1、引入</center></h2><p>使用方法完成两个数求和计算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码完成两个整数的求和操作，随着时间发展，你的老板需要你在提供一个求两个小数和的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">getSum1</span><span class="params">(<span class="type">double</span> d1,<span class="type">double</span> d2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> d1+d2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过两天，你的老板又来，要你定义两个byte类型和两个short类型变量进行进行求和操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum2</span><span class="params">(<span class="type">byte</span> b1,<span class="type">byte</span> b2)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> b1+b2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum3</span><span class="params">(<span class="type">short</span> s1,<span class="type">short</span> s2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> s1+s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又过了两天，你的老板有来，需要爱提供其他数据类型进行求和计算，此时方法的方法名就需要提供多个，外界使用方法的然就需要记忆多个方法名字，通过记忆方法名字来区分不同的方法参数是什么，才可以方便我们的调用，无形之中就对开发人员增加了压力，一个项目中多数方法都是这样，开发人员就需要大量记忆，那么有没有什么办法既可以减少记忆又可以满足不同数据计算原则</p><h2 id="2、方法重载的定义"><a href="#2、方法重载的定义" class="headerlink" title="2、方法重载的定义"></a><center>2、方法重载的定义</center></h2><p>方法定义的名字是有规则的，在一个类中是不允许出现重名方法的，即每个方法的方法签名是唯一【方法签名 &#x3D; 方法名+参数列表】，在这种情况下，为了方便程序猿的开发并且对方法记忆，可以使用Java中提供方法重载来完成操作</p><h2 id="3、方法重载的规则"><a href="#3、方法重载的规则" class="headerlink" title="3、方法重载的规则"></a><center>3、方法重载的规则</center></h2><p>方法名相同，参数列表不同【只要满足其一即可：“参数定义类型不同、参数定义个数不同、参数定义顺序不同”】即是重载</p><h2 id="4、重载的好处"><a href="#4、重载的好处" class="headerlink" title="4、重载的好处"></a><center>4、重载的好处</center></h2><p>使用重载可以减少同样逻辑方法名字的定义【就是方法参数不同，实现逻辑是一样的】，减少程序猿对同样实现逻辑的方法记忆，提高开发效率，编译器会自动选择最合适方法进行操作</p><p>在一个类中同名不同参的方法称之为方法的重载</p><p>重载的特点：</p><p>&ensp;&ensp;&ensp;&ensp;1）同方法名不同参（参数个数、顺序、类型要不一样）</p><p>&ensp;&ensp;&ensp;&ensp;2）与返回值和访问修饰符无关</p><p>重载的好处：</p><p>&ensp;&ensp;&ensp;&ensp;屏蔽了使用时的差异</p><p>例：</p><p>&ensp;&ensp;&ensp;&ensp;使用重载完成，两个数的求和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OverloadMethodDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//只需要记忆getSum这个方法可以求得两个数据之和就可以了</span></span><br><span class="line">        <span class="comment">//IDEA就会动态选择合适方法提供给我们调用实现，这样就可以减少程序员对方法名字记忆，方法调用</span></span><br><span class="line">        getSum(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//提供一个方法，求两个数的和</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    此时 getSum这个方法就发生了重载，他们方法名字相同，但是参数列表定义不同</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">getSum</span><span class="params">(<span class="type">double</span> d1,<span class="type">double</span> d2)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> d1+d2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：但是不能这样重载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OverloadMethodDemo2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果提供这样数据参与操作</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Ambiguous method call. Both getSum(byte,short) in</span></span><br><span class="line"><span class="comment">        OverloadMethodDemo2 and</span></span><br><span class="line"><span class="comment">        getSum(short,byte)in OverloadMethodDemo2 match</span></span><br><span class="line"><span class="comment">        出现这个报错的原因在于，提供两个方法都可以满足调用需求，此时IDEA无法分辨出调用那个方法</span></span><br><span class="line"><span class="comment">        方法出现了二义性，在定义重载时，设置参数尽量都是同时一个数据类型，这样可以避免出现二义</span></span><br><span class="line"><span class="comment">        性问题</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        getSum(num1,num2);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//不可以这样提供重载</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">        public static int getSum(byte b1,short s1)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            return b1+s1;</span></span><br><span class="line"><span class="comment">        &#125; </span></span><br><span class="line"><span class="comment">        public static int getSum(short s1,byte b1)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            return s1+b1;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//修改为</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">byte</span> b1,<span class="type">byte</span> s1)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> b1+s1;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">short</span> s1,<span class="type">short</span> b1)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> s1+b1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点五：方法的内存调用"><a href="#知识点五：方法的内存调用" class="headerlink" title="知识点五：方法的内存调用"></a><center>知识点五：方法的内存调用</center></h1><p>需求：使用方法完成两个数的交换，并在调用之后打印交换过后的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;交换之前a的值是：&quot;</span>+a);</span><br><span class="line">        System.out.println(<span class="string">&quot;交换之前b的值是：&quot;</span>+b);</span><br><span class="line">        <span class="comment">//在不使用方法的前提下交换两个数据的值</span></span><br><span class="line">        <span class="comment">/* //提供第三方变量进行数据存交换</span></span><br><span class="line"><span class="comment">            int tmp = a; //tmp中存储是a变量值</span></span><br><span class="line"><span class="comment">            a = b; //将b变量的值存储在a中 a就具有b的值</span></span><br><span class="line"><span class="comment">            b = tmp; //将tmp的值赋值b，间接的等于将a的值赋值给b，所以b中存储这个a值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//使用方法交换两个数据的值</span></span><br><span class="line">        swap(a,b);</span><br><span class="line">        System.out.println(<span class="string">&quot;交换之后a的值是：&quot;</span>+a);</span><br><span class="line">        System.out.println(<span class="string">&quot;交换之后b的值是：&quot;</span>+b);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> a; <span class="comment">//tmp中存储是a变量值</span></span><br><span class="line">        a = b; <span class="comment">//将b变量的值存储在a中 a就具有b的值</span></span><br><span class="line">        b = tmp; <span class="comment">//将tmp的值赋值b，间接的等于将a的值赋值给b，所以b中存储这个a值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271921086.jpg" alt="JVM内存调用"></p><h1 id="知识点六：方法的递归"><a href="#知识点六：方法的递归" class="headerlink" title="知识点六：方法的递归"></a><center>知识点六：方法的递归</center></h1><h2 id="1、定义-1"><a href="#1、定义-1" class="headerlink" title="1、定义"></a><center>1、定义</center></h2><p>什么是递归？</p><p>&ensp;&ensp;&ensp;&ensp;解决具有既定规律的问题时，在方法内部再次调用自身方法的一种编程方式。</p><p>何时使用递归？</p><p>&ensp;&ensp;&ensp;&ensp;当需要解决的问题可以拆分成若干个小问题，大小问题的解决方式相同，方法中自己调用自己。</p><p>&ensp;&ensp;&ensp;&ensp;使用循环解决的常规问题，都可以替换为递归解决。</p><p>如何正确使用递归？</p><p>&ensp;&ensp;&ensp;&ensp;设置有效的出口条件，可以让调用链上的每个方法都可以正确返回，避免无穷递归</p><h2 id="2、递归过程"><a href="#2、递归过程" class="headerlink" title="2、递归过程"></a><center>2、递归过程</center></h2><p>1）递进：大问题简化小问题</p><p>2）回溯：一步一步地给出结果</p><h2 id="3、应用"><a href="#3、应用" class="headerlink" title="3、应用"></a><center>3、应用</center></h2><p>案例1：求某个数的阶乘 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> jc(<span class="number">5</span>);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">jc</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num * jc(num-<span class="number">1</span>);  <span class="comment">//jc()相当于调用(重复调用达到循环效果)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>案例2：求斐波那契数列第n项</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//        int a = fb(5);</span></span><br><span class="line"><span class="comment">//        System.out.println(a);</span></span><br><span class="line">        System.out.println(fb(<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fb</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span> || n==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fb(n-<span class="number">1</span>) + fb(n-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点七：调用"><a href="#知识点七：调用" class="headerlink" title="知识点七：调用"></a><center>知识点七：调用</center></h1><h2 id="调用变量："><a href="#调用变量：" class="headerlink" title="调用变量："></a>调用变量：</h2><p>（1）有static修饰</p><p>&ensp;&ensp;&ensp;&ensp;方式：类名.静态变量名</p><p>（2）无static修饰</p><p>&ensp;&ensp;&ensp;&ensp;方式：类名 自定义名 &#x3D; new 类名();</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;自定义名.方法名();</p><h2 id="调用方法："><a href="#调用方法：" class="headerlink" title="调用方法："></a>调用方法：</h2><p>（1）有static修饰</p><p>&ensp;&ensp;&ensp;&ensp;方式：类名.方法名();</p><p>（2）无static修饰</p><p>&ensp;&ensp;&ensp;&ensp;方式：类名 自定义名 &#x3D; new 类名();</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;自定义名.方法名();</p><p>不同包调用变量和方法</p><p>&ensp;&ensp;&ensp;&ensp;只有static修饰的才可以访问</p><p>&ensp;&ensp;&ensp;&ensp;import static 对应到类文件的路径.*;</p><p>&ensp;&ensp;&ensp;&ensp;*：类中所有static修饰的都可以访问</p><p>&ensp;&ensp;&ensp;&ensp;*可以替换对应类中某一个指定的方法或者变量</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前学习了循环结构【while 、do-while、for】，学习循环的目的解决一些重复性执行的操作代码，但是循环解决的重复性从操作是有要求：【解决重复问题（操作代码）是有一定次数要求（有规律），语法格式近乎与是相同（循环变量赋初值、循环条件、循环变量的自增或自减、重复操作</summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>14.语句</title>
    <link href="http://example.com/post/43a94ea1.html"/>
    <id>http://example.com/post/43a94ea1.html</id>
    <published>2023-12-30T05:05:46.000Z</published>
    <updated>2024-02-29T12:30:16.054Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识点一：Scanner键盘输入语句"><a href="#知识点一：Scanner键盘输入语句" class="headerlink" title="知识点一：Scanner键盘输入语句"></a><center>知识点一：Scanner键盘输入语句</center></h1><p>步骤 ：</p><p>&ensp;&ensp;&ensp;&ensp;1）导入该类的所在包, java.util.*</p><p>&ensp;&ensp;&ensp;&ensp;2）创建该类对象（声明变量）</p><p>&ensp;&ensp;&ensp;&ensp;3）调用里面的功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入canner类(找包)</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;<span class="comment">//表示把 java.util 下的 Scanner 类导入</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建一个键盘录取对象，sc 就是 Scanner 类的对象</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);    <span class="comment">//如果没有导入Canner类可以：ctrl + enter</span></span><br><span class="line">        <span class="comment">//3、使用Scanner对象扫描输入的内容</span></span><br><span class="line">        <span class="comment">//整数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个数字&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;你输入的数字为：&quot;</span>+num);</span><br><span class="line">        <span class="comment">//字符串</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个字符串：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sc.next();   <span class="comment">//遇到空格结束</span></span><br><span class="line">        System.out.println(<span class="string">&quot;你输入的字符串为：&quot;</span>+s);</span><br><span class="line">        <span class="comment">//作用：用于读取上面输入的回车</span></span><br><span class="line">        sc.nextLine();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个字符串&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> sc.nextLine();  <span class="comment">//遇到回车结束</span></span><br><span class="line">        System.out.println(<span class="string">&quot;你输入的字符串为：&quot;</span>+s1);</span><br><span class="line">        <span class="comment">//小数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个小数：&quot;</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">s2</span> <span class="operator">=</span> sc.nextDouble();</span><br><span class="line">        System.out.println(<span class="string">&quot;你输入的小数为：&quot;</span>+s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点二：分支语句（选择语句）"><a href="#知识点二：分支语句（选择语句）" class="headerlink" title="知识点二：分支语句（选择语句）"></a><center>知识点二：分支语句（选择语句）</center></h1><h2 id="1、单分支"><a href="#1、单分支" class="headerlink" title="1、单分支"></a><center>1、单分支</center></h2><h3 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(逻辑条件(<span class="type">boolean</span>类型)) &#123;</span><br><span class="line">    满足逻辑条件执行的代码</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>执行流程：</p><p>&ensp;&ensp;&ensp;&ensp;①首先计算关系表达式的值</p><p>&ensp;&ensp;&ensp;&ensp;②如果关系表达式的值为true就执行语句体</p><p>&ensp;&ensp;&ensp;&ensp;③如果关系表达式的值为false就不执行语句体</p><p>&ensp;&ensp;&ensp;&ensp;④继续执行后面的语句内容</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271917443.jpg" alt="分支流程图" style="zoom: 33%;"><p>案例：输入一个人的年龄，如果年龄大于等于18岁允许上网</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">p</span><br><span class="line">ublic <span class="keyword">class</span> <span class="title class_">IfDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//需求：输入一个人的年龄，如果年龄大于等于18岁允许上网</span></span><br><span class="line">        <span class="comment">//Java代码如何在控制台上获取到数据输入【固定写法】</span></span><br><span class="line">        <span class="comment">//需要在自定义类文件中第一行的位置添加 import java.util.Scanner;导入操作</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入您的年龄：&quot;</span>);</span><br><span class="line">        <span class="comment">//在控制台获取到int类型数据存储到age变量中，通过后续操作age变量就相当于操作控制台输入</span></span><br><span class="line">        数据</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> input.nextInt();<span class="comment">// nextInt就可以获取到控制台输入int类型数据了，</span></span><br><span class="line">        <span class="keyword">if</span>(age &gt;= <span class="number">18</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;允许上网&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、双分支"><a href="#2、双分支" class="headerlink" title="2、双分支"></a><center>2、双分支</center></h2><h3 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="type">boolean</span>类型条件)&#123;​</span><br><span class="line">    满足逻辑条件执行的代码​(语句体<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;​</span><br><span class="line">    不满足逻辑条件执行的代码(语句体<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程：</p><p>&ensp;&ensp;&ensp;&ensp;①首先计算关系表达式的值</p><p>&ensp;&ensp;&ensp;&ensp;②如果关系表达式的值为true就执行语句体1</p><p>&ensp;&ensp;&ensp;&ensp;③如果关系表达式的值为false就执行语句体2</p><p>&ensp;&ensp;&ensp;&ensp;④继续执行后面的语句内容</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271917356.jpg" alt="双分支流程图" style="zoom:33%;"><p>案例：如果用户名为admin、密码为123456，则跳转首页，否则跳转登录页面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">stc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入用户名：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> stc.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入密码：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">password</span> <span class="operator">=</span> stc.nextInt();</span><br><span class="line">        <span class="comment">//String类型比较时尽量使用equals方法（==两边比较的是同一个空间里，字符串在常量区而输入的是在堆区）</span></span><br><span class="line">        <span class="keyword">if</span>(username.equals(<span class="string">&quot;admin&quot;</span>) &amp;&amp; password == (<span class="number">123456</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;跳转首页&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;跳转登陆页面&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、多分支"><a href="#3、多分支" class="headerlink" title="3、多分支"></a><center>3、多分支</center></h2><p>注意：苛刻条件写前面</p><h3 id="语法：-2"><a href="#语法：-2" class="headerlink" title="语法："></a>语法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="type">boolean</span>类型条件<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    满足逻辑条件<span class="number">1</span>执行的代码(语句体<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="type">boolean</span>类型条件<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//隐藏条件(不满足条件1)</span></span><br><span class="line">    满足逻辑条件<span class="number">2</span>执行的代码(语句体<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="type">boolean</span>类型条件<span class="number">3</span>)    </span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">//隐藏条件(不满足条件1、2)</span></span><br><span class="line">    满足逻辑条件<span class="number">3</span>执行的代码(语句体<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>    (可以没有<span class="keyword">else</span>)</span><br><span class="line">&#123;</span><br><span class="line">    不满足以上所有逻辑条件执行的代码(语句体n+<span class="number">1</span>)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>执行流程：</p><p>&ensp;&ensp;&ensp;&ensp;①首先计算关系表达式1的值</p><p>&ensp;&ensp;&ensp;&ensp;②如果值为true就执行语句体1；如果值为false就计算关系表达式2的值</p><p>&ensp;&ensp;&ensp;&ensp;③如果值为true就执行语句体2；如果值为false就计算关系表达式3的值</p><p>&ensp;&ensp;&ensp;&ensp;④…</p><p>&ensp;&ensp;&ensp;&ensp;⑤如果没有任何关系表达式为true，就执行语句体n+1</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271917195.jpg" alt="多分支流程图" style="zoom:33%;"><p>案例：根据手上的余额选择购买的手机品牌</p><p>&ensp;&ensp;&ensp;&ensp;如果大于10000, 买个苹果</p><p>&ensp;&ensp;&ensp;&ensp;如果大于7000, 买个华为</p><p>&ensp;&ensp;&ensp;&ensp;如果大于5000,买个小米</p><p>&ensp;&ensp;&ensp;&ensp;如果大于3000,买个诺基亚</p><p>&ensp;&ensp;&ensp;&ensp;否则,去打公共电话</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;请输入余额&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="keyword">if</span>(money &gt; <span class="number">10000</span>)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;苹果手机&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(money &gt; <span class="number">7000</span>)</span><br><span class="line">&#123; <span class="comment">//money &lt;= 10000</span></span><br><span class="line">    System.out.println(<span class="string">&quot;华为手机&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(money &gt; <span class="number">5000</span>)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;小米手机&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(money &gt; <span class="number">3000</span>)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;诺基亚手机&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;打公共电话&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、嵌套if分支"><a href="#4、嵌套if分支" class="headerlink" title="4、嵌套if分支"></a><center>4、嵌套if分支</center></h2><p>在一个分支结构中又完整的嵌套了另一个完整的分支结构， 里面的分支的结构称为内层分支外面的分支结构称为外层分支。 老师建议: 不要超过 3 层 （可读性不好）</p><h3 id="语法：-3"><a href="#语法：-3" class="headerlink" title="语法："></a>语法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="type">boolean</span>类型条件<span class="number">1</span>)&#123;​</span><br><span class="line">    <span class="keyword">if</span>(<span class="type">boolean</span>类型条件<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        满足<span class="type">boolean</span>类型条件<span class="number">1</span>且满足条件<span class="number">2</span>执行的代码</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        满足<span class="type">boolean</span>类型条件<span class="number">1</span>但不满足条件<span class="number">2</span>执行的代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    不满足<span class="type">boolean</span>类型条件<span class="number">1</span>执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demeo04</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入你的成绩：&quot;</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">score</span> <span class="operator">=</span> str.nextDouble();</span><br><span class="line">        <span class="keyword">if</span> (score &lt; <span class="number">15</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入你的性别：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">sex</span> <span class="operator">=</span> str.next();</span><br><span class="line">            <span class="keyword">if</span> (sex.equals(<span class="string">&quot;男&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;进入男子决赛组&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;进入女子决赛组&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;很遗憾你被淘汰&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、分支语句细节"><a href="#5、分支语句细节" class="headerlink" title="5、分支语句细节"></a><center>5、分支语句细节</center></h2><p>注意1：</p><p>&ensp;&ensp;&ensp;&ensp;在java中 &#x3D;&#x3D; 比较的是内存地址，String类的equals比较的是内容</p><p>&ensp;&ensp;&ensp;&ensp;基本数据类型使用&#x3D;&#x3D;比较。</p><p>&ensp;&ensp;&ensp;&ensp;String类型使用equals比较</p><p>注意2：</p><p>&ensp;&ensp;&ensp;&ensp;在if分支中，大括号可以省略不写，但是如果不写大括号，那么这个if分支只能控制一行代码（一般不这么写）</p><p>注意3：</p><p>&ensp;&ensp;&ensp;&ensp;多重if中要将苛刻条件写前面</p><h2 id="6、switch语句"><a href="#6、switch语句" class="headerlink" title="6、switch语句"></a><center>6、switch语句</center></h2><p>switch中的值的类型</p><p>&ensp;&ensp;&ensp;&ensp;byte  short  int  char  String   枚举</p><h3 id="语法：-4"><a href="#语法：-4" class="headerlink" title="语法："></a>语法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(值)&#123;​</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">switch</span>中的值与值<span class="number">1</span>相等时候执行的代码</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">switch</span>中的值与值<span class="number">2</span>相等时候执行的代码</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">3</span>:</span><br><span class="line">        <span class="keyword">switch</span>中的值与值<span class="number">3</span>相等时候执行的代码</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">4</span>:</span><br><span class="line">        <span class="keyword">switch</span>中的值与值<span class="number">4</span>相等时候执行的代码</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">switch</span>中的值与以上所有值都不相等时候执行的代码</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>案例：</p><p>&ensp;&ensp;&ensp;&ensp;选择1：查询操作</p><p>&ensp;&ensp;&ensp;&ensp;选择2：增加操作</p><p>&ensp;&ensp;&ensp;&ensp;选择3：删除操作</p><p>&ensp;&ensp;&ensp;&ensp;选择4：修改操作</p><p>&ensp;&ensp;&ensp;&ensp;选择5：退出系统</p><p>&ensp;&ensp;&ensp;&ensp;选择其他：提示输入有误 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;请输入你的选择&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">option</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="keyword">switch</span>(option)    </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    System.out.println(<span class="string">&quot;查询操作&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    System.out.println(<span class="string">&quot;增加操作&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    System.out.println(<span class="string">&quot;删除操作&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    System.out.println(<span class="string">&quot;修改操作&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    System.out.println(<span class="string">&quot;退出系统&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    System.out.println(<span class="string">&quot;输入有误&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、switch语句细节"><a href="#7、switch语句细节" class="headerlink" title="7、switch语句细节"></a><center>7、switch语句细节</center></h2><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271918301.jpg" alt="switch语句细节" style="zoom: 50%;"><p>例：</p><p>&ensp;&ensp;&ensp;&ensp;在不考虑平闰年的前提下，通过控制台输入1-12月之间任意一个月份，输出对应的天数</p><p>&ensp;&ensp;&ensp;&ensp;如果不适用switch语句穿透效果，那么需要提供12个case进行数据匹配，但是在12个case中有多个case执行效果都是一样的</p><p>&ensp;&ensp;&ensp;&ensp;2月份 28天 4,6,9,11 月份30天 1,3,5,7,8,10,12 月份 31天</p><p>&ensp;&ensp;&ensp;&ensp;利用case穿透特性节约代码，解决不同case条件但是执行语句操作相同的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">i</span><br><span class="line">mport java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwitchDemo2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入(1~12)之间数字代表月份：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">        <span class="keyword">switch</span> (month)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;28天&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;30天&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;31天&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8、总结-switch-和-if-分支"><a href="#8、总结-switch-和-if-分支" class="headerlink" title="8、总结 switch 和 if 分支"></a><center>8、总结 switch 和 if 分支</center></h2><p>1）如果判断的具体数值不多， 而且符合 byte、 short 、 int、 char, enum[枚举], String 这 6 种类型。虽然两个语句都可以使用， 建议使用 swtich 语句。</p><p>2）其他情况： 对区间判断， 对结果为 boolean 类型判断， 使用 if， if 的使用范围更广</p><p>多重if中可以做关系运算，在swtich中只能做等值判断 </p><p>PS:实际开发中还是使用if分支语句较多</p><h1 id="知识点三：循环语句"><a href="#知识点三：循环语句" class="headerlink" title="知识点三：循环语句"></a><center>知识点三：循环语句</center></h1><p>例如：在控制台上每一秒钟输出一行Hello World，打印语句就是重复性操作</p><p>&ensp;&ensp;&ensp;&ensp;开发一个机器人踢足球程序，程序中会有一个问题，如果没有进入到射门范围内，此时就需要让机器人持续的带球，重复性操作就是持续带球</p><p>使用循环结构可以轻松控制某些事情（操作）重复，重复在重复性操作</p><p>Java中提供循环结构有哪些？</p><p>&ensp;&ensp;&ensp;&ensp;“while循环、do-while循环 和 for循环”，利用这三个结构中某一种就可以完成某些代码重复性操作</p><p>所以在编写循环的时候主要提供要素【必要条件】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 要执行重复性操作的代码时什么</span><br><span class="line"><span class="number">2.</span> 执行重复操作的次数</span><br></pre></td></tr></table></figure><p>就要可以在代码结构中添加循环操作，让代码执行重复性操作</p><h2 id="1、for循环"><a href="#1、for循环" class="headerlink" title="1、for循环"></a><center>1、for循环</center></h2><h3 id="1）语法"><a href="#1）语法" class="headerlink" title="1）语法"></a>1）语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(循环变量赋初值;循环条件;循环变量自增或自减)&#123;</span><br><span class="line">    重复执行操作【执行语句】；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细说明：</p><ol><li>循环变量赋初值：这个变量主要作用是组成循环条件，可以参与到循环体计算与打印</li><li>循环条件： 使用循环变量与某个值构建一个循环的范围，这个范围也就是循环次数因为是范围的存在，所以循环条件多使用的“关系表达式 即 常用关系运算符 &gt; 、&gt;&#x3D; 、&lt; 、&lt;&#x3D;” 来组成循环范围，偶尔可见使用逻辑运算符与关系运算符共同组成表达式作为循环范围 或者使用 &#x3D;&#x3D; 或 !&#x3D; 来组建这个循环范围既然循环条件使用关系或逻辑运算符的表达式，所以条件得到结果值只有true 或 false</li><li>执行语句：就是你要让循环重复什么代码，这个代码时泛指【打印语句、逻辑计算、分支语句或者循环语句】</li><li>循环变量控制：因为使用循环变量与某个值构建循环范围，所有需要对循环变量加以控制【自增或自减】，以让循环条件可以达到我们需要的循环次数</li></ol><p>常见的自增或自检操作使用“++ 或 – 运算符”，偶尔可见使用运算符“+&#x3D;、-&#x3D;、*&#x3D; 、= 运算符“</p><p>PS: for循环在书写过程中需要在小括号内使用【;】分隔不同的循环条件</p><h3 id="2）for循环的执行顺序："><a href="#2）for循环的执行顺序：" class="headerlink" title="2）for循环的执行顺序："></a>2）for循环的执行顺序：</h3><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271918473.jpg" alt="for循环的执行顺序" style="zoom: 50%;"><p>案例：打印 1~100 之间所有是 9 的倍数的整数，统计个数 及 总和[化繁为简,先死后活]】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForExercise</span> &#123; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个main方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//打印1~100之间所有是9的倍数的整数，统计个数  及 总和.[化繁为简,先死后活]</span></span><br><span class="line">        <span class="comment">//老韩的两个编程思想(技巧)</span></span><br><span class="line">        <span class="comment">//1. 化繁为简 : 即将复杂的需求，拆解成简单的需求，逐步完成</span></span><br><span class="line">        <span class="comment">//2. 先死后活 : 先考虑固定的值，然后转成可以灵活变化的值</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//思路分析</span></span><br><span class="line">        <span class="comment">//打印1~100之间所有是9的倍数的整数，统计个数  及 总和</span></span><br><span class="line">        <span class="comment">//化繁为简</span></span><br><span class="line">        <span class="comment">//(1) 完成 输出 1-100的值</span></span><br><span class="line">        <span class="comment">//(2) 在输出的过程中，进行过滤，只输出9的倍数  i % 9 ==0</span></span><br><span class="line">        <span class="comment">//(3) 统计个数 定义一个变量 int count = 0; 当 条件满足时 count++;</span></span><br><span class="line">        <span class="comment">//(4) 总和 , 定义一个变量 int sum = 0; 当条件满足时累积 sum += i;</span></span><br><span class="line">        <span class="comment">//先死后活</span></span><br><span class="line">        <span class="comment">//(1) 为了适应更好的需求，把范围的开始的值和结束的值，做出变量</span></span><br><span class="line">        <span class="comment">//(2) 还可以更进一步 9 倍数也做成变量 int t = 9;</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//统计9的倍数个数 变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//总和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">5</span>; <span class="comment">// 倍数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>( i % t == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;i=&quot;</span> + i);</span><br><span class="line">                count++;</span><br><span class="line">                sum += i;<span class="comment">//累积</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;count=&quot;</span> + count);</span><br><span class="line">        System.out.println(<span class="string">&quot;sum=&quot;</span> + sum);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项和细节说明</p><ol><li>循环条件是返回一个布尔值的表达式</li><li>for(;循环判断条件;) 中的初始化和变量迭代可以写到其它地方， 但是两边的分号不能省略。</li><li>循环初始值可以有多条初始化语句，但要求类型一样，并且中间用逗号隔开，循环变量迭代也可以有多条变量迭代语句，中间用逗号隔开</li></ol><h2 id="2、while循环"><a href="#2、while循环" class="headerlink" title="2、while循环"></a><center>2、while循环</center></h2><p>注意：</p><p>&ensp;&ensp;&ensp;&ensp;1）一般用于不知道循环次数</p><p>&ensp;&ensp;&ensp;&ensp;2）循环初始化一般不能定义在循环里面</p><p>while循环在以后开发中占比0.9%左右【书写while循环比例也就是在0.9%】,但是是一个经典的循环结构，利用这循环结构完成某些代码重复执行</p><h3 id="1）语法："><a href="#1）语法：" class="headerlink" title="1）语法："></a>1）语法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">循环变量初值;</span><br><span class="line"><span class="keyword">while</span>(循环条件)【使用循环变量与某个值组成】&#123;</span><br><span class="line">    执行语句【让循环重复执行的操作】;</span><br><span class="line">    循环变量控制【循环变量的自增或自减】;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细说明：</p><ol><li>循环变量赋初值：这个变量主要作用是组成循环条件，可以参与到循环体计算与打印</li><li>循环条件： 使用循环变量与某个值构建一个循环的范围，这个范围也就是循环次数因为是范围的存在，所以循环条件多使用的“关系表达式 即 常用关系运算符 &gt; 、&gt;&#x3D; 、&lt; 、&lt;&#x3D;” 来组成循环范围，偶尔可见使用逻辑运算符与关系运算符共同组成表达式作为循环范围 或者使用 &#x3D;&#x3D; 或 !&#x3D; 来组建这个循环范围既然循环条件使用关系或逻辑运算符的表达式，所以条件得到结果值只有true 或 false</li><li>执行语句：就是你要让循环重复什么代码，这个代码时泛指【打印语句、逻辑计算、分支语句或者循环语句】</li><li>循环变量控制：因为使用循环变量与某个值构建循环范围，所有需要对循环变量加以控制【自增或自减】，以让循环条件可以达到我们需要的循环次数</li></ol><p>常见的自增或自检操作使用“++ 或 – 运算符”，偶尔可见使用运算符“+&#x3D;、-&#x3D;、*&#x3D; 、= 运算符“</p><h3 id="2、while执行顺序："><a href="#2、while执行顺序：" class="headerlink" title="2、while执行顺序："></a>2、while执行顺序：</h3><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271918653.jpg" alt="while执行顺序" style="zoom:50%;"><p>案例：利用while循环计算100以内（包括100）所有的奇数、偶数和3的倍数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">p</span><br><span class="line">ublic <span class="keyword">class</span> <span class="title class_">WhileDemo2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//利用while循环计算100以内（包括100），所有的奇数、偶数和3的倍数</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            分析:</span></span><br><span class="line"><span class="comment">            1.重复操作的事情 ---》 需要提供判断数据是否是奇数、偶数和3的倍数</span></span><br><span class="line"><span class="comment">            如果需要提供所有的奇数、偶数和3的倍数都要打印出来，此时应该提供一个什么样if判断是合理？</span></span><br><span class="line"><span class="comment">            三个条件 ---》 if-else if ---》不可以，因为if-else if原则 只要有一个条件</span></span><br><span class="line"><span class="comment">            判断为true，剩余条件皆不判断就会出现少一个打印结果情况 --》 那么应该选用谁？</span></span><br><span class="line"><span class="comment">            2.重复的次数 --》 从1~100之间的所有数据 ---》 100次</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//循环变量赋初值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=<span class="number">100</span>)    <span class="comment">//循环条件</span></span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">//重复操作的事情</span></span><br><span class="line">            <span class="comment">//先提供if-else if分支判断 --》无法完成具体需求</span></span><br><span class="line">            <span class="comment">//修改为 if 单分支</span></span><br><span class="line">            <span class="keyword">if</span>(i %<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;偶数：&quot;</span>+i);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;奇数：&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">3</span> ==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;3的倍数：&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//循环变量控制</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、do-while循环"><a href="#3、do-while循环" class="headerlink" title="3、do while循环"></a><center>3、do while循环</center></h2><p>注意：</p><p>&ensp;&ensp;&ensp;&ensp;1、先执行后判断，无论什么情况至少执行一次</p><p>&ensp;&ensp;&ensp;&ensp;2、循环初始化一般不能定义在循环里面</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">循环变量初值;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    执行语句【重复操作的代码】;</span><br><span class="line">    循环变量自增或自减【循环变量控制】;</span><br><span class="line">&#125;<span class="keyword">while</span>(循环条件);</span><br></pre></td></tr></table></figure><p>详细说明：</p><ol><li>循环变量赋初值：这个变量主要作用是组成循环条件，可以参与到循环体计算与打印</li><li>循环条件： 使用循环变量与某个值构建一个循环的范围，这个范围也就是循环次数因为是范围的存在，所以循环条件多使用的“关系表达式 即 常用关系运算符 &gt; 、&gt;&#x3D; 、&lt; 、&lt;&#x3D;” 来组成循环范围，偶尔可见使用逻辑运算符与关系运算符共同组成表达式作为循环范围 或者使用 &#x3D;&#x3D; 或 !&#x3D; 来组建这个循环范围既然循环条件使用关系或逻辑运算符的表达式，所以条件得到结果值只有true 或 false</li><li>执行语句：就是你要让循环重复什么代码，这个代码时泛指【打印语句、逻辑计算、分支语句或者循环语句】</li><li>循环变量控制：因为使用循环变量与某个值构建循环范围，所有需要对循环变量加以控制【自增或自减】，以让循环条件可以达到我们需要的循环次数</li></ol><p>常见的自增或自检操作使用“++ 或 – 运算符”，偶尔可见使用运算符“+&#x3D;、-&#x3D;、*&#x3D; 、= 运算符“</p><p>PS：在书写do-while循环的时候一定要注意循环末尾的【;】一要添加</p><h3 id="do-while-执行顺序-："><a href="#do-while-执行顺序-：" class="headerlink" title="do..while 执行顺序 ："></a>do..while 执行顺序 ：</h3><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271918158.jpg" alt="do..while执行顺序" style="zoom:50%;"><p>案例：学生根据老师的评语，是否继续敲代码，直到测评为ok，就结束 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">i</span><br><span class="line">mport java.awt.image.Kernel;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoWhileDemo2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//在同等条件下使用while循环和do-while进行数据打印操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------while循环的打印----------------&quot;</span>);</span><br><span class="line">        <span class="comment">//将正常案例操作注释，提供特条件，无论是while还是do-while都设置条件为 &lt;= 0</span></span><br><span class="line">        <span class="comment">/* int i = 1;</span></span><br><span class="line"><span class="comment">        while(i &lt;= 5)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            System.out.println(i);</span></span><br><span class="line"><span class="comment">            i++;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        i++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;---------do-while循环的打印--------------&quot;</span>);</span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">        int j = 1;    //此变量不能定义在do while语句里，因为在do while语句是局部变量while判断实在do while语句外，不在同一个范围内</span></span><br><span class="line"><span class="comment">        do</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            System.out.println(j);</span></span><br><span class="line"><span class="comment">            j++;</span></span><br><span class="line"><span class="comment">        &#125;while(j&lt;=5);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">while</span>(j &lt;= <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、嵌套循环"><a href="#4、嵌套循环" class="headerlink" title="4、嵌套循环"></a><center>4、嵌套循环</center></h2><p>将一个循环放在另一个循环体内， 就形成了嵌套循环。 其中， for ,while ,do…while 均可以作为外层循环和内层循环。【建议一般使用两层， 最多不要超过 3 层, 否则， 代码的可读性很差】</p><p>循环嵌套中有一个经典的理论：<strong>外层循环执行一次内层循环执行多次</strong></p><p>&ensp;&ensp;&ensp;&ensp;设外层循环次数为 m 次， 内层为 n 次， 则内层循环体实际上需要执行 m*n 次</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271919595.jpg" alt="嵌套循环" style="zoom:50%;"><p>某些操作中提供一层循环是无法满足所有循环逻辑，所以在这样前提下，我们就需要提供嵌套循环了</p><p>需求：打印下面样式</p><p>&ensp;&ensp;&ensp;&ensp;1 2  3   4   5</p><p>&ensp;&ensp;&ensp;&ensp;2 4  6   8  10</p><p>&ensp;&ensp;&ensp;&ensp;3 6  9  12 15</p><p>&ensp;&ensp;&ensp;&ensp;4 8 12 16 20</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">p</span><br><span class="line">ublic <span class="keyword">class</span> <span class="title class_">NestingForDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1 2 3 4 5</span></span><br><span class="line"><span class="comment">            2 4 6 8 10</span></span><br><span class="line"><span class="comment">            3 6 9 12 15</span></span><br><span class="line"><span class="comment">            4 8 12 16 20</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//外层循环中 变量是可以参与到 内层循环计算中</span></span><br><span class="line">        <span class="comment">// 参与到 内层循环中 j的赋值、 j的循环条件和参与到内层循环的重复执行操作中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i&lt;=<span class="number">4</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">5</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                Java中打印语句有两个方式一个是带有 ln方法【println】 一个是不带有 ln方法</span></span><br><span class="line"><span class="comment">                【print】</span></span><br><span class="line"><span class="comment">                区别在于带有ln的打印语句输出结果时，会在打印结束的位置添加换行【添加回车-</span></span><br><span class="line"><span class="comment">                -》&quot;\n&quot;】</span></span><br><span class="line"><span class="comment">                不带有ln的打印语句输出结果时，不会有添加换行的，将打印内容在一行显示</span></span><br><span class="line"><span class="comment">                可以在打印语句中添加 “\t” 代表4个空格 也是键盘上tab键</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                System.out.print(j*i + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//调用一个带有ln方法进行打印，添加换行操作</span></span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;&ensp;&ensp;可以将当前代码中这种循环形式理解为在看书，外层第一层循环【i层】相当于是书中页数，内层（第二层）循环【j层】相当于书页作用内一行内容，只有当书中每一行内容都看完之后，才可以翻页即只有内层循环执行完毕之后，外层循环才会开启下一次</p><p>&ensp;&ensp;&ensp;&ensp;执行流程：当前代码执行到嵌套循环时，首先先执行外层循环的循环变量赋初值【执行1次】，判断外层循环循环条件是否成立，如果成立就执行大括号中的，内层循环，先执行循环变量赋初值【随外层循环的次数而进行初始化】，然后判断内层循环的循环条件，如果为true，就执行内层循环中大括号内执行语句，然后内层循环变量自增或自减，再次执行内层循环条件判断，直到循环条件为false，内层循环停止，此时外层循环开始循环变量自增或自减，然后再判断外层循环条件，如果为true，就会再次开启内层循环，否则循环完全结束</p><p>PS:外层循环变量是可以参与到内层循环操作的，可以影响内层循环条件，参与到内存循环计算</p><h1 id="知识点四：break和continue关键字"><a href="#知识点四：break和continue关键字" class="headerlink" title="知识点四：break和continue关键字"></a><center>知识点四：break和continue关键字</center></h1><p>含义：</p><p>&ensp;&ensp;&ensp;&ensp;break：表示结束当前循环</p><p>&ensp;&ensp;&ensp;&ensp;continue：表示结束本次循环,继续下一次循环</p><p>注意：紧跟着break和continue后面不能写任何代码 </p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271919940.jpg" alt="break和continue" style="zoom: 67%;"><p>实现登录验证，有 3 次机会， 如果用户名为”丁真” ,密码”666”提示登录成功，否则提示还有几次机会，请使用 for+break</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BreakExercise02</span> &#123;</span><br><span class="line">    <span class="comment">//编写一个 main 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//实现登录验证， 有 3 次机会， 如果用户名为&quot;丁真&quot; ,密码&quot;666&quot;提示登录成功，</span></span><br><span class="line">        <span class="comment">//否则提示还有几次机会， 请使用 for+break 完成</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 思路分析</span></span><br><span class="line">        <span class="comment">// 1. 创建 Scanner 对象接收用户输入</span></span><br><span class="line">        <span class="comment">// 2. 定义 String name ; String passwd; 保存用户名和密码</span></span><br><span class="line">        <span class="comment">// 3. 最多循环 3 次[登录 3 次]， 如果 满足条件就提前退出</span></span><br><span class="line">        <span class="comment">// 4. 定义一般变量 int chance 记录还有几次登录机会</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 代码实现</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">myScanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">passwd</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">chance</span> <span class="operator">=</span> <span class="number">3</span>; <span class="comment">//登录一次 ， 就减少一次</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;<span class="comment">//3 次登录机会</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入名字&quot;</span>);</span><br><span class="line">        name = myScanner.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入密码&quot;</span>);</span><br><span class="line">        passwd = myScanner.next();</span><br><span class="line">        <span class="comment">//比较输入的名字和密码是否正确</span></span><br><span class="line">        <span class="comment">//补充说明字符串 的内容 比较 使用的 方法 equals</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;丁真&quot;</span>.equals(name) &amp;&amp; <span class="string">&quot;666&quot;</span>.equals(passwd)) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;恭喜你， 登录成功~&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//登录的机会就减少一次</span></span><br><span class="line">    chance--;</span><br><span class="line">    System.out.println(<span class="string">&quot;你还有&quot;</span> + chance + <span class="string">&quot;次登录机会&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">continue</span> 语句出现在多层嵌套的循环语句体中时， 可以通过标签指明要跳过的是哪一层循环 , 这个和前面的标签的</span><br><span class="line">使用的规则一样</span><br><span class="line">label1:</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)&#123;</span><br><span class="line">    label2:</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">//看看分别输出什么值， 并分析</span></span><br><span class="line">            <span class="comment">//continue ;</span></span><br><span class="line">            <span class="comment">//continue label2;</span></span><br><span class="line">            <span class="keyword">continue</span> label1;</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>跳转控制语句-return</strong></p><p>&ensp;&ensp;&ensp;&ensp;return 使用在方法，表示<strong>跳出所在的方法</strong>，在讲解方法的时候，会详细的介绍，这里我们简单的提一下。注意：如果 return 写在 <strong>main 方法，退出程序</strong> </p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271919833.jpg" alt="return作用" style="zoom:50%;">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;知识点一：Scanner键盘输入语句&quot;&gt;&lt;a href=&quot;#知识点一：Scanner键盘输入语句&quot; class=&quot;headerlink&quot; title=&quot;知识点一：Scanner键盘输入语句&quot;&gt;&lt;/a&gt;&lt;center&gt;知识点一：Scanner键盘输入语句&lt;/cent</summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>13.运算符</title>
    <link href="http://example.com/post/ded373.html"/>
    <id>http://example.com/post/ded373.html</id>
    <published>2023-12-30T05:05:31.000Z</published>
    <updated>2024-02-29T12:30:12.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识点一：算术运算符"><a href="#知识点一：算术运算符" class="headerlink" title="知识点一：算术运算符"></a><center>知识点一：算术运算符</center></h1><p>算数运算符遵守就是数学四则运算</p><table><thead><tr><th align="center">符号</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">加</td></tr><tr><td align="center">-</td><td align="center">减</td></tr><tr><td align="center">*</td><td align="center">乘</td></tr><tr><td align="center">&#x2F;</td><td align="center">除</td></tr><tr><td align="center">%</td><td align="center">取余</td></tr><tr><td align="center">++</td><td align="center">自增（自身加1）</td></tr><tr><td align="center">–</td><td align="center">自减（自身减1）</td></tr></tbody></table><p>+号在java中有两个作用：</p><p>&ensp;&ensp;&ensp;&ensp;1、字符串的拼接（字符串拼接的时候，任何类型与字符串拼接最终的结果是字符串类型 ）</p><p>&ensp;&ensp;&ensp;&ensp;2、加法运算 </p><p><strong>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;++、–在前：先加+1、-1再使用</strong></p><p>&ensp;&ensp;&ensp;&ensp;<strong>&ensp;&ensp;&ensp;&ensp;++、–在后：先使用再加+1 、-1</strong></p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271915907.jpg" alt="面试题" style="zoom: 50%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArithmeticOperatorExercise01</span> &#123;</span><br><span class="line">    <span class="comment">//编写一个 main 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// int i = 1;//i-&gt;1</span></span><br><span class="line">        <span class="comment">// i = i++; //规则使用临时变量: (1) temp=i;(2) i=i+1;(3)i=temp;</span></span><br><span class="line">        <span class="comment">// System.out.println(i); // 1</span></span><br><span class="line">        <span class="comment">// int i=1;</span></span><br><span class="line">        <span class="comment">// i=++i; //规则使用临时变量: (1) i=i+1;(2) temp=i;(3)i=temp;</span></span><br><span class="line">        <span class="comment">// System.out.println(i); //2</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 测试输出</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> i1++;</span><br><span class="line">        System.out.print(<span class="string">&quot;i=&quot;</span>+i);<span class="comment">//10</span></span><br><span class="line">        System.out.println(<span class="string">&quot;i2=&quot;</span>+i2);<span class="comment">//20</span></span><br><span class="line">        i = --i2;</span><br><span class="line">        System.out.print(<span class="string">&quot;i=&quot;</span>+i);<span class="comment">//19</span></span><br><span class="line">        System.out.println(<span class="string">&quot;i2=&quot;</span>+i2);<span class="comment">//19</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细说明</p><p>&ensp;&ensp;&ensp;&ensp;1）加号运算符（+）：加号运算符不仅可以对数值类型（整数或小数）数据进行计算，而且还可以提供给字符类型进行计算，并且还可以对字符串类型提供操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddOperator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//提供给 char类型【字符类型】进行计算</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            字符类型char 默认存储范围是0~65535结束，在这个范围内都可以存正整数</span></span><br><span class="line"><span class="comment">            如果char类型中存储的字符 也是可以通过 +号 进行计算的</span></span><br><span class="line"><span class="comment">            将char类型中存储字符转换为对应十进制数据，转换原则是Unicode【万国码】</span></span><br><span class="line"><span class="comment">            有一个存储字符的集合--》ASCII码【美国信息标准交换代码】</span></span><br><span class="line"><span class="comment">            美国人将字符和字符定义到这个码中，并且提供字符对应十进制数据</span></span><br><span class="line"><span class="comment">            所以使用字符类型在计算时，会将字符转换为对应十进制参与计算</span></span><br><span class="line"><span class="comment">            在ASCII码表中大家需要记录一个范围</span></span><br><span class="line"><span class="comment">            &#x27;a&#x27; -- 97 a~z之间是一个连续存储范围，所以b对应的数值就是98 ，依次类推 递增+1</span></span><br><span class="line"><span class="comment">            &#x27;A&#x27; -- 65 A~Z之间是一个连续存储范围，所以B对应的数值就是66，依次类推，递增+1</span></span><br><span class="line"><span class="comment">            &#x27;0&#x27;(字符零) -- 48 &#x27;0&#x27;~&#x27;9&#x27;之间是一个连续存储范围，所以&#x27;1&#x27;对应的数值就是49，依次类</span></span><br><span class="line"><span class="comment">推，递增+1</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch2</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line">        System.out.println(ch+ch2);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            在使用byte、short、char类型变量发生计算时，他们会被默认提升为为int类型参与到计算中</span></span><br><span class="line"><span class="comment">            所以要存储会原有数据类型中必须进行强制类型转换操作</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">ch3</span> <span class="operator">=</span> (<span class="type">char</span>)(ch+ch2); <span class="comment">//这个计算等式就等于 ---&gt; char ch3 = 65+32;</span></span><br><span class="line">        System.out.println(ch3);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果小数据数据类型范围数据变量与大数据类型范围数据变量发生计算，最终结果数据类型一定是大范围数据类型</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d3</span> <span class="operator">=</span> <span class="number">3.14</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> i1 + d3;</span><br><span class="line">        <span class="comment">//+号运算符是可以参与到 字符串计算的，但是是拼接效果</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">        System.out.println(str+str1);</span><br><span class="line">        <span class="comment">//字符串类型与任何类型数据使用【+】进行拼接得到结果都是 拼接效果，所以利用这个原则就可以定义打印语句</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//在执行和字符串拼接计算时遵守的是从左向右执行所以最先开始执行效果就是</span></span><br><span class="line">        <span class="comment">//&quot;num1+num2的和是：&quot;+num1 --&gt; &quot;num1+num2的和是：1&quot;</span></span><br><span class="line">        <span class="comment">//然后在利用&quot;num1+num2的和是：1&quot;+num2 --&gt; num1+num2的和是：12</span></span><br><span class="line">        System.out.println(<span class="string">&quot;num1+num2的和是：&quot;</span>+(num1+num2));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//++的使用</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        i++;<span class="comment">//自增 等价于 i = i + 1; =&gt; i = 11</span></span><br><span class="line">        ++i;<span class="comment">//自增 等价于 i = i + 1; =&gt; i = 12</span></span><br><span class="line">        System.out.println(<span class="string">&quot;i=&quot;</span> + i);<span class="comment">//12</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            作为表达式使用</span></span><br><span class="line"><span class="comment">            前++： ++i 先自增后赋值</span></span><br><span class="line"><span class="comment">            后++： i++先赋值后自增</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">        <span class="comment">//int k = ++j; //等价 j=j+1;k=j;</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> j++; <span class="comment">// 等价 k =j;j=j+1;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;k=&quot;</span> + k + <span class="string">&quot;j=&quot;</span> + j);<span class="comment">//8 9</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//笔试题：short s1 = 1; short s2 = 1; s2 = s1 + s2? s2 += s1;?</span></span><br><span class="line">        <span class="type">short</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">short</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// s2 = s1 + s2; //错误</span></span><br><span class="line">        s2 += s1; <span class="comment">//正确</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;&ensp;&ensp;2）除号运算符（&#x2F;）：Java中整数除以整数只能得到整数，如果需要得到小数，需要使用小数数据类型计算</p><p>在使用除号进行计算时，不允许除数为0即不能除以0，会已发Java程序异常导致后学代码无法执行</p><p>小数允许这个操作，但是得到结果不是我们想要的0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">p</span><br><span class="line">ublic class DivOperator</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        //演示除法</span><br><span class="line">        //Java中整数除以整数只能得到整数</span><br><span class="line">        int num1 = 1;</span><br><span class="line">        int num2 = 10;</span><br><span class="line">        System.out.println(&quot;计算1/10等于：&quot;+(num1/num2));//0</span><br><span class="line">        </span><br><span class="line">        //小数</span><br><span class="line">        System.out.println(10 / 4); //从数学来看是 2.5, java 中 2</span><br><span class="line">        System.out.println(10.0 / 4); //java 是 2.5</span><br><span class="line"></span><br><span class="line">        double d = 10 / 4;//java 中 10 / 4 = 2, 2=&gt;2.0</span><br><span class="line">        System.out.println(d);// 是 2.0</span><br><span class="line">        </span><br><span class="line">        //使用除法的时候是不可以除以0的</span><br><span class="line">        //java.lang.ArithmeticException 在java中叫做异常【程序出现了错误】</span><br><span class="line">        int i1 = 0;</span><br><span class="line">        int i2 = 1;</span><br><span class="line">        System.out.println(&quot;计算1/0等于：&quot;+(i2/i1));</span><br><span class="line">        //小数是可以除以0,但是这样做是没有意义</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;&ensp;&ensp;3）求余操作（%），求余操作与除法计算时有本质上区别除法主要是计算求商，求余计算计算得到是余数，因为整数除以整数得到结果只能是整数，所以在Java要进行某些判断时候，除法操作是无法完成通用性判断，所以建议使用（%）求余的形式来记性一些辅助型的计算</p><p>例如：判断某个数是否整数此时就不能使用除法来进行计算，可需要使用求余方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// % 取模，取余</span></span><br><span class="line"><span class="comment">// 在 % 的本质 看一个公式!!!! a % b = a - a / b * b</span></span><br><span class="line"><span class="comment">// -10 % 3 =&gt; -10 - (-10) / 3 * 3 = -10 + 9 = -1</span></span><br><span class="line"><span class="comment">// 10 % -3 = 10 - 10 / (-3) * (-3) = 10 - 9 = 1</span></span><br><span class="line"><span class="comment">// -10 % -3 = (-10) - (-10) / (-3) * (-3) = -10 + 9 = -1</span></span><br><span class="line">System.out.println(<span class="number">10</span> % <span class="number">3</span>); <span class="comment">//1</span></span><br><span class="line">System.out.println(-<span class="number">10</span> % <span class="number">3</span>); <span class="comment">//-1</span></span><br><span class="line">System.out.println(<span class="number">10</span> % -<span class="number">3</span>); <span class="comment">//1</span></span><br><span class="line">System.out.println(-<span class="number">10</span> % -<span class="number">3</span>);<span class="comment">//-1</span></span><br></pre></td></tr></table></figure><p>剩余运算符就可以按照四则运算计算即可</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271916027.jpg" alt="结果" style="zoom:33%;"><h1 id="知识点二：赋值运算符"><a href="#知识点二：赋值运算符" class="headerlink" title="知识点二：赋值运算符"></a><center>知识点二：赋值运算符</center></h1><table><thead><tr><th align="center">符号</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">&#x3D;</td><td align="center">赋值</td></tr><tr><td align="center">+&#x3D;</td><td align="center">先计算加法然后再赋值操作</td></tr><tr><td align="center">-&#x3D;</td><td align="center">先计算减法然后再赋值操作</td></tr><tr><td align="center">*&#x3D;</td><td align="center">先计算乘法然后再赋值操作等于</td></tr><tr><td align="center">&#x2F;&#x3D;</td><td align="center">先计算除法然后再赋值操作</td></tr><tr><td align="center">%&#x3D;</td><td align="center">先计算求余然后再赋值操作</td></tr></tbody></table><p>复合赋值运算符会进行类型转换。byte b &#x3D; 2; b+&#x3D;3; b++;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AssignmentOperator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        n1 += <span class="number">4</span>;<span class="comment">// n1 = n1 + 4;</span></span><br><span class="line">        System.out.println(n1); <span class="comment">// 14</span></span><br><span class="line">        n1 /= <span class="number">3</span>;<span class="comment">// n1 = n1 / 3;//4</span></span><br><span class="line">        System.out.println(n1); <span class="comment">// 4</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//复合运算符还可以减少强制类型转换的用法操作</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//byte、short和char类型在变量计算时，会默提升为int类型</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum2</span> <span class="operator">=</span> (<span class="type">byte</span>)(num1+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//加入将计算记过存储到num1中 --》 修改后为</span></span><br><span class="line">        num1 = (<span class="type">byte</span>)(num1+<span class="number">1</span>);</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//复合赋值运算符会进行类型转换</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        b += <span class="number">2</span>; <span class="comment">// 等价 b = (byte)(b + 2);</span></span><br><span class="line">        b++; <span class="comment">// b = (byte)(b+1);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点三：-–运算符"><a href="#知识点三：-–运算符" class="headerlink" title="知识点三：++ –运算符"></a><center>知识点三：++ –运算符</center></h1><p>无论 ++ 和 – 运算符出现在变量任何一个位置，当前的变量都需要进行需要进行一次+1和-1操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">p</span><br><span class="line">ublic <span class="keyword">class</span> <span class="title class_">AddOperator2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//提供++ -- 运算符操作</span></span><br><span class="line">        <span class="comment">//单独使用</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//执行 i++ 操作</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            单独使用++运算符对变量进行计算即【没有参与到其它运算中和赋值运算符】</span></span><br><span class="line"><span class="comment">            i++ 和 ++i的效果是一样的 i这边量 会进行+1操作</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        i++; <span class="comment">// 等价于执行 i = i+1;</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">        ++i; <span class="comment">// 等价于执行 i = i+1;</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">        <span class="comment">// -- 也是同样的道理， 在单独使用前提下 i-- 和 --i效果都是一样 都是变量i进行-1操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;&ensp;&ensp;如果使用自增或自减变量参与到运算符中时，此时++ 或 – 运算符出现的位置 得到计算结果就是完全不一样的</p><p>&ensp;&ensp;&ensp;&ensp;如果参与计算中 ++ 运算符出现在变量之前即 ++i，此时当前i变量要先执行+1自增操作，然后再参与到其它运算中</p><p>&ensp;&ensp;&ensp;&ensp;如果参与计算中 ++ 运算符出现在变量之后即 i++，此时当前i变量要先参与到其他运算中，然后再执行+1自增操作</p><p>&ensp;&ensp;&ensp;&ensp;– 是同理的，只要将+1为-1即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">p</span><br><span class="line">ublic <span class="keyword">class</span> <span class="title class_">AddOperator3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> aplus;</span><br><span class="line">        <span class="type">int</span> bplus;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            无论++和--运算符出现在变量任何一个位置，当前的变量都需要进行需要进行一次+1和-1操作</span></span><br><span class="line"><span class="comment">            区分运算符使用方式【单独使用】或【参与运算符】</span></span><br><span class="line"><span class="comment">            参与运算计算 ，此时就要区分运算符出现在变量位置，变量之前还是变量之后</span></span><br><span class="line"><span class="comment">            如果参与计算中 ++ 运算符出现在变量之前即 ++i，此时当前i变量要先执行+1自增操作，然后再</span></span><br><span class="line"><span class="comment">参与到其它运算中</span></span><br><span class="line"><span class="comment">            如果参与计算中 ++ 运算符出现在变量之后即 i++，此时当前i变量要先参与到其他运算中，然后</span></span><br><span class="line"><span class="comment">再执行+1自增操作</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            a++ ++运算符出现在变量之后 满足了</span></span><br><span class="line"><span class="comment">            如果参与计算中 ++ 运算符出现在变量之后即 i++，此时当前i变量要先参与到其他运算中，然</span></span><br><span class="line"><span class="comment">后再执行+1自增操作</span></span><br><span class="line"><span class="comment">            先执行 aplus = a 的操作 此时a的值是1 所以 aplus中赋值为1</span></span><br><span class="line"><span class="comment">            然后执行 a++ 即 a = a+1 此时 a = 2</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        aplus = a++;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            ++b ++运算符出现在变量之前 满足了</span></span><br><span class="line"><span class="comment">            如果参与计算中 ++ 运算符出现在变量之前即 ++i，此时当前i变量要先执行+1自增操作，然</span></span><br><span class="line"><span class="comment">后再参与到其它运算中</span></span><br><span class="line"><span class="comment">            先执行 bplus = b= b+1 即先执行 b= b+1操作 b= 2</span></span><br><span class="line"><span class="comment">            然后执行 bplus = b操作 bplus 存储2这个值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        bplus = ++b;</span><br><span class="line">        System.out.println(<span class="string">&quot;a的值是：&quot;</span>+a);<span class="comment">//2</span></span><br><span class="line">        System.out.println(<span class="string">&quot;b的值是：&quot;</span>+b); <span class="comment">//2</span></span><br><span class="line">        System.out.println(<span class="string">&quot;aplus的值是：&quot;</span>+aplus);<span class="comment">//1</span></span><br><span class="line">        System.out.println(<span class="string">&quot;bplus的值是：&quot;</span>+bplus);<span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点四：关系运算符"><a href="#知识点四：关系运算符" class="headerlink" title="知识点四：关系运算符"></a><center>知识点四：关系运算符</center></h1><p>1）关系运算符的结果都是 boolean 型， 也就是要么是 true， 要么是 false</p><p>2）关系表达式 经常用在 if 结构的条件中或循环结构的条件中</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271916838.jpg" alt="关系运算符" style="zoom:50%;"><p>细节说明</p><p>&ensp;&ensp;&ensp;&ensp;1）关系运算符的结果都是 boolean 型， 也就是要么是 true， 要么是 false</p><p>&ensp;&ensp;&ensp;&ensp;2）关系运算符组成的表达式， 我们称为关系表达式。 a &gt; b</p><p>&ensp;&ensp;&ensp;&ensp;3）比较运算符 “&#x3D;&#x3D;” 不能误写成 “&#x3D;”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RelationalOperator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//演示关系运算符</span></span><br><span class="line">        <span class="comment">//提供两个变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="comment">//判断a和b变量之间的关系 --&gt; 得到结果只有true 和 false</span></span><br><span class="line">        <span class="comment">//在代码中看到是a和b两个变量在比较，其实在执行的是10和20这个两个数据在比较</span></span><br><span class="line">        System.out.println(a == b); <span class="comment">//10等于20吗？ false</span></span><br><span class="line">        System.out.println(a != b); <span class="comment">//10不等于20吗？ true</span></span><br><span class="line">        System.out.println(a &gt; b); <span class="comment">// 10大于20吗？ false</span></span><br><span class="line">        System.out.println(a &gt;= b);<span class="comment">//10大于等于20吗？即10大于20 或 10等于20 吗？false</span></span><br><span class="line">        System.out.println(a &lt; b);<span class="comment">//10小于20吗？ true</span></span><br><span class="line">        System.out.println(a &lt;= b);<span class="comment">//10小于等于20吗？即10小于20 或 10等于20 吗？ true</span></span><br><span class="line">        <span class="comment">//又因为关系表达式计算结果得到true或false，所以可以存储在boolean变量中</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> a&gt;b;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点五：逻辑运算符"><a href="#知识点五：逻辑运算符" class="headerlink" title="知识点五：逻辑运算符"></a><center>知识点五：逻辑运算符</center></h1><p>逻辑运算符的作用就是将多个关系表达式连接在一起，形成一个复杂的逻辑表达式，来进行逻辑判断操作</p><p>结果：boolean类型 </p><p>分为两组学习</p><ol><li>短路与 &amp;&amp; ， 短路或 ||+， 取反 !</li><li>逻辑与 &amp;， 逻辑或 |， ^ 逻辑异或</li></ol><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271916832.jpg" alt="逻辑运算符" style="zoom:50%;"><p><strong>&amp;&amp; 和 &amp; 基本规则</strong></p><table><thead><tr><th align="center">名称</th><th align="center">语法</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center">短路与&amp;&amp;</td><td align="center">条件1 &amp;&amp; 条件2</td><td align="center">两个条件都为 true， 结果为 true,否则 false</td></tr><tr><td align="center">逻辑与&amp;</td><td align="center">条件1 &amp; 条件2</td><td align="center">两个条件都为 true， 结果为 true,否则 false</td></tr></tbody></table><p><strong>&amp;&amp; 和 &amp; 使用区别</strong></p><p>&ensp;&ensp;&ensp;&ensp;1）&amp;&amp;短路与： 如果第一个条件为 false，则第二个条件不会判断，最终结果为 false，效率高</p><p>&ensp;&ensp;&ensp;&ensp;2）&amp; 逻辑与：不管第一个条件是否为 false，第二个条件都要判断， 效率低</p><p>&ensp;&ensp;&ensp;&ensp;3）开发中，我们使用的基本是使用短路与&amp;&amp;，效率高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 演示逻辑运算符的使用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogicOperator01</span> &#123;</span><br><span class="line">    <span class="comment">//编写一个 main 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//&amp;&amp;短路与 和 &amp; 案例演示</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">if</span>(age &gt; <span class="number">20</span> &amp;&amp; age &lt; <span class="number">90</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ok100&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//&amp;逻辑与使用</span></span><br><span class="line">        <span class="keyword">if</span>(age &gt; <span class="number">20</span> &amp; age &lt; <span class="number">90</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ok200&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//区别</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">        <span class="comment">//对于&amp;&amp;短路与而言， 如果第一个条件为 false ,后面的条件不再判断</span></span><br><span class="line">        <span class="comment">//对于&amp;逻辑与而言， 如果第一个条件为 false ,后面的条件仍然会判断</span></span><br><span class="line">        <span class="keyword">if</span>(a &lt; <span class="number">1</span> &amp; ++b &lt; <span class="number">50</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ok300&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(<span class="string">&quot;a=&quot;</span> + a + <span class="string">&quot; b=&quot;</span> + b);<span class="comment">// 4 10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>|| 和 | 基本规则</strong></p><table><thead><tr><th align="center">名称</th><th align="center">语法</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center">|| 短路或</td><td align="center">条件1 || 条件2</td><td align="center">只要有一个条件成立,结果为 true,否则为 false</td></tr><tr><td align="center">| 逻辑或</td><td align="center">条件1 | 条件2</td><td align="center">只要有一个条件成立，结果为 true，否则为 false</td></tr></tbody></table><p><strong>|| 和 | 使用区别</strong></p><p>&ensp;&ensp;&ensp;&ensp;1）||短路或：如果第一个条件为 true，则第二个条件不会判断，最终结果为 true，效率高</p><p>&ensp;&ensp;&ensp;&ensp;2）| 逻辑或：不管第一个条件是否为 true，第二个条件都要判断，效率低</p><p>&ensp;&ensp;&ensp;&ensp;3）开发中，我们基本使用 ||</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//演示| || 使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogicOperator02</span> &#123;</span><br><span class="line">    <span class="comment">//编写一个 main 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//||短路或 和 |逻辑或 案例演示</span></span><br><span class="line">        <span class="comment">//|| 规则: 两个条件中只要有一个成立， 结果为 true,否则为 false</span></span><br><span class="line">        <span class="comment">//| 规则: 两个条件中只要有一个成立， 结果为 true,否则为 false</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">if</span>(age &gt; <span class="number">20</span> || age &lt; <span class="number">30</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ok100&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//&amp;逻辑与使用</span></span><br><span class="line">        <span class="keyword">if</span>(age &gt; <span class="number">20</span> | age &lt; <span class="number">30</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ok200&quot;</span>);</span><br><span class="line">        &#125; <span class="comment">//</span></span><br><span class="line">        看看区别</span><br><span class="line">        <span class="comment">//(1)||短路或： 如果第一个条件为 true，</span></span><br><span class="line">        <span class="comment">//则第二个条件不会判断， 最终结果为 true， 效率高</span></span><br><span class="line">        <span class="comment">//(2)| 逻辑或： 不管第一个条件是否为 true， 第二个条件都要判断， 效率低</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">if</span>( a &gt; <span class="number">1</span> || ++b &gt; <span class="number">4</span>) &#123; <span class="comment">// 可以换成 | 测试</span></span><br><span class="line">            System.out.println(<span class="string">&quot;ok300&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(<span class="string">&quot;a=&quot;</span> + a + <span class="string">&quot; b=&quot;</span> + b); <span class="comment">//4 10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>! 取反 基本规则</strong></p><table><thead><tr><th align="center">名称</th><th align="center">语法</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center">! 非（取反）</td><td align="center">! 条件</td><td align="center">如果条件本身成立，结果为 false，否则为 true</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//!和^案例演示</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InverseOperator</span> &#123;</span><br><span class="line">    <span class="comment">//编写一个 main 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//! 操作是取反 T-&gt;F , F -&gt; T</span></span><br><span class="line">        System.out.println(<span class="number">60</span> &gt; <span class="number">20</span>); <span class="comment">//T</span></span><br><span class="line">        System.out.println(!(<span class="number">60</span> &gt; <span class="number">20</span>)); <span class="comment">//F</span></span><br><span class="line">        <span class="comment">//a^b: 叫逻辑异或， 当 a 和 b 不同时， 则结果为 true, 否则为 false</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="number">10</span> &gt; <span class="number">1</span>) ^ ( <span class="number">3</span> &gt; <span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;b=&quot;</span> + b);<span class="comment">//T</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>PS：根据逻辑与和短路与 还有逻辑或和短路或的特点【不同】，建议在实际开中使用短路与和短路或作为开发操作的原则</strong></p><h1 id="知识点六：位运算符"><a href="#知识点六：位运算符" class="headerlink" title="知识点六：位运算符"></a><center>知识点六：位运算符</center></h1><p>java 中有7个位运算(&amp;、 |、 ^、 ~、 &gt;&gt;、 &lt;&lt;和 &gt;&gt;&gt;)</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271916692.jpg" alt="位运算符" style="zoom:50%;"><p>&gt;&gt;、 &lt;&lt; 和 &gt;&gt;&gt; ，运算规则:</p><ol><li>算术右移 &gt;&gt;： 低位溢出,符号位不变,并用符号位补溢出的高位</li><li>算术左移 &lt;&lt;: 符号位不变,低位补 0</li><li>逻辑右移也叫无符号右移,运算规则是: 低位溢出， 高位补 0</li><li>特别说明： 没有 &lt;&lt;&lt; 符号</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位运算</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BitOperator</span> &#123; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个main方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//看老师的推导过程</span></span><br><span class="line">        <span class="comment">//1. 先得到 2的补码 =&gt; 2的原码 00000000 00000000 00000000 00000010</span></span><br><span class="line">        <span class="comment">//   2的补码 00000000 00000000 00000000 00000010</span></span><br><span class="line">        <span class="comment">//2. 3的补码 3的原码 00000000 00000000 00000000 00000011</span></span><br><span class="line">        <span class="comment">//   3的补码 00000000 00000000 00000000 00000011</span></span><br><span class="line">        <span class="comment">//3. 按位&amp;</span></span><br><span class="line">        <span class="comment">//   00000000 00000000 00000000 00000010</span></span><br><span class="line">        <span class="comment">//   00000000 00000000 00000000 00000011 </span></span><br><span class="line">        <span class="comment">//   00000000 00000000 00000000 00000010 &amp; 运算后的补码</span></span><br><span class="line">        <span class="comment">//   运算后的原码 也是  00000000 00000000 00000000 00000010</span></span><br><span class="line">        <span class="comment">//   结果就是  2</span></span><br><span class="line">        System.out.println(<span class="number">2</span>&amp;<span class="number">3</span>);<span class="comment">//2</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//推导</span></span><br><span class="line">        <span class="comment">//1. 先得到 -2的原码 10000000 00000000 00000000 00000010</span></span><br><span class="line">        <span class="comment">//2. -2的 反码         11111111 11111111 11111111 11111101</span></span><br><span class="line">        <span class="comment">//3. -2的 补码       11111111 11111111 11111111 11111110</span></span><br><span class="line">        <span class="comment">//4. ~-2操作        00000000 00000000 00000000 00000001运算后的补码</span></span><br><span class="line">        <span class="comment">//5. 运算后的原码 就是 00000000 00000000 00000000 00000001 =&gt; 1</span></span><br><span class="line">        System.out.println(~-<span class="number">2</span>);<span class="comment">//1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//推导</span></span><br><span class="line">        <span class="comment">//1. 得到2的补码 00000000 00000000 00000000 00000010</span></span><br><span class="line">        <span class="comment">//2. ~2操作     11111111 11111111 11111111 11111101  运算后的补码</span></span><br><span class="line">        <span class="comment">//3. 运算后的反码  11111111 11111111 11111111 11111100</span></span><br><span class="line">        <span class="comment">//4. 运算后的原码  10000000 00000000 00000000 00000011=&gt;-3</span></span><br><span class="line">        System.out.println(~<span class="number">2</span>); <span class="comment">//-3</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="number">1</span> &gt;&gt; <span class="number">2</span>); <span class="comment">//0</span></span><br><span class="line">        System.out.println(<span class="number">1</span> &lt;&lt; <span class="number">2</span>); <span class="comment">//4</span></span><br><span class="line">        System.out.println(<span class="number">4</span> &lt;&lt; <span class="number">3</span>); <span class="comment">// 4 * 2 * 2 * 2 = 32</span></span><br><span class="line">        System.out.println(<span class="number">15</span> &gt;&gt; <span class="number">2</span>); <span class="comment">// 15 / 2 / 2 = 3               </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点七：三目运算符"><a href="#知识点七：三目运算符" class="headerlink" title="知识点七：三目运算符"></a><center>知识点七：三目运算符</center></h1><p>形式：</p><p>&ensp;&ensp;&ensp;&ensp;<strong>条件表达式 ? 结果1 : 结果2;</strong> </p><p>嵌套使用：</p><p>&ensp;&ensp;&ensp;&ensp;条件表达式 ? 条件表达式 ? 结果1 : 结果2 : 结果3;</p><p>例：&#x2F;&#x2F;判断年龄如果大于18岁，输出成年人,但是如果大于60岁，输出老年人，否则输出未成年人</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TernaryOperator</span> &#123;</span><br><span class="line">    <span class="comment">//编写一个 main 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">99</span>;</span><br><span class="line">        <span class="comment">// 解读</span></span><br><span class="line">        <span class="comment">// 1. a &gt; b 为 false</span></span><br><span class="line">        <span class="comment">// 2. 返回 b--, 先返回 b 的值,然后在 b-1</span></span><br><span class="line">        <span class="comment">// 3. 返回的结果是 99</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> a &lt; b ? a++ : b--;</span><br><span class="line">        System.out.println(<span class="string">&quot;result=&quot;</span> + result);    <span class="comment">//10</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a=&quot;</span> + a);<span class="comment">//11</span></span><br><span class="line">        System.out.println(<span class="string">&quot;b=&quot;</span> + b);<span class="comment">//99</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用细节</strong></p><p>&ensp;&ensp;&ensp;&ensp;1）表达式 1 和表达式 2 要为可以赋给接收变量的类型(或可以自动转换)</p><p>&ensp;&ensp;&ensp;&ensp;2）三元运算符可以转成 if–else 语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> a &gt; b ? a++ : --b;</span><br><span class="line"><span class="keyword">if</span> ( a &gt; b) res = a++;    <span class="comment">//等同</span></span><br><span class="line"><span class="keyword">else</span> res = --b;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TernaryOperatorDetail</span> &#123;</span><br><span class="line">    <span class="comment">//编写一个 main 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//表达式 1 和表达式 2 要为可以赋给接收变量的类型</span></span><br><span class="line">        <span class="comment">//(或可以自动转换/或者强制转换)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a &gt; b ? (<span class="type">int</span>)<span class="number">1.1</span> : (<span class="type">int</span>)<span class="number">3.4</span>;<span class="comment">//可以的</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> a &gt; b ? a : b + <span class="number">3</span>;<span class="comment">//可以的， 满足 int -&gt; double</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TernaryOperatorExercise</span> &#123;</span><br><span class="line">    <span class="comment">//编写一个 main 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//案例： 实现三个数的最大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">553</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">33</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line">        <span class="comment">//思路</span></span><br><span class="line">        <span class="comment">//1. 先得到 n1 和 n2 中最大数 , 保存到 max1</span></span><br><span class="line">        <span class="comment">//2. 然后再 求出 max1 和 n3 中的最大数， 保存到 max2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max1</span> <span class="operator">=</span> n1 &gt; n2 ? n1 : n2;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max2</span> <span class="operator">=</span> max1 &gt; n3 ? max1 : n3;</span><br><span class="line">        System.out.println(<span class="string">&quot;最大数=&quot;</span> + max2);</span><br><span class="line">        <span class="comment">//使用一条语句实现, 推荐使用上面方法</span></span><br><span class="line">        <span class="comment">//老师提示: 后面我们可以使用更好方法,比如排序</span></span><br><span class="line">        <span class="comment">// int max = (n1 &gt; n2 ? n1 : n2) &gt; n3 ?</span></span><br><span class="line">        <span class="comment">// (n1 &gt; n2 ? n1 : n2) : n3;</span></span><br><span class="line">        <span class="comment">// System.out.println(&quot;最大数=&quot; + max);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;知识点一：算术运算符&quot;&gt;&lt;a href=&quot;#知识点一：算术运算符&quot; class=&quot;headerlink&quot; title=&quot;知识点一：算术运算符&quot;&gt;&lt;/a&gt;&lt;center&gt;知识点一：算术运算符&lt;/center&gt;&lt;/h1&gt;&lt;p&gt;算数运算符遵守就是数学四则运算&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
</feed>
