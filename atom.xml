<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>星仔人生录</title>
  
  <subtitle>珍惜当下 不负此生</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-07-12T14:15:17.282Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>星仔</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>6.IIC通信</title>
    <link href="http://example.com/post/f5fba2c3.html"/>
    <id>http://example.com/post/f5fba2c3.html</id>
    <published>2024-06-19T08:41:34.000Z</published>
    <updated>2024-07-12T14:15:17.282Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IIC理论"><a href="#IIC理论" class="headerlink" title="IIC理论"></a><center>IIC理论</center></h1><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a><center>实现方式</center></h2><p>软件IIC：流程清楚、占用时间、速度慢</p><p>硬件IIC ：用法复杂、速度快、可以用DMA</p><h2 id="电路"><a href="#电路" class="headerlink" title="电路"></a><center>电路</center></h2><p>SCL：时钟线，SDA：数据线</p><p>上拉电阻：4.7k-10k</p><h2 id="速率"><a href="#速率" class="headerlink" title="速率"></a><center>速率</center></h2><p>标准模式：100Kb&#x2F;s、快速模式：400Kb&#x2F;s、高速模式：3.4Mb&#x2F;s</p><p>100kbit&#x2F;s 是指1秒钟传输100kbit。1个时钟脉冲只能传输1bit数据。1秒中内要传输100kbit数据，则需要100k个时钟脉冲。每个时钟脉冲的周期 T&#x3D;1&#x2F;100 000 &#x3D; 10us</p><p>HZ和bit&#x2F;s是一个相同的概念。时钟周期为1HZ，则传输数据的速率为1bit&#x2F;s；时钟周期为100KHZ，则传输数据的速率为100kbit&#x2F;s</p><h2 id="时序"><a href="#时序" class="headerlink" title="时序"></a><center>时序</center></h2><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202407091551334.png" alt="时钟信号图"></p><h3 id="空闲状态"><a href="#空闲状态" class="headerlink" title="空闲状态"></a>空闲状态</h3><p>SDA和SCL全为高电平</p><h3 id="开始信号"><a href="#开始信号" class="headerlink" title="开始信号"></a>开始信号</h3><p>当SCL为高电平时，SDA<code>由高到低</code>的跳变：表示数据传输的开始</p><h3 id="停止信号"><a href="#停止信号" class="headerlink" title="停止信号"></a>停止信号</h3><p>当SCL为高电平时，SDA<code>由低到高</code>的跳变：表示数据的结束</p><h3 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h3><ul><li>发送从机地址<ul><li>每个 I2C 器件都有一个设备地址<ul><li>先发送设备地址来决定访问哪个 I2C 器件</li></ul></li><li>发送8位数据<ul><li>高 7 位是设备地址,后 1 位是读写位<ul><li>1 表示读操作</li><li>0表示写操作</li></ul></li></ul></li><li>应答信号  <ul><li>发端在SDA上每发送一个字节的数据，在SCL第9个时钟期间释放该数据线SDA</li><li>接收端反馈一个应答信号<ul><li>应答信号为低电平时：规定为有效应答（ACK），表示已地接收了</li><li>该字节应答信号为高电平时，规定为非应答（NACK），表示没有成功接收该字节</li><li>有时候简单的软件IIC不校验ACK</li></ul></li></ul></li><li>读写数据<ul><li>根据前一个字节的读写位，确定读写</li></ul></li></ul></li></ul><h2 id="总线设备相关"><a href="#总线设备相关" class="headerlink" title="总线设备相关"></a><center>总线设备相关</center></h2><p>总线最多挂载2^7-1&#x3D;127个设备（0地址不算）</p><p>设备枚举（for）</p><h1 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a><center>代码编写</center></h1><p>OLED屏的使用</p><h2 id="iic-c（主要）"><a href="#iic-c（主要）" class="headerlink" title="iic.c（主要）"></a>iic.c（主要）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iic.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="comment">//参考上面时序图理解（按时间先为主判断）</span></span><br><span class="line"><span class="comment">//开始</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">IIC_SCL = <span class="number">1</span>;</span><br><span class="line">IIC_SDA = <span class="number">1</span>;</span><br><span class="line">Delay5us();</span><br><span class="line">IIC_SDA = <span class="number">0</span>;</span><br><span class="line">Delay5us();</span><br><span class="line">IIC_SCL = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结束</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Stop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">IIC_SCL = <span class="number">1</span>;</span><br><span class="line">IIC_SDA = <span class="number">0</span>;</span><br><span class="line">Delay5us();</span><br><span class="line">IIC_SDA = <span class="number">1</span>;</span><br><span class="line">Delay5us();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//发送数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Write_Byte</span><span class="params">(uchar wbyte)</span></span><br><span class="line">&#123;</span><br><span class="line">uchar i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">wbyte &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">IIC_SDA = CY;<span class="comment">//进位标志位，左移溢出的保存在CY里</span></span><br><span class="line">IIC_SCL = <span class="number">1</span>;</span><br><span class="line">Delay5us();</span><br><span class="line">IIC_SCL = <span class="number">0</span>;</span><br><span class="line">Delay5us();</span><br><span class="line">&#125;</span><br><span class="line">IIC_SCL = <span class="number">1</span>;</span><br><span class="line">Delay5us();</span><br><span class="line">IIC_SCL = <span class="number">0</span>;</span><br><span class="line">Delay5us();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="iic-h"><a href="#iic-h" class="headerlink" title="iic.h"></a>iic.h</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __IIC_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __IIC_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;main.h&gt;</span></span></span><br><span class="line"><span class="comment">//声明三个函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Start</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Stop</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_Write_Byte</span><span class="params">(uchar wbyte)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iic.h&quot;</span><br><span class="line">#include &quot;oled.h&quot;</span><br><span class="line">#include &quot;bmp.h&quot;</span><br><span class="line">#include &quot;main.h&quot;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">u8 t;</span><br><span class="line">OLED_Init();//初始化OLED</span><br><span class="line">OLED_Clear();</span><br><span class="line">OLED_ShowCHinese(0,0,0);//星</span><br><span class="line">OLED_ShowCHinese(18,0,1);//仔</span><br><span class="line">OLED_ShowCHinese(36,0,2);//爱</span><br><span class="line">OLED_ShowCHinese(54,0,3);//分</span><br><span class="line">OLED_ShowCHinese(72,0,4);//享</span><br><span class="line">OLED_ShowCHinese(90,0,5);//抖</span><br><span class="line">OLED_ShowCHinese(108,0,6);//音</span><br><span class="line">OLED_ShowCHinese(0,2,6);//星</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OLED_Clear();</span><br><span class="line">OLED_ShowString(6,3,&quot;0.96&#x27; OLED TEST&quot;,16);//显示字符串（x,y,字符串,字号）</span><br><span class="line">OLED_Clear();</span><br><span class="line">OLED_ShowNum(103,6,224,3,16);//显示数字（x,y,数字,数字个数,字号）</span><br><span class="line">OLED_Clear();</span><br><span class="line">OLED_DrawBMP(0,0,128,8,BMP1);//（1,2：左上角坐标，3,4：右下角坐标，图片字模）</span><br><span class="line">while(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main-h"><a href="#main-h" class="headerlink" title="main.h"></a>main.h</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MAIN_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MAIN_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> uchar;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义时间线和数据线</span></span><br><span class="line">sbit IIC_SCL = P1^<span class="number">5</span>;</span><br><span class="line">sbit IIC_SDA = P1^<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="oled-c"><a href="#oled-c" class="headerlink" title="oled.c"></a>oled.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oled.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oledfont.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iic.h&quot;</span></span></span><br><span class="line"><span class="comment">/**********************************************</span></span><br><span class="line"><span class="comment">// IIC Write Command命令</span></span><br><span class="line"><span class="comment">**********************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Write_IIC_Command</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> IIC_Command)</span></span><br><span class="line">&#123;</span><br><span class="line">   IIC_Start();</span><br><span class="line">   IIC_Write_Byte(<span class="number">0x78</span>);            <span class="comment">//Slave address,SA0=0</span></span><br><span class="line">   IIC_Write_Byte(<span class="number">0x00</span>);<span class="comment">//write command</span></span><br><span class="line">   IIC_Write_Byte(IIC_Command); </span><br><span class="line">   IIC_Stop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**********************************************</span></span><br><span class="line"><span class="comment">// IIC Write Data数据</span></span><br><span class="line"><span class="comment">**********************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Write_IIC_Data</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> IIC_Data)</span></span><br><span class="line">&#123;</span><br><span class="line">   IIC_Start();</span><br><span class="line">   IIC_Write_Byte(<span class="number">0x78</span>);<span class="comment">//D/C#=0; R/W#=0</span></span><br><span class="line">   IIC_Write_Byte(<span class="number">0x40</span>);<span class="comment">//write data</span></span><br><span class="line">   IIC_Write_Byte(IIC_Data);</span><br><span class="line">   IIC_Stop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_WR_Byte</span><span class="params">(<span class="type">unsigned</span> dat,<span class="type">unsigned</span> cmd)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(cmd)</span><br><span class="line">&#123;</span><br><span class="line">        Write_IIC_Data(dat);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Write_IIC_Command(dat);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************</span></span><br><span class="line"><span class="comment">// fill_Picture</span></span><br><span class="line"><span class="comment">********************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fill_picture</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> fill_Data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> m,n;</span><br><span class="line"><span class="keyword">for</span>(m=<span class="number">0</span>;m&lt;<span class="number">8</span>;m++)</span><br><span class="line">&#123;</span><br><span class="line">OLED_WR_Byte(<span class="number">0xb0</span>+m,<span class="number">0</span>);<span class="comment">//page0-page1</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0x00</span>,<span class="number">0</span>);<span class="comment">//low column start address</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0x10</span>,<span class="number">0</span>);<span class="comment">//high column start address</span></span><br><span class="line"><span class="keyword">for</span>(n=<span class="number">0</span>;n&lt;<span class="number">128</span>;n++)</span><br><span class="line">&#123;</span><br><span class="line">OLED_WR_Byte(fill_Data,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************Delay****************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_50ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> Del_50ms)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> m;</span><br><span class="line"><span class="keyword">for</span>(;Del_50ms&gt;<span class="number">0</span>;Del_50ms--)</span><br><span class="line"><span class="keyword">for</span>(m=<span class="number">6245</span>;m&gt;<span class="number">0</span>;m--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_1ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> Del_1ms)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> j;</span><br><span class="line"><span class="keyword">while</span>(Del_1ms--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">123</span>;j++);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//坐标设置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Set_Pos</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y)</span> </span><br><span class="line">&#123;</span><br><span class="line">    OLED_WR_Byte(<span class="number">0xb0</span>+y,OLED_CMD);</span><br><span class="line">OLED_WR_Byte(((x&amp;<span class="number">0xf0</span>)&gt;&gt;<span class="number">4</span>)|<span class="number">0x10</span>,OLED_CMD);</span><br><span class="line">OLED_WR_Byte((x&amp;<span class="number">0x0f</span>),OLED_CMD); </span><br><span class="line">&#125;     </span><br><span class="line"><span class="comment">//开启OLED显示    </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Display_On</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_WR_Byte(<span class="number">0X8D</span>,OLED_CMD);  <span class="comment">//SET DCDC命令</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0X14</span>,OLED_CMD);  <span class="comment">//DCDC ON</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0XAF</span>,OLED_CMD);  <span class="comment">//DISPLAY ON</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭OLED显示     </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Display_Off</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_WR_Byte(<span class="number">0X8D</span>,OLED_CMD);  <span class="comment">//SET DCDC命令</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0X10</span>,OLED_CMD);  <span class="comment">//DCDC OFF</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0XAE</span>,OLED_CMD);  <span class="comment">//DISPLAY OFF</span></span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">//清屏函数,清完屏,整个屏幕是黑色的!和没点亮一样!!!  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Clear</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">u8 i,n;    </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)  </span><br><span class="line">&#123;  </span><br><span class="line">OLED_WR_Byte (<span class="number">0xb0</span>+i,OLED_CMD);    <span class="comment">//设置页地址（0~7）</span></span><br><span class="line">OLED_WR_Byte (<span class="number">0x00</span>,OLED_CMD);      <span class="comment">//设置显示位置—列低地址</span></span><br><span class="line">OLED_WR_Byte (<span class="number">0x10</span>,OLED_CMD);      <span class="comment">//设置显示位置—列高地址   </span></span><br><span class="line"><span class="keyword">for</span>(n=<span class="number">0</span>;n&lt;<span class="number">128</span>;n++)OLED_WR_Byte(<span class="number">0</span>,OLED_DATA); </span><br><span class="line">&#125; <span class="comment">//更新显示</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_On</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">u8 i,n;    </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)  </span><br><span class="line">&#123;  </span><br><span class="line">OLED_WR_Byte (<span class="number">0xb0</span>+i,OLED_CMD);<span class="comment">//设置页地址（0~7）</span></span><br><span class="line">OLED_WR_Byte (<span class="number">0x00</span>,OLED_CMD);<span class="comment">//设置显示位置—列低地址</span></span><br><span class="line">OLED_WR_Byte (<span class="number">0x10</span>,OLED_CMD);<span class="comment">//设置显示位置—列高地址   </span></span><br><span class="line"><span class="keyword">for</span>(n=<span class="number">0</span>;n&lt;<span class="number">128</span>;n++)OLED_WR_Byte(<span class="number">1</span>,OLED_DATA); </span><br><span class="line">&#125; <span class="comment">//更新显示</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在指定位置显示一个字符,包括部分字符</span></span><br><span class="line"><span class="comment">//x:0~127</span></span><br><span class="line"><span class="comment">//y:0~63</span></span><br><span class="line"><span class="comment">//mode:0,反白显示;1,正常显示 </span></span><br><span class="line"><span class="comment">//size:选择字体 16/12 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowChar</span><span class="params">(u8 x,u8 y,u8 chr,u8 Char_Size)</span></span><br><span class="line">&#123;      </span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> c=<span class="number">0</span>,i=<span class="number">0</span>;</span><br><span class="line">    c=chr-<span class="string">&#x27; &#x27;</span>;<span class="comment">//得到偏移后的值</span></span><br><span class="line">    <span class="keyword">if</span>(x&gt;Max_Column<span class="number">-1</span>)&#123;x=<span class="number">0</span>;y=y+<span class="number">2</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(Char_Size ==<span class="number">16</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        OLED_Set_Pos(x,y);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">        OLED_WR_Byte(F8X16[c*<span class="number">16</span>+i],OLED_DATA);</span><br><span class="line">        OLED_Set_Pos(x,y+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">        OLED_WR_Byte(F8X16[c*<span class="number">16</span>+i+<span class="number">8</span>],OLED_DATA);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        OLED_Set_Pos(x,y);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">        OLED_WR_Byte(F6x8[c][i],OLED_DATA);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//m^n函数</span></span><br><span class="line">u32 <span class="title function_">oled_pow</span><span class="params">(u8 m,u8 n)</span></span><br><span class="line">&#123;</span><br><span class="line">u32 result=<span class="number">1</span>; </span><br><span class="line"><span class="keyword">while</span>(n--)result*=m;    </span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//显示2个数字</span></span><br><span class="line"><span class="comment">//x,y :起点坐标 </span></span><br><span class="line"><span class="comment">//len :数字的位数</span></span><br><span class="line"><span class="comment">//size:字体大小</span></span><br><span class="line"><span class="comment">//mode:模式0,填充模式;1,叠加模式</span></span><br><span class="line"><span class="comment">//num:数值(0~4294967295);   </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowNum</span><span class="params">(u8 x,u8 y,u32 num,u8 len,u8 size2)</span></span><br><span class="line">&#123;         </span><br><span class="line">u8 t,temp;</span><br><span class="line">u8 enshow=<span class="number">0</span>;   </span><br><span class="line"><span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;len;t++)</span><br><span class="line">&#123;</span><br><span class="line">temp=(num/oled_pow(<span class="number">10</span>,len-t<span class="number">-1</span>))%<span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(enshow==<span class="number">0</span>&amp;&amp;t&lt;(len<span class="number">-1</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(temp==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowChar(x+(size2/<span class="number">2</span>)*t,y,<span class="string">&#x27; &#x27;</span>,size2);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> enshow=<span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"> OLED_ShowChar(x+(size2/<span class="number">2</span>)*t,y,temp+<span class="string">&#x27;0&#x27;</span>,size2); </span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//显示一个字符号串</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowString</span><span class="params">(u8 x,u8 y,u8 *chr,u8 Char_Size)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (chr[j]!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">        OLED_ShowChar(x,y,chr[j],Char_Size);</span><br><span class="line">x+=<span class="number">8</span>;</span><br><span class="line"><span class="keyword">if</span>(x&gt;<span class="number">120</span>)&#123;x=<span class="number">0</span>;y+=<span class="number">2</span>;&#125;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//显示汉字</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowCHinese</span><span class="params">(u8 x,u8 y,u8 no)</span></span><br><span class="line">&#123;          </span><br><span class="line">u8 t,adder=<span class="number">0</span>;</span><br><span class="line">OLED_Set_Pos(x,y);</span><br><span class="line">    <span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;<span class="number">16</span>;t++)</span><br><span class="line">&#123;</span><br><span class="line">        OLED_WR_Byte(Hzk[<span class="number">2</span>*no][t],OLED_DATA);</span><br><span class="line">adder+=<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">OLED_Set_Pos(x,y+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;<span class="number">16</span>;t++)</span><br><span class="line">&#123;</span><br><span class="line">        OLED_WR_Byte(Hzk[<span class="number">2</span>*no+<span class="number">1</span>][t],OLED_DATA);</span><br><span class="line">        adder += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********功能描述：显示显示BMP图片128×64起始点坐标(x,y),x的范围0～127，y为页的范围0～7*****************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DrawBMP</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x0, <span class="type">unsigned</span> <span class="type">char</span> y0,<span class="type">unsigned</span> <span class="type">char</span> x1, <span class="type">unsigned</span> <span class="type">char</span> y1,<span class="type">unsigned</span> <span class="type">char</span> BMP[])</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> x,y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(y1%<span class="number">8</span>==<span class="number">0</span>) y=y1/<span class="number">8</span>;      </span><br><span class="line">    <span class="keyword">else</span> y=y1/<span class="number">8</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(y=y0;y&lt;y1;y++)</span><br><span class="line">    &#123;</span><br><span class="line">        OLED_Set_Pos(x0,y);</span><br><span class="line">    <span class="keyword">for</span>(x=x0;x&lt;x1;x++)</span><br><span class="line">        &#123;      </span><br><span class="line">            OLED_WR_Byte(BMP[j++],OLED_DATA);    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化SSD1306    </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; </span><br><span class="line"> </span><br><span class="line">OLED_WR_Byte(<span class="number">0xAE</span>,OLED_CMD);<span class="comment">//--display off</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0x00</span>,OLED_CMD);<span class="comment">//---set low column address</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0x10</span>,OLED_CMD);<span class="comment">//---set high column address</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0x40</span>,OLED_CMD);<span class="comment">//--set start line address  </span></span><br><span class="line">OLED_WR_Byte(<span class="number">0xB0</span>,OLED_CMD);<span class="comment">//--set page address</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0x81</span>,OLED_CMD); <span class="comment">// contract control</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0xFF</span>,OLED_CMD);<span class="comment">//--128   </span></span><br><span class="line">OLED_WR_Byte(<span class="number">0xA1</span>,OLED_CMD);<span class="comment">//set segment remap </span></span><br><span class="line">OLED_WR_Byte(<span class="number">0xA6</span>,OLED_CMD);<span class="comment">//--normal / reverse</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0xA8</span>,OLED_CMD);<span class="comment">//--set multiplex ratio(1 to 64)</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0x3F</span>,OLED_CMD);<span class="comment">//--1/32 duty</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0xC8</span>,OLED_CMD);<span class="comment">//Com scan direction</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0xD3</span>,OLED_CMD);<span class="comment">//-set display offset</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0x00</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">OLED_WR_Byte(<span class="number">0xD5</span>,OLED_CMD);<span class="comment">//set osc division</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0x80</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">OLED_WR_Byte(<span class="number">0xD8</span>,OLED_CMD);<span class="comment">//set area color mode off</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0x05</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">OLED_WR_Byte(<span class="number">0xD9</span>,OLED_CMD);<span class="comment">//Set Pre-Charge Period</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0xF1</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">OLED_WR_Byte(<span class="number">0xDA</span>,OLED_CMD);<span class="comment">//set com pin configuartion</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0x12</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">OLED_WR_Byte(<span class="number">0xDB</span>,OLED_CMD);<span class="comment">//set Vcomh</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0x30</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">OLED_WR_Byte(<span class="number">0x8D</span>,OLED_CMD);<span class="comment">//set charge pump enable</span></span><br><span class="line">OLED_WR_Byte(<span class="number">0x14</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">OLED_WR_Byte(<span class="number">0xAF</span>,OLED_CMD);<span class="comment">//--turn on oled panel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="oled-h"><a href="#oled-h" class="headerlink" title="oled.h"></a>oled.h</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __OLED_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __OLED_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  u8 unsigned char </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  u32 unsigned int </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_CMD  0<span class="comment">//写命令</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_DATA 1<span class="comment">//写数据</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_MODE 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//OLED模式设置</span></span><br><span class="line"><span class="comment">//0:4线串行模式</span></span><br><span class="line"><span class="comment">//1:并行8080模式</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XLevelL0x02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XLevelH0x10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Max_Column128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Max_Row64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>Brightness0xFF </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X_WIDTH 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Y_WIDTH 64      </span></span><br><span class="line"><span class="comment">//-----------------OLED端口定义----------------     </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//OLED控制用函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_WR_Byte</span><span class="params">(<span class="type">unsigned</span> dat,<span class="type">unsigned</span> cmd)</span>;  </span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Display_On</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Display_Off</span><span class="params">(<span class="type">void</span>)</span>;          </span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Clear</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DrawPoint</span><span class="params">(u8 x,u8 y,u8 t)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Fill</span><span class="params">(u8 x1,u8 y1,u8 x2,u8 y2,u8 dot)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowChar</span><span class="params">(u8 x,u8 y,u8 chr,u8 Char_Size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowNum</span><span class="params">(u8 x,u8 y,u32 num,u8 len,u8 size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowString</span><span class="params">(u8 x,u8 y, u8 *p,u8 Char_Size)</span>; </span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Set_Pos</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowCHinese</span><span class="params">(u8 x,u8 y,u8 no)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DrawBMP</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x0, <span class="type">unsigned</span> <span class="type">char</span> y0,<span class="type">unsigned</span> <span class="type">char</span> x1, <span class="type">unsigned</span> <span class="type">char</span> y1,<span class="type">unsigned</span> <span class="type">char</span> BMP[])</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_50ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> Del_50ms)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_1ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> Del_1ms)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fill_picture</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> fill_Data)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Picture</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Write_IIC_Command</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> IIC_Command)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Write_IIC_Data</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> IIC_Data)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>oledfont.h、bmp.h为字符字模、图片字模</p><h2 id="delay-c"><a href="#delay-c" class="headerlink" title="delay.c"></a>delay.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay5us</span><span class="params">()</span><span class="comment">//@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="delay-h"><a href="#delay-h" class="headerlink" title="delay.h"></a>delay.h</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DELAY_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DELAY_H__</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay5us</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;IIC理论&quot;&gt;&lt;a href=&quot;#IIC理论&quot; class=&quot;headerlink&quot; title=&quot;IIC理论&quot;&gt;&lt;/a&gt;&lt;center&gt;IIC理论&lt;/center&gt;&lt;/h1&gt;&lt;h2 id=&quot;实现方式&quot;&gt;&lt;a href=&quot;#实现方式&quot; class=&quot;headerl</summary>
      
    
    
    
    <category term="51单片机" scheme="http://example.com/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="51单片机" scheme="http://example.com/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>串口</title>
    <link href="http://example.com/post/f736596e.html"/>
    <id>http://example.com/post/f736596e.html</id>
    <published>2024-04-12T02:13:58.000Z</published>
    <updated>2024-07-06T14:47:51.937Z</updated>
    
    <content type="html"><![CDATA[<h1 id="串口的介绍"><a href="#串口的介绍" class="headerlink" title="串口的介绍"></a><center>串口的介绍</center></h1><p>UART（通用异步收发器）是一种双向、串行、异步的通信总线，仅用一根数据接收线（RX）和一根数据发送线（TX）就能实现全双工通信</p><p>R：Receiver(接收)，T：Transmit(发送)</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202406111508432.png" alt="数据组成" style="zoom: 33%;"><p>UART 在发送或接收过程中的一帧数据由4部分组成，起始位、数据位、奇偶校验位和停止位</p><p>如图所示。其中，起始位标志着一帧数据的开始，停止位标志着一帧数据的结束，数据位是一帧数据中的有效数据，校验位分为奇校验和偶校验，用于检验数据在传输过程中是否出错。（奇校验时，发送方应使数据位中1的个数与校验位中1的个数之和为奇数；接收方在接收数据时， 对1的个数进行检查，若不为奇数，则说明数据在传输过程中出了差错。同样，偶校验则检查1的个数是否为偶数）</p><p> UART通信过程中的数据格式及传输速率是可设置的，为了正确的通信，收发双方应约定并遵循同样的设置。数据位可选择为5、6、7、8位，其中8位数据位是最常用的，在实际应用中一般都选择8位数据位；校验位可选择奇校验、偶校验或者无校验位；停止位可选择1位（默认）， 1.5或2位</p><p>串口通信的速率用波特率表示，它表示每秒传输二进制数据的位数，单位是bps（位 &#x2F;秒），常用的波特率有9600、19200、38400、57600以及115200等</p><p>如波特率9600则代表每秒传输9600bit数据，以串口发送1个字节10bit算（起始位1bit+数据8bit+停止位1bit+NO校验位），则传输1个字节需要的时间是1*10&#x2F;9600秒</p><p>USART：通用同步&#x2F;异步串行接收&#x2F;发送器</p><h2 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a><center>TTL</center></h2><p>一般单片机产生的都是TTL电平。无论是51、32、还是各种跑Linux的ARM芯片，TTL满足绝大多数调试需求</p><p>TTL串口采用的是单一的信号线 (TX线和RX线) 进行数据传输，其中TX线用于单片机发送数据，RX线用于单片机接收数据。数据传输速率通常可以达到几-kbps至上百kbps的速率，<font color="red">传输距离较短，一般不超过数十米</font></p><p>TTL转USB</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202406111546131.png" alt="例图" style="zoom:50%;"><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202406111545487.png" alt="传输方向" style="zoom:50%;"><p>TTL的逻辑电平通常是0V和5V，其中0V表示逻辑“0”，5V表示逻辑“1”</p><h2 id="RS-232"><a href="#RS-232" class="headerlink" title="RS-232"></a><center>RS-232</center></h2><p>RS-232转USB</p><p>规定逻辑“1”的电平为-5V~-15 V，逻辑“0”的电平为+5 V～+15 V</p><p>由于RS -232采用串行传送方式，并且将TTL电平(某芯片)转换为RS-232C电平，其传送距离一般可达30 m。若采用光电隔离20 mA的电流环进行传送，其传送距离可以达到1000 m</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202406111708423.png" alt="公母头接法" style="zoom: 67%;"><h2 id="RS-485"><a href="#RS-485" class="headerlink" title="RS-485"></a><center>RS-485</center></h2><p>传输速度可以达到10Mb&#x2F;s以上，传输距离可以达到3000米左右</p><p>传输方式为：差分方式</p><h1 id="分类方式"><a href="#分类方式" class="headerlink" title="分类方式"></a><center>分类方式</center></h1><h2 id="串口并口"><a href="#串口并口" class="headerlink" title="串口并口"></a><center>串口并口</center></h2><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202406111729362.png" alt="图解" style="zoom:33%;"><h2 id="同步异步"><a href="#同步异步" class="headerlink" title="同步异步"></a><center>同步异步</center></h2><p>异步：通信双方各自约定通信速率</p><p>UART：TX、RX</p><p>1 Wire</p><p>同步：通信双方靠一根时钟线来约定通信速率</p><p>IIC：SDA、SCL</p><p>SPI：MOSI、MISO、SCK、CS</p><p>单工：指消息只能单方向传输的工作方式</p><p>半双工：指信息即可从A到B，也可以从B到A，任一时刻只能有一个方向上的传输存在</p><p>全双工：指在任意时刻线路上存在A到B和B到A的双向信号传输</p><h1 id="相关寄存器"><a href="#相关寄存器" class="headerlink" title="相关寄存器"></a><center>相关寄存器</center></h1><h2 id="SCON"><a href="#SCON" class="headerlink" title="SCON"></a><center>SCON</center></h2><p>工作模式：01（8位UART波特率可变）其他不用为0</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202406131001458.png" alt="SCON详细1" style="zoom: 67%;"><p>REN &#x3D; 1，接收信息，一开始发送中断标志位、接收中断标志位置0</p><p>TB8：发送校验位，RB8：接收校验位，TI：发送中断，RI：接收中断</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202406131001199.png" alt="SCON详细2" style="zoom: 67%;"><p>则SCON &#x3D; 0x50</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202406131002775.png" alt="SCON详细3" style="zoom: 67%;"><h2 id="PCON"><a href="#PCON" class="headerlink" title="PCON"></a><center>PCON</center></h2><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202406131029450.png" alt="PCON解释图" style="zoom:67%;"><h2 id="TMOD"><a href="#TMOD" class="headerlink" title="TMOD"></a><center>TMOD</center></h2><p>模式(M1、M0)：这里选10（8位自动重装载定时器），其他在定时器有讲解</p><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202404131536016.png" alt="TMOD解释图"></p><h2 id="SBUF"><a href="#SBUF" class="headerlink" title="SBUF"></a><center>SBUF</center></h2><p>接收和发送的数据都存在SBUF</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202406131633290.png" alt="SBUF图解" style="zoom: 67%;"><h2 id="IE"><a href="#IE" class="headerlink" title="IE"></a><center>IE</center></h2><p>中断允许寄存器</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202404121351544.png" alt="允许寄存器分析" style="zoom:67%;"><h1 id="中断处理函数"><a href="#中断处理函数" class="headerlink" title="中断处理函数"></a><center>中断处理函数</center></h1><table><thead><tr><th>中断源</th><th>中断处理函数</th></tr></thead><tbody><tr><td>UART</td><td>UART_Routine(void)         interrupt 4</td></tr></tbody></table><h1 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a><center>代码编写</center></h1><p>为何需要使用定时器观看链接讲解(9.34)：<a href="https://www.bilibili.com/video/BV1Bg4y1M7vi/?spm_id_from=333.788&vd_source=1c838941386ee32c4501615c317f75e0">波特率发生器</a></p><h2 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span><span class="comment">//声明头文件，可在此文件使用头文件声明的函数、变量等</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Uart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">uchar recv;<span class="comment">//全局变量用于接收数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">UART_Init();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Delay1000ms();</span><br><span class="line">UART_send_str(<span class="string">&quot;i am xingzai&quot;</span>);<span class="comment">//发送字符</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//串口中断处理函数</span></span><br><span class="line">UART_Routine(<span class="type">void</span>)         interrupt <span class="number">4</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span> == RI)</span><br><span class="line">&#123;</span><br><span class="line">RI = <span class="number">0</span>;<span class="comment">//接收中断请求标志位软件复位</span></span><br><span class="line">recv = SBUF;<span class="comment">//接收数据赋值给变量</span></span><br><span class="line"><span class="keyword">switch</span>(recv)</span><br><span class="line">&#123;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">0x1</span>: LED1 = <span class="number">0</span>;<span class="keyword">break</span>;   </span><br><span class="line">           <span class="keyword">case</span> <span class="number">0x2</span>: LED2 = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">0x3</span>: LED3 = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">0x4</span>: LED4 = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">0x5</span>: P1  |= <span class="number">0x0F</span>;<span class="keyword">break</span>;<span class="comment">//这里采用或等于，目的不让P1.6蜂鸣器为0，保留高位原数据</span></span><br><span class="line">           <span class="keyword">case</span> <span class="number">0x6</span>: BEEP = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">0x7</span>: BEEP = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">0x8</span>: JDQ1 = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">0x9</span>: JDQ1 = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="delay-c"><a href="#delay-c" class="headerlink" title="delay.c"></a>delay.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span><span class="comment">//声明对应头文件，用于声明里面此文件函数、变量等</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrins.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="comment">//延时函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay1000ms</span><span class="params">()</span><span class="comment">//@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line">uchar data i, j, k;</span><br><span class="line"></span><br><span class="line">_nop_();</span><br><span class="line">i = <span class="number">8</span>;</span><br><span class="line">j = <span class="number">1</span>;</span><br><span class="line">k = <span class="number">243</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (--k);</span><br><span class="line">&#125; <span class="keyword">while</span> (--j);</span><br><span class="line">&#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="delay-h"><a href="#delay-h" class="headerlink" title="delay.h"></a>delay.h</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件固定格式，防止头文件重复包含</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DELAY_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DELAY_H__</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay1000ms</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="Uart-c"><a href="#Uart-c" class="headerlink" title="Uart.c"></a>Uart.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Uart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//配置相关寄存器</span></span><br><span class="line">SCON = <span class="number">0x50</span>;<span class="comment">//配置串口寄存器</span></span><br><span class="line">PCON=<span class="number">0x00</span>;</span><br><span class="line">TMOD |= <span class="number">0x20</span>;<span class="comment">//配置时间寄存器定时器1</span></span><br><span class="line"><span class="comment">//定时器初值</span></span><br><span class="line">TH1 = <span class="number">0xFD</span>;</span><br><span class="line">TL1 = <span class="number">0xFD</span>;</span><br><span class="line">EA = <span class="number">1</span>;<span class="comment">//打开中断总允许位</span></span><br><span class="line">ES = <span class="number">1</span>;<span class="comment">//打开串口中断允许位</span></span><br><span class="line">TR1 = <span class="number">1</span>;<span class="comment">//打开定时器1运行控制位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符发送函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_send_char</span><span class="params">(uchar send_char)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//将字符赋值给数据缓存寄存器</span></span><br><span class="line">SBUF = send_char;</span><br><span class="line"><span class="keyword">while</span>(!TI);<span class="comment">//发送时为0，发送完触发发送中断时为1，为1时则数据发送完</span></span><br><span class="line">TI = <span class="number">0</span>;<span class="comment">//发送中断请求标志位软件复位</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接收传过来的字符串</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_send_str</span><span class="params">(uchar *send_str)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//判断字符到最后&#x27;\0&#x27;则停止发送</span></span><br><span class="line"><span class="keyword">while</span>(*send_str != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">UART_send_char(*send_str++);<span class="comment">//将字符逐个传给这个函数发送</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Uart-h"><a href="#Uart-h" class="headerlink" title="Uart.h"></a>Uart.h</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __UART_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __UART_H__</span></span><br><span class="line"><span class="comment">//因为main.c中已经声明了Uart.h，在Uart.h声明了main.h则main.c中也可以使用mian.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_Init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_send_char</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> send_char)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_send_str</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *send_str)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="main-h"><a href="#main-h" class="headerlink" title="main.h"></a>main.h</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MAIN_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MAIN_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> uchar;<span class="comment">//给unsigned char取别名uchar</span></span><br><span class="line"></span><br><span class="line">sbit LED1 = P1^<span class="number">0</span>;</span><br><span class="line">sbit LED2 = P1^<span class="number">1</span>;</span><br><span class="line">sbit LED3 = P1^<span class="number">2</span>;</span><br><span class="line">sbit LED4 = P1^<span class="number">3</span>;</span><br><span class="line">sbit BEEP = P1^<span class="number">6</span>;</span><br><span class="line">sbit JDQ1 = P1^<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="回环"><a href="#回环" class="headerlink" title="回环"></a>回环</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrins.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> recv;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> send_buf[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">sbit LED1 = P1^<span class="number">0</span>;</span><br><span class="line">sbit LED2 = P1^<span class="number">1</span>;</span><br><span class="line">sbit LED3 = P1^<span class="number">2</span>;</span><br><span class="line">sbit LED4 = P1^<span class="number">3</span>;</span><br><span class="line">sbit BEEP = P1^<span class="number">6</span>;</span><br><span class="line">sbit JDQ1 = P1^<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay1000ms</span><span class="params">()</span>    <span class="comment">//@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> data i, j, k;</span><br><span class="line"> </span><br><span class="line">  _nop_();</span><br><span class="line">  i = <span class="number">8</span>;</span><br><span class="line">  j = <span class="number">1</span>;</span><br><span class="line">  k = <span class="number">243</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">     <span class="keyword">do</span></span><br><span class="line">     &#123;</span><br><span class="line">       <span class="keyword">while</span> (--k);</span><br><span class="line">     &#125; <span class="keyword">while</span> (--j);</span><br><span class="line">  &#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_send_byte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> send_byte)</span></span><br><span class="line">&#123;</span><br><span class="line">SBUF = send_byte;</span><br><span class="line"><span class="keyword">while</span>(!TI);</span><br><span class="line">TI=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_send_str</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *send_str)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(*send_str != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">UART_send_byte(*send_str++);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">SCON = <span class="number">0x50</span>;</span><br><span class="line">PCON=<span class="number">0x00</span>;</span><br><span class="line">TMOD |= <span class="number">0x20</span>;</span><br><span class="line">TH1 = <span class="number">0xFD</span>;</span><br><span class="line">TL1 = <span class="number">0xFD</span>;</span><br><span class="line">EA = <span class="number">1</span>;</span><br><span class="line">ES = <span class="number">1</span>;</span><br><span class="line">TR1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">Delay1000ms();</span><br><span class="line"><span class="comment">//UART_send_str(&quot;i am wfeng!\r\n&quot;);</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UART_Routine(<span class="type">void</span>)    interrupt <span class="number">4</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span> == RI) <span class="comment">//if(RI)</span></span><br><span class="line">&#123;</span><br><span class="line">RI=<span class="number">0</span>;</span><br><span class="line">recv = SBUF;</span><br><span class="line">SBUF = recv;</span><br><span class="line"><span class="keyword">while</span>(!TI);</span><br><span class="line">TI=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="继电器"><a href="#继电器" class="headerlink" title="继电器"></a><center>继电器</center></h1><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202406191552254.gif" alt="继电器动态原理图"></p><p>继电器模块的基本工作原理：</p><p>电磁线圈： 继电器内部包含一个电磁线圈，通常由绕制在绝缘芯片上的细导线组成。当通过线圈通电时，产生电磁场。</p><p>磁性吸引： 电磁场会使继电器中的铁芯（或磁性材料）受到磁性吸引，导致铁芯在电磁力的作用下移动。</p><p>触点操作： 铁芯的移动会导致机械部分的运动，最终使触点（开关）发生动作。继电器通常有常开（Normally Open，NO）和常闭（Normally Closed，NC）两组触点。</p><p>常开触点： 在继电器未通电时处于闭合状态，当电磁线圈通电时，触点打开。</p><p>常闭触点： 在继电器未通电时处于打开状态，当电磁线圈通电时，触点闭合。</p><p>电气隔离： 继电器的主要作用之一是提供电气隔离。通过电磁原理，可以在控制信号与被控制电路之间提供隔离，从而使得不同电路之间的电流不会相互影响。继电器模块常用于控制高电流或高电压的电路。</p><h1 id="ESP8266"><a href="#ESP8266" class="headerlink" title="ESP8266"></a><center>ESP8266</center></h1><p>AP模式：无线接入点，它是一个无线网络的中心节点，可以看成是一个服务器。它作为一个网络的中心节点，提供无线接入服务，其他的无线设备允许接入该节点，所有接入该节点设备的无线信号数据都要通过它才能进行交换和互相访问。一般的无线路由器、网关、热点就是工作在AP模式下，AP节点和AP节点之间允许相互连接。</p><p>STA模式：无线网络中的一个终端站点设备，可以看成是一个客户端，一般来说，处在STA模式下的设备本身不接受无线的接入，该设备连接到AP节点进行网络访问，STA模式下的设备之间的通信可以通过AP进行转发实现</p><h2 id="AT指令"><a href="#AT指令" class="headerlink" title="AT指令"></a><center>AT指令</center></h2><p>可在官网寻找对应的指令集：<a href="https://docs.ai-thinker.com/esp8266/docs">安信可科技</a></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">配置 WiFi 模式：AT+CWMODE=3//STA+AP</span><br><span class="line">连接路由器：AT+CWJAP=&quot;wfeng&quot;,&quot;wf05430543&quot;</span><br><span class="line">查询 ESP8266的IP 地址： AT+CIFSR</span><br><span class="line">//PC端使用网络调试工具，建⽴一个 TCP 服务器器</span><br><span class="line">ESP8266 作为Client 连接到服务器：AT+CIPSTART=&quot;TCP&quot;,&quot;192.168.31.118&quot;,8090</span><br><span class="line">发送数据：AT+CIPSEND=4</span><br></pre></td></tr></table></figure><h2 id="代码编写-1"><a href="#代码编写-1" class="headerlink" title="代码编写"></a><center>代码编写</center></h2><p>电脑当服务端，单片机当客户端，电脑发指令控制单片机(接收)，单片机发送字符给电脑</p><h3 id="main-c-1"><a href="#main-c-1" class="headerlink" title="main.c"></a>main.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span><span class="comment">//声明头文件，可在此文件使用头文件声明的函数、变量等</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Uart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">uchar recv;<span class="comment">//全局变量用于接收数据</span></span><br><span class="line">uchar ESP [<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> ESP_Ok_flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">UART_Init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">UART_send_str(<span class="string">&quot;AT+CWMODE=3\r\n&quot;</span>);</span><br><span class="line">Delay1000ms();</span><br><span class="line">&#125;<span class="keyword">while</span>(ESP_Ok_flag);</span><br><span class="line"></span><br><span class="line">ESP_Ok_flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">UART_send_str(<span class="string">&quot;AT+CWJAP=\&quot;qji\&quot;,\&quot;13145200\&quot;\r\n&quot;</span>);</span><br><span class="line">Delay1000ms();</span><br><span class="line">&#125;<span class="keyword">while</span>(ESP_Ok_flag);</span><br><span class="line"></span><br><span class="line">ESP_Ok_flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">UART_send_str(<span class="string">&quot;AT+CIPSTART=\&quot;TCP\&quot;,\&quot;192.168.43.10\&quot;,8085\r\n&quot;</span>);</span><br><span class="line">Delay1000ms();</span><br><span class="line">&#125;<span class="keyword">while</span>(ESP_Ok_flag);</span><br><span class="line"></span><br><span class="line">ESP_Ok_flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">UART_send_str(<span class="string">&quot;AT+CIPSEND=4\r\n&quot;</span>);</span><br><span class="line">Delay1000ms();</span><br><span class="line">&#125;<span class="keyword">while</span>(ESP_Ok_flag);</span><br><span class="line"></span><br><span class="line">ESP_Ok_flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">UART_send_str(<span class="string">&quot;xinz&quot;</span>);</span><br><span class="line">Delay1000ms();</span><br><span class="line">&#125;<span class="keyword">while</span>(ESP_Ok_flag);</span><br><span class="line"></span><br><span class="line">ESP_Ok_flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Delay1000ms();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//串口中断处理函数</span></span><br><span class="line">UART_Routine(<span class="type">void</span>)         interrupt <span class="number">4</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span> == RI)</span><br><span class="line">&#123;</span><br><span class="line">RI = <span class="number">0</span>;<span class="comment">//接收中断请求标志位软件复位</span></span><br><span class="line">recv = SBUF;<span class="comment">//接收数据赋值给变量</span></span><br><span class="line"><span class="keyword">if</span>(recv == <span class="string">&#x27;O&#x27;</span> || recv == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line">ESP[i] = recv;</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">ESP[i] = recv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ESP[<span class="number">0</span>] == <span class="string">&#x27;O&#x27;</span> &amp;&amp; ESP[<span class="number">1</span>] == <span class="string">&#x27;K&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">ESP_Ok_flag = <span class="number">0</span>;</span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ESP[<span class="number">0</span>] == <span class="string">&#x27;+&#x27;</span> &amp;&amp; ESP[<span class="number">1</span>] == <span class="string">&#x27;I&#x27;</span> &amp;&amp; ESP[<span class="number">2</span>] == <span class="string">&#x27;P&#x27;</span> &amp;&amp; ESP[<span class="number">3</span>] == <span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(ESP[<span class="number">7</span>] == <span class="string">&#x27;L&#x27;</span> &amp;&amp; ESP[<span class="number">8</span>] == <span class="string">&#x27;E&#x27;</span> &amp;&amp; ESP[<span class="number">9</span>] == <span class="string">&#x27;D&#x27;</span> &amp;&amp; ESP[<span class="number">10</span>] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; ESP[<span class="number">11</span>] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">LED1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(ESP[<span class="number">7</span>] == <span class="string">&#x27;L&#x27;</span> &amp;&amp; ESP[<span class="number">8</span>] == <span class="string">&#x27;E&#x27;</span> &amp;&amp; ESP[<span class="number">9</span>] == <span class="string">&#x27;D&#x27;</span> &amp;&amp; ESP[<span class="number">10</span>] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; ESP[<span class="number">11</span>] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">LED1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(ESP[<span class="number">7</span>] == <span class="string">&#x27;L&#x27;</span> &amp;&amp; ESP[<span class="number">8</span>] == <span class="string">&#x27;E&#x27;</span> &amp;&amp; ESP[<span class="number">9</span>] == <span class="string">&#x27;D&#x27;</span> &amp;&amp; ESP[<span class="number">10</span>] == <span class="string">&#x27;2&#x27;</span> &amp;&amp; ESP[<span class="number">11</span>] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">LED2 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(ESP[<span class="number">7</span>] == <span class="string">&#x27;L&#x27;</span> &amp;&amp; ESP[<span class="number">8</span>] == <span class="string">&#x27;E&#x27;</span> &amp;&amp; ESP[<span class="number">9</span>] == <span class="string">&#x27;D&#x27;</span> &amp;&amp; ESP[<span class="number">10</span>] == <span class="string">&#x27;2&#x27;</span> &amp;&amp; ESP[<span class="number">11</span>] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">LED2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(ESP[<span class="number">7</span>] == <span class="string">&#x27;L&#x27;</span> &amp;&amp; ESP[<span class="number">8</span>] == <span class="string">&#x27;E&#x27;</span> &amp;&amp; ESP[<span class="number">9</span>] == <span class="string">&#x27;D&#x27;</span> &amp;&amp; ESP[<span class="number">10</span>] == <span class="string">&#x27;3&#x27;</span> &amp;&amp; ESP[<span class="number">11</span>] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">LED3 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(ESP[<span class="number">7</span>] == <span class="string">&#x27;L&#x27;</span> &amp;&amp; ESP[<span class="number">8</span>] == <span class="string">&#x27;E&#x27;</span> &amp;&amp; ESP[<span class="number">9</span>] == <span class="string">&#x27;D&#x27;</span> &amp;&amp; ESP[<span class="number">10</span>] == <span class="string">&#x27;3&#x27;</span> &amp;&amp; ESP[<span class="number">11</span>] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">LED3 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(ESP[<span class="number">7</span>] == <span class="string">&#x27;L&#x27;</span> &amp;&amp; ESP[<span class="number">8</span>] == <span class="string">&#x27;E&#x27;</span> &amp;&amp; ESP[<span class="number">9</span>] == <span class="string">&#x27;D&#x27;</span> &amp;&amp; ESP[<span class="number">10</span>] == <span class="string">&#x27;4&#x27;</span> &amp;&amp; ESP[<span class="number">11</span>] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">LED4 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(ESP[<span class="number">7</span>] == <span class="string">&#x27;L&#x27;</span> &amp;&amp; ESP[<span class="number">8</span>] == <span class="string">&#x27;E&#x27;</span> &amp;&amp; ESP[<span class="number">9</span>] == <span class="string">&#x27;D&#x27;</span> &amp;&amp; ESP[<span class="number">10</span>] == <span class="string">&#x27;4&#x27;</span> &amp;&amp; ESP[<span class="number">11</span>] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">LED4 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(ESP[<span class="number">7</span>] == <span class="string">&#x27;B&#x27;</span> &amp;&amp; ESP[<span class="number">8</span>] == <span class="string">&#x27;E&#x27;</span> &amp;&amp; ESP[<span class="number">9</span>] == <span class="string">&#x27;E&#x27;</span> &amp;&amp; ESP[<span class="number">10</span>] == <span class="string">&#x27;P&#x27;</span> &amp;&amp; ESP[<span class="number">11</span>] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">BEEP = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(ESP[<span class="number">7</span>] == <span class="string">&#x27;B&#x27;</span> &amp;&amp; ESP[<span class="number">8</span>] == <span class="string">&#x27;E&#x27;</span> &amp;&amp; ESP[<span class="number">9</span>] == <span class="string">&#x27;E&#x27;</span> &amp;&amp; ESP[<span class="number">10</span>] == <span class="string">&#x27;P&#x27;</span> &amp;&amp; ESP[<span class="number">11</span>] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">BEEP = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(ESP[<span class="number">7</span>] == <span class="string">&#x27;J&#x27;</span> &amp;&amp; ESP[<span class="number">8</span>] == <span class="string">&#x27;D&#x27;</span> &amp;&amp; ESP[<span class="number">9</span>] == <span class="string">&#x27;Q&#x27;</span> &amp;&amp; ESP[<span class="number">10</span>] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; ESP[<span class="number">11</span>] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">JDQ1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(ESP[<span class="number">7</span>] == <span class="string">&#x27;J&#x27;</span> &amp;&amp; ESP[<span class="number">8</span>] == <span class="string">&#x27;D&#x27;</span> &amp;&amp; ESP[<span class="number">9</span>] == <span class="string">&#x27;Q&#x27;</span> &amp;&amp; ESP[<span class="number">10</span>] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; ESP[<span class="number">11</span>] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">JDQ1 = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i&gt;<span class="number">18</span>)</span><br><span class="line">i=<span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="delay-c-1"><a href="#delay-c-1" class="headerlink" title="delay.c"></a>delay.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span><span class="comment">//声明对应头文件，用于声明里面此文件函数、变量等</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrins.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="comment">//延时函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay1000ms</span><span class="params">()</span><span class="comment">//@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line">uchar data i, j, k;</span><br><span class="line"></span><br><span class="line">_nop_();</span><br><span class="line">i = <span class="number">8</span>;</span><br><span class="line">j = <span class="number">1</span>;</span><br><span class="line">k = <span class="number">243</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (--k);</span><br><span class="line">&#125; <span class="keyword">while</span> (--j);</span><br><span class="line">&#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="delay-h-1"><a href="#delay-h-1" class="headerlink" title="delay.h"></a>delay.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件固定格式，防止头文件重复包含</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DELAY_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DELAY_H__</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay1000ms</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="Uart-c-1"><a href="#Uart-c-1" class="headerlink" title="Uart.c"></a>Uart.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Uart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//配置相关寄存器</span></span><br><span class="line">SCON = <span class="number">0x50</span>;<span class="comment">//配置串口寄存器</span></span><br><span class="line">PCON=<span class="number">0x00</span>;</span><br><span class="line">TMOD |= <span class="number">0x20</span>;<span class="comment">//配置时间寄存器定时器1</span></span><br><span class="line"><span class="comment">//定时器初值</span></span><br><span class="line">TH1 = <span class="number">0xFD</span>;</span><br><span class="line">TL1 = <span class="number">0xFD</span>;</span><br><span class="line">EA = <span class="number">1</span>;<span class="comment">//打开中断总允许位</span></span><br><span class="line">ES = <span class="number">1</span>;<span class="comment">//打开串口中断允许位</span></span><br><span class="line">TR1 = <span class="number">1</span>;<span class="comment">//打开定时器1运行控制位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符发送函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_send_char</span><span class="params">(uchar send_char)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//将字符赋值给数据缓存寄存器</span></span><br><span class="line">SBUF = send_char;</span><br><span class="line"><span class="keyword">while</span>(!TI);<span class="comment">//发送时为0，发送完触发发送中断时为1，为1时则数据发送完</span></span><br><span class="line">TI = <span class="number">0</span>;<span class="comment">//发送中断请求标志位软件复位</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接收传过来的字符</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_send_str</span><span class="params">(uchar *send_str)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//判断字符到最后&#x27;\0&#x27;则停止发送</span></span><br><span class="line"><span class="keyword">while</span>(*send_str != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">UART_send_char(*send_str++);<span class="comment">//将字符逐个传给这个函数发送</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Uart-h-1"><a href="#Uart-h-1" class="headerlink" title="Uart.h"></a>Uart.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __UART_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __UART_H__</span></span><br><span class="line"><span class="comment">//因为main.c中已经声明了Uart.h，在Uart.h声明了main.h则main.c中也可以使用mian.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_Init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_send_char</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> send_char)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_send_str</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *send_str)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="main-h-1"><a href="#main-h-1" class="headerlink" title="main.h"></a>main.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MAIN_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MAIN_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> uchar;<span class="comment">//给unsigned char取别名uchar</span></span><br><span class="line"></span><br><span class="line">sbit LED1 = P1^<span class="number">0</span>;</span><br><span class="line">sbit LED2 = P1^<span class="number">1</span>;</span><br><span class="line">sbit LED3 = P1^<span class="number">2</span>;</span><br><span class="line">sbit LED4 = P1^<span class="number">3</span>;</span><br><span class="line">sbit BEEP = P1^<span class="number">6</span>;</span><br><span class="line">sbit JDQ1 = P1^<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;串口的介绍&quot;&gt;&lt;a href=&quot;#串口的介绍&quot; class=&quot;headerlink&quot; title=&quot;串口的介绍&quot;&gt;&lt;/a&gt;&lt;center&gt;串口的介绍&lt;/center&gt;&lt;/h1&gt;&lt;p&gt;UART（通用异步收发器）是一种双向、串行、异步的通信总线，仅用一根数据接收线（R</summary>
      
    
    
    
    <category term="51单片机" scheme="http://example.com/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="51单片机" scheme="http://example.com/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>定时器/计数器</title>
    <link href="http://example.com/post/2e5216dd.html"/>
    <id>http://example.com/post/2e5216dd.html</id>
    <published>2024-04-12T02:13:46.000Z</published>
    <updated>2024-07-05T07:56:42.774Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a><center>原理</center></h1><ol><li>时钟源：定时器是内部时钟源（晶振），计数器是外部</li><li>计时长度：对应TH  TL计数器初值寄存器(高八位,低八位)</li><li>对应的中断触发函数</li></ol><table><thead><tr><th>中断源</th><th>中断处理函数</th></tr></thead><tbody><tr><td>Timer0</td><td>Timer0_Routine(void)      interrupt 1</td></tr><tr><td>Timer1</td><td>Timer1_Routine(void)       interrupt 3</td></tr><tr><td>Timer2</td><td>Timer2_Routine(void)      interrupt 5</td></tr></tbody></table><h1 id="相关寄存器"><a href="#相关寄存器" class="headerlink" title="相关寄存器"></a><center>相关寄存器</center></h1><h2 id="TCON：定时器控制寄存器"><a href="#TCON：定时器控制寄存器" class="headerlink" title="TCON：定时器控制寄存器"></a><center>TCON：定时器控制寄存器</center></h2><p>只需用到：TF0、TF1、TR0、TR1</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202404131443931.png" alt="定时器/计数器" style="zoom: 50%;"><p>定时器&#x2F;计数器运行控制位(代码)：TR0、TR1</p><p>中断触发标志位(内部)：TF0、TF1</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202404121532268.png" alt="定时器中断分析" style="zoom: 50%;"><h2 id="TMOD：定时器模式寄存器"><a href="#TMOD：定时器模式寄存器" class="headerlink" title="TMOD：定时器模式寄存器"></a><center>TMOD：定时器模式寄存器</center></h2><p>两个定时器&#x2F;计数器（任选一个即可）：<code>T0(TL0\TH0)</code>、<code>T1(TL1\TH1)</code></p><p>工作模式：</p><ul><li>模式0（13位定时器&#x2F;计数器）</li><li>模式1（16位定时器&#x2F;计数器）</li><li>模式2（8位自动重装初值）</li><li>模式3（两个8位定时器&#x2F;计数器）</li></ul><p>我们学的是定时器，计数器是外部计数，则0.7、0.3地址是计数器的置0，C&#x2F;T：置0为定时器，模式（M1、M0）这里我们选01（16位定时器，不自动重装初值）</p><p>如果不会自动重装载寄存器（不会自动赋初值）则要触发中断处理函数时重新手动赋初值</p><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202404131536016.png" alt="工作模式"></p><h2 id="定时器计算初值"><a href="#定时器计算初值" class="headerlink" title="定时器计算初值"></a><center>定时器计算初值</center></h2><p>需要定时的时间带入公式，求出x</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202406101704253.png" alt="初值计算方式" style="zoom: 50%;"><h2 id="中断允许寄存器"><a href="#中断允许寄存器" class="headerlink" title="中断允许寄存器"></a><center>中断允许寄存器</center></h2><p>&ensp;&ensp;&ensp;&ensp;总中断允许控制位：EA</p><p>&ensp;&ensp;&ensp;&ensp;ET0：定时&#x2F;计数器T0的溢出中断允许位，ET1：定时&#x2F;计数器T1的溢出中断允许位，ET2：定时&#x2F;计数器T2的溢出中断允许位</p><p>&ensp;&ensp;&ensp;&ensp;需要外部、定时器、串口那个则赋值那个为1</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202404121351544.png" alt="允许寄存器分析" style="zoom:67%;"><h1 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a><center>代码编写</center></h1><p>每1s翻转LED灯状态</p><ul><li>模式选择（定时器0；工作模式1）</li><li>定时器初值（10ms）</li><li>打开定时器T0运行控制位</li><li>打开定时器0中断允许位</li><li>打开总中断允许控制位</li><li>编写中断服务函数</li><li>当溢出时，触发中断，执行中断函数，执行完之后，回到主函数继续执行</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line">sbit LED1 = P1^<span class="number">0</span>;<span class="comment">//定义LED灯</span></span><br><span class="line"><span class="type">int</span> count;<span class="comment">//由于51单片机没办法定时1s，只能通过计数达到效果</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">TMOD = <span class="number">0x01</span>;<span class="comment">//配置定时器工作模式：使用定时器0，使用16位定时器模式(不自动重装初值)</span></span><br><span class="line"><span class="comment">//定时10ms，给寄存器赋初值</span></span><br><span class="line">TL0 = <span class="number">0x00</span>;</span><br><span class="line">TH0 = <span class="number">0xDC</span>;</span><br><span class="line">TR0 = <span class="number">1</span>;<span class="comment">//打开定时器T0运行控制位</span></span><br><span class="line">ET0 = <span class="number">1</span>;<span class="comment">//打开定时器0中断允许位</span></span><br><span class="line">EA = <span class="number">1</span>;<span class="comment">//打开总中断允许控制位</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//大于99时则取反LED状态</span></span><br><span class="line"><span class="keyword">if</span>(count &gt; <span class="number">99</span>)</span><br><span class="line">&#123;</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line">LED1 = ~LED1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定时中断处理函数</span></span><br><span class="line">Timer0_Routine(<span class="type">void</span>)      interrupt <span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//触发中断函数，需要重新给定时器赋初值</span></span><br><span class="line">TL0 = <span class="number">0x00</span>;</span><br><span class="line">TH0 = <span class="number">0xDC</span>;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;&lt;center&gt;原理&lt;/center&gt;&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;时钟源：定时器是内部时钟源（晶振），计数器是外部&lt;/li&gt;
&lt;li&gt;计时长度：对应TH  TL</summary>
      
    
    
    
    <category term="51单片机" scheme="http://example.com/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="51单片机" scheme="http://example.com/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>外部中断</title>
    <link href="http://example.com/post/81b224e1.html"/>
    <id>http://example.com/post/81b224e1.html</id>
    <published>2024-04-12T02:13:12.000Z</published>
    <updated>2024-07-05T03:07:43.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="中断原理"><a href="#中断原理" class="headerlink" title="中断原理"></a><center>中断原理</center></h1><p>你在打游戏，水开了，水壶发出响声，你停止打游戏，去倒水，倒完水接着打游戏</p><p>打游戏：就相当于While(1){}里面执行的代码</p><p>水壶响：就是中断源</p><p>倒水：触发中断后要去做的事情，中断处理函数</p><h1 id="代码实现过程"><a href="#代码实现过程" class="headerlink" title="代码实现过程"></a><center>代码实现过程</center></h1><h2 id="中断源"><a href="#中断源" class="headerlink" title="中断源"></a><center>中断源</center></h2><p>INT0(外部中断源)、Timer0(定时器中断源)、INT1、Timer1、UART(串口中断源)、Timer2、INT2、INT3</p><p>中断触发方式：</p><p>&ensp;&ensp;&ensp;&ensp;外部中断：下降沿或者低电平</p><p>&ensp;&ensp;&ensp;&ensp;定时器中断：定时器计数溢出</p><p>&ensp;&ensp;&ensp;&ensp;串口中断：串口发送或者接收完成</p><h2 id="中断处理函数"><a href="#中断处理函数" class="headerlink" title="中断处理函数"></a><center>中断处理函数</center></h2><p>与中断源对应的中断处理函数，直接使用对应的函数</p><table><thead><tr><th align="center">中断源</th><th>中断处理函数</th></tr></thead><tbody><tr><td align="center">INT0</td><td>Int0_Routine(void)              interrupt 0</td></tr><tr><td align="center">INT1</td><td>Int1_Routine(void)              interrupt 2</td></tr><tr><td align="center">INT2</td><td>Int2_Routine(void)             interrupt 6</td></tr><tr><td align="center">INT3</td><td>Int3_Routine(void)              interrupt 7</td></tr></tbody></table><h2 id="中断寄存器"><a href="#中断寄存器" class="headerlink" title="中断寄存器"></a><center>中断寄存器</center></h2><p>保存中断源的中断请求信息的专用寄存器</p><h3 id="中断控制寄存器"><a href="#中断控制寄存器" class="headerlink" title="中断控制寄存器"></a>中断控制寄存器</h3><p>外部中断只需用到：IT0、IT1、IE0、IE1</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202404121515869.png" alt="中断寄存器功能" style="zoom: 50%;"><p><code>外部中断触发方式控制位</code>(代码)：IT0、IT1，中断触发标志位(内部)：IE0、IE1</p><p><code>下降沿触发</code>：IT0 &#x3D; 1，<code>低电平触发</code>：IT0 &#x3D; 0（IT1同理）</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202404121721299.png" alt="外部中断分析" style="zoom:60%;"><p>定时器、串口(后续讲)</p><h3 id="中断优先级寄存器（暂不学）"><a href="#中断优先级寄存器（暂不学）" class="headerlink" title="中断优先级寄存器（暂不学）"></a>中断优先级寄存器（暂不学）</h3><h3 id="中断允许寄存器"><a href="#中断允许寄存器" class="headerlink" title="中断允许寄存器"></a>中断允许寄存器</h3><p>在外部中断只需要（置1为打开）：</p><ol><li>总中断允许控制位：EA</li><li>EX0：外部中断0中断允许位、EX1：外部中断1中断允许位</li></ol><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202404121351544.png" alt="允许寄存器分析" style="zoom:67%;"><h1 id="中断代码"><a href="#中断代码" class="headerlink" title="中断代码"></a><center>中断代码</center></h1><ol><li>配置外部中断0为下降沿触发（为1则低电平触发）</li><li>打开外部中断0中断允许位</li><li>打开总中断允许控制位</li><li>当有中断源发出，触发中断，执行中断函数，执行完之后，回到主函数继续执行</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrins.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit LED1 = P1^<span class="number">0</span>;<span class="comment">//引脚初始化：P1^0：对应引脚的LED灯，定义LED1代表P1^0这个引脚的LED灯</span></span><br><span class="line"><span class="comment">//延时函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay120ms</span><span class="params">()</span><span class="comment">//@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> data i, j;</span><br><span class="line">i = <span class="number">216</span>;</span><br><span class="line">j = <span class="number">37</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (--j);</span><br><span class="line">&#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//电路图知：中断源INT0、INT1引脚与按键P3^2、P3^3同一个，则按键为中断源，无需定义按键</span></span><br><span class="line">IT0 = <span class="number">1</span>;<span class="comment">//配置外部中断0为下降沿触发（为1则低电平触发）</span></span><br><span class="line">EX0 = <span class="number">1</span>;<span class="comment">//打开外部中断0中断允许位</span></span><br><span class="line">EA = <span class="number">1</span>;<span class="comment">//打开总中断允许控制位</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Delay120ms();</span><br><span class="line">Delay120ms();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Int0_Routine(<span class="type">void</span>)        interrupt <span class="number">0</span><span class="comment">//中断处理函数</span></span><br><span class="line">&#123;</span><br><span class="line">    Delay120ms();</span><br><span class="line">LED1 = ~LED1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;中断原理&quot;&gt;&lt;a href=&quot;#中断原理&quot; class=&quot;headerlink&quot; title=&quot;中断原理&quot;&gt;&lt;/a&gt;&lt;center&gt;中断原理&lt;/center&gt;&lt;/h1&gt;&lt;p&gt;你在打游戏，水开了，水壶发出响声，你停止打游戏，去倒水，倒完水接着打游戏&lt;/p&gt;
&lt;p&gt;打</summary>
      
    
    
    
    <category term="51单片机" scheme="http://example.com/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="51单片机" scheme="http://example.com/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>I/O</title>
    <link href="http://example.com/post/74750b31.html"/>
    <id>http://example.com/post/74750b31.html</id>
    <published>2024-04-11T05:11:34.000Z</published>
    <updated>2024-07-04T01:33:32.920Z</updated>
    
    <content type="html"><![CDATA[<h1 id="I-O输出-点灯"><a href="#I-O输出-点灯" class="headerlink" title="I&#x2F;O输出(点灯)"></a><center>I&#x2F;O输出(点灯)</center></h1><h2 id="分析电路"><a href="#分析电路" class="headerlink" title="分析电路"></a><center>分析电路</center></h2><p>看电路图，元器件形成电压差，即可点亮LED灯</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202406061928657.png" alt="LED电路图" style="zoom:50%;"><h2 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a><center>代码编写</center></h2><p>使用不同操作进行LED控制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span><span class="comment">//51单片机头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrins.h&gt;</span></span></span><br><span class="line">sbit LED1 = P1^<span class="number">0</span>;<span class="comment">//引脚初始化：P1^0：对应引脚的LED灯，定义LED1代表P1^0这个引脚的LED灯</span></span><br><span class="line">sbit LED2 = P1^<span class="number">1</span>;</span><br><span class="line">sbit LED3 = P1^<span class="number">2</span>;</span><br><span class="line">sbit LED4 = P1^<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="comment">//延时1000ms的延时函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay1000ms</span><span class="params">()</span>    <span class="comment">//@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> data i, j, k;</span><br><span class="line">  _nop_();</span><br><span class="line">  i = <span class="number">8</span>;</span><br><span class="line">  j = <span class="number">1</span>;</span><br><span class="line">  k = <span class="number">243</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">     <span class="keyword">do</span></span><br><span class="line">     &#123;</span><br><span class="line">       <span class="keyword">while</span> (--k);</span><br><span class="line">     &#125; <span class="keyword">while</span> (--j);</span><br><span class="line">  &#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//方法一：对位操作，P1^0为0，接通</span></span><br><span class="line">LED1 = <span class="number">0</span>;<span class="comment">//电路图得知，LED为0时，接通LED灯</span></span><br><span class="line">LED2 = <span class="number">1</span>;</span><br><span class="line">LED3 = <span class="number">1</span>;</span><br><span class="line">LED4 = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//方法二：P1寄存器直接赋值，两种效果相同</span></span><br><span class="line"><span class="comment">//P1 = 0xfe;   //11111110，LED灯为P1^0~P1^3，则为最低位3位</span></span><br><span class="line">Delay1000ms();</span><br><span class="line">      </span><br><span class="line"><span class="comment">//方法一：对位操作，P1^1为0，接通</span></span><br><span class="line">LED1 = <span class="number">1</span>;</span><br><span class="line">LED2 = <span class="number">0</span>;</span><br><span class="line">LED3 = <span class="number">1</span>;</span><br><span class="line">LED4 = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//P1 = 0xfd; //11111101</span></span><br><span class="line">Delay1000ms(); </span><br><span class="line">      </span><br><span class="line"><span class="comment">//方法一：对位操作，P1^2为0，接通</span></span><br><span class="line">LED1 = <span class="number">1</span>;</span><br><span class="line">LED2 = <span class="number">1</span>;</span><br><span class="line">LED3 = <span class="number">0</span>;</span><br><span class="line">LED4 = <span class="number">1</span>; </span><br><span class="line"><span class="comment">//P1 = 0xfb; //11111011</span></span><br><span class="line">Delay1000ms(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//方法一：对位操作，P1^3为0，接通</span></span><br><span class="line">LED1 = <span class="number">1</span>;</span><br><span class="line">LED2 = <span class="number">1</span>;</span><br><span class="line">LED3 = <span class="number">1</span>;</span><br><span class="line">LED4 = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//P1 = 0xf7; //11110111</span></span><br><span class="line">Delay1000ms();</span><br><span class="line"></span><br><span class="line"><span class="comment">//对方法三分析</span></span><br><span class="line"><span class="comment">//P1 = 0xff; //11111111</span></span><br><span class="line"><span class="comment">//Delay1000ms();</span></span><br><span class="line"><span class="comment">//P1 = P1&lt;&lt;1;  //11111110</span></span><br><span class="line"><span class="comment">//Delay1000ms();</span></span><br><span class="line"><span class="comment">//P1 = P1&lt;&lt;1; //11111100</span></span><br><span class="line"><span class="comment">//Delay1000ms();</span></span><br><span class="line">      </span><br><span class="line"><span class="comment">//方法三：位移实现对LED灯控制</span></span><br><span class="line">P1 = <span class="number">0xff</span>; <span class="comment">//11111111，将LED灯初始为灭</span></span><br><span class="line">Delay1000ms();</span><br><span class="line"><span class="comment">//通过4次循环左移，实现对LED灯的控制</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">P1 = P1&lt;&lt;<span class="number">1</span>;</span><br><span class="line">Delay1000ms();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="I-O输入-电平检测"><a href="#I-O输入-电平检测" class="headerlink" title="I&#x2F;O输入(电平检测)"></a><center>I&#x2F;O输入(电平检测)</center></h1><p>输入是检测输入的电平的高低，与输出不同</p><p>电路图知，按键按下为低电平，则判断按键引脚为低电平则按键按下</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202406071642838.png" alt="按键电路图" style="zoom:50%;"><p>注意：按键会有抖动。消除方法：按键并联一个电容 或 代码延时</p><h2 id="代码编写-1"><a href="#代码编写-1" class="headerlink" title="代码编写"></a><center>代码编写</center></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;reg52.h&gt;</span><span class="comment">//51单片机头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrins.h&gt;</span></span></span><br><span class="line">sbit LED1 = P1^<span class="number">0</span>;</span><br><span class="line">sbit KEY1 = P3^<span class="number">2</span>;<span class="comment">//第一个按键位引脚</span></span><br><span class="line">sbit KEY2 = P3^<span class="number">3</span>;<span class="comment">//第二个按键位引脚</span></span><br><span class="line">sbit BEEP = P1^<span class="number">6</span>;<span class="comment">//蜂鸣器位引脚</span></span><br><span class="line"><span class="comment">//延时函数，用来消除按键抖动</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay120ms</span><span class="params">()</span><span class="comment">//@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> data i, j;</span><br><span class="line"></span><br><span class="line">i = <span class="number">216</span>;</span><br><span class="line">j = <span class="number">37</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (--j);</span><br><span class="line">&#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(KEY1 == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">Delay120ms();</span><br><span class="line"><span class="comment">//双重判断且加延时函数，消除按键抖动</span></span><br><span class="line"><span class="keyword">if</span>(KEY1 == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">LED1 = ~LED1;<span class="comment">//对LED取反，则实现LED开关</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(KEY2 == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">Delay120ms();</span><br><span class="line"><span class="keyword">if</span>(KEY2 == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">BEEP = ~BEEP;<span class="comment">//对蜂鸣器取反，则实现蜂鸣器开关</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="I-O内部电路分析"><a href="#I-O内部电路分析" class="headerlink" title="I&#x2F;O内部电路分析"></a><center>I&#x2F;O内部电路分析</center></h1><h2 id="51单片机"><a href="#51单片机" class="headerlink" title="51单片机"></a><center>51单片机</center></h2><p>准双向口&#x2F;弱上拉：可用作输出和输入功能而不需要配置口线输出状态</p><p>开漏输出(P0)：当P0管脚做I&#x2F;O时，需要外加<code>上拉电阻</code>，若作为地址&#x2F;数据总线时，不需要加上拉电阻</p><h2 id="STM32单片机"><a href="#STM32单片机" class="headerlink" title="STM32单片机"></a><center>STM32单片机</center></h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>浮空输入：从IO引脚入，VDD(上拉电阻)打开和Vss(下拉电阻)打开，经过输入数据寄存器，读出</p><p>上拉输入：从IO引脚入，VDD(上拉电阻)闭合和Vss(下拉电阻)打开，经过输入数据寄存器，读出</p><p>下拉输入：从IO引脚入，VDD(上拉电阻)打开和Vss(下拉电阻)闭合，经过输入数据寄存器，读出</p><p>模拟输入：从IO引脚入，VDD(上拉电阻)打开和Vss(下拉电阻)打开，经过模拟输入</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202404121123673.png" alt="分析图" style="zoom: 67%;"><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>开漏输出：在开漏输出模式下，P-MOS(上拉)管不工作，只有N-MOS(下拉)管起作用。若输出数据寄存器的值为0，则N-MOS导通，IO口输出低电平；若输出数据寄存器的值为1，则N-MOS截止；由于P-MOS不工作，此时IO口既不是高电平，也不是低电平，这种状态被称为高阻态</p><p>推挽输出：在推挽输出模式下，若输出数据寄存器的值为0，则N-MOS(下拉)导通，P-MOS(上拉)截止，IO口输出低电平；若输出数据寄存器的值为1，则N-MOS截止，P-MOS导通，IO口输出高电平</p><p>复用：使别引脚也具备原本引脚功能</p><p>推挽复用输出、开漏复用输出</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;I-O输出-点灯&quot;&gt;&lt;a href=&quot;#I-O输出-点灯&quot; class=&quot;headerlink&quot; title=&quot;I&amp;#x2F;O输出(点灯)&quot;&gt;&lt;/a&gt;&lt;center&gt;I&amp;#x2F;O输出(点灯)&lt;/center&gt;&lt;/h1&gt;&lt;h2 id=&quot;分析电路&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="51单片机" scheme="http://example.com/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="51单片机" scheme="http://example.com/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>寄存器</title>
    <link href="http://example.com/post/f8f1fb54.html"/>
    <id>http://example.com/post/f8f1fb54.html</id>
    <published>2024-04-10T15:39:56.000Z</published>
    <updated>2024-06-06T09:01:08.567Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是寄存器"><a href="#什么是寄存器" class="headerlink" title="什么是寄存器"></a><center>什么是寄存器</center></h1><p>单片机寄存器是一组特定的存储单元，每个存储单元可以存储一个特定的数据值，对寄存器赋不同特定值，起到配置和控制各种功能的作用</p><h1 id="寄存器分类"><a href="#寄存器分类" class="headerlink" title="寄存器分类"></a><center>寄存器分类</center></h1><h2 id="特殊功能寄存器"><a href="#特殊功能寄存器" class="headerlink" title="特殊功能寄存器"></a><center>特殊功能寄存器</center></h2><p>8位单片机则一个寄存器有8位：P1：P1_0 ~ P1_7，单片机可能还有P0、P1等等</p><p>TCON、TMOD、IE…….</p><h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a><center>通用寄存器</center></h2><p>51单片机包括：R0、R1、R3、R4……（）</p><p>作用：存储临时数据、提高数据访问速度、传递函数参数、存储程序状态</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202406061701959.png" alt="通用寄存器" style="zoom:50%;"><h1 id="寄存器操作方式"><a href="#寄存器操作方式" class="headerlink" title="寄存器操作方式"></a><center>寄存器操作方式</center></h1><p>位寻址：一个位对应单片机一个引脚，这个引脚连接对应的器件&ensp;&ensp;&ensp;&ensp;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如：P0_1连接LED灯</span><br><span class="line">sbit LED1 = P0^<span class="number">1</span>;</span><br><span class="line">LED1 = <span class="number">1</span>;<span class="comment">//则LED灯亮</span></span><br></pre></td></tr></table></figure><p>如果没有位寻址，则整个寄存器赋值(十六进制0x00 ~ 0xff)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P0=<span class="number">0XFF</span>;<span class="comment">//P0=0XA5;</span></span><br></pre></td></tr></table></figure><p><code>如何知道寄存器对应的位以及芯片对应引脚功能，查看数据手册</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是寄存器&quot;&gt;&lt;a href=&quot;#什么是寄存器&quot; class=&quot;headerlink&quot; title=&quot;什么是寄存器&quot;&gt;&lt;/a&gt;&lt;center&gt;什么是寄存器&lt;/center&gt;&lt;/h1&gt;&lt;p&gt;单片机寄存器是一组特定的存储单元，每个存储单元可以存储一个特定的数据值，对</summary>
      
    
    
    
    <category term="51单片机" scheme="http://example.com/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="51单片机" scheme="http://example.com/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>单片机工作原理</title>
    <link href="http://example.com/post/c6b2a2fd.html"/>
    <id>http://example.com/post/c6b2a2fd.html</id>
    <published>2024-04-08T12:55:48.000Z</published>
    <updated>2024-06-04T04:40:37.369Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最小系统"><a href="#最小系统" class="headerlink" title="最小系统"></a><center>最小系统</center></h1><h2 id="单片机芯片"><a href="#单片机芯片" class="headerlink" title="单片机芯片"></a><center>单片机芯片</center></h2><p>本次51单片机的芯片为：STC89C52</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202404101723175.png" alt="芯片类型" style="zoom:50%;"><p>Flash(闪存)程序存储器：存储程序的空间</p><p>SRAM：数据存储器，可用于存放程序执行的中间结果和过程数据</p><p>DPTR：16位的寄存器（两个8位寄存器组成），用于间接寻址，DPH存储地址的高8位，而DPL存储地址的低8位</p><p>EEPROM：带电可擦可编程只读存储器。是一种掉电后数据不丢失的存储芯片</p><p>看门狗：用于监控单片机程序运行状态的机制。它通过一个定时器电路实现，能够在程序运行失控或遇到硬件错误时对单片机进行复位操作，以确保程序能够重新开始执行</p><p>A&#x2F;D：模拟信号到数字信号的转换（模拟&#x2F;数字）</p><p>I&#x2F;O：输入和输出，输入（Input）是指数据或信号从外部设备或用户传输到计算机系统内部的过程，而输出（Output）则是指数据或信号从计算机系统传输到外部设备或用户的过程</p><h2 id="时钟电路"><a href="#时钟电路" class="headerlink" title="时钟电路"></a><center>时钟电路</center></h2><p>产生固定频率的交流信号，晶振是产生信号的元器件（由晶振频率计算产生）</p><p>12Mhz：</p><p>时钟周期：1&#x2F;12Mhz，单位是秒，12Mhz要转为秒为12000000hz</p><p>1&#x2F;12000000 ≈ 0.00000008s</p><p>机器周期：12 × 时钟周期 &#x3D; 0.00000008s × 12 &#x3D; 0.000001s，转为us就是1us</p><h2 id="复位电路"><a href="#复位电路" class="headerlink" title="复位电路"></a><center>复位电路</center></h2><p>按键复位和上电复位</p><h2 id="电源"><a href="#电源" class="headerlink" title="电源"></a><center>电源</center></h2><p>供电，51单片机一般5v，smt32单片机一般3.3v</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;最小系统&quot;&gt;&lt;a href=&quot;#最小系统&quot; class=&quot;headerlink&quot; title=&quot;最小系统&quot;&gt;&lt;/a&gt;&lt;center&gt;最小系统&lt;/center&gt;&lt;/h1&gt;&lt;h2 id=&quot;单片机芯片&quot;&gt;&lt;a href=&quot;#单片机芯片&quot; class=&quot;headerlin</summary>
      
    
    
    
    <category term="51单片机" scheme="http://example.com/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="51单片机" scheme="http://example.com/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>浏览器插件</title>
    <link href="http://example.com/post/def84ee6.html"/>
    <id>http://example.com/post/def84ee6.html</id>
    <published>2024-04-07T04:43:37.000Z</published>
    <updated>2024-04-07T06:46:20.495Z</updated>
    
    <content type="html"><![CDATA[<p>如果我们经常使用的浏览器不是edge或者是chrome浏览器时，需要在浏览器安装插件时，无法获取插件以及不知道如何安装插件，本文章教你如何获取以及安装使用。</p><h1 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a><center>获取方法</center></h1><h2 id="第一种方法（推荐）"><a href="#第一种方法（推荐）" class="headerlink" title="第一种方法（推荐）"></a><center>第一种方法（推荐）</center></h2><p>无需魔法，即可访问获取插件的网站：<a href="https://www.crxsoso.com/">链接</a></p><p>还有一个浏览器一些黑科技小网站（正规绿色）：<a href="https://www.youxiaohou.com/">链接</a></p><h2 id="网上搜集下载地址"><a href="#网上搜集下载地址" class="headerlink" title="网上搜集下载地址"></a><center>网上搜集下载地址</center></h2><p>由于这些都是搬运的插件，若怕插件不安全，请使用第一种方法（本人正在使用），也可自行必应搜<code>浏览器插件下载</code>关键词</p><p>Extfans：<a href="https://extfans.com/">链接</a></p><p>画夹插件：<a href="https://huajiakeji.com/">链接</a></p><p>收藏猫插件：<a href="https://chrome.pictureknow.com/">链接</a></p><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><center>使用方法</center></h1><p>一般下载之后，插件文件的后缀名为：crx的单文件</p><p>这里以华为浏览器为例，首先打开华为浏览器，在右上角点击三点图标，选择设置，进入设置</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202404071329022.png" alt="打开浏览器设置" style="zoom:50%;"><p>打开在左边的下面，有一个扩展程序，点击进去</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202404071331220.png" alt="打开扩展程序" style="zoom:50%;"><p>打开开发者模式</p><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202404071332308.png" alt="开发者模式"></p><p>打开之后，如果下载后的插件文件后缀为：<code>crx</code> 的单文件，则直接将文件拖进扩展程序这个页面，即可添加插件</p><p>如果是压缩包，解压之后是多文件，则点击左上角的加载已解压的扩展程序，然后选择解压出来的插件文件夹，打开即可。</p><p>如果是其他浏览器也是类似操作，也可以进行模仿尝试是否可以导入插件</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如果我们经常使用的浏览器不是edge或者是chrome浏览器时，需要在浏览器安装插件时，无法获取插件以及不知道如何安装插件，本文章教你如何获取以及安装使用。&lt;/p&gt;
&lt;h1 id=&quot;获取方法&quot;&gt;&lt;a href=&quot;#获取方法&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    <category term="技术教程" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="插件" scheme="http://example.com/tags/%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>资源搜索网址</title>
    <link href="http://example.com/post/1f293ccb.html"/>
    <id>http://example.com/post/1f293ccb.html</id>
    <published>2024-04-03T15:18:19.000Z</published>
    <updated>2024-07-05T01:31:58.960Z</updated>
    
    <content type="html"><![CDATA[<h3 id="猫狸盘搜"><a href="#猫狸盘搜" class="headerlink" title="猫狸盘搜"></a>猫狸盘搜</h3><p><a href="https://www.alipansou.com/">地址</a></p><h3 id="千帆搜索"><a href="#千帆搜索" class="headerlink" title="千帆搜索"></a>千帆搜索</h3><p><a href="https://pan.qianfan.app/">地址</a></p><h3 id="懒盘搜索"><a href="#懒盘搜索" class="headerlink" title="懒盘搜索"></a>懒盘搜索</h3><p><a href="https://www.lzpanx.com/">地址</a></p><h3 id="快盘搜"><a href="#快盘搜" class="headerlink" title="快盘搜"></a>快盘搜</h3><p><a href="https://www.kpanso.com/">地址</a></p><h3 id="秒搜"><a href="#秒搜" class="headerlink" title="秒搜"></a>秒搜</h3><p><a href="https://miaosou.fun/">地址</a></p><h3 id="皮卡搜索"><a href="#皮卡搜索" class="headerlink" title="皮卡搜索"></a>皮卡搜索</h3><p><a href="https://www.pikaso.top/">地址</a></p><h3 id="磁力狗"><a href="#磁力狗" class="headerlink" title="磁力狗"></a>磁力狗</h3><p><a href="http://clg0.icu/">地址</a></p><h3 id="老王磁力"><a href="#老王磁力" class="headerlink" title="老王磁力"></a>老王磁力</h3><p><a href="https://laowangyx.top/">地址</a></p><h3 id="搜度盘"><a href="#搜度盘" class="headerlink" title="搜度盘"></a>搜度盘</h3><p><a href="http://www.sodu123.com/index.html">地址</a></p><h3 id="小白盘"><a href="#小白盘" class="headerlink" title="小白盘"></a>小白盘</h3><p><a href="https://www.xiaobaipan.com/">地址</a></p><h3 id="文件搜"><a href="#文件搜" class="headerlink" title="文件搜"></a>文件搜</h3><p><a href="https://wjsou.com/">地址</a></p><h3 id="SOSO云盘"><a href="#SOSO云盘" class="headerlink" title="SOSO云盘"></a>SOSO云盘</h3><p><a href="https://www.sosoyunpan.com/">地址</a></p><h3 id="搜BaiDu盘"><a href="#搜BaiDu盘" class="headerlink" title="搜BaiDu盘"></a>搜BaiDu盘</h3><p><a href="https://www.sobaidupan.com/">地址</a></p><h3 id="盘友圈"><a href="#盘友圈" class="headerlink" title="盘友圈"></a>盘友圈</h3><p><a href="https://panyq.com/">地址</a></p><h3 id="UP云搜"><a href="#UP云搜" class="headerlink" title="UP云搜"></a>UP云搜</h3><p><a href="https://www.upyunso.com/">地址</a></p><h3 id="学霸盘"><a href="#学霸盘" class="headerlink" title="学霸盘"></a>学霸盘</h3><p><a href="https://www.xuebapan.com/">地址</a></p><h3 id="盘他一下"><a href="#盘他一下" class="headerlink" title="盘他一下"></a>盘他一下</h3><p><a href="https://www.panothers.com/">地址</a></p><h3 id="云盘分享网"><a href="#云盘分享网" class="headerlink" title="云盘分享网"></a>云盘分享网</h3><p><a href="https://alypw.cn/">网址</a></p><h3 id="好当家"><a href="#好当家" class="headerlink" title="好当家"></a>好当家</h3><p><a href="https://www.hjdang.com/">网址</a></p><h3 id="爱盘搜"><a href="#爱盘搜" class="headerlink" title="爱盘搜"></a>爱盘搜</h3><p><a href="https://aipanso.com/">网址</a></p><h3 id="易搜"><a href="#易搜" class="headerlink" title="易搜"></a>易搜</h3><p><a href="https://yiso.fun/">网址</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;猫狸盘搜&quot;&gt;&lt;a href=&quot;#猫狸盘搜&quot; class=&quot;headerlink&quot; title=&quot;猫狸盘搜&quot;&gt;&lt;/a&gt;猫狸盘搜&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.alipansou.com/&quot;&gt;地址&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;千帆搜索&quot;&gt;</summary>
      
    
    
    
    <category term="技术教程" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="资源搜索" scheme="http://example.com/tags/%E8%B5%84%E6%BA%90%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>图片压缩在线工具</title>
    <link href="http://example.com/post/79959306.html"/>
    <id>http://example.com/post/79959306.html</id>
    <published>2024-03-31T08:54:07.000Z</published>
    <updated>2024-04-01T03:57:39.737Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TinyPng"><a href="#TinyPng" class="headerlink" title="TinyPng"></a>TinyPng</h3><p><a href="https://tinypng.com/">地址</a></p><h3 id="图好快"><a href="#图好快" class="headerlink" title="图好快"></a>图好快</h3><p><a href="https://www.tuhaokuai.com/">地址</a></p><h3 id="Jpeg-io"><a href="#Jpeg-io" class="headerlink" title="Jpeg.io"></a>Jpeg.io</h3><p><a href="https://www.jpeg.io/">地址</a></p><h3 id="色彩笔"><a href="#色彩笔" class="headerlink" title="色彩笔"></a>色彩笔</h3><p><a href="https://www.secaibi.com/tools/">地址</a></p><h3 id="压缩图"><a href="#压缩图" class="headerlink" title="压缩图"></a>压缩图</h3><p><a href="https://www.yasuotu.com/">地址</a></p><h3 id="Recompressor"><a href="#Recompressor" class="headerlink" title="Recompressor"></a>Recompressor</h3><p><a href="https://zh.recompressor.com/">地址</a></p><h3 id="Picdiet"><a href="#Picdiet" class="headerlink" title="Picdiet"></a>Picdiet</h3><p><a href="https://www.picdiet.com/zh-cn?ref=dartools.com#google_vignette">地址</a></p><h3 id="Squoosh"><a href="#Squoosh" class="headerlink" title="Squoosh"></a>Squoosh</h3><p><a href="https://squoosh.app/">地址</a></p><h3 id="Imagify"><a href="#Imagify" class="headerlink" title="Imagify"></a>Imagify</h3><p><a href="http://webresizer.com/resizer/">地址</a></p><h3 id="Optimizilla"><a href="#Optimizilla" class="headerlink" title="Optimizilla"></a>Optimizilla</h3><p><a href="https://imagecompressor.com/zh/">地址</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;TinyPng&quot;&gt;&lt;a href=&quot;#TinyPng&quot; class=&quot;headerlink&quot; title=&quot;TinyPng&quot;&gt;&lt;/a&gt;TinyPng&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://tinypng.com/&quot;&gt;地址&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;</summary>
      
    
    
    
    <category term="技术教程" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="图片压缩在线工具" scheme="http://example.com/tags/%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>小狼毫配置</title>
    <link href="http://example.com/post/5f6e69ef.html"/>
    <id>http://example.com/post/5f6e69ef.html</id>
    <published>2024-03-14T13:57:15.000Z</published>
    <updated>2024-04-06T09:53:59.248Z</updated>
    
    <content type="html"><![CDATA[<h1 id="下载小狼毫软件"><a href="#下载小狼毫软件" class="headerlink" title="下载小狼毫软件"></a><center>下载小狼毫软件</center></h1><p>小狼毫下载：<a href="https://rime.im/download/#">地址</a></p><h1 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a><center>安装步骤</center></h1><p>下载好安装包后，打开安装包，安装，步骤如下</p><p>点击我接受</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403142202912.png" alt="步骤一" style="zoom:50%;"><p>这里是软件安装路径，选择自己要安装的位置，后直接点击安装</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403142203014.png" alt="步骤二" style="zoom:50%;"><p>后续还有个<code>用户配置文件</code>的安装目录，这个目录保存好，在别的电脑可以直接恢复配置。</p><p>方案选定，选择图片单个即可，选择 中 下一步</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403142204796.png" alt="步骤三" style="zoom:50%;"><p>然后，选择自己喜欢的风格，点击中，即可安装完成。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>在任务栏中，在 中 字右键，选择用户文件夹</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403142207761.png" alt="配置一" style="zoom:67%;"><p>在大佬整理的文件下载词库配置，大佬的：GitHub<a href="https://github.com/iDvel/rime-ice">地址</a>，直接整个打包下载</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403142209429.png" alt="打包下载" style="zoom: 33%;"><h1 id="重点配置"><a href="#重点配置" class="headerlink" title="重点配置"></a>重点配置</h1><p>解压下载好的词库配置包，右键退出算法服务（若点击退出没有反应，直接重启即可），然后删除用户文件夹内的所有文件（最好备份一下原本的文件），复制大佬仓库中的所有文件到你的用户文件夹中，重启电脑，刚重启之后，等待一会儿，如果还不行，再右键重新部署，这期间会出现 输入法调出来但是无法打字的问题，等重新部署完成，可以打字即部署完成</p><hr><p>tip：个人感觉不是很好用，可能不会配置，或者说没有精力去配置，如果想要好用需要花费精力去配置。本人已切换到百度输入法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;下载小狼毫软件&quot;&gt;&lt;a href=&quot;#下载小狼毫软件&quot; class=&quot;headerlink&quot; title=&quot;下载小狼毫软件&quot;&gt;&lt;/a&gt;&lt;center&gt;下载小狼毫软件&lt;/center&gt;&lt;/h1&gt;&lt;p&gt;小狼毫下载：&lt;a href=&quot;https://rime.im/do</summary>
      
    
    
    
    <category term="技术教程" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="小狼毫输入法" scheme="http://example.com/tags/%E5%B0%8F%E7%8B%BC%E6%AF%AB%E8%BE%93%E5%85%A5%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>GitHub+Picgo图片上传</title>
    <link href="http://example.com/post/d20e58f5.html"/>
    <id>http://example.com/post/d20e58f5.html</id>
    <published>2024-03-01T09:14:17.000Z</published>
    <updated>2024-03-01T09:42:37.913Z</updated>
    
    <content type="html"><![CDATA[<p> Picgo下载，修改安装路径，其他一路下一步！</p><blockquote><p><a href="https://github.com/Molunerfinn/picgo/releases">地址</a></p></blockquote><p> 注册GitHub，注册过程不详细展开，不会的百度一下</p><blockquote><p><a href="https://github.com/">地址</a></p></blockquote><h1 id="新建GitHub仓库存放图片"><a href="#新建GitHub仓库存放图片" class="headerlink" title="新建GitHub仓库存放图片"></a>新建GitHub仓库存放图片</h1><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011715417.png" alt="新建" style="zoom: 33%;"><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011718105.png" alt="填写信息"></p><h1 id="生成Token令牌"><a href="#生成Token令牌" class="headerlink" title="生成Token令牌"></a>生成Token令牌</h1><p>点击头像，点击Settings</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011720770.png" alt="img" style="zoom: 50%;"><p>滑到最后</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011720876.png" alt="进入生成令牌" style="zoom: 33%;"><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011721976.png" alt="选择对应选项"></p><p>过期时间：<code>No expiration</code>(永久不过期)</p><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011722080.png" alt="设置令牌信息"></p><blockquote><p><strong>务必将令牌保存起来</strong>，放在一个安全的地方，页面关掉后就看不到了。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011726560.png" alt="生产令牌"></p><h1 id="创建img文件夹"><a href="#创建img文件夹" class="headerlink" title="创建img文件夹"></a>创建img文件夹</h1><p>回到刚才新建存放图片的仓库，新建文件夹</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011726060.png" alt="创建文件夹" style="zoom:50%;"><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011727746.png" alt="命名文件夹" style="zoom: 33%;"><h1 id="设置GitHub图床"><a href="#设置GitHub图床" class="headerlink" title="设置GitHub图床"></a>设置GitHub图床</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">自定义域名需要配置为：https://cdn.jsdelivr.net/gh/用户名/仓库名，这样就才可以通过cdn访问图片</span><br><span class="line">仓库名：GitHub用户名/GitHub仓库地址</span><br><span class="line">分支名：main</span><br><span class="line">Token：GitHub中设定的AccessToken</span><br><span class="line">自定义域名：https://cdn.jsdelivr.net/gh/用户名/仓库名</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011728215.png" alt="Picgo设置"></p><p>点击上传区上传图片</p><p>上传成功之后</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011729915.png" alt="例图" style="zoom: 50%;"><p>如果提示网络不好等错误，可能不稳定，稍后再试试看。或者可以重启试试看!！</p><p>在Typora中，文件-》偏好设置中，设置成下图，将语法偏好所有选项关闭，可以避免直接复制图片进Typora报错</p><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011729398.png" alt="img"></p><p>仓库可能最多只能存放1g，网上说的，所以最好快到的时候重新建一个仓库</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; Picgo下载，修改安装路径，其他一路下一步！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Molunerfinn/picgo/releases&quot;&gt;地址&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 注册GitHu</summary>
      
    
    
    
    <category term="技术教程" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="GitHub+Picgo图片上传" scheme="http://example.com/tags/GitHub-Picgo%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/"/>
    
  </entry>
  
  <entry>
    <title>GitHub同步gitee并部署</title>
    <link href="http://example.com/post/6c3f8114.html"/>
    <id>http://example.com/post/6c3f8114.html</id>
    <published>2024-02-28T14:32:35.000Z</published>
    <updated>2024-02-28T15:29:04.008Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建并同步GitHub仓库"><a href="#创建并同步GitHub仓库" class="headerlink" title="创建并同步GitHub仓库"></a><center>创建并同步GitHub仓库</center></h1><p>点击加号，选择从GitHub仓库导入</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402282300375.jpg" alt="导入仓库" style="zoom:67%;"><p>选择导入GitHub仓库</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402282301124.jpg" alt="选择仓库" style="zoom: 50%;"><p>导入对应GitHub仓库，此时需要注意仓库名字需要和你创建gitee时的名字相同，如果不知道名字可先往下看，中间可修改仓库名字</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402282303081.jpg" alt="导入仓库" style="zoom: 50%;"><p>查看名字为哪个，可看浏览器网址，中间名字就是</p><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402282318977.jpg" alt="查看用户名"></p><p>设置仓库为公有，为了可以开启pages，进入仓库，点击管理</p><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402282306887.jpg" alt="进入设置"></p><p>基本信息最下方找到，是否开源，点击开源</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402282307142.jpg" alt="开源" style="zoom: 50%;"><h1 id="部署gitee-pages"><a href="#部署gitee-pages" class="headerlink" title="部署gitee pages"></a>部署gitee pages</h1><p>进入对应仓库，点击服务，点击gitee pages，此处需要实名认证，实名认证完之后才可以开启</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402282320319.jpg" alt="部署" style="zoom: 50%;"><p>进入之后，直接选中对应仓库中的分支，点击部署即可</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402282322599.jpg" alt="部署中" style="zoom: 50%;"><p>GitHub上传部署之后不会自动更新gitee，需要手动部署，只需要在对应的仓库中，点击仓库名字旁边的旋转图标，强制更新即可，更新就直接部署了，不需要自己再进入pages重新部署。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;创建并同步GitHub仓库&quot;&gt;&lt;a href=&quot;#创建并同步GitHub仓库&quot; class=&quot;headerlink&quot; title=&quot;创建并同步GitHub仓库&quot;&gt;&lt;/a&gt;&lt;center&gt;创建并同步GitHub仓库&lt;/center&gt;&lt;/h1&gt;&lt;p&gt;点击加号，选择从G</summary>
      
    
    
    
    <category term="技术教程" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="GitHub同步gitee并部署" scheme="http://example.com/tags/GitHub%E5%90%8C%E6%AD%A5gitee%E5%B9%B6%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>云图床</title>
    <link href="http://example.com/post/2ec6e870.html"/>
    <id>http://example.com/post/2ec6e870.html</id>
    <published>2024-02-23T01:53:48.000Z</published>
    <updated>2024-02-24T06:29:59.265Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图床导航"><a href="#图床导航" class="headerlink" title="图床导航"></a>图床导航</h1><p><a href="http://imgdh.com/">网址</a></p><h1 id="路过图床"><a href="#路过图床" class="headerlink" title="路过图床"></a>路过图床</h1><p><a href="https://imgse.com/">网址</a></p><h1 id="Picgo图床"><a href="#Picgo图床" class="headerlink" title="Picgo图床"></a>Picgo图床</h1><p><a href="https://www.picgo.net/">网址</a></p><h1 id="sm-ms图床"><a href="#sm-ms图床" class="headerlink" title="sm.ms图床"></a>sm.ms图床</h1><p><a href="https://sm.ms/">网址</a></p><h1 id="薄荷图床"><a href="#薄荷图床" class="headerlink" title="薄荷图床"></a>薄荷图床</h1><p><a href="https://zixiaoyun.com/">网址</a></p><h1 id="风筝图床"><a href="#风筝图床" class="headerlink" title="风筝图床"></a>风筝图床</h1><p><a href="https://www.imgbed.link/">网址</a></p><h1 id="ImgURL图床"><a href="#ImgURL图床" class="headerlink" title="ImgURL图床"></a>ImgURL图床</h1><p><a href="https://www.imgurl.org/vip/manage/upload">网址</a></p><h1 id="Z4A图床"><a href="#Z4A图床" class="headerlink" title="Z4A图床"></a>Z4A图床</h1><p><a href="https://z4a.net/">网址</a></p><h1 id="Hello图床"><a href="#Hello图床" class="headerlink" title="Hello图床"></a>Hello图床</h1><p><a href="https://www.helloimg.com/">网址</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;图床导航&quot;&gt;&lt;a href=&quot;#图床导航&quot; class=&quot;headerlink&quot; title=&quot;图床导航&quot;&gt;&lt;/a&gt;图床导航&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://imgdh.com/&quot;&gt;网址&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;路过图床&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="技术教程" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="云图床" scheme="http://example.com/tags/%E4%BA%91%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>魔法</title>
    <link href="http://example.com/post/812d49a5.html"/>
    <id>http://example.com/post/812d49a5.html</id>
    <published>2024-02-22T14:02:09.000Z</published>
    <updated>2024-04-11T01:04:39.164Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="ebfa71a3ddfbe28bbc4dc219dd98ece3a00e737d9a33da54df14312da76d77c3">d0082e95ce53ece4a4c0f5b8a727fc3f7abb847cc98e7a9a6a2fde3b380d7c463eab01dd65778c150e07dcadb67c6af1d15b71b699b47174951fa67a2912481f86bfc3f40db66f875cde4163a833c2282a5ef27e4dce42910951c1fb29d2bcede01f597d9b999b5ae308c011e3a8bcfe87f6943b92da1629ebf2f20f85e1ff09f7ac03362d4799f57091d1ce3affbc597b5318e09fba03e79b9330c9282a9530ab686db628d7499492ad97c86bcd148c5955f26e767728282d95e46c39afe37e7b3125e16426491d24604cb05862abbd276c34f94a0a10e1d1c5a3f40e3aa3f2a340378712f0329a6c38f361781b02e77129aece2ee545f49116099dd42be108e85d0d6c93d1650da9e333105a9e2ce14df0b1d76be27466bd48064da706e38d7a7aa70e122cda666c38c16945e90fd655b5e1b7f482947e00fe39a263f7243626482cfc6e33301285edfce86fe4bd930a32a247a2fd08747b7d0bdb3d3ac2bc43fe860f7ec0967543000929eb011651ba4494aca9ce5937be5d5a872ea65ebad211ace06566d8c6b1ec3973953c8979b0715d02068f688ba0cd9165cc13279583427e9e9b64810ea8c48fd5ebc786fc10eb5ffa5c656853f859a8e923f6f1f2569f74ebc27a1072ab5d68201b5ba236d2288b01d101eb7e56da22546facb31bba2589b3b247a0fca3c376543294e3207ab5fe131ff4e463ad77635bbcd2de80781b01397a0b1fb02e9a68e1f165ea4a16f8f2aa5019f87a69f4cc32172bace6fae2b612a33c2a1d41568fa05d6b5c11421b5ed153a2bc30ed1dd7ad95b1945b1515ded15105b848d3221e0970a97d1c00d043bd72a393ec8e41cdbe4c12a04cde385026f4923b4271f033be2630e1b5</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码，查看文章。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这是一篇加密文章，内容可能是个人情感宣泄或者收费技术。如果你非常好奇，请与我联系。</summary>
    
    
    
    <category term="技术教程" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="魔法" scheme="http://example.com/tags/%E9%AD%94%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>计算机备考</title>
    <link href="http://example.com/post/df95841.html"/>
    <id>http://example.com/post/df95841.html</id>
    <published>2024-01-06T01:00:00.000Z</published>
    <updated>2024-06-04T01:42:56.128Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C语言程序和程序设计概述"><a href="#C语言程序和程序设计概述" class="headerlink" title="C语言程序和程序设计概述"></a><center>C语言程序和程序设计概述</center></h1><p>程序：可以连续执行的一条条指令的集合</p><p>开发过程：C源程序(.c文件) –&gt; 目标程序(.obj二进制文件，目标文件) –&gt; 可执行文件(.exe文件) –&gt;结果</p><p>在任何机器上可以运行C源程序生成的<code> .exe 文件</code></p><p>没有安装C语言集成开发环境，不能编译C语言程序，<code>函数</code>是C程序的<code>基本单位</code></p><p>程序设计有以下几个部分：</p><ol><li>确定数据结构</li><li>确定算法</li><li>编码（编写代码）</li><li>计算机上调试程序</li><li>整理并写出文档资料</li></ol><p>C语言运行方法：编译执行，python：解释执行</p><p>头文件：#include&lt;stdio.h&gt;</p><p>C语言的结构特点：</p><ul><li>函数是C程序的主要组成部分</li></ul><p>&ensp;&ensp;&ensp;&ensp;一个C程序是由一个或多个函数组成</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;必须包含一个main函数（只能有一个）</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;每个函数都用来实现一个或多个特定功能</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;被调用的函数可以是库函数，也可以是自己编制设计的函数</p><ul><li>程序总是从main函数开始执行</li><li>C程序书写可以一行内写几个语句，也可以一个语句分写在多行上（以<mark>分号</mark>为标准，判断是否是一个语句）</li><li>数据声明和语句最后必须有分号</li><li>C语言本事不提供输入输出语句，由库函数提供</li></ul><p>算法表示方法：</p><ol><li>自然语言</li><li>用伪代码表示</li><li>用流程图表示</li></ol><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402220850908.png" alt="流程图常用符号" style="zoom:50%;"><ol start="4"><li>N-S流程图表示</li></ol><h2 id="标识符、常量和变量"><a href="#标识符、常量和变量" class="headerlink" title="标识符、常量和变量"></a><center>标识符、常量和变量</center></h2><p>常量</p><p>整型常量：12、0、-3</p><p>实型常量：</p><p>&ensp;&ensp;&ensp;&ensp;十进制小数：0.34、-56.79</p><p>&ensp;&ensp;&ensp;&ensp;指数形式：12.34e3（12.34×10³）</p><p>符号常量：’a’、’b’</p><p>字符串常量：”Beijing”</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">常量在程序运行期间，值不可以改变的</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159<span class="comment">//定义符号常量不需要分号</span></span></span><br></pre></td></tr></table></figure><p>变量</p><p>&ensp;&ensp;&ensp;&ensp;在程序运行期间，值是可以改变的</p><p>&ensp;&ensp;&ensp;&ensp;定义变量时指定该变量的名字和类型</p><p>&ensp;&ensp;&ensp;&ensp;变量名实际上是以一个名字代表一个存储地址</p><p>&ensp;&ensp;&ensp;&ensp;从变量取值，实际上是通过变量名找到相应的内存地址，从该存储单元中读取数据</p><p>标识符</p><p>&ensp;&ensp;&ensp;&ensp;只能由字母、数字和下划线组成，且第一个字符必须为字符或下划线，不能使用C语言关键字作为标识符</p><p>C语言是严格区分字母大小写</p><p>关键字必须用小写字母</p><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402220849778.png" alt="关键字"></p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><center>数据类型</center></h2><h3 id="整型数据"><a href="#整型数据" class="headerlink" title="整型数据"></a>整型数据</h3><p>&ensp;&ensp;&ensp;&ensp;整型常量3种表示形式</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;十进制整数，如2，-983</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;八进制整数。以0开头，由0~7构成，通常为无符号数，如012，八进制12</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;十六进制整数。以0x开头，由 0 ~ 9 和 A ~ F 或 a ~ f 构成，如0x12A，十六进制12A</p><p>&ensp;&ensp;&ensp;&ensp;整型变量：<font color="red">类型说明符 变量名标识符;</font>如 int a,b,c;</p><p>&ensp;&ensp;&ensp;&ensp;在定义变量的同时给变量赋初值，称变量初始化，若没有初始化，则内容不确定</p><p>计算机最小存储单位：位(bit)</p><p>&ensp;&ensp;&ensp;&ensp;一个<mark>字节</mark>(byte) &#x3D; 8bit</p><table><thead><tr><th align="center">关键字</th><th align="center">类型</th><th align="center">所占的空间</th></tr></thead><tbody><tr><td align="center">char</td><td align="center">字符串类型</td><td align="center">占1字节空间（8位二进制位）</td></tr><tr><td align="center">short</td><td align="center">短整型</td><td align="center">占2字节空间（16位二进制位）</td></tr><tr><td align="center">int</td><td align="center">整型</td><td align="center">占4个字节空间（32位二进制）</td></tr><tr><td align="center">long</td><td align="center">长整型</td><td align="center">占4个字节空间（32位二进制）（在64为平台下占8个字节）</td></tr><tr><td align="center">float</td><td align="center">单精度浮点数</td><td align="center">占4个字节空间（32为二进制）（7位有效位，指数-37到38）</td></tr><tr><td align="center">double</td><td align="center">双精度浮点数</td><td align="center">占8个字节空间（64为二进制）（16位有效位，指数-307到308）</td></tr></tbody></table><p>在存储有符号数时，存储单元最高为代表符号位，0为正，1为负</p><p>设计程序时，注意变量类型的取值范围，当赋值超过取值范围时，会出现溢出错误</p><p>一个整 型常量后加 U或u 后缀则被认为时unsigned类型，内存中按unsigned规定方式存放</p><p>一个整型常量后加 L或l 后缀则被认为时long类型，内存中按long规定位数存放</p><p>无符号长整数：用后缀 UL&#x2F;ul表示，如：15ul</p><h3 id="浮点型-实型-数据"><a href="#浮点型-实型-数据" class="headerlink" title="浮点型(实型)数据"></a>浮点型(实型)数据</h3><p>实型常量</p><p>&ensp;&ensp;&ensp;&ensp;又称实属或浮点数</p><p>&ensp;&ensp;&ensp;&ensp;十进制小数形式，如123.456</p><p>&ensp;&ensp;&ensp;&ensp;指数形式：以 “e” 或 “E” 后跟一个整数来表示以10为底的幂数，如 2.3026e2</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;规定：字母 e 或 E 之前必须有数字，且e或E后面指数必须为整数</p><p>&ensp;&ensp;&ensp;&ensp;10⁸不能写成e8，必须写成：1e8 或 1.0E8</p><p>实型变量</p><p>&ensp;&ensp;&ensp;&ensp;实型(3.14159)数据在内存中存放的形式：</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;+：数符</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;.314159：小数部分</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1：指数</p><p>&ensp;&ensp;&ensp;&ensp;小数部分占的为数越多，数的有效数字越多，精度越高</p><p>&ensp;&ensp;&ensp;&ensp;指数部分占的位数越多，则能表示的数值范围越大</p><h3 id="字符型数据"><a href="#字符型数据" class="headerlink" title="字符型数据"></a>字符型数据</h3><p>字符常量</p><p>&ensp;&ensp;&ensp;&ensp;用单引号括起来的一个字符，如’a‘、’E‘，不能 ’ab‘</p><p>&ensp;&ensp;&ensp;&ensp;字符常量以ASCII码存储，一个字符占一个字节，<mark>大写</mark>字母与<mark>小写</mark>字母ASCII码值相差 32</p><p>字符变量</p><p>&ensp;&ensp;&ensp;&ensp;如：char c1,c2,c3; c1 &#x3D; ‘A’; c2 &#x3D; ‘\n’;</p><p>&ensp;&ensp;&ensp;&ensp;每个字符变量分配一个字节用于存放一个字符（存放的是字符的ASCII码值）</p><p>字符数据与整型数据可相互赋值，直接运算</p><p>用%d输出，则输出整型数，用%c输出，则输出字符</p><p>字符串常量</p><p>&ensp;&ensp;&ensp;&ensp;一对双引号(“ “)括起来的字符序列，字符个数称为其长度，如：”hellow”</p><p>&ensp;&ensp;&ensp;&ensp;长度为n的字符串，在计算机存储中占n+1个字节，原因：会自动在结尾添加 ’\0‘</p><p>ASCII码表</p><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402220849502.png" alt="ASCII码表"></p><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><table><thead><tr><th align="center">字符形式</th><th align="center">功能</th><th align="center">字符形式</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">\n</td><td align="center">回车换行</td><td align="center">\\</td><td align="center">一个反斜杠字符(\)</td></tr><tr><td align="center">\t</td><td align="center">将当前位置移到下一个tab位置</td><td align="center">\‘</td><td align="center">一个单引号(‘)</td></tr><tr><td align="center">\v</td><td align="center">当前位置移到下一个垂直制表对齐点</td><td align="center">\“</td><td align="center">一个双引号(“)</td></tr><tr><td align="center">\r</td><td align="center">回车符</td><td align="center">\ddd</td><td align="center">三位八进制数代表一个ASCII字符</td></tr><tr><td align="center">\f</td><td align="center">换页符</td><td align="center">\xhh</td><td align="center">二位十六进制代表一个ASCII字符</td></tr><tr><td align="center">\b</td><td align="center">将当前位置后退一个字符</td><td align="center">\0</td><td align="center">空值，其ASCII码值为0</td></tr></tbody></table><h3 id="符号常量"><a href="#符号常量" class="headerlink" title="符号常量"></a>符号常量</h3><p>用标识符表示的常量，一般符号常量名用大写字母表示，命令通常放在文件头，在程序中不允许重新赋值，注意：不需要分号结尾</p><p>格式：#define 标识符 常量如：#define PI 3</p><h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402220849431.png" alt="数学函数" style="zoom: 50%;"><h2 id="运算符和表达式"><a href="#运算符和表达式" class="headerlink" title="运算符和表达式"></a><center>运算符和表达式</center></h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>优先级越小，越优先，优先级相同时，运算次序由<mark>结合性</mark>决定</p><table><thead><tr><th align="center">运算符</th><th align="center">运算规则</th><th align="center">操作数数目</th><th align="center">优先级</th><th align="center">结合方向</th></tr></thead><tbody><tr><td align="center">-</td><td align="center">负号</td><td align="center">单目</td><td align="center">2</td><td align="center">左结合</td></tr><tr><td align="center">+</td><td align="center">加法</td><td align="center">双目</td><td align="center">4</td><td align="center">左结合</td></tr><tr><td align="center">-</td><td align="center">减法</td><td align="center">双目</td><td align="center">4</td><td align="center">左结合</td></tr><tr><td align="center">*</td><td align="center">乘法</td><td align="center">双目</td><td align="center">3</td><td align="center">左结合</td></tr><tr><td align="center">&#x2F;</td><td align="center">除法</td><td align="center">双目</td><td align="center">3</td><td align="center">左结合</td></tr><tr><td align="center">%</td><td align="center">取余或模</td><td align="center">双目</td><td align="center">3</td><td align="center">左结合</td></tr></tbody></table><p>1.&#x2F;3 + 1.&#x2F;3 + 1.&#x2F;3 &#x3D; 1</p><p>取余运算符，所得结果的符号与运算符左侧操作数符号相同，如：-5 % 2 &#x3D; -1，5 % -2 &#x3D; 1，<code>运算对象只能是整型</code>，结果也是整型，如：5 % 2 &#x3D;1</p><h3 id="自增、自减运算符"><a href="#自增、自减运算符" class="headerlink" title="自增、自减运算符"></a>自增、自减运算符</h3><p>自增和自减运算符只能用于变量，不能用于常量和表达式</p><table><thead><tr><th align="center">含义</th><th align="center">运算符</th><th align="center">优先级</th><th align="center">结合性</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">自增</td><td align="center">++</td><td align="center">2</td><td align="center">右结合</td><td align="center">使变量的值增1</td></tr><tr><td align="center">自减</td><td align="center">–</td><td align="center">2</td><td align="center">右结合</td><td align="center">使变量的值减1</td></tr></tbody></table><p>使用形式：</p><p>&ensp;&ensp;&ensp;&ensp;++i 或 –i 变量 i 先自增或自减 1，再引用 i</p><p>&ensp;&ensp;&ensp;&ensp;i++ 或 i– 先使用变量 i，再自增或自减1</p><h3 id="不同数据类型间的转换"><a href="#不同数据类型间的转换" class="headerlink" title="不同数据类型间的转换"></a>不同数据类型间的转换</h3><p>自动转换类型：数据类型自动由低级向高级转换</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402220849472.png" alt="自动转换类型图" style="zoom:33%;"><p>强制转换：将表达式的运算结果强制转换成指定的数据类型</p><p>格式：(数据类型说明符)(表达式)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="type">float</span> z;</span><br><span class="line">(<span class="type">float</span>)(x+y);<span class="comment">//浮点型</span></span><br><span class="line">(<span class="type">int</span>)z+x;<span class="comment">//整型</span></span><br></pre></td></tr></table></figure><h3 id="关系运算符（比较运算）"><a href="#关系运算符（比较运算）" class="headerlink" title="关系运算符（比较运算）"></a>关系运算符（比较运算）</h3><p>关系表达式：</p><p>&ensp;&ensp;&ensp;&ensp;格式：表达式1 关系运算符 表达式2;如：m+n &lt;&#x3D; 20; 成立表达式值为 1，不成立值为0</p><table><thead><tr><th align="center">含义</th><th align="center">运算符</th><th align="center">优先级</th><th align="center">结合性</th></tr></thead><tbody><tr><td align="center">小于</td><td align="center">&lt;</td><td align="center">6</td><td align="center">左结合</td></tr><tr><td align="center">小于等于</td><td align="center">&lt;&#x3D;</td><td align="center">6</td><td align="center">左结合</td></tr><tr><td align="center">大于</td><td align="center">&gt;</td><td align="center">6</td><td align="center">左结合</td></tr><tr><td align="center">大于等于</td><td align="center">&gt;&#x3D;</td><td align="center">6</td><td align="center">左结合</td></tr><tr><td align="center">等于</td><td align="center">&#x3D;&#x3D;</td><td align="center">7</td><td align="center">左结合</td></tr><tr><td align="center">不等于</td><td align="center">!&#x3D;</td><td align="center">7</td><td align="center">左结合</td></tr></tbody></table><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><table><thead><tr><th>含义</th><th>运算符</th><th>优先级</th><th>结合性</th><th>运算逻辑</th></tr></thead><tbody><tr><td>逻辑非</td><td>!</td><td>2</td><td>右结合</td><td>取反</td></tr><tr><td>逻辑与</td><td>&amp;&amp;</td><td>11</td><td>左结合</td><td>全真为真，其余为假</td></tr><tr><td>逻辑或</td><td>||</td><td>12</td><td>左结合</td><td>全假为假，其余为真</td></tr></tbody></table><h4 id="逻辑表达式"><a href="#逻辑表达式" class="headerlink" title="逻辑表达式"></a>逻辑表达式</h4><p>&ensp;&ensp;&ensp;&ensp;形式：表达式1 逻辑运算符 表达式2如：5 &gt; 3 &amp;&amp; 2 || 4 - !’a’</p><p>判断时，0 代表 假，非0 代表真</p><p>逻辑与 和 逻辑或 短路能力</p><p>&ensp;&ensp;&ensp;&ensp;逻辑与：只有表达式1值为真，才求表达式2 的值</p><p>&ensp;&ensp;&ensp;&ensp;逻辑或：只有表达式1值为假，才判断表达式2的值</p><h3 id="三目表达式"><a href="#三目表达式" class="headerlink" title="三目表达式"></a>三目表达式</h3><p>形式：表达式1 ? 表达式2 : 表达式3如：max &#x3D; (a&gt;b)?a:b;</p><p>如果表达式1为真，执行表达式2，为假，执行表达式3</p><p>最终判断出的值类型，为表达式2和表达式3 中较高的类型</p><p>可以嵌套的，这种嵌套是右结合，如：a &gt; b ? c : c &gt; d ? b : d;</p><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>复合赋值运算符：+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;、%&#x3D;优先级14，右结合性</p><h3 id="赋值表达式"><a href="#赋值表达式" class="headerlink" title="赋值表达式"></a>赋值表达式</h3><p>简单赋值表达式</p><p>&ensp;&ensp;&ensp;&ensp;格式：变量 &#x3D; 表达式如：k &#x3D; i+++–j</p><p>&ensp;&ensp;&ensp;&ensp;执行顺序：先计算，再赋值</p><p>复合表达式</p><p>&ensp;&ensp;&ensp;&ensp;x +&#x3D; y +&#x3D; z*z–&gt; x&#x3D; x+(y&#x3D;y+z*z)</p><h3 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h3><p>符号：,</p><p>优先级15，左结合</p><h3 id="逗号表达式"><a href="#逗号表达式" class="headerlink" title="逗号表达式"></a>逗号表达式</h3><p>格式：表达式1,表达式2,表达式3如：a &#x3D; 3*5,a*10,a+8</p><p>求解过程中：先求表达式1的值，再表达式2的值，再表达式n的值，<mark>表达式n</mark>的值作为<font color="red">整个逗号表达式的值</font></p><h2 id="选择结构（分支结构）"><a href="#选择结构（分支结构）" class="headerlink" title="选择结构（分支结构）"></a><center>选择结构（分支结构）</center></h2><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p>格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式) 语句<span class="number">1</span>;<span class="comment">//语句1，只能是一条语句</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(表达式)</span><br><span class="line">&#123;</span><br><span class="line">语句块<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>()</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>()</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：else 与 if 必须成对出现，且else总是与<mark>最近</mark>的一个未配对的 if 配对</p><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p>格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)<span class="comment">//表达式类型要与case后面常量值类型匹配，只能是整型、字符型或枚举型</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> 常量表达式:<span class="comment">//每个case后的常量表达式不允许相同</span></span><br><span class="line">语句<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> 常量表达式:</span><br><span class="line">语句<span class="number">2</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">语句n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>语句终止<span class="keyword">switch</span>语句的执行</span><br></pre></td></tr></table></figure><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a><center>循环结构</center></h2><h3 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h3><p>格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(表达式)</span><br><span class="line">&#123;</span><br><span class="line">    语句块;<span class="comment">//循环体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先判断，再执行，有可能一次也不执行</span></span><br></pre></td></tr></table></figure><p>注意：<br>&ensp;&ensp;&ensp;&ensp;1）while没有初始化语句，用户提前初始化好</p><p>&ensp;&ensp;&ensp;&ensp;2）while没有步进语句，用户必须在循环语句中写好步进语句</p><p>&ensp;&ensp;&ensp;&ensp;3）循环变量的值可以被引用、修改，但不能赋新值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test04</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=<span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">        i++;   <span class="comment">//步进条件 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum = %d\n&quot;</span>,sum);<span class="comment">//sum = 5050</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    test04();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当循环体是空语句或单个语句</span></span><br><span class="line"><span class="keyword">while</span>(x++ &lt; <span class="number">1000</span>);<span class="comment">//分号不能省略</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span>(x-- &gt; <span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,x);</span><br></pre></td></tr></table></figure><h3 id="do-while语句"><a href="#do-while语句" class="headerlink" title="do-while语句"></a>do-while语句</h3><p>格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//循环体语句</span></span><br><span class="line">&#125;<span class="keyword">while</span>(表达式);</span><br><span class="line"><span class="comment">//特点：先执行，再判断，至少执行一次循环体</span></span><br></pre></td></tr></table></figure><h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h3><p>格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始语句;循环条件;步进条件)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//循环语句</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始语句：只在循环开始时执行一次</span></span><br><span class="line"><span class="comment">//循环条件: 每次循环都要执行，如果循环条件为 真 进入循环体，如果为 假 退出循环</span></span><br><span class="line"><span class="comment">//步进条件：每次循环结束的时候要执行的语句</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始语句可以省略，但要在for语句之前给循环变量赋初值</span></span><br><span class="line"><span class="comment">//循环条件为空时，则会陷入死循环</span></span><br><span class="line"><span class="comment">//进步条件省略时，需要在循环体内写进步条件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始语句和进步条件可以有多项，若有多项则使用逗号表达式</span></span><br><span class="line"><span class="keyword">for</span>(s = <span class="number">0</span>,i = <span class="number">1</span>;i &lt;= <span class="number">100</span>;s += i,i++);</span><br><span class="line"></span><br><span class="line"><span class="comment">//单个语句时</span></span><br><span class="line"><span class="keyword">for</span>(初始语句;循环条件;步进条件)</span><br><span class="line">    语句;</span><br><span class="line"><span class="comment">//特点：先判断，再执行，有可能一次也不执行</span></span><br></pre></td></tr></table></figure><p>嵌套for循环：总结外层循环的次数*内层循环的次数&#x3D;&#x3D;总循环次数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并列的循环变量可以同名，但嵌套的循环变量不能同名</span></span><br><span class="line"><span class="keyword">for</span>(初始语句;循环条件;步进条件)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">for</span>(初始语句;循环条件;步进条件)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="comment">//循环语句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h2><p>格式：break;</p><p>作用：提前退出某个循环或跳出switch结构</p><p>只能在switch语句和循环体中使用</p><h2 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h2><p>格式：continue;</p><p>作用：结束本次循环，接着下次循环，通常与if语句连用</p><h2 id="数组与结构"><a href="#数组与结构" class="headerlink" title="数组与结构"></a><center>数组与结构</center></h2><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><p>格式：<font color="red">类型说明符 数组名[常量表达式];</font></p><p>常量表达式可以是 <mark>正</mark>整数常量、符号常量或常量表达式，不能包含变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 10</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">11</span>],b[N],c[<span class="string">&#x27;0&#x27;</span>];</span><br><span class="line"><span class="type">float</span> d[<span class="number">2</span>*N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//sizeof(类型) * 数组长度 = 总字节数</span></span><br><span class="line"><span class="type">int</span>(<span class="number">4</span>字节) * <span class="number">11</span> = <span class="number">44</span></span><br><span class="line"><span class="comment">//引用方式</span></span><br><span class="line">数组名 [下标]</span><br><span class="line"><span class="comment">//数组初始化</span></span><br><span class="line">类型符 数组名[表达式] = &#123;初值表&#125;;</span><br><span class="line"><span class="comment">//全部元素赋初值</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">8</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;<span class="comment">//初始数据个数&gt;数组长度，编译出错</span></span><br><span class="line"><span class="comment">//部分元素赋初值</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">8</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;<span class="comment">//剩下元素的初值为0</span></span><br><span class="line"><span class="comment">//给全部元素赋初值时可以不指定数组长度</span></span><br><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;<span class="comment">//数组长度是初值表中数值的个数</span></span><br><span class="line"><span class="comment">//当对全部数组元素初始化为0时，可以写成</span></span><br><span class="line"><span class="type">int</span> x[<span class="number">5</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">或 <span class="type">int</span> x[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//初值表不能为空 如：int a[5] = &#123;&#125;;但是可以int a[5]; 但元素值不确定</span></span><br><span class="line"><span class="comment">//如果没有初始化的数组，元素的值不确定</span></span><br></pre></td></tr></table></figure><p>数组是数目固定，类型相同的若干变量的有序集合</p><p>数组中每一个变量称为数组元素，属于同一个数据类型</p><p>数组在内存占有一段连续的存储空间</p><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>格式：类型说明符 数组名[常量表达式1] [常量表达式2];如：int a[3][4];</p><p>注意：下标从0开始</p><p>二维数组总字节数：行数 * 列数 * 类型字节数</p><h3 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h3><h1 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a><center>标准库</center></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如使用输入输出函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//使用字符串处理函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">//使用数学库中的函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span><span class="comment">//所有数学函数返回都是double型</span></span></span><br></pre></td></tr></table></figure><p>C语言中将 null 定义为 0，则null表示则为0</p><p>EOF：为-1</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><center>数据结构</center></h1><blockquote><p>课件：<a href="https://maifile.cn/est/a65c2e423881c5/pdf">https://maifile.cn/est/a65c2e423881c5/pdf</a></p></blockquote><h2 id="第二章-线性表"><a href="#第二章-线性表" class="headerlink" title="第二章 线性表"></a><center>第二章 线性表</center></h2><p>线性表定义：n(&gt;&#x3D; 0)个数据特性相同的元素的有限序列，记作(a1,a2,…..,an)</p><p>线性表逻辑结构：一对一</p><p>ai是表中数据元素，n是表长度</p><p>遍历：逐项访问，从前向后，从后向前</p><p>线性表特点：</p><p>&ensp;&ensp;&ensp;&ensp;除了第一个元素外，其他每一个元素有且只有一个<font color="red">直接前驱</font></p><p>&ensp;&ensp;&ensp;&ensp;除了最后一个元素外，其他每一个元素有且只有一个<font color="red">直接后驱</font></p><p>&ensp;&ensp;&ensp;&ensp;例：a1&lt;–&gt;a2&lt;—-&gt;a3&lt;—-&gt;a4</p><p>&ensp;&ensp;&ensp;&ensp;线性表的存储结构：顺序存储结构、链式存储结构（单链表、双链表、循环链表）</p><p>顺序表（顺序存储）：</p><p>&ensp;&ensp;&ensp;&ensp;每个节点只存放数据元素</p><p>&ensp;&ensp;&ensp;&ensp;定义：将线性表中的元素相继存放在一个连续的存储空间中</p><p>&ensp;&ensp;&ensp;&ensp;特点：线性表的顺序存储方式，可以随机存取</p><p>&ensp;&ensp;&ensp;&ensp;优点：可随机存取，存储密度高</p><p>&ensp;&ensp;&ensp;&ensp;缺点：要求大片连续空间，改变容量不方便</p><p>&ensp;&ensp;&ensp;&ensp;插入&#x2F;删除 要将后续元素后移&#x2F;前移动，可通过下表确定目标元素位置，时间开销主要移动元素(O(n))</p><p>&ensp;&ensp;&ensp;&ensp;按位查找 O(1) ，按值查找(需要对元素值一一比较) O(n)</p><p>链表（链式存储）</p><p>&ensp;&ensp;&ensp;&ensp;每个节点除了存放数据元素外，还存储向下一个节点的指针</p><p>&ensp;&ensp;&ensp;&ensp;优点：不要求大片连续空间，改变容量方便</p><p>&ensp;&ensp;&ensp;&ensp;缺点：不可随机存取，要耗费一定空间存放指针</p><p>&ensp;&ensp;&ensp;&ensp;单链表：无法逆向检索，增加头节点目的：方便运算的实现(使得对第一个元素的操作与其他元素操作相同)</p><p>&ensp;&ensp;&ensp;&ensp;双链表：可进退检索</p><p>&ensp;&ensp;&ensp;&ensp;空表：头节点指针域都指向头节点</p><p>&ensp;&ensp;&ensp;&ensp;循环单链表：表尾节点的指针指向头节点，形成循环</p><p>&ensp;&ensp;&ensp;&ensp;循环双链表：双向指针域，尾节点指向头节点，头节点指向下一个节点和尾节点，形成循环且可进退</p><p>&ensp;&ensp;&ensp;&ensp;复杂度：若从头节点找到尾部，时间复杂度为O(n)，n：n个元素</p><p>&ensp;&ensp;&ensp;&ensp;插入&#x2F;删除 元素只需修改指针即可，但需要遍历找到对应修改元素的位置，时间开销主要查找目标元素(O(n))</p><p>&ensp;&ensp;&ensp;&ensp;按位查找 O(n) ，按值查找 O(n)</p><p>总结：</p><p>&ensp;&ensp;&ensp;&ensp;链表：用于经常需要增加&#x2F;删除元素(弹性)</p><p>&ensp;&ensp;&ensp;&ensp;顺序表：用于查询(搜索)操作</p><p>栈：<code>先进后出</code>（全部元素不用全部进栈才可以出栈，进栈和出栈的顺序可组成不同的序列）</p><p>&ensp;&ensp;&ensp;&ensp;压栈(push)，出栈(pop)</p><p>队列：<code>先进先出</code></p><p>栈和队列的共同点：只允许端点处插入和删除元素，都是线性表</p><p>括号配对算法结构：栈 最佳</p><h2 id="串和广义表"><a href="#串和广义表" class="headerlink" title="串和广义表"></a><center>串和广义表</center></h2><h3 id="串"><a href="#串" class="headerlink" title="串"></a>串</h3><p>串或字符串：由零个或多个字符组成的有限序列</p><p>串也称为字符串，在 C 语言中是由数字、字母、下划线以及特殊字符组成的串字符，字符串需要用一对双引号括起来。在一个字符串中取一部分作为一个新字符串，这个新字符串叫子串，另一个叫做它的母串</p><p>s &#x3D; “a₁ a₂ a₃ … an” （n &gt;&#x3D; 0） n为串的长度</p><p>子串：串中任意个连续字符组成的子序列，包含字串的串称为主串</p><p>空串：零个字符的串</p><p>例：a &#x3D; “BEI”b &#x3D; “JING”c &#x3D; “BEIJING”d &#x3D; “BEI JING”</p><p>&ensp;&ensp;&ensp;&ensp;a和b都是c和d的字串，a在c和d中的位置都是1，b在c中的位置是4，在d中的位置是5</p><p>只有两个串的长度相等，并各个对应位置的字符都相等时，则这两个串都是相等的</p><h3 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h3><p>定义：广义表是线性表的推广，也称为列表</p><p>广义表的深度，可以通过观察该表中所包含括号的层数间接得到</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如：&#123;&#123;1,2&#125;,&#123;3,&#123;4,5&#125;&#125;&#125; 中，子表 &#123;1,2&#125; 和 &#123;3,&#123;4,5&#125;&#125; 位于同层，此广义表中包含 3 层括号，因此深度为 3</span><br></pre></td></tr></table></figure><p>广义表的长度(广度)：广义表中所包含的数据元素的个数</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如：广义表 &#123;&#123;a,b,c&#125;&#125; 中只有一个子表 &#123;a,b,c&#125;，因此它的长度为 1</span><br></pre></td></tr></table></figure><h2 id="树"><a href="#树" class="headerlink" title="树"></a><center>树</center></h2><p>树的逻辑结构：一对多</p><p>空树：节点数为0的树</p><p>有且只有一个根节点</p><p>没有后继的节点：叶子节点</p><p>有后继的节点：分支节点</p><p>除了根节点外，任何一个节点有且只有一个前驱</p><p>每个节点可以有 0 个或 多个后继</p><p>路径：由一节点到另一节点间的分支构成（只能从上往下）</p><p>路径长度：路径上的分支数目（经过几条边）</p><p>树的路径长度：树中所有叶子节点到根的路径长度之和</p><p>节点的层次(深度)：从上往下数</p><p>节点的高度：从下往上数</p><p>树的高度(深度)：总共有多少层</p><p>节点的度：有几个孩子(分支)</p><p>树的度：各节点的度的最大值</p><p>树的性质：</p><p>&ensp;&ensp;&ensp;&ensp;<code>总点数 = 总度数 + 1</code></p><p>&ensp;&ensp;&ensp;&ensp;m叉树：每个节点最多只能有m个孩子的树，可以是空树</p><p>&ensp;&ensp;&ensp;&ensp;度为 m 的树第 i 层最多有 m的 i-1 次方 个节点</p><p>&ensp;&ensp;&ensp;&ensp;m叉树第 i 层最多有 <code>m的 i-1次方</code> 个节点</p><p>&ensp;&ensp;&ensp;&ensp;高度为 h 的m叉树至多有几个节点（每一层都最多，则使用每层计算最多节点的方法再相加）</p><p>&ensp;&ensp;&ensp;&ensp;高度为 h 的m叉树至少有 h 个节点</p><p>&ensp;&ensp;&ensp;&ensp;高度为 h，度为m的树至少有 <code>h+m-1</code> 个节点</p><p>&ensp;&ensp;&ensp;&ensp;具有n个节点的m叉树的最小高度？ 每一层节点打满</p><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>特点：每个节点至多只有两颗子树，左右子树不能颠倒(二叉树是有序树)</p><p>任意二叉树满足：<code>n0 = n2 + 1</code></p><p>二叉树转森林：二叉树从根(包含)开始路过几个节点就有几个根，也就是有森林有几棵树</p><h4 id="满二叉"><a href="#满二叉" class="headerlink" title="满二叉"></a>满二叉</h4><p>&ensp;&ensp;&ensp;&ensp;一颗高度为h，含有 <code>2的h次方-1</code> 个节点的二叉树</p><p>&ensp;&ensp;&ensp;&ensp;特点：</p><p>&ensp;&ensp;&ensp;&ensp;只有最后一层有叶子节点</p><p>&ensp;&ensp;&ensp;&ensp;不存在度为1 的节点</p><p>&ensp;&ensp;&ensp;&ensp;按层序从1开始编号，节点 i 的左孩子为 2i，右孩子为 2i + 1，节点i的父亲节点为 i&#x2F;2(向下取整)</p><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>&ensp;&ensp;&ensp;&ensp;在满二叉树的基础上可去掉若干个编号更大的节点(最后几个缺失)，某节点只有一个孩子，一定是左孩子</p><p>&ensp;&ensp;&ensp;&ensp;高度：H &#x3D; ㏒₂N + 1</p><p>&ensp;&ensp;&ensp;&ensp;特点：</p><p>&ensp;&ensp;&ensp;&ensp;只有最后两层可能有叶子节点</p><p>&ensp;&ensp;&ensp;&ensp;最多只有一个度为 1 的节点</p><p>&ensp;&ensp;&ensp;&ensp;按层序从1开始编号，节点 i 的左孩子为 2i，右孩子为 2i + 1，节点i的父亲节点为 i&#x2F;2(向下取整)</p><p>&ensp;&ensp;&ensp;&ensp;i &lt;&#x3D; n&#x2F;2 为分支节点，i &gt; n&#x2F;2 为叶子节点  n：节点数</p><h4 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h4><p>&ensp;&ensp;&ensp;&ensp;左子树上所有节点的关键字均小于根节点的关键字</p><p>&ensp;&ensp;&ensp;&ensp;右子树上所有节点的关键字均大于根节点的关键字</p><p>&ensp;&ensp;&ensp;&ensp;左子树和右子树又各是一颗二叉排序树</p><p>&ensp;&ensp;&ensp;&ensp;判断二叉排序树的元素大小</p><p>&ensp;&ensp;&ensp;&ensp;在树图下方画个向右的坐标轴，从图中对应元素垂直到坐标轴，则可得到元素从小到大排序</p><p>&ensp;&ensp;&ensp;&ensp;查找(考察比较次数 &#x3D;&#x3D; 查找长度)</p><p>&ensp;&ensp;&ensp;&ensp;从上往下寻找，左树比根小，右数比根大，查找成功，返回结点指针，查找失败，返回null</p><p>&ensp;&ensp;&ensp;&ensp;查找成功时  平均查找长度(ASL)：每层的 查找长度 * 节点数 相加 &#x2F; 节点数</p><p>&ensp;&ensp;&ensp;&ensp;查找失败时  平均查找长度(ASL)：有叶子节点每一层的 同一层叶子节点数 * 查找长度 相加 &#x2F; 总叶子节点数</p><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>&ensp;&ensp;&ensp;&ensp;平衡二叉树是排序二叉树的特殊情况</p><p> &ensp;&ensp;&ensp;&ensp;树上，任一节点的左子树和右子树的深度之差不超过1</p><p>&ensp;&ensp;&ensp;&ensp;节点平衡因子 &#x3D; 左子树高 - 右子树高，只能是 <code>-1  0 或 1</code></p><h4 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h4><p>&ensp;&ensp;&ensp;&ensp;都是先左树后右树</p><p>&ensp;&ensp;&ensp;&ensp;先序遍历：根左右（从上到下，从左到右）</p><p>&ensp;&ensp;&ensp;&ensp;中序遍历：左根右（小嵌套再大嵌套）</p><p>&ensp;&ensp;&ensp;&ensp;后续遍历：左右根（小嵌套再大嵌套）</p><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402220848250.jpg" alt="二叉树遍历"></p><p>&ensp;&ensp;&ensp;&ensp;层序遍历：从上到下，从左到右</p><p>只给出前、中、后、层序遍历序列中的一种，可能对应多种二叉树形态，所以不能确定唯一一颗二叉树</p><p>需要两种来确定唯一（给出两个序列画图）</p><p>&ensp;&ensp;&ensp;&ensp;前序(确根) + 中序遍历(确左右)</p><p>&ensp;&ensp;&ensp;&ensp;后序(确根) + 中序遍历(确左右)</p><p>&ensp;&ensp;&ensp;&ensp;层序 + 中序遍历</p><h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><p>结点的权(节点上面的数值)：有某种显示含义的数值（如：表示结点的重要性等）</p><p><code>结点</code>的带权路径长度：从树的根到该结点的路径长度(经过边数) 与 该<code>结点上权值</code>的乘积</p><p><code>树</code>的带权路径长度(WPL)：树中所有<code>叶子结点</code>的带权路径长度之和</p><p>定义：含有n个带权叶子结点的二叉树中，其中树的<code>带权路径长度最小</code>的二叉树，哈夫曼树(最优二叉树)</p><p>构造</p><p>&ensp;&ensp;&ensp;&ensp;选取<code>权值最小</code>的结点构成新结点，新结点的权值为左 右子树上根结点权值之和，直到全部结点拼接完</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403172258571.png" alt="哈夫曼树构造" style="zoom:50%;"><p>&ensp;&ensp;&ensp;&ensp;特点：</p><p>&ensp;&ensp;&ensp;&ensp;每个初始结点(给出)最终都成为叶子结点，且权值越小的结点到根结点的路径长度越大</p><p>&ensp;&ensp;&ensp;&ensp;哈夫曼树的结点总数为：2n-1n：初始结点数</p><p>&ensp;&ensp;&ensp;&ensp;哈夫曼树中<code>不存在度为 1 的结点</code></p><p>&ensp;&ensp;&ensp;&ensp;哈夫曼树并不唯一，但WPL(树的带权路径长度)必然相同且最优</p><p>哈夫曼编码</p><p>&ensp;&ensp;&ensp;&ensp;固定长度编码：每个字符用相等长度的二进制表示</p><p>&ensp;&ensp;&ensp;&ensp;可变长编码：允许对不同字符用不等长的二进制位表示（使用哈夫曼树编辑二进制位）</p><p>&ensp;&ensp;&ensp;&ensp;前缀编码：没有一个编码是另一个编码的前缀，无歧义。非前缀编码有歧义</p><p>&ensp;&ensp;&ensp;&ensp;哈夫曼编码可以用于数据压缩</p><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>图(G)由顶点集(V)和边集(E)组成，|V|：图中顶点的个数|E|：图中边的条数</p><p>元素存在<code>多对多</code>的关系</p><p>图不可以是空，即 V 一定是非空集，但E可为0</p><p>有向图：边是有方向的(有向边)</p><p>G &#x3D; (V,E)</p><p>V &#x3D; {A,B,C,D,E}</p><p>E &#x3D; {&lt;A,B&gt;,&lt;A,C&gt;,&lt;A,D&gt;,&lt;A,E&gt;,&lt;B,A&gt;,&lt;B,C&gt;,&lt;B,E&gt;,&lt;C,D&gt;}</p><p>无向图：边是没有方向的(无向边)</p><p>G &#x3D; (V,E)</p><p>V &#x3D; {A,B,C,D,E}</p><p>E &#x3D; {(A,B),(B,D),(B,E),(C,D),(C,E),(D,E)}</p><p>简单图：不存在重复边，不存在顶点到自身的边（有向图中两个方向不同的边不属于重复边）</p><p>多重图：两个结点之间边数多余一条，允许顶点通过同一条边和自己联系</p><p>对于无向图</p><p>&ensp;&ensp;&ensp;&ensp;顶点的度：依附于该顶点的边的条数</p><p>&ensp;&ensp;&ensp;&ensp;无向图的全部顶点的度的和 等于 边数的2倍</p><p>对于有向图</p><p>&ensp;&ensp;&ensp;&ensp;入度(进来)：顶点 v 为终点的有向边的数目</p><p>&ensp;&ensp;&ensp;&ensp;出度(出去)：顶点 v 为起点的有向边的数目</p><p>&ensp;&ensp;&ensp;&ensp;顶点v的度：入度和出度之和入度之和 &#x3D; 出度之和 &#x3D; 边数</p><p>路径：顶点到顶点之间的路径</p><p>回路或环：第一个顶点和最后一个顶点相同的路径(构成闭环)</p><p>简单路径：顶点不重复出现的路径</p><p>简单回路：除了第一个顶点和最后一个顶点外，其余顶点不重复出现的回路</p><p>路径长度：路径上 边的数目</p><p>点到点的距离：顶点u到顶点v的最短路径若存在，则此路径的长度为u到v的距离，若不存在，则该距离为无穷(∞)</p><p>无向图中，顶点v 到 顶点w 有路径存在，则称 v 和 w 是<mark>连通</mark>的</p><p>有向图中，顶点v 到 顶点w 和 顶点w 到 顶点v 之间都有路径，则这两个顶点为<mark>强连通</mark>的</p><p>若图(无向)中，任意两个顶点都是连通的，则成为连通图，否则为非连通图</p><p>&ensp;&ensp;&ensp;&ensp;对于n个顶点的无向图G</p><p>&ensp;&ensp;&ensp;&ensp;若G是连通图，则最少有 <code>n-1</code> 条边</p><p>&ensp;&ensp;&ensp;&ensp;若G是非连通图，则最多可能有n(n-1)&#x2F;2</p><p>若图(有向)中，任何一堆顶点都是强连通，则此图为强连通图</p><p>&ensp;&ensp;&ensp;&ensp;n个顶点的强连通图，最少有<code>n</code>条边(形成回路)</p><p>生成子图：无向图中包含全部点(父图)</p><p>连通分量：无向图中有几个分开的整体，几个整体就是连通分量</p><p>强连通分量：有向图中有几个分开的整体，几个整体就是连通分量</p><p>连通图生成树：包含图中全部顶点，边尽可能少，但要保持连通</p><p>无向全连通图边数：<code>n(n-1)/2</code>n：顶点数</p><p>n个顶点有向图，每个顶点的度最大可达 <code>2(n-1)</code></p><h3 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h3><h4 id="邻接矩阵法"><a href="#邻接矩阵法" class="headerlink" title="邻接矩阵法"></a>邻接矩阵法</h4><p>&ensp;&ensp;&ensp;&ensp;注意：有向图的方向，<font color="red"><code>无向图</code></font><code>斜角45度对称</code></p><p>&ensp;&ensp;&ensp;&ensp;在无向图中，第i个结点的度 &#x3D; 第i行(或者第i列)的非零元素个数</p><p>&ensp;&ensp;&ensp;&ensp;在有向图中，第i个结点的<mark>出度</mark> &#x3D; 第i行的非零元素个数</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第i个结点的<mark>入度</mark> &#x3D; 第i列的非零元素个数</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;第i个结点的度 &#x3D; 第i行、第i列的非零元素的个数之和</p><p>&ensp;&ensp;&ensp;&ensp;邻接矩阵法求顶点的度 出度 入度 的时间复杂度为 O(|v|)v：顶点个数</p><p>&ensp;&ensp;&ensp;&ensp;邻接矩阵法：所占存储空间与顶点个数相关</p><p>&ensp;&ensp;&ensp;&ensp;结点数为n，邻接矩阵A是 n*n 的</p><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402220848000.jpg" alt="邻接矩阵法"></p><p>&ensp;&ensp;&ensp;&ensp;邻接矩阵法存储带权图</p><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402220847724.jpg" alt="邻接矩阵图_带权"></p><p>&ensp;&ensp;&ensp;&ensp;邻接矩阵图性能分析</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;空间复杂度：O(|v|²)v：顶点数只和顶点数有关，和实际边数无关</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;适合用于存储稠密图</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<code>无向图</code>的的邻接矩阵是<code>对称矩阵</code>，<code>可以压缩存储</code></p><h4 id="邻接表-顺序-链式存储"><a href="#邻接表-顺序-链式存储" class="headerlink" title="邻接表(顺序+链式存储)"></a>邻接表(顺序+链式存储)</h4><p>&ensp;&ensp;&ensp;&ensp;边结点的数量是2|E|（每条边被记录了两次）</p><p>&ensp;&ensp;&ensp;&ensp;无向图空间复杂度为：O(|v| + 2|E|)</p><p>&ensp;&ensp;&ensp;&ensp;有向图空间复杂度为：O(v+e)</p><p>&ensp;&ensp;&ensp;&ensp;排列方式：<code>不唯一</code>。存储稀疏图(边较少)</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402220847734.jpg" alt="邻接表法" style="zoom:50%;"><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402291650507.png" style="zoom:50%;"><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p>可能序列排序不唯一，按节点编号的<code>升序</code>一次访问</p><h4 id="广度优先遍历-BFS"><a href="#广度优先遍历-BFS" class="headerlink" title="广度优先遍历(BFS)"></a>广度优先遍历(BFS)</h4><p>树：类似<code>层序遍历</code>，一层一层遍历，先孩子再孙子，按编号升序访问</p><p>时间复杂度：O(n+e)n：顶点数  e：边数</p><p>使用<code>队列</code>数据结构</p><h4 id="深度优先遍历-DFS"><a href="#深度优先遍历-DFS" class="headerlink" title="深度优先遍历(DFS)"></a>深度优先遍历(DFS)</h4><p>树：类似<code>先序遍历</code>，一条直线走到底，走完再换另一个，按编号升序访问方向</p><p>时间复杂度：O(n+e)n：顶点数  e：边数</p><p>使用<code>栈</code>数据结构，是一个递归过程</p><p>图：</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402220846594.jpg" alt="图1" style="zoom:33%;"><p>广度优先：以2为先，21653748</p><p>深度优先：以3为先，34762158以2为先，21563478</p><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>连通图生成树：包含图中全部点，最少边，保持连通</p><p>最小生成树：带权值，边权值最小，<code>图形不唯一</code>，但最小代价唯一</p><h3 id="Prim算法-普里姆"><a href="#Prim算法-普里姆" class="headerlink" title="Prim算法(普里姆)"></a>Prim算法(普里姆)</h3><p>贪心算法</p><p>先选最小权值的边，再从以选中的顶点所附带的边中选择最小权值的边，以此类推，推出树图</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402220829529.jpg" alt="图2" style="zoom:33%;"><h3 id="Kruskal算法-克鲁斯卡尔"><a href="#Kruskal算法-克鲁斯卡尔" class="headerlink" title="Kruskal算法(克鲁斯卡尔)"></a>Kruskal算法(克鲁斯卡尔)</h3><p>贪心算法</p><p>每次选择一条权值最小的边，这条边两头连通（原本连通的就不选）</p><h2 id="排序-需要代码"><a href="#排序-需要代码" class="headerlink" title="排序(需要代码)"></a>排序(需要代码)</h2><h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><p>冒泡：把最大的或最小的冒到一边</p><p>每两个数字相互比较，按对应顺序排序，比较完一次，再和后面的一个数比较，以此类推</p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>类似打扑克牌时整理牌的顺序一样，从左往右整理</p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h3 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h3><p>只能在顺序存储，不能在链表，元素有序</p><h1 id="简答题备考"><a href="#简答题备考" class="headerlink" title="简答题备考"></a><center>简答题备考</center></h1><h2 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h2><p>机器语言：紧密依赖于计算机的硬件</p><p>高级语言：比较接近人们习惯使用的自然语言和数学语言</p><p>程序：一组计算机能识别和执行的指令</p><p>源程序：用高级语言编写的程序</p><p>常量：程序运行过程中不能改变的量</p><p>变量：程序运行过程中其值可以改变的量</p><p>变量名：以一个容易记忆的名字代表存储单元的地址</p><p>转义字符：将反斜杠 “\“ 后面的字符转换成另外的意义，输出信息时的控制符号 如 ‘\n’代表换行</p><p>字符串常量：一对双撇号括起来的字符序列</p><p>算术表达式：用算术运算符和括号将运算对象连接起来的、符合C语法规则的式子</p><p>数据结构：在程序中指定数据类型和数据的组织形式</p><p>算法：即操作步骤</p><p>修饰符：用来丰富格式字符功能的附加字符</p><p>关系表达式：用关系运算符将两个表达式连接起来的式子</p><p>逻辑表达式：用逻辑运算符将两个表达式连接起来的式子</p><p>用选择机构来检查所指定的条件是否满足，并根据判断的结果决定执行哪种操作</p><p>循环结构就是用来处理需要重复处理的问题</p><p>数组：具有相同类型的变量，用连续空间存储起来</p><p>字符数组：用来存放字符数据的数组</p><p>函数就是用来完成一定的功能的</p><p>函数的声明称为函数原型</p><p>递归调用：在调用一个函数的过程中又出现直接或间接地调用函数本身</p><p>局部变量：在函数或复合语句中定义的变量，只在本函数或复合语句内范围内有效</p><p>全局变量：在函数之外定义的变量，从定义变量到本源程序文件结束有效，在范围内可以为本程序文件中所有函数共用</p><p>静态存储：在程序运行期间由系统在静态存储区分配存储空间的方式，在程序运行期间不释放</p><p>动态存储：在函数调用期间根据需要在动态存储分配存储空间的方式</p><p>寄存器变量(register)：一些变量频繁使用，将局部变量的值放在CPU中的寄存器，寄存器对于存取速度远高于内存的存取速度，这样可以提高执行效率</p><p>内部函数(静态函数)：用static声明的，函数作用只局限于所在文件，其他文件不能引用</p><p>外部函数：函数首部最左端添加extern，可供其他文件调用</p><p>函数的定义：对函数功能的确立，包括指定函数名、函数值类型、形参及其类型以及函数体等，它是一个完整的、独立的函数单位</p><p>函数的声明：好吧函数的名字、函数类型以及形参的类型、个数和顺序通知编译系统，以便在调用该函数时系统按此进行对照检查</p><p>变量的定义：定义变量时，要指明数据类型，编译系统要据此给变量分配存储空间，称为定义行声明</p><p>变量的声明：不必指定数据类型，数据类型在定义时指定了，只是为了引用的需要，称为引用性声明</p><p>将地址形象化地称为“指针”</p><p>指针变量：一个变量专门用来存放另一个变量的地址</p><p>结构体：用户自己建立由不同类型的数据组成的组合型的数据结构</p><p>结构体数组：一个结构体变量中可以存放一组有关联的数据</p><p>结构体指针：指向结构</p><p>枚举：将变量的值一一列举出来，变量的值只限于列举出来的值的范围内</p><p>程序文件：包括源程序(后缀为.c)、目标文件(后缀.obj)、可执行文件(后缀为.exe)文件等。这种文件是用来存放程序的，以便实现程序的功能</p><p>数据文件：文件内容不是程序，而是供程序运行时读写的数据，或共程序运行时读入内存的数据</p><p>文件分类：按数据的组织形式，数据文件可分为<code>ASCII文件</code>和<code>二进制文件</code></p><h2 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h2><p>数据：客观事物的符号表示，是所有能输入计算机中并被计算机程序处理的符号的总称</p><p>数据元素：是数据的基本单位，在计算机中通常作为一个整体进行考虑</p><p>数据项：组成数据元素的、有独立含义的、不可分割的最小单位</p><p>数据对象：是性质相同的数据元素的集合，是数据的一个子集</p><p>数据结构：相互之间存在一种或多种特定关系的数据元素的集合</p><p>算法：为了解决某类问题而规定的一个有限长的操作序列</p><p>算法特性：有穷性、确定性、可行性、输入、输出</p><p>算法基本标准：正确性、可读性、健壮性、高效性</p><p>线性表：由n个数据特性相同的元素构成的有限序列</p><p>&ensp;&ensp;&ensp;&ensp;如学生基本信息表，每个学生为一个数据元素，包括学号、姓名、性别、籍贯等数据项</p><p>节点：存储七本身的信息之外，还需存储一个指示七直接后继的信息，这两部分信息组成数据元素的存储映像</p><p>数据域：存储数据元素信息的域</p><p>指针域：存储直接后继存储位置的域</p><p>链表：n个节点链接成的表</p><p>栈：限定仅在表尾进行插入或删除操作的线性表</p><p>栈底：表头端</p><p>栈顶：表尾端</p><p>队列：一种先进先出的线性表</p><p>队尾：允许插入的一端</p><p>对头：允许删除的一端</p><p>栈和队列都有：顺序和链式存储</p><p>串也称为字符串，在 C 语言中是由数字、字母、下划线以及特殊字符组成的串字符，字符串需要用一对双引号括起来。在一个字符串中取一部分作为一个新字符串，这个新字符串叫子串，另一个叫做它的母串</p><p>树：n个节点的有限集</p><p>森林：n棵互不相交的树的集合</p><p>图(G)：由两个集合V和E组成，记为G &#x3D; (V,E)，V是顶点的有穷非空集合，E是V中顶点偶对的有穷集合，这些顶点偶对 称为 边</p><p>查找表：由同一个类型的数据元素构成的集合</p><p>关键字：数据元素中某个数据项的值，用它可以标识一个数据元素</p><p>&ensp;&ensp;&ensp;&ensp;主关键字：此关键字可以唯一地标识一个记录</p><p>&ensp;&ensp;&ensp;&ensp;次关键字：用以识别若干记录的关键字</p><p>查找：指根据给定的某个值，在查找表中确定一个关键字等于给定值的记录或数据元素，如果存在查找成功，不存在查找失败</p><p>查找分类：顺序查找、折半查找、分块查找</p><p>排序：按关键字的非递减或非递增顺序对一组记录重新进行排列的操作</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C语言程序和程序设计概述&quot;&gt;&lt;a href=&quot;#C语言程序和程序设计概述&quot; class=&quot;headerlink&quot; title=&quot;C语言程序和程序设计概述&quot;&gt;&lt;/a&gt;&lt;center&gt;C语言程序和程序设计概述&lt;/center&gt;&lt;/h1&gt;&lt;p&gt;程序：可以连续执行的一条条</summary>
      
    
    
    
    <category term="升学" scheme="http://example.com/categories/%E5%8D%87%E5%AD%A6/"/>
    
    
    <category term="计算机程序与基础" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>25.网络编程</title>
    <link href="http://example.com/post/f1dbdc9f.html"/>
    <id>http://example.com/post/f1dbdc9f.html</id>
    <published>2023-12-30T05:12:09.000Z</published>
    <updated>2024-03-01T15:03:29.738Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识点一：什么是网络编程"><a href="#知识点一：什么是网络编程" class="headerlink" title="知识点一：什么是网络编程"></a><center>知识点一：什么是网络编程</center></h1><p>Java是Internet上语言，它从语言级别上提供了对网络编程支持，程序猿可以利用Java语言进行网络应用程序编写，Java提供大量网络库，可以实现不同网络连接【TCP&#x2F;UDP】，联网的底层实现已经被Java进行封装了，只需调用网络包中提供实现类方法就可以完成网络编程</p><p>网络编程就是提供互联网应用程序，互联网是什么？把分布在不同区域的计算机与专门外部设备进行通信相互链接在一起，提供一个强大网络关系，从而通过链接网络就可以方便计算机与计算机之间的信息传递，共享硬件，数据和软件信息</p><p>之所以计算机之间可以进行网络通信是因为提供网络连接【网线和wifi】</p><h1 id="知识点二：网络通信协议"><a href="#知识点二：网络通信协议" class="headerlink" title="知识点二：网络通信协议"></a><center>知识点二：网络通信协议</center></h1><p>网络通信协议就是联网设备之间可以进行更好交互，需要遵守一套通信规则</p><p>通讯协议有两套【一套是理论协议和一套是实际操作协议】</p><h2 id="1、OSI通信模型【网络7层协议】"><a href="#1、OSI通信模型【网络7层协议】" class="headerlink" title="1、OSI通信模型【网络7层协议】"></a><center>1、OSI通信模型【网络7层协议】</center></h2><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012250386.png" alt="OSI通信模型"></p><p>在7协议的基础至少之上进行网络协议修改，修改之后的协议更加适合现实生活中网络的实现【TCP&#x2F;IP通信模型】</p><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012250533.png" alt="层次"></p><p>在这个模型中 传输层和网络层是需要使用的，提供TCP&#x2F;IP编程可以完成网络通信操作</p><h1 id="知识点三：网络编程三要素"><a href="#知识点三：网络编程三要素" class="headerlink" title="知识点三：网络编程三要素"></a><center>知识点三：网络编程三要素</center></h1><p><strong>协议、IP地址、端口号</strong>，在这三个要素的前提下得到到两种网络编程模式【软件结构】-&gt; <strong>C&#x2F;S架构和B&#x2F;S架构</strong></p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012251097.png" alt="三要素" style="zoom:50%;"><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012252229.png" alt="B/S结构" style="zoom:50%;"><p>其实这两种框架开发时各有有点，但是无论是那种框架，都要离不开【“网络”】，需要提供网络编程，就可以架构通信操作了</p><h2 id="1、协议"><a href="#1、协议" class="headerlink" title="1、协议"></a><center>1、协议</center></h2><p>通信协议是计算必须遵守规则， 只有遵守规则才可以进行计算机与计算机之间通信，这就好比道路中行驶的汽车必须遵守交通规则，通讯协议也是一样的，通信协议中提供对数据的【传输格式、传输速率、传输步骤】等等都提供统一的规范，通讯双方必须遵守这个规范，最终完成数据的交换</p><h2 id="2、TCP协议"><a href="#2、TCP协议" class="headerlink" title="2、TCP协议"></a><center>2、TCP协议</center></h2><p>在 java.net 这个包中就提供了这种常见协议：</p><p>TCP：传输控制协议，TCP协议是<strong>面向连接</strong>的通信协议，即传输数据之前，在发送端和接收端需要建立起逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输</p><p>TCP协议的特点: <strong>面向连接、传输数据安全、传输速度低</strong></p><p>例如： 大宝发现了李四家里牛丢了</p><p>&ensp;&ensp;&ensp;&ensp;TCP协议： 大宝一定要找到李四，面对面的告诉他你们家牛丢了</p><p>TCP如何保证面向连接安全？</p><p>&ensp;&ensp;&ensp;&ensp;TCP在连接时会进行【<strong>三次握手</strong>】，TCP协议中，在发送数据的准备阶段，客户端与服务器之间进行三次交互，以保证可靠连接</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012253925.png" alt="TCP协议" style="zoom:50%;"><p>第一次握手： 客户端向服务器发送连接请求，等待服务器确认</p><p>第二次握手：服务器端接收客户端请求并向客户端回送一个响应，通知客户端收到了连接请求</p><p>第三次握手：客户端接收到服务器响应，再次向服务器端发送确认信息，确认连接</p><p>客户端与服务器之间就可以开始进行通信操作了</p><p>完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了，由于这种连接时面思连接的特性，所以TCP协议可以保证传输数据的安全，所以TCP通信协议被广泛的应用【HTTP协议（网页浏览）、文件上传、文件下载】等等</p><p>三次握手可以理解为打电话</p><p>&ensp;&ensp;&ensp;&ensp;第一次握手就相当于 —》 你拿起电话开始拨号</p><p>&ensp;&ensp;&ensp;&ensp;第二次握手就相当于 —》 对方拿起电话说“喂”</p><p>&ensp;&ensp;&ensp;&ensp;第三次握手就相当于 —》 听到“喂”就说明两端连同，开始通话</p><h2 id="3、UDP协议"><a href="#3、UDP协议" class="headerlink" title="3、UDP协议"></a><center>3、UDP协议</center></h2><p>在 java.net 这个包中就提供了这种常见协议：</p><p>UDP被称之为 【数据报（文）协议】，UDP协议是一个面向无连接的协议，传输数据时候，不需要建立连接，不管对方服务器是否启动，【直接将数据，数据源和目的地都封装到数据包，直接发送】，每个数据包的大小被限制在64KB，因为连接不可靠而且是面向无连接，所以它传输速度快，但是容易丢包【数据】，日日常应用中：视频、游戏等等</p><p>例如： 大宝发现了李四家里牛丢了</p><p>UDP协议： 大宝在村里的广播站广播以下李四你家牛丢了，效率快</p><h2 id="4、IP地址"><a href="#4、IP地址" class="headerlink" title="4、IP地址"></a><center>4、IP地址</center></h2><p>IP地址：是互联网中协议地址，俗称IP，<strong>IP地址用来给一个网络中的计算机设备做唯一的编号</strong></p><p>IP地址分类</p><p>&ensp;&ensp;&ensp;&ensp;IPv4：是一个32位的二进制数，通常被划分4个字节，表示形式D.D.D.D 形式表示</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;例如： 192.168.10.27 这就是IP地址，其中的每一位即 D 范围是一个从0~255结束范围 ，最多表示42亿个IP地址，就算这样全世界的IPv4地址已经没有了</p><p>&ensp;&ensp;&ensp;&ensp;IPv6：中国主导的，随着全世界互联网网络发展IPv4已经不能满足所有需求，但是网络资源地址还是需要的，使用IPv6来缓解IPv4的缺失，IPv6是一个128位的二进制数，每16个字节划分一组，8组16进制，表示形成 F.F.F.F.F.F.F.F</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;例如： fdb2:2c26:f4e4:0:3421:943d:8040:8eef</p><p><strong>windows中CMD中 输入 ipconfig可以查看本机的IP地址</strong></p><p>所有的人电脑其实在出厂时都有自己的一个IP地址，这个IP地址是供给计算机内容进行通信使用，称之为“环形网络”–》这个IP地址是127.0.0.1 –》 称之为 localhost</p><h2 id="5、端口号"><a href="#5、端口号" class="headerlink" title="5、端口号"></a><center>5、端口号</center></h2><p>网络的通信，本质上是有两个进程（应用程序）的通信，每台计算机都有很多的进程，那么在网络通信时，如何区分是哪个进程呢？</p><p>如果说“IP地址”可以唯一标识网络中的设备，那么“端口号”就可以唯一标识设备中进程（应用程序)了</p><p>端口号：用两个字节标识的整数，它的取值范围是0<del>65535。其中，**0</del>1023之间端口号用于一些知名的网络服务器与系统应用<strong>，普通的应用程序需啊哟使用1024以上的端口号。</strong>如果端口号被另外一个服务器或应用程序所占用，会导致当前程序启动失败**</p><p>开中常见端口号 ： MySQL ： 3306 Oracle 1521 或 1520 Tomcat： 8080</p><p>利用这个三个组合 <strong>协议 + IP地址 + 端口号</strong>就可以提供网络中进程（应用程序）</p><h1 id="知识点四：InteAddress类"><a href="#知识点四：InteAddress类" class="headerlink" title="知识点四：InteAddress类"></a><center>知识点四：InteAddress类</center></h1><p>此类表示互联网协议 (IP) 地址，能够通过InetAddress这个类获取到IP地址，InteAddress也可以理解为一个IP地址的在Java代码中抽象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterAddressDemo</span> 。</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------创建局域网IP地址对象-------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//1.使用本机的IP地址创建对象</span></span><br><span class="line">        <span class="comment">//提供一个编译时异常Unhandled exception: java.net.UnknownHostException【无法获取主机（IP地址）】</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">localHost</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">        <span class="comment">//获取封装在对象中IP地址</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ip地址：&quot;</span>+localHost.getHostAddress());</span><br><span class="line">        <span class="comment">//获取封装在对象中主机名</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主机名：&quot;</span>+localHost.getHostName());</span><br><span class="line">        <span class="comment">//通过赋值IP地址来创建IP地址对象 --》这个参数也可以赋值为 localhost(主机) ---》赋值网络域名</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">byName</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;10.211.55.3&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------创建外网IP地址对象-------------------------------&quot;</span>);</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">byName1</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;百度IP地址：&quot;</span>+byName1.getHostAddress());</span><br><span class="line">        System.out.println(<span class="string">&quot;百度主机名：&quot;</span>+byName1.getHostName());</span><br><span class="line">        <span class="comment">//判断连接访问 ---》 ping命令</span></span><br><span class="line">        System.out.println(<span class="string">&quot;2秒内是否可以访问到？&quot;</span>+ byName1.isReachable(<span class="number">2000</span>));    <span class="comment">// ping www.baidu.com</span></span><br><span class="line">        <span class="comment">//获取IP地址对象中所有的信息</span></span><br><span class="line">        InetAddress[] allByName = InetAddress.getAllByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(InetAddress ip : allByName)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(ip);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点五：TCP协议编程"><a href="#知识点五：TCP协议编程" class="headerlink" title="知识点五：TCP协议编程"></a><center>知识点五：TCP协议编程</center></h1><p>Java中TCP协议编程并不需要我们从头开始写，Java已经在net包中提供操作，专门提供两个类来完成TCP操作</p><p><strong>Socket</strong>【客户端】：此类实现客户端套接字（也可以就叫“套接字”）。套接字是两台机器间通信的端点</p><p><strong>ServerSocket</strong>【服务器】：此类实现服务器套接字。服务器套接字等待请求通过网络传入。它基于该请求执行某些操作，然后可能向请求者返回结果</p><p>因为TCP连接时面向连接的，也就是属于“长连接”，所以需要进行关闭操作，<strong>客户端是可以与服务器进行通信使用的是字节流</strong></p><p>案例1</p><p>&ensp;&ensp;&ensp;&ensp;需求：客户端向服务器发送请求，并传递数据发送【服务你好】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.TCP.V1;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="comment">//客户端程序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建客户端对象提供IP地址和端口号</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            第一个参数：字符串类型IP地址</span></span><br><span class="line"><span class="comment">            第二个参数：通信端口号</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;10.211.55.3&quot;</span>,<span class="number">8888</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端信息：&quot;</span>+client);</span><br><span class="line">        <span class="comment">//2.获取网络字节输出流对象【建立一条客户端通向服务器的通道】</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> client.getOutputStream();</span><br><span class="line">        <span class="comment">//利用字节输入流的对象向服务器发送数据即可</span></span><br><span class="line">        outputStream.write(<span class="string">&quot;服务器你好，我是客户端，来自远方问候.....嘿嘿(*^▽^*)！！！&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">//强烈推荐在使用网路流传输数据时必须要写刷新</span></span><br><span class="line">        outputStream.flush();</span><br><span class="line">        <span class="comment">//3.关闭客户端</span></span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">package</span> com.qfedu.TCP.V1;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建服务器端对象，参数只有一个需要和客户端一样的端口号</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器在等待客户端的链接.......&quot;</span>);</span><br><span class="line">        <span class="comment">//2.通过服务器端对象调用 accept 方法获取到连接服务器的客户端对象进行操作</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">sClient</span> <span class="operator">=</span> server.accept();    <span class="comment">//返回的是客户端的信息(端口号等信息)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;恭喜!来自客户端&quot;</span>+sClient+<span class="string">&quot;已经链接上了.......&quot;</span>);</span><br><span class="line">        <span class="comment">//3.创建网络字节输入流对象，获取传输的数据【建立客户端与服务器连接通道】</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> sClient.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> inputStream.read(bs);</span><br><span class="line">        <span class="comment">//4.打印客户端的信息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;来自客户端的信息是：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(bs,<span class="number">0</span>,len));</span><br><span class="line">        <span class="comment">//5.关闭服务器</span></span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>案例2</p><p>&ensp;&ensp;&ensp;&ensp;需求：此时客户端与服务器之间是建立了连接发送了信息，客户端服务器发送了信息，服务器要给客户端予以响应</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.TCP.V2;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="comment">//客户端程序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建客户端对象提供IP地址和端口号</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            第一个参数是字符串类型IP地址</span></span><br><span class="line"><span class="comment">            第二个参数通信端口号</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;10.211.55.3&quot;</span>,<span class="number">8888</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端信息：&quot;</span>+client);</span><br><span class="line">        <span class="comment">//2.获取网络字节输出流对象【建立一条客户端通向服务器的通道】</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> client.getOutputStream();</span><br><span class="line">        <span class="comment">//利用字节输入流的对象向服务器发送数据即可</span></span><br><span class="line">        outputStream.write(<span class="string">&quot;服务器你好，我是客户端，来自远方问候.....嘿嘿(*^▽^*)！！！&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">//强烈推荐在使用网路流传输数据时必须要写刷新</span></span><br><span class="line">        outputStream.flush();</span><br><span class="line">        <span class="comment">//3.接收服务器的反馈信息[获取网络字节输入流对象]</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> client.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> inputStream.read(bs);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前来之服务器的反馈信息：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(bs,<span class="number">0</span>,len));</span><br><span class="line">        <span class="comment">//4.关闭客户端</span></span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">package</span> com.qfedu.TCP.V2;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建服务器端对象，参数只有一个需要和客户端一样的端口号</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器在等待客户端的链接.......&quot;</span>);</span><br><span class="line">        <span class="comment">//2.通过服务器端对象调用 accept 方法获取到连接服务器的客户端对象进行操作</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">sClient</span> <span class="operator">=</span> server.accept();</span><br><span class="line">        System.out.println(<span class="string">&quot;恭喜!来自客户端&quot;</span>+sClient+<span class="string">&quot;已经链接上了.......&quot;</span>);</span><br><span class="line">        <span class="comment">//3.创建网络字节输入流对象，获取传输的数据【建立客户端与服务器连接通道】</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> sClient.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> inputStream.read(bs);</span><br><span class="line">        <span class="comment">//4.打印客户端的信息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;来之客户端的信息是：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(bs,<span class="number">0</span>,len));</span><br><span class="line">        <span class="comment">//5.服务器向客户予以响应</span></span><br><span class="line">        <span class="comment">//5.1提供网络字节输出流对象</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> sClient.getOutputStream();</span><br><span class="line">        outputStream.write(<span class="string">&quot;已收到信息，感谢访问(#^.^#)！&quot;</span>.getBytes());</span><br><span class="line">        outputStream.flush();</span><br><span class="line">        <span class="comment">//6.关闭服务器</span></span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>案例3</p><p>&ensp;&ensp;&ensp;&ensp;需求: 提供客户端与服务器之间聊天程序， 当某一个方输入 886 停止聊天</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.TCP.V3;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="comment">//提供一个客户端程序，完成客户端接收与发送信息给服务器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供客户端对象</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;10.211.55.3&quot;</span>,<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//2.提供网络字节输入输出流对象</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">//3.提供Scanner获取控制台信息</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端向服务器说：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> input.next();</span><br><span class="line">            outputStream.write(content.getBytes());</span><br><span class="line">            outputStream.flush();</span><br><span class="line">            <span class="comment">//做了一个约定，如果哪一方输入886 就关闭聊天</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;886&quot;</span>.equals(content))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//提供数组存数据操作</span></span><br><span class="line">            <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> inputStream.read(bs);</span><br><span class="line">            System.out.println(<span class="string">&quot;来之服务器的信息：&quot;</span>+ <span class="keyword">new</span> <span class="title class_">String</span>(bs,<span class="number">0</span>,len));</span><br><span class="line">        &#125; </span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">package</span> com.qfedu.TCP.V3;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span></span><br><span class="line">Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建服务器端对象</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//2.利用serverSocket对象中accept方法获取客户端连接</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">accept</span> <span class="operator">=</span> server.accept();</span><br><span class="line">        <span class="comment">//3.提供网络字节输入输出流对象完成信息发送</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> accept.getInputStream();</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> accept.getOutputStream();</span><br><span class="line">        <span class="comment">//4.提供控制台获取数据</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//4.1接收客户端向服务器发送的数据</span></span><br><span class="line">            <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> inputStream.read(bs);</span><br><span class="line">            <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bs,<span class="number">0</span>,len);</span><br><span class="line">            System.out.println(<span class="string">&quot;来之客户端的信息：&quot;</span>+content);</span><br><span class="line">            <span class="comment">//判断客户单输入的输入的数据是什么</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;886&quot;</span>.equals(content))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//4.2服务器向客户端发送数据</span></span><br><span class="line">            System.out.println(<span class="string">&quot;服务器端向客户端说：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> input.next();</span><br><span class="line">            outputStream.write(str.getBytes());</span><br><span class="line">            outputStream.flush();</span><br><span class="line">        &#125; </span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1、使用TCP模拟Tomcat服务器"><a href="#1、使用TCP模拟Tomcat服务器" class="headerlink" title="1、使用TCP模拟Tomcat服务器"></a><center>1、使用TCP模拟Tomcat服务器</center></h2><p>需求：利用浏览器进行网页访问，访问服务器中HTML页面，展示服务器端HTML页面在浏览器中</p><p>需要在项目中提供web目录并在web目录下提供html页面</p><p>在浏览器中访问地址时：</p><p>&ensp;&ensp;&ensp;&ensp;IP地址:服务器端口号&#x2F;访问资源路径 –》 相当于 –》127.0.0.1:9999&#x2F;web&#x2F;regist.html</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="comment">//利用ServerSocket模拟Tomcat服务器提供网页访问服务器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TomcatServer</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.通过读取浏览器页面请求信息，获取浏览器需要访问的路径</span></span><br><span class="line">        <span class="comment">//提供ServerSocket服务器端对象</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//调用accept方法获取连接的客户端</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> server.accept();</span><br><span class="line">        <span class="comment">//通过返回socket对象获取网络字节输入流对象【建立连接通道】</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="comment">//将字节流转换为字符流【缓冲的】--》读取到字符串了</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream));</span><br><span class="line">        <span class="comment">//利用字符缓冲输入流读取文件访问路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">        System.out.println(path);</span><br><span class="line">        <span class="comment">//利用空格将path路径进行分隔，获取到访问资源路径</span></span><br><span class="line">        String[] s = path.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="comment">//通过下标获取出资源路径，将路径最前面的/去掉</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> s[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;浏览器访问服务器的资源路径：&quot;</span>+realPath);</span><br><span class="line">        <span class="comment">//利用相对路径读取服务器中相对路径中资源反馈给浏览器</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(realPath);</span><br><span class="line">        <span class="comment">//在通过accept方法获取Socket对象获取网络字节输出流【将流中数据反馈给浏览器】</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">//开始读写</span></span><br><span class="line">        <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8192</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="comment">//响应页面的时候需要将服务器返回给浏览器的必要信息</span></span><br><span class="line">        outputStream.write(<span class="string">&quot;HTTP/1.1 200OK\r\n&quot;</span>.getBytes());</span><br><span class="line">        outputStream.write(<span class="string">&quot;ContentType:text/html\r\n&quot;</span>.getBytes());</span><br><span class="line">        outputStream.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(bs))!=-<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            outputStream.write(bs,<span class="number">0</span>,len);</span><br><span class="line">        &#125; </span><br><span class="line">        outputStream.flush();</span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">        fis.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点六：UDP协议编程（了解）"><a href="#知识点六：UDP协议编程（了解）" class="headerlink" title="知识点六：UDP协议编程（了解）"></a><center>知识点六：UDP协议编程（了解）</center></h1><p>Java中也提供UDP编程操作提供两个必要类：</p><p>&ensp;&ensp;&ensp;&ensp;<strong>DatagramSocket【即是客户端也是服务器】 和DatagramPacket【UDP需要的数据包】</strong></p><p>UDP是无责任的发送模式类似于【广播电台】，UDP发送数据是不保证包安全，UDP的客户端与服务器是同一个类，发送数据时候需要使用DatagramPacket进行数据封装，包的限制64K</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.UDP;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketException;</span><br><span class="line"><span class="comment">//UDP发送数据类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Send</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建UDP对象</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">sender</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">        <span class="comment">//2.提供信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;今天天气好晴朗，下班要下雨了，赶快跑路....&quot;</span>;</span><br><span class="line">        <span class="comment">//3.提供数据包将数据封装到包中</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(</span><br><span class="line">            content.getBytes(),            <span class="comment">//提供数据字节数组</span></span><br><span class="line">            content.getBytes().length,    <span class="comment">//字节数组的长度</span></span><br><span class="line">            InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="comment">//设置发送IP地址</span></span><br><span class="line">            <span class="number">9999</span>    <span class="comment">//发送端口号</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//发送信息</span></span><br><span class="line">        sender.send(packet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketException;</span><br><span class="line"><span class="comment">//UDP接收类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Receiver</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建UDP对象并指定接收数据端口号</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">receiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//2.需要提供byte类型数据接收存数据</span></span><br><span class="line">        <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//3.创建数据包对象</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bs,bs.length);</span><br><span class="line">        <span class="comment">//接收数据存储在包对象中</span></span><br><span class="line">        receiver.receive(packet);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        拆包:</span></span><br><span class="line"><span class="comment">            getData() 获取包中字节数组</span></span><br><span class="line"><span class="comment">            getLength() 获取包中字节数组的长度</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(packet.getData(),<span class="number">0</span>,packet.getLength());</span><br><span class="line">        System.out.println(content);</span><br><span class="line">        receiver.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;知识点一：什么是网络编程&quot;&gt;&lt;a href=&quot;#知识点一：什么是网络编程&quot; class=&quot;headerlink&quot; title=&quot;知识点一：什么是网络编程&quot;&gt;&lt;/a&gt;&lt;center&gt;知识点一：什么是网络编程&lt;/center&gt;&lt;/h1&gt;&lt;p&gt;Java是Internet</summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>26.反射</title>
    <link href="http://example.com/post/5883a4af.html"/>
    <id>http://example.com/post/5883a4af.html</id>
    <published>2023-12-30T05:11:56.000Z</published>
    <updated>2024-03-01T15:13:58.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识点一：类的加载"><a href="#知识点一：类的加载" class="headerlink" title="知识点一：类的加载"></a><center>知识点一：类的加载</center></h1><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012304354.png" alt="类的加载过程" style="zoom: 50%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qf.Demo03;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作者：星仔</span></span><br><span class="line"><span class="comment"> * 描述：永无Bug</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反射：在程序运行期获取的相关信息（对象、构造、方法、属性..）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 以前创建对象：通过new关键字去创建</span></span><br><span class="line"><span class="comment">     *      User user = new User();</span></span><br><span class="line"><span class="comment">     * 如果学习了反射，那么可以在代码运行期间创建类的对象（String）</span></span><br><span class="line"><span class="comment">     * 类的对象：通过new关键字创建的对象是类的对象（可以创建多个）</span></span><br><span class="line"><span class="comment">     * 类对象：在类加载的时候会产生一个类对象（包含类的所有的信息：属性、方法、构造方法、父类、接口、包名）（只会有一个）</span></span><br><span class="line"><span class="comment">     * 所有类的类对象的类型是Class类型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 类加载的时机；</span></span><br><span class="line"><span class="comment">     *      1.创建对象</span></span><br><span class="line"><span class="comment">     *      2.创建子类对象</span></span><br><span class="line"><span class="comment">     *      3.调用类中的静态方法和属性</span></span><br><span class="line"><span class="comment">     *      4.通过Class.forName(&quot;&quot;);  主动触发类加载</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在JVM中类的加载是有细分操作，当程序启动时候说那个到某个类，如果该类被加载到内存中，则JVM会通过三个步骤进行类的初始化操作【加载、连接和初始化】</p><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012304757.png" alt="初始化"></p><h1 id="知识点二：什么是Class对象？"><a href="#知识点二：什么是Class对象？" class="headerlink" title="知识点二：什么是Class对象？"></a><center>知识点二：什么是Class对象？</center></h1><p>PS：在Java中提供一个类这个类叫做Class，用于存储类的字节码文件对象【存储自定义类中描述信息】</p><p>例如：Java中需要创建某个类的对象</p><p>做法： Student stu &#x3D; new Student(); —》通过Student类来创建stu这个对象，stu对象是Student类的实例，在创建过程中隐藏了一些内部实现的细节【类的加载】，就可以直接在代码中使用stu这个对象触发Student类中的属性和方法了</p><p>&ensp;&ensp;&ensp;&ensp;Java是一门面向对象的语言，面向对象核心【世间万物皆对象】，所有东西都以对象角度为出发来进行思考，既然是这样那么就可以看待提供stu这个实例的类也是一个对象，那么Java就提供了一个可以描述自定义类的类Class【即描述类的类】，在整个类的加载过程中，反复提到了一点就是在类的字节文件【.class文件】加载到内存中时候，会生成一个【Class类的对象】，整个对象存中存储的就是类中所描述的信息，所以外界就可以提供Student stu &#x3D; new Student(); —》通过Student类来创建stu这个对象</p><p>&ensp;&ensp;&ensp;&ensp;但是除了这种创建方式之外，因为JVM中是存在Class类对象的，所以Java就提供了另外一种方式，可以直接通过Class类的对象加载出来对应类的对象操作，这个操作就叫做“【反射reflect】”</p><p>正常创建对象 —》 Student stu &#x3D; new Student()；</p><p>但是在JVM中先得到Student类的.class字节码文件，通过字节码文件创建出Student这类的对象</p><p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012305610.png" alt="解说"></p><h1 id="知识点三：获取Class对象"><a href="#知识点三：获取Class对象" class="headerlink" title="知识点三：获取Class对象"></a><center>知识点三：获取Class对象</center></h1><p>如何获取Class对象,一共有三种方式获取类对象</p><p>&ensp;&ensp;&ensp;&ensp;1、通过对象的getClass方法</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;应用场景：必须有类的对象</p><p>&ensp;&ensp;&ensp;&ensp;2、通过类的class属性</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;应用场景：一般多用于方法传参</p><p>&ensp;&ensp;&ensp;&ensp;3、通过Class类的forName方法</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;应用场景：一般在运行期获取类对象(使用较多)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfeud.JDBC2.reflect;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassTest</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//通过Class类的对象获取Student类的对象</span></span><br><span class="line">        <span class="comment">//1.正常创建Student类的对象操作</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;stu就是Student类的对象&quot;</span>);</span><br><span class="line">        <span class="comment">//通过反射获取到Student类的class对象并创建Student类的对象</span></span><br><span class="line">        <span class="comment">//1.通过Class类中静态方法，forName获取Student类的对象【Class对象】</span></span><br><span class="line">        <span class="comment">//参数需要是一个类的全限定名称【包名+类名】</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">aClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.qfeud.JDBC2.reflect.Student&quot;</span>);</span><br><span class="line">        <span class="comment">//此时aClass对象就代表着Student类的【Class对象】</span></span><br><span class="line">        <span class="comment">//Class对象存储的就是Student类中提供描述信息，所以可以得到 Student类的对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot;通过反射得到o对象是Student类的对象吗？&quot;</span>+(o <span class="keyword">instanceof</span> Student));</span><br><span class="line">        <span class="comment">//2.Java中每个类都有一个静态方法，Class类是描述类的类，那么所有类都是Class的实例(即Class对象)</span></span><br><span class="line">        <span class="comment">// Java中每个类都了一调用class这个静态方法获取到Class类的对象</span></span><br><span class="line">        Class&lt;Student&gt; studentClass = Student.class;    <span class="comment">//Class对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> studentClass.newInstance();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            3.利用了Object类中提供getClass方法获取到Class对象【强烈不推荐】</span></span><br><span class="line"><span class="comment">            PS：这个操作需要创建类的对象，并通过对象调用从Object类中继承而来的方法进行获取</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">aClass1</span> <span class="operator">=</span> stu1.getClass();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> aClass1.newInstance();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Class类中提供方法有两个比较常用</span></span><br><span class="line"><span class="comment">            newInstance() 这个方法是可以通过Class对象创建出与之相关联的类的对象【调用时无参方法】</span></span><br><span class="line"><span class="comment">            getName()     这个方法可以获取到类的全限定名称 ---&gt; 包名+类名</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.out.println(aClass1.getName());</span><br><span class="line">        System.out.println(stu);</span><br><span class="line">        <span class="comment">//强烈推荐第一种方式来获取Class对象，它不收到.java源文件的影响</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java中有九大内置Class对象【他们是JVM预先加载好的Class实例】 –》 【byte、short、int、long、float、double、char、boolean、void】其中八中基本数据类型对应包装类中存在一个静态属性Type，这个Type属性就可以获取到基本数据类型所对应Class对象</p><p>当执行 Integer.Type 等价于 int.class</p><p>除此之外Class对象还支持数组，得到数组的Class对象只能通过 数据类型[].class 或 数据对象.getClass()</p><h1 id="知识点四：反射操作"><a href="#知识点四：反射操作" class="headerlink" title="知识点四：反射操作"></a><center>知识点四：反射操作</center></h1><p>反射其实可以帮组我们做很多的操作，通过分装性将属性和方法进行私有化操作，但是私有化的属性和方法之后，外界就无法获取到属性和方法，如果通过反射的形式来获取类属性和方法可以无视权限修饰符，在返回面前是没有权限修饰符可言，<strong>可以利用反射中操作形成【代理模式】，可以通过【代理模式】动态向类中添加方法【在不改变原码的前提下添加类中方法】—》spring框架（IOC&#x2F;AOP）</strong>，反射可以作为资源文件加载操作方式</p><h2 id="1、Class对象的常用方法"><a href="#1、Class对象的常用方法" class="headerlink" title="1、Class对象的常用方法"></a><center>1、Class对象的常用方法</center></h2><ul><li>c.getSimpleName() 获取类名</li><li>c.getName() 获取类的全限定名</li><li>c.getSuperclass(); 获取父类的类对象</li><li>c.getInterfaces(); 获取父接口的类对象，返回的是一个数组</li><li>newInstance(); 通过类对象创建的类的对象</li></ul><p>调用newInstance方法需要注意：</p><ul><li>1、这个了类必须有一个无参构造方法 InstantiationException</li><li>2、这个类的构造方法必须是public修饰 IllegalAccessException</li></ul><p>提供演示操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个是一个类的 ---&gt; 提供Student类中一些方法属性操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> age,String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Student</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个没有参数的方法&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span> a)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个参数的方法&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span> a ,String b)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是多个参数的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">package</span> com.qfeud.JDBC2.reflect;</span><br><span class="line"><span class="keyword">import</span> jdk.nashorn.internal.ir.CallNode;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//利用反射来处理这个类的操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1. 获取到Student类的class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">aClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.qfeud.JDBC2.reflect.Student&quot;</span>);</span><br><span class="line">        <span class="comment">//2.通过反射获取到类中所提供构造方法【Constructor】</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        相当于通过反射操作获取到Constructor构造方法对象，在通过这个对象创建类的对象</span></span><br><span class="line"><span class="comment">        这个方法可以获取到class对象中对应类的构造方法对象,参数是可变参数</span></span><br><span class="line"><span class="comment">        【这个参数如果不传递（不赋值得到就是无参构造方法）、这个参数进行传递(赋值操作，根据赋值个数决定获取对应构造方法)】</span></span><br><span class="line"><span class="comment">        getConstructor(Class&lt;?&gt;... parameterTypes)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//获取到的就是constructor对象【就是Student类中无参构造方法的对象】</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> aClass.getConstructor();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            这个方法是使用constructor构造方法对象调用newInstance方法</span></span><br><span class="line"><span class="comment">            操作就相当于间接的调用对应构造方法得到这个class对象中存储类的对应对象</span></span><br><span class="line"><span class="comment">            newInstance(Object ... initargs) 方法中使用也是可变参数</span></span><br><span class="line"><span class="comment">            所以这个方法参数的传递时根据getConstructor这个方法的参数决定的，如果getConstructor方法没有设置参数</span></span><br><span class="line"><span class="comment">            newInstance这个方法也要没有参数 --》触发的就是无参构造方法</span></span><br><span class="line"><span class="comment">            如果如果getConstructor方法设置参数调用 newInstance这个方法也要给与参数，就是对构造方法参数的赋值</span></span><br><span class="line"><span class="comment">            PS：之前演示Class这个操作的时候，提供newInstance方法调用，并没有获取Constructor对象</span></span><br><span class="line"><span class="comment">            这样操作也是可以的，但是只能调用类中提供无参构造方法，无法选择有参构造方法</span></span><br><span class="line"><span class="comment">            这个方式调用构造方法必须是公有的</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> constructor.newInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot;此时o这个对象得到是Student类的对象吗?&quot;</span>+(o <span class="keyword">instanceof</span> Student));</span><br><span class="line">        <span class="comment">//通过上面方式获取有参构造方法的操作 ---》 方法参数传递就是传递方法参数的 class对象</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            获取有参构造方法的对象必须传递方法参数class对象到getConstructor这个方法中</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor1</span> <span class="operator">=</span> aClass.getConstructor(<span class="type">int</span>.class,String.class);</span><br><span class="line">        <span class="comment">//对构造方法中参数进行赋值操作了</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> constructor1.newInstance(<span class="number">18</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="comment">//得到这个返回值类型时Object类型，所以得到操作是不能直接使用子类数据的</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> (Student)o1;</span><br><span class="line">        System.out.println(<span class="string">&quot;stu对象中age属性的值是：&quot;</span>+stu.age);</span><br><span class="line">        <span class="comment">//反射操作---》在反射面前是没有任何权限修饰符可言 ---》 利用反射操作获取到私有构造方法对象</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            获取到非public修饰的构造方法、属性或方法怎么办？</span></span><br><span class="line"><span class="comment">            在Class这个类中提供带有 Declared 单词的方法就是 ---》 翻译为暴力反射[无视权限修饰符]</span></span><br><span class="line"><span class="comment">            getDeclaredConstructor 这个方法的使用和getConstructor方法是一样的</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor2</span> <span class="operator">=</span> aClass.getDeclaredConstructor(String.class);</span><br><span class="line">        <span class="comment">//private权限是一个特殊权限，因为在权限修饰符中代表最低权限，为了防止外界恶意进行暴力反射</span></span><br><span class="line">        <span class="comment">//反射获取到操作对象之后，需要再次做一个操作，开启访问权限</span></span><br><span class="line">        <span class="comment">//setAccessible这个是开启权限的方法，参数是boolean类型，如果为true就开启权限，false就是不开启</span></span><br><span class="line">        constructor2.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> constructor2.newInstance(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu2</span> <span class="operator">=</span> (Student)o2;</span><br><span class="line">        System.out.println(<span class="string">&quot;stu对象中name属性的值是：&quot;</span>+stu2.getName());</span><br><span class="line">        <span class="comment">//类中通过反射访问类中属性</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            通过两个反射方法获取 getField() --&gt; 针对的public修饰的属性</span></span><br><span class="line"><span class="comment">                               DeclaredField() ---&gt; 针对非public(private)修饰的属性</span></span><br><span class="line"><span class="comment">            通过属性对象调用setAccessible(true)开启权限配合使用 ---》 针对private使用</span></span><br><span class="line"><span class="comment">            通过反射方法可以得到一个 Field对象 ---》这个对象可以操作类中属性</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">age</span> <span class="operator">=</span> aClass.getField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        <span class="comment">//获取这个属性值如何操作？</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            只需要使用Field类中提供 get方法即可以获取到 属性值，但是get方法是有参数</span></span><br><span class="line"><span class="comment">            这个参数就是通过反射创建的对象即通过newInstance创建出来的对象</span></span><br><span class="line"><span class="comment">            PS:获取的是静态变量 get方法参数就是null值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o3</span> <span class="operator">=</span> age.get(stu);</span><br><span class="line">        System.out.println(<span class="string">&quot;stu这个对象中age属性的值是：&quot;</span>+o3);</span><br><span class="line">        <span class="comment">//对类中提供属性进行赋值操作？</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        只需要使用Field类中提供 set方法即可以对属性进行赋值</span></span><br><span class="line"><span class="comment">        这个方法有两个参数</span></span><br><span class="line"><span class="comment">            第一个参数:一共有两种赋值方式，原则是根据获取的数据类型决定【成员变量还是静态变量】</span></span><br><span class="line"><span class="comment">            如果是成员变量 ---》 这个参数就是通过反射创建的对象即通过newInstance创建出来的对象</span></span><br><span class="line"><span class="comment">            如果是静态变量 ---》 null ---》 对应的是Static修饰符</span></span><br><span class="line"><span class="comment">            第二个参数对属性赋值的具体数据</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        age.set(stu,<span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;stu对象中age属性修改之后的数据是：&quot;</span>+age.get(stu));</span><br><span class="line">        <span class="comment">//【重点记忆】 ---》 获取类中方法操作【通过反射】</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            通过两个反射方法获取</span></span><br><span class="line"><span class="comment">                getMethod() --&gt; 针对的public修饰的方法</span></span><br><span class="line"><span class="comment">                DeclaredMethod() ---&gt; 针对非public修饰的方法</span></span><br><span class="line"><span class="comment">            通过属性对象调用</span></span><br><span class="line"><span class="comment">                setAccessible(true)开启权限配合使用 --&gt; 针对private</span></span><br><span class="line"><span class="comment">            通过反射获取方法的操作是需要两个参数的</span></span><br><span class="line"><span class="comment">                第一个参数 : 方法的名字</span></span><br><span class="line"><span class="comment">                第二个参数： 是一个可变参数，需要传递方法中参数的数据类型---》是class对象</span></span><br><span class="line"><span class="comment">                不传递参数赋值就是无参方法 传递参数赋值就是有参方法</span></span><br><span class="line"><span class="comment">                getMethod(String name, Class&lt;?&gt;...parameterTypes)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">show</span> <span class="operator">=</span> aClass.getMethod(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">        <span class="comment">//得到是一个方法对象要执行方法</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            需要调用 invoke这个方法，这个方法也是有两个参数</span></span><br><span class="line"><span class="comment">            第一个参数:</span></span><br><span class="line"><span class="comment">                一共有两种赋值方式，原则是根据获取的方法类型决定【成员方法还是静态方法】</span></span><br><span class="line"><span class="comment">                    如果是成员变量 ---》 这个参数就是通过反射创建的对象即通过newInstance创建出来的对象</span></span><br><span class="line"><span class="comment">                    如果是静态变量 ---》 null ---》 对应的是Static修饰符</span></span><br><span class="line"><span class="comment">            第二个参数:</span></span><br><span class="line"><span class="comment">                需要和getMethod方法相配合 ，如果调用无参方法，这个可变参数就不传递数据</span></span><br><span class="line"><span class="comment">                如果调用有参反方，这个可变参数就需要进行赋值操作</span></span><br><span class="line"><span class="comment">                invoke(Object obj, Object... args)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        show.invoke(stu);</span><br><span class="line">        <span class="comment">//获取一个show方法对象，如果方法有参数，需要将方法参数类型Class对象传递到参数中</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">show1</span> <span class="operator">=</span> aClass.getMethod(<span class="string">&quot;show&quot;</span>, <span class="type">int</span>.class,</span><br><span class="line"><span class="type">int</span>.class);</span><br><span class="line">        show1.invoke(stu,<span class="number">1</span>,<span class="number">1</span>);    <span class="comment">//对应数据类型赋值即可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>可以利用反射操作在没有【.java】文件的前提之下可以操作类【构造方法、属性和方法】</p><p>针对与使用public修饰构造方法、成员或静态属性和成员或静态方法 —》提供方法是</p><p>&ensp;&ensp;&ensp;&ensp;getConstructor() —-》 获取构造方法  —》配套使用方法 —》 newInstance()</p><p>&ensp;&ensp;&ensp;&ensp;getField() —》 获取属性的 —》配套使用方法—》 get获取 、 set赋值【这个方法中如果是成员属性需要传递反射创建对象，如果是静态属性传递null】</p><p>&ensp;&ensp;&ensp;&ensp;getMethod —》 获取方法的 【重点记忆】—》 配套使用方法 –》 invoke() 【这个方法中如果是成员方法需要传递反射创建对象，如果是静态方法传递null】</p><p>如果遇到非public修饰的，可以使用带有Declared单词的方法记性获取，并且如果修饰符是private修饰那么就需要配合使用setAccessible(true)开启权限</p><h2 id="2、利用反射可以直接加载properties文件"><a href="#2、利用反射可以直接加载properties文件" class="headerlink" title="2、利用反射可以直接加载properties文件"></a><center>2、利用反射可以直接加载properties文件</center></h2><p>这个操作是在开发中比较常见的一种方式，多用于对资源文件加载</p><p>在工程中创建文件夹就不能是普通文件夹，这里需要创建是一个资源文件夹【Source Folder】</p><p>这个文件在工程内部的特点：自动编译文件夹中所有文件并且添加到classPath路径【也就是说将文件添加到工程内部存储字节码文件的文件夹中】，就可以利用反射进行文件的加载</p><p>PS:资源文件夹在项目中是以【“蓝色标色”】，在工程中src这个文件夹就是资源文件夹</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfeud.JDBC2.reflect;</span><br><span class="line"><span class="keyword">import</span> jdk.nashorn.internal.ir.CallNode;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectReadPropertiesFile</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//使用这种方式加载文件，这个文件必须在资源文件夹中</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            利用的原理就是 使用类加载器对classPath路径中文件进行加载，会返回一个流资源对象</span></span><br><span class="line"><span class="comment">            类的加载器在加载这个文件时会去classPath(在IDEA中就是out目录)下寻找这个同名文件</span></span><br><span class="line"><span class="comment">            建立流资源进行读取操作</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//提供一个Properties资源文件对象</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">//提供一个类的加载器【每一个类都有类的加载器】</span></span><br><span class="line">        <span class="comment">//利用线程对象获取类的加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">contextClassLoader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">        <span class="comment">//利用本类的class对象获取类的加载器</span></span><br><span class="line">        <span class="comment">//ClassLoader classLoader = ReflectReadPropertiesFile.class.getClassLoader();</span></span><br><span class="line">        <span class="comment">//使用类的加载器对象加载资源文件夹--》这个方法的参数不需要路径，只要文件名字就可以了</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> contextClassLoader.getResourceAsStream(<span class="string">&quot;db.properties&quot;</span>);</span><br><span class="line">        <span class="comment">//通过字节输入流对象加载资源</span></span><br><span class="line">        p.load(resourceAsStream);</span><br><span class="line">        System.out.println(p);</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">resourceAsStream1</span> <span class="operator">=</span>ReflectReadPropertiesFile.class.getClassLoader()</span><br><span class="line">                                                            .getResourceAsStream(<span class="string">&quot;db.properties&quot;</span>);</span><br><span class="line">        <span class="comment">//这个方法只能在JavaSE中调用在，在后续学习中EE中是不可以调用</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">systemResourceAsStream</span> <span class="operator">=</span> contextClassLoader.getSystemResourceAsStream(<span class="string">&quot;db.properties&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、扩展：静态方法和数组参数如何传递"><a href="#3、扩展：静态方法和数组参数如何传递" class="headerlink" title="3、扩展：静态方法和数组参数如何传递"></a><center>3、扩展：静态方法和数组参数如何传递</center></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfeud.JDBC2.reflect;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>    <span class="comment">//这是一个员工类</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">(<span class="type">int</span>... arr)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doWork1被调用了:&quot;</span>+ Arrays.toString(arr));</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">(String... arr)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doWork1被调用了:&quot;</span>+ Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectInvokeStaticMethod</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这里简化获取操作</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">employeeClass</span> <span class="operator">=</span> Employee.class;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">doWork</span> <span class="operator">=</span> employeeClass.getMethod(<span class="string">&quot;doWork&quot;</span>,<span class="type">int</span>[].class);</span><br><span class="line">        <span class="comment">//调用静态方法执行并对可变参数进行赋值操作</span></span><br><span class="line">        <span class="comment">//执行方法时，如果是静态方法第一个参数传递null值,第二个参数需要传递一个数组对象进来</span></span><br><span class="line">        doWork.invoke(<span class="literal">null</span>,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">doWork1</span> <span class="operator">=</span> employeeClass.getMethod(<span class="string">&quot;doWork&quot;</span>, String[].class);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            如果此时方法的参数类型是存储引用类型数组，此时通过反射方式调用，编译器对方法参数的认知不是String</span></span><br><span class="line"><span class="comment">            认知为当前参数是一个Object类型的数组，这个数组中存储这个String类型数组</span></span><br><span class="line"><span class="comment">            即将String类型的数组作为Object类型数组的一个元素存储</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        doWork1.invoke(<span class="literal">null</span>,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>&#125;&#125;);</span><br><span class="line">        <span class="comment">//提示：只要是数组作为方法的参数类型，无论是基本数据类型数据还是引用数据类型的数组</span></span><br><span class="line">        <span class="comment">// 统一作为反射调用方法参数传递时，都使用 new</span></span><br><span class="line">        Object[]&#123;具体数据值&#125;；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点五：Stream流"><a href="#知识点五：Stream流" class="headerlink" title="知识点五：Stream流"></a><center>知识点五：Stream流</center></h1><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a><center>1、概念</center></h2><p>流（Stream）与集合类似，但集合中保存的是数据，而Stream中保存对集合或数组数据的操作</p><h2 id="2、Stream特点"><a href="#2、Stream特点" class="headerlink" title="2、Stream特点"></a><center>2、Stream特点</center></h2><p>Stream 自己不会存储元素</p><p>Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</p><p>Stream 操作是延迟执行的，会等到需要结果的时候才执行</p><h2 id="3、Stream使用步骤"><a href="#3、Stream使用步骤" class="headerlink" title="3、Stream使用步骤"></a><center>3、Stream使用步骤</center></h2><p>创建：</p><p>&ensp;&ensp;&ensp;&ensp;新建一个流</p><p>中间操作：</p><p>&ensp;&ensp;&ensp;&ensp;在一个或多个步骤中，将初始Stream转化到另一个Stream的中间操作。</p><p>终止操作：</p><p>&ensp;&ensp;&ensp;&ensp;使用一个终止操作来产生一个结果。该操作会强制之前的延迟操作立即执行，在此之后，该Stream就不能使用了</p><h2 id="4、创建Stream的方法"><a href="#4、创建Stream的方法" class="headerlink" title="4、创建Stream的方法"></a><center>4、创建Stream的方法</center></h2><ol><li>通过Collection对象的stream()或parallelStream()方法</li><li>通过Arrays类的stream()方法</li><li>通过Stream接口的of()、iterate()、generate()方法</li><li>通过IntStream、LongStream、DoubleStream接口中的of、range、rangeClosed方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取Stream对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;22&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;456557&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;56789&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">    <span class="comment">//list.forEach(System.out::println);    //集合中有forEach遍历方法</span></span><br><span class="line">    <span class="comment">//通过集合对象获取Stream对象</span></span><br><span class="line">    Stream&lt;String&gt; stream = list.stream();</span><br><span class="line">    stream.forEach(s -&gt; System.out.println(s));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取Stream对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">IntStream</span> <span class="variable">stream</span> <span class="operator">=</span> Arrays.stream(arr);    <span class="comment">//返回一种流</span></span><br><span class="line">    stream.forEach(System.out::println);    <span class="comment">//快捷方式：soutc</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//获取Stream对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王五&quot;</span>);</span><br><span class="line">    stream.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、中间操作的方法"><a href="#5、中间操作的方法" class="headerlink" title="5、中间操作的方法"></a><center>5、中间操作的方法</center></h2><p>常见中间操作方法：</p><ul><li>filter、limit、skip、distinct、sorted</li><li>map</li><li>parallel</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Stream对象中常用的方法 中间操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;22&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;456557&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;56789&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">    <span class="comment">//获取集合中长度大于3的元素</span></span><br><span class="line">    <span class="comment">//list.stream().filter(li -&gt; li.length()&gt;3).forEach(System.out::println);</span></span><br><span class="line">    <span class="comment">//获取集合的第一页数据（前三条）</span></span><br><span class="line">    <span class="comment">//list.stream().limit(3).forEach(System.out::println);</span></span><br><span class="line">    <span class="comment">//获取集合的第二页数据（4~6条）</span></span><br><span class="line">    <span class="comment">//list.stream().skip(3).limit(3).forEach(System.out::println);</span></span><br><span class="line"><span class="comment">//第一个三是跳过几个元素,第二个是获取几个</span></span><br><span class="line">    <span class="comment">//获取集合中不重复的元素</span></span><br><span class="line">    <span class="comment">//list.stream().distinct().forEach(System.out::println);</span></span><br><span class="line">    <span class="comment">//将集合中的元素进行排序(注意：集合中的元素必须实现了Comparable接口)</span></span><br><span class="line">    <span class="comment">//list.stream().sorted().forEach(System.out::println);</span></span><br><span class="line">    <span class="comment">//将集合中的元素进行排序(按照元素的长度降序)</span></span><br><span class="line">    <span class="comment">//list.stream().sorted((o1, o2) -&gt; o2.length() - o1.length()).forEach(System.out::println);</span></span><br><span class="line">    <span class="comment">//将集合中的元素转换成int类型</span></span><br><span class="line">    <span class="comment">//list.stream().map(li -&gt; Integer.parseInt(li)+1).forEach(System.out::println);</span></span><br><span class="line">    <span class="comment">//list.stream().map(Integer::parseInt).forEach(System.out::println);</span></span><br><span class="line">    <span class="comment">//使用多线程操作集合中的元素</span></span><br><span class="line">    <span class="comment">// list.stream().forEach(li-&gt;    //单线程操作</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//     System.out.println(Thread.currentThread().getName()+&quot;=====&gt;&quot;+li);</span></span><br><span class="line">    <span class="comment">//&#125;);</span></span><br><span class="line">    list.stream().parallel().forEach(li-&gt;    <span class="comment">//多线程操作</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=====&gt;&quot;</span>+li);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、终止操作"><a href="#6、终止操作" class="headerlink" title="6、终止操作"></a><center>6、终止操作</center></h2><p>常见终止操作：</p><ul><li>forEach、min、max、count</li><li>reduce、collect</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Stream对象中常用的方法 终止操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m5</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;22&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;456557&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;562789&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">    <span class="comment">//遍历集合中的元素</span></span><br><span class="line">    <span class="comment">//list.forEach(System.out::println);</span></span><br><span class="line">    <span class="comment">//list.stream().forEach(System.out::println);</span></span><br><span class="line">    <span class="comment">//获取集合中元素长度最小的元素</span></span><br><span class="line">    <span class="comment">//Optional&lt;String&gt; min = list.stream().min((o1, o2) -&gt; o1.length() - o2.length());</span></span><br><span class="line">    <span class="comment">//System.out.println(min.get());</span></span><br><span class="line">    <span class="comment">//Optional&lt;String&gt; max = list.stream().max((o1, o2) -&gt; o1.length() - o2.length());</span></span><br><span class="line">    <span class="comment">//System.out.println(max.get());</span></span><br><span class="line">    <span class="comment">//获取集合中长度为3的元素个数</span></span><br><span class="line">    <span class="comment">//long count = list.stream().filter(li -&gt; li.length() == 3).count();</span></span><br><span class="line">    <span class="comment">//System.out.println(count);</span></span><br><span class="line">    <span class="comment">//将集合中的元素转成int类型并计算总和(计算)</span></span><br><span class="line">    <span class="comment">//Integer result = list.stream().map(Integer::parseInt).reduce(0, (o1, o2) -&gt; o1 + o2);</span></span><br><span class="line">    <span class="comment">//System.out.println(result);</span></span><br><span class="line">    <span class="comment">//将Stream流对象转换成List、set、Map集合</span></span><br><span class="line">    List&lt;String&gt; collect = list.stream().filter(li -&gt; li.contains(<span class="string">&quot;2&quot;</span>)).collect(Collectors.toList());</span><br><span class="line">    collect.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;知识点一：类的加载&quot;&gt;&lt;a href=&quot;#知识点一：类的加载&quot; class=&quot;headerlink&quot; title=&quot;知识点一：类的加载&quot;&gt;&lt;/a&gt;&lt;center&gt;知识点一：类的加载&lt;/center&gt;&lt;/h1&gt;&lt;img src=&quot;https://cdn.jsdeli</summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>24.多线程</title>
    <link href="http://example.com/post/fbc0ae86.html"/>
    <id>http://example.com/post/fbc0ae86.html</id>
    <published>2023-12-30T05:11:26.000Z</published>
    <updated>2024-03-01T14:49:02.328Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识点一：Thread线程基础"><a href="#知识点一：Thread线程基础" class="headerlink" title="知识点一：Thread线程基础"></a><center>知识点一：Thread线程基础</center></h1><p>有一个场景：在一个程序中即可以玩游戏又可以播放音乐？</p><p>以现在编程手段而言 —》 提供编程结构【顺序、分支、循环】</p><p>代码是要遵守顺序执行，代码需要遵守从上至下逐行执行，利用分支和循环修改循环执行一些操作，选择性执行某代码或者是让某些代码重复执行，无论如何操作代码依旧要顺序执行，没有办法让两段代交替执行</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012202919.png" alt="线程流程" style="zoom: 50%;"><p>此时Java为了解决这样的问题，提供一个操作，这个操作就叫做<strong>线程</strong>，可以在代码中使用多线程形式来完成这个操作</p><p>PS:现在电脑基本上都是多核CPU，所以每个人电脑上运行线程程序结果可能都不一样，这是一个非常正常现象，多线程运行时是一个不可预知状态，程序猿可以通过代码干预线程运行，以达到我们运行效果</p><h1 id="知识点二：并行和并发"><a href="#知识点二：并行和并发" class="headerlink" title="知识点二：并行和并发"></a><center>知识点二：并行和并发</center></h1><p>这两个概念在宏观的角度而言他们是一样(相似)的，但是在微观的角度而言他们是有区别</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012203194.png" alt="并行和并发" style="zoom:50%;"><p><strong>并行就是同时执行，并发就是在交替执行</strong></p><p>&ensp;&ensp;&ensp;&ensp;在操作系统中，安装了很多程序，并发指的是在一段时间内宏观上多个程序同时执行，这个在单个CPU系统中，每一个时刻只有一个程序执行，即微观上这些程序是分时交替的执行，只不过给人感觉是在同时运行，因为分时交替运行时间非常短暂</p><p>&ensp;&ensp;&ensp;&ensp;现在而言都是多核CPU，则这些并发执行程序可以分配到不同的处理器上（CPU），实现多个任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序就可以同时执行了，你的电脑CPU核心越多你电脑的性能就相对更加强悍</p><p>PS:单核处理的计算机肯定是不能并行处理多个任务，只能是多个任务在单个CPU上并发需要运行，同理线程也是一样的从宏观的角度而言线程并行运行从微观角度看就是串行运行，即线程是一个一个去执行的，当系统只有一个CPU是，线程会以某种顺序执行多个线程，这个情况称之线程调度【线程提供CPU时间争抢】</p><h1 id="知识点三：线程和进程"><a href="#知识点三：线程和进程" class="headerlink" title="知识点三：线程和进程"></a><center>知识点三：线程和进程</center></h1><p><strong>进程</strong></p><p>&ensp;&ensp;&ensp;&ensp;进程是程序的一次执行过程，是系统运行程序的基本单元，系统运行一个程序即在运行一个进程【从创建、运行、消亡的一个过程】，每一个进程都有自己一个独立的空间【内存空间】，一个应用程序(进程)可以同时运行多个线程</p><p>特点：</p><ol><li>进程是一个独立程序单元并且拥有自己独立空间</li><li>一个进程中可以同时运行多个线程</li></ol><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012204035.png" alt="进程" style="zoom:50%;"><p>进程是可以完成多个任务交替执行的，可以开发一个音乐软件（QQ音乐、网易云音乐、酷狗音乐），也可以开发一个打游戏软件（L0L、吃鸡战场、Dota2），只要运行这两个进程程序就可以完成一边听音乐，一边打游戏，这样做开发成本高，进行是独立的进程与进程之间是无法进行“<strong>通信</strong>”的</p><p><strong>线程</strong></p><p>&ensp;&ensp;&ensp;&ensp;线程是进程中一个内部执行单元，负责当前进程中的程序执行，一个进程中至少有一个线程，一个进程可以有多个线程，这些线程在进程中被称之为“多线程”，进程就可以利用这些多线程，去完成不同操作</p><p>特点:</p><ol><li>线程是在进程的内部执行，并且可以存在多个，彼此之间共享进程的内存区域</li><li>线程与线程之间彼此独立，但是可以进行“通信”</li></ol><p>可以利用这个轻量级的开发完成一个进程内部程序交替执行效果（线程并发执行）</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012205517.png" alt="线程" style="zoom:50%;"><p>总结进程与线程的区别：</p><p>&ensp;&ensp;&ensp;&ensp;进程： 有独立的内存空间，进程中数据存放的空间是独立的并且至少有一个线程</p><p>&ensp;&ensp;&ensp;&ensp;线程：堆空间是共享的，栈空间是独立的，线程消耗的资源要比进程小，并且可以多个线程存在同一个进程中</p><p>PS:需要知道了解的知识点：</p><ol><li>因为一个程序中有多个线程并发运行，那么从微观的角度而言是有先后顺序的，那么线程执行的顺序是取决于CPU的调度【线程争抢CPU时间片】，程序猿只能进行干涉，在不加干涉前提下线程执行就会出现很多随机性</li><li>Java程序进程中最少包含两个线程，一个是主线程就是main()方法【它在执行方法是或者执行程序时它的优先级永远最高】，另外一个垃圾回收机制线程(GC)【守护线程】，每当Java执行一个类的时候，实际上都会启动一个JVM，每一个JVM实际上就是在操作系统中启动了一个线程，Java本身就被垃圾回收机制所守护，所Java运行时至少启动了两个线程</li><li>由于创建一个线程开销远比创建一个进程开销要小很多，那么我们在开发多任务运行时，通常会优先考虑创建多线程，而不是多进程</li><li>所有的线程轮流使用CPU，每一个线程都会得到CPU分配的时间片，这个分配“尽量”平均分配CPU资源，但是这个效果不一定能达到，所以同优先级的线程对CPU时间的争抢是存在随机性的，可以对线程进行优先级设置来概念获取CPU时间片的几率，优先级越高几率越大，优先级越低几率越小</li></ol><h1 id="知识点四：Java程序中实现线程的方式"><a href="#知识点四：Java程序中实现线程的方式" class="headerlink" title="知识点四：Java程序中实现线程的方式"></a><center>知识点四：Java程序中实现线程的方式</center></h1><p>在Java中主要创建线程方式有四种：</p><ol><li>继承Thread类，此时子类就是线程类</li><li>实现Runnable接口，此时实现类不是线程类，使用Thread类才可成为线程</li></ol><p><strong>无论是上述两种方式中那种方式都需必须重写run方法实现线程逻辑</strong></p><ol start="3"><li>实现Callable接口， 此实现方方式并不是线程类，主要针对的是线程池提供</li><li>线程池可以帮组我们创建线程并进行管理操作</li></ol><p>如果实现线程需要继承Thread或实现Runnable接口，但是无论是那种都需要实现一个必要核心方法</p><p><strong>这个run方法是提供线程实现的核心逻辑，需要线程什么样需求代码，就将将代码写入到这个线程中</strong></p><table><thead><tr><th align="center">void</th><th align="center">run() 使用实现接口 Runnable 的对象创建一个线程时，启动该线程将导致在独立执行的线程中调用对象的 run方法</th></tr></thead><tbody><tr><td align="center"></td><td align="center"><strong>PS：通过观察可以发现这个run方法是没有参数和返回值类型，所以这个run不能通过方法接收参数和返回数据值</strong></td></tr></tbody></table><h2 id="1、线程创建方式之继承Thread类"><a href="#1、线程创建方式之继承Thread类" class="headerlink" title="1、线程创建方式之继承Thread类"></a><center>1、线程创建方式之继承Thread类</center></h2><p>步骤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 定义一个普通类继承与`java.lang.Thread`类</span><br><span class="line"><span class="number">2.</span> 在子类中重新给父类Thread中run方法并提供线程实现逻辑</span><br><span class="line"><span class="number">3.</span> 在测试类中main方法中，通过线程子类或Thread这个父类创建线程对象并执行线程启动完成调用run方法中逻辑执行</span><br></pre></td></tr></table></figure><p>PS：因为Thread本身就是线程类，所以继承Thread类子类也是线程类，具备父类中Thread所提供的所有操作者线程方法</p><p>需求：使用继承Thread类方法是完成边打游戏和边听音乐</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了演示效果方便观察写在同一个文件中</span></span><br><span class="line"><span class="comment">//此时GameThread继承与Thread类所以GameThread就是线程类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GameThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//必须重写Thread父类中的run方法，提供这个线程需要的执行逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span> ; i&lt;=<span class="number">50</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;打游戏：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//此时MusicThread继承与Thread类所以GameThread就是线程类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MusicThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//必须重写Thread父类中的run方法，提供这个线程需要的执行逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span> ; i&lt;=<span class="number">50</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;听音乐：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//提供一个测试类完成线程创建与调用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//main方法本身一个线程，主线线程优先级最高</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如何创建线程对象</span></span><br><span class="line">        <span class="comment">//下面两种创建线程方式并没有指定线程优先级，所以都是默认优先级athread和bthread的优先级相同</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1. 使用多态的效果【Thread是子线程类父类，所以可以使用Thread方式创建】</span></span><br><span class="line"><span class="comment">                Thread 线程对象的名字 = new 子线程类();</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">athread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GameThread</span>();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            2. 直接使用继承线程子类创建对象</span></span><br><span class="line"><span class="comment">                子线程类 线程对象的名字 = new 子线程类();</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">MusicThread</span> <span class="variable">bthread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MusicThread</span>();</span><br><span class="line">        <span class="comment">//启动线程执行 ---》调用 Thread类中提供 start方法 ，而不是调用run方法</span></span><br><span class="line">        athread.start();</span><br><span class="line">        bthread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、线程创建方式之实现Runnable接口"><a href="#2、线程创建方式之实现Runnable接口" class="headerlink" title="2、线程创建方式之实现Runnable接口"></a><center>2、线程创建方式之实现Runnable接口</center></h2><p>PS：<strong>实现Runnable接口的类并不是线程类，只是实现Runnable接口并提供run方法的重写，需要配合使用Thread类创建线程对象，此时线程才可以操作</strong>。因为Runnable接口中提供run方法的实现【实现Runnable接口的类】，传入到Thread类中时，就会覆盖Thread类中run方法，所以Thread提供创建线程对象就会执行重写Runnable接口中run方法，就会得到线程的效果</p><p>步骤:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 定义一个普通类实现Runnable接口</span><br><span class="line"><span class="number">2.</span> 实现Runnable接口的类必须重写run方法提供线程需要执行的逻辑</span><br><span class="line"><span class="number">3.</span> 在测试类中main方法中，使用Thread创建线程对象完成线程操作</span><br></pre></td></tr></table></figure><p>需求：使用继承Thread类方法是完成边打游戏和边听音乐</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.Runnable;</span><br><span class="line"><span class="comment">//为了演示效果方便观察写在同一个文件中</span></span><br><span class="line"><span class="comment">//此类就是实现Runnable接口并提供run方法实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GameRunnableImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">1</span>; i&lt;=<span class="number">50</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;打游戏：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MusicRunnableImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">1</span>; i&lt;=<span class="number">50</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;听音乐：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建Runnable接口实现类作为Thread线程对象操作</span></span><br><span class="line">        <span class="comment">//需要将Runnable接口的对象传递到Thread这个类中</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1. 先创建Runnable接口实现类的对象，然后再传递到Thread类中进行线程对象创建</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">GameRunnableImpl</span> <span class="variable">gri</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GameRunnableImpl</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(gri);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            2.使用匿名对象的方式进行Thread构造方法Runnable参数传递</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MusicRunnableImpl</span>());</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、Thread类创建线程和Runnable接口创建线程"><a href="#3、Thread类创建线程和Runnable接口创建线程" class="headerlink" title="3、Thread类创建线程和Runnable接口创建线程"></a><center>3、Thread类创建线程和Runnable接口创建线程</center></h2><p>&ensp;&ensp;&ensp;&ensp;两种方式皆可，因为都要实现run方法，但是从类的扩展角度而言，建议使用实现Runnable接口方式来完成作，因为Java中类是单一继承，所以如果继承Thread类就无法在继承其他类，所以就会影响类的扩展，但是如果实现接口方式完成，不仅可以继承一个类还可以实现多个接口所以就比较推荐实现Runnable接口</p><p>继承效果：</p><p>&ensp;&ensp;&ensp;&ensp;class A extends Thread{} &#x2F;&#x2F;没有办法让A在继承</p><p>&ensp;&ensp;&ensp;&ensp;class B extends XXXX implements Runnable{} &#x2F;&#x2F; 不仅可以作为线程类操作而且还可以进行继承其他类</p><h2 id="4、start方法和run方法"><a href="#4、start方法和run方法" class="headerlink" title="4、start方法和run方法"></a><center>4、start方法和run方法</center></h2><p>PS：<strong>创建完毕线程对象之后，线程执行需要调用的是start方法而不是run方法</strong></p><p>start方法： 用start方法来启动线程，真正的实现了线程运行，通过Thread类中给提供start来启动一个线程，此时线程会进入到“<strong>准备就绪</strong>”状态，但是真正运行，一旦线程获取到CPU时间片，此时线程才会真正的执行，执行调用提供run方法完成线程逻辑</p><p>run方法：run方法只是一个普通方法，只是在run方法中实现线程执行逻辑，如果外界直接调用run方法，线程是没有启动，只不过是在main方法调用了run方法执行，执行出run方法提供操作，和线程一点关系都没有</p><h2 id="5、使用匿名内部类或Lambda表达式便捷的创建线程对象并执行（了解）"><a href="#5、使用匿名内部类或Lambda表达式便捷的创建线程对象并执行（了解）" class="headerlink" title="5、使用匿名内部类或Lambda表达式便捷的创建线程对象并执行（了解）"></a><center>5、使用匿名内部类或Lambda表达式便捷的创建线程对象并执行（了解）</center></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousAndLambdaThread</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这种方式，线程是现创建现使用，只会使用一次即可</span></span><br><span class="line">        <span class="comment">//1.针对Thread类提供匿名内部类创建【只支持匿名内部类】</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i&lt;<span class="number">50</span>;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;听音乐：&quot;</span>+i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();     <span class="comment">// 在最外侧的大括号中调用start方法</span></span><br><span class="line">        <span class="comment">//2.针对Runnable接口提供匿名内部类和Lambda表达式实现</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i&lt;<span class="number">50</span>;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;打游戏：&quot;</span>+i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start(); <span class="comment">// 在最外侧的大括号中调用start方法</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i&lt;<span class="number">50</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;吃饭：&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start(); <span class="comment">// 在最外侧的大括号中调用start方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点五：线程常用方法"><a href="#知识点五：线程常用方法" class="headerlink" title="知识点五：线程常用方法"></a><center>知识点五：线程常用方法</center></h1><h2 id="1、线程状态getState"><a href="#1、线程状态getState" class="headerlink" title="1、线程状态getState"></a><center>1、线程状态getState</center></h2><p>这个方法可以返回线程运行状态</p><p>PS：API有一个静态属性 State【API中给返回类型时错误的，它不是静态类，他是一个枚举】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetStateDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//使用run方法进行求和操作【GetStateDemo 是 Thread子类</span></span><br><span class="line">        所以会得到所有方法】</span><br><span class="line">        System.out.println(<span class="string">&quot;进入run方法是当前线程状态：&quot;</span> + <span class="built_in">this</span>.getState());</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;=<span class="number">100</span> ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(<span class="string">&quot;sum = &quot;</span>+sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetStateDemo</span>();</span><br><span class="line">        <span class="comment">//在启动线程之前</span></span><br><span class="line">        System.out.println(<span class="string">&quot;start方法之前线程状态：&quot;</span>+thread.getState());</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;start方法之后线程状态：&quot;</span>+thread.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以表示线程状态说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 出生、新生</span></span><br><span class="line"><span class="comment">* 至今尚未启动的线程就是这种状态</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">NEW,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 准备就绪和执行</span></span><br><span class="line"><span class="comment">*PS：Java中提供Thread类并没有提供准备就绪的状态描述，所以RUNNABLE就有两个概念</span></span><br><span class="line"><span class="comment">* 调用start方法时是 ---&gt; 准备就绪</span></span><br><span class="line"><span class="comment">* 执行run方法时是 ---&gt; 执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">RUNNABLE,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 阻塞或睡眠 ---》 sleep方法</span></span><br><span class="line"><span class="comment">* 当线程出现【阻塞状态】，当前线程就会出现让出CPU时间片的操作等待后续执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">BLOCKED,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 等待 ---》 wait</span></span><br><span class="line"><span class="comment">* 等待是无限期等待只有进行唤醒之后等待效果才会消失【等待不是阻塞状态】</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">WAITING,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 时间等待</span></span><br><span class="line"><span class="comment">* 在设置等待状态时设置一个时间，只要在时间范围内都是等待状</span></span><br><span class="line"><span class="comment">态，如果到了并且在等待时期并没有进行唤 </span></span><br><span class="line"><span class="comment">* 醒从操作，等待线程会自动唤醒</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">TIMED_WAITING,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 消亡，死亡</span></span><br><span class="line"><span class="comment">* 线程都执行完毕不会在执行就出现这个状态【线程结束】</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">TERMINATED;</span><br></pre></td></tr></table></figure><h2 id="2、线程优先级setPriority"><a href="#2、线程优先级setPriority" class="headerlink" title="2、线程优先级setPriority"></a><center>2、线程优先级setPriority</center></h2><p>理论上线程优先级越高，获取CPU时间片的几率越大，反之获取几率越小</p><p>PS：但是优先级只是相当于给CPU一个暗示【先由我开始】，但是CPU是否会决定将时间片给当前线程，是CPU决定</p><p>所有在没有修改优先级之前的线程默认优先级都是相同，在Java中使用1~10之间数字表示线程优先级，数值越大优先级越高，所有在没有</p><p>修改优先级之前默认优先级是【5】API中提供三个静态常量方便对优先级的定义</p><table><thead><tr><th align="center">static int</th><th align="center">MAX_PRIORITY 线程可以具有的最高优先级【等级10】</th></tr></thead><tbody><tr><td align="center">static int</td><td align="center">MIN_PRIORITY 线程可以具有的最低优先级【等级1】</td></tr><tr><td align="center">static int</td><td align="center">NORM_PRIORITY 分配给线程的默认优先级【等级5】</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetPriorityDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span> ;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//getName()获取线程名字</span></span><br><span class="line">            System.out.println(getName()+<span class="string">&quot;：i的数值：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//利用线程创建两个线程对象使用默认优先级</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">athread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SetPriorityDemo</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">bthread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SetPriorityDemo</span>();</span><br><span class="line">        <span class="comment">//可能会出现Thread-0先执行 或 Thread-1先执行</span></span><br><span class="line">        <span class="comment">// athread.start(); // Thread-0</span></span><br><span class="line">        <span class="comment">// bthread.start(); // Thread-1</span></span><br><span class="line">        <span class="comment">//修改优先级</span></span><br><span class="line">        <span class="comment">// 【只要优先级的差别较大就可以的得到先执行和后执行效果】</span></span><br><span class="line">        <span class="comment">// 【只要优先级等级差别不是很大(比较接近)，执行效果就不是很明显了】</span></span><br><span class="line">        athread.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        bthread.setPriority(<span class="number">6</span>);</span><br><span class="line">        athread.start();     <span class="comment">// Thread-0</span></span><br><span class="line">        bthread.start();     <span class="comment">// Thread-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、更改和获取线程的名字"><a href="#3、更改和获取线程的名字" class="headerlink" title="3、更改和获取线程的名字"></a><center>3、更改和获取线程的名字</center></h2><p>线程是有默认名字组成方式 —》 使用到一个关键字“Thread” + “-” +“数字”，数字的从0开始，随着线程创建而逐渐增多，随着线程的减少而逐渐减少 —》 默认名字 【Thread-数字】</p><p>在编写线程程序时可以通过<strong>getName方法获取线程名字</strong>，但是如果创建线程过多使用默认名字看到效果就不是很明显</p><p>Java中提供线程名字修改方式有三种：</p><ol><li>在创建出线程对象之后调用setName(“线程新的名字”)</li><li>使用类实现Runnable接口并使用Thread类创建线程对象，调用两个参数版本构造方法进行名字设置</li></ol><p>&ensp;&ensp;&ensp;&ensp;Thread(Runnable接口实现类的对象，”线程名字”);</p><ol start="3"><li>使用类继承与Thread类，子类中提供一个仿照父类生成构造方法，这个方法参数是String name，子类只需要实现这个构造方法即可，在创建线程对象时只需要调用有参构造方法就可以指定线程名字</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetNameDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//方式一</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">athread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AThread</span>();</span><br><span class="line">        athread.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        System.out.println(athread.getName());</span><br><span class="line">        <span class="comment">//方式二</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">bthread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">BThread</span>(),<span class="string">&quot;线程B&quot;</span>);</span><br><span class="line">        System.out.println(bthread.getName());</span><br><span class="line">        <span class="comment">//方式三</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">cthread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CThread</span>(<span class="string">&quot;线程C&quot;</span>);    <span class="comment">//多态</span></span><br><span class="line">        System.out.println(cthread.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//实现Runnable接口不是线程类，所以不能在实现Runnable接口类中调用Thread类中方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// System.out.println(&quot;线程的名字：&quot;+getName());</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 如何在实现Runnable接口的类中获取当前线程</span></span><br><span class="line"><span class="comment">        * Thread类中提供一个静态方法currentThread() 可以获取当前线程对象</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;通过静态访获取到线程对象：&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//子类只要仿照生成一个带有String类型参数方法即可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CThread</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、线程休眠sleep【使用几率极高】"><a href="#4、线程休眠sleep【使用几率极高】" class="headerlink" title="4、线程休眠sleep【使用几率极高】"></a><center>4、线程休眠sleep【使用几率极高】</center></h2><p>sleep这个方法是静态方法，它可以让线程进入到【阻塞状态】即让线程进行到休眠时间，<strong>进入休眠之后线程会让出CPU时间片，给其他的线程进行争抢，当休眠时间到了之后恢复之后线程会继续和其线程进行CPU时间片的争抢</strong></p><p>sleep方法的参数是毫秒值 —》 1000毫秒 等于 1秒</p><p>线程如果触发sleep方法会有两种方式可以醒来：</p><ol><li>自然醒来【睡眠时间到了，自动醒来】</li><li>中断醒来【会通过Thread类中添加中断标记，强行让sleep醒来】</li></ol><p>所以sleep方法在调用时候会有一个编译时异常【InterruptedException(中断异常)】</p><p><strong>特别注意：如果sleep方法被调用在【同步锁、对象锁、同步监听器、同步代码块】中，sleep方法休眠之后是不会让出当前系统时间片【虽然会睡眠时间片也会释放，但是外界线程是无法获取】</strong></p><p>需求：通过sleep方法来实现以下交替执行效果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SleepDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;=<span class="number">100</span> ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">5</span> == <span class="number">0</span>)    <span class="comment">//只要i值可以对5整除</span></span><br><span class="line">            &#123; </span><br><span class="line">                System.out.println(<span class="string">&quot;当前线程:&quot;</span>+getName()+<span class="string">&quot;~~~~~~~~~&quot;</span>+i);</span><br><span class="line">                <span class="comment">//在run方法中调用sleep方法是不可以throws异常，只能try-catch抓取</span></span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">athread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SleepDemo</span>();</span><br><span class="line">        athread.setName(<span class="string">&quot;子线程&quot;</span>);</span><br><span class="line">        athread.start();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Java程序会默认提供两个线程一个是GC 和 一个是main方法【主线程作为线程操作】</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//在主线程中提供和SleepDemo类中一样的操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i&lt;=<span class="number">100</span> ;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">5</span> ==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;当前线程：&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;~~~~~~~~~&quot;</span>+i);</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sleep方法确实可以让线程进入到休眠状态，并且释放出CPU时间片，但是时间无法正确把控就会造成无法使用sleep方法进行代码的交替执行</p><h2 id="5、线程礼让yield（了解）"><a href="#5、线程礼让yield（了解）" class="headerlink" title="5、线程礼让yield（了解）"></a><center>5、线程礼让yield（了解）</center></h2><p>礼让线程的作用就是在调用yield方法的线程中，让出CPU时间片【相当于通知CPU不急着执行】，让出之后CPU会不会回收CPU时间片取决于CPU，礼让原则是：线程优先级越高礼让效果就是会明显一些</p><p>yield和sleep方法是有一定区别的，sleep是立即让出CPU时间片，在睡眠时间内是不会争抢CPU时间片，yield方法执行之后，礼让线程会进入“准备就绪”，礼让线程可能会再次持有CPU时间片</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YieldDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span> ; i&lt;=<span class="number">50</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程的名字：&quot;</span>+getName()+<span class="string">&quot;~~~~~~~~&quot;</span>+i);</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Thread.<span class="keyword">yield</span>(); <span class="comment">//让线程礼让</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建两个线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">athread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">YieldDemo</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">bthread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">YieldDemo</span>();</span><br><span class="line">        athread.setName(<span class="string">&quot;a线程&quot;</span>);</span><br><span class="line">        bthread.setName(<span class="string">&quot;b线程&quot;</span>);</span><br><span class="line">        athread.start();</span><br><span class="line">        bthread.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        bthread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、线程合并join"><a href="#6、线程合并join" class="headerlink" title="6、线程合并join"></a><center>6、线程合并join</center></h2><p>合并线程是一个效果非常明显操作，合并线程是一个线程正处于运行阶段，此时这个线程达到某个条件时，可以让其他线程合并到这个执行线程中，只要使用join合并，合并线程<strong>必然</strong>会得到CPU时间片，被合并的线程需要等待合并线程执行完毕之后才会继续运行</p><p>需求：妹子在看葫芦娃【50级】，当看到【10级】汉子要看喜洋洋</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoinDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Meizi</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Meizi</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;=<span class="number">50</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;妹子正在看精钢葫芦娃大战蛇精：&quot;</span>+i);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//启动另外一个线程进行合并操作</span></span><br><span class="line">                <span class="type">Hanzi</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hanzi</span>();</span><br><span class="line">                <span class="comment">//合并之前必要前提：要合并线程必须进入准备就绪状态，即调用start方法</span></span><br><span class="line">                thread.start();</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    thread.join();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hanzi</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;=<span class="number">10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;汉子正在看喜羊羊与灰太狼：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程合并必然是让出CPU时间片，CPU时间片会join的线程，线程必须是启动状态【调用start】</p><h2 id="7、线程中断-标记"><a href="#7、线程中断-标记" class="headerlink" title="7、线程中断(标记)"></a><center>7、线程中断(标记)</center></h2><p>在Thread这个类中提供让线程停止方法 stop方法，但是这个方法被Java进行过时处理，所以就不建议在线程中进行使用了，所以Java就提供一个替代 stop方法的方法 —》interrupt方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptThreadDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;=<span class="number">20</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(getName()+<span class="string">&quot;线程中执行i值是:&quot;</span>+i);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//停止线程 --&gt;过时的stop方法</span></span><br><span class="line">                <span class="comment">// stop();</span></span><br><span class="line">                <span class="comment">//中断线程</span></span><br><span class="line">                interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InterruptThreadDemo</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这个线程中断标记方法向线程中添加【中断标记】，只有被含有中断异常方法检测到这个标记就会终止方法的执行效果【sleep明显 和join不明显】，<strong>直接在线程调用这个方法是无用的</strong>，只是添加标记不会停止线程，配合API中所提供的一个方法来使用【<strong>interrupted</strong>】，作用检查线程中是否存在中断标记，如果存在着返回true，不存在则返回false</p><p><strong>正确使用方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptThreadDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;=<span class="number">20</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(getName()+<span class="string">&quot;线程中执行i值是:&quot;</span>+i);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//使用替代stop方法中断线程时，当遇到某个条件要终止线程时，检查中断标记</span></span><br><span class="line">                <span class="keyword">if</span>(Thread.interrupted())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//停止线程</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">InterruptThreadDemo</span> <span class="variable">interruptThreadDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterruptThreadDemo</span>();</span><br><span class="line">        interruptThreadDemo.start();</span><br><span class="line">        <span class="comment">//向线程中添加中断标记</span></span><br><span class="line">        interruptThreadDemo.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>强行终止睡眠</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.ThreadMethod;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptThreadDemo2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入线程&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;没有被中断正常睡眠苏醒&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;中断睡眠苏醒&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(<span class="string">&quot;线程结束&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">InterruptThreadDemo2</span> <span class="variable">interruptThreadDemo2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterruptThreadDemo2</span>();</span><br><span class="line">        interruptThreadDemo2.start();</span><br><span class="line">        <span class="comment">//为了效果让主线程休眠2秒之后在触发中断标记</span></span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">        interruptThreadDemo2.interrupt();  <span class="comment">//如果检查到中断标记就会强行终止睡眠</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点六：火车售票问题"><a href="#知识点六：火车售票问题" class="headerlink" title="知识点六：火车售票问题"></a><center>知识点六：火车售票问题</center></h1><p>需求：火车站买票，一共有且仅有【100】张票，4个窗口同时贩卖临界资源就是这个票，多个线程访问保证票有且仅有100张，开4个线程同时买100张票</p><p>&ensp;&ensp;&ensp;&ensp;其实这个卖票案例就是多线程下同时操作一个资源(临界资源),如何保证线程操作资源安全不出现以下情况</p><p>&ensp;&ensp;&ensp;&ensp;买票不会出现重票 –&gt; 线程1 卖出第99张票 线程2 卖出99张票</p><p>&ensp;&ensp;&ensp;&ensp;错误票 —&gt; 线程1 卖出第75张票. 线程2 卖出76张票 —&gt; 这个是对</p><p>&ensp;&ensp;&ensp;&ensp;但是 线程2 卖出49张票</p><p>&ensp;&ensp;&ensp;&ensp;负数票 —&gt; 某个线程买完最后一张票的时候 剩余线程就不能在卖票0 -1 -2…票</p><p>&ensp;&ensp;&ensp;&ensp;1秒卖一张 —&gt; 有且仅有100张 —&gt;不要卖出400张票数</p><p><strong>问题1：如何将票固定在100张，而不是每个线程都卖出100张票</strong></p><p>&ensp;&ensp;&ensp;&ensp;如何做到所有的线程都共享这一个资源？</p><ol><li>将票作为成员变量，作为成员变量之后，需要保证这个提供票的类在外界创建对象必须是唯一的，如果不唯一的，就会出现你创建票的对象每个对象都会唯一，一个成员变量，4个对象就是4个成员变量，此时相当于400张票【单例设计模式】</li></ol><p>PS：单例设计模式的原则：保证外界无论如何获取对象都是唯一的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v1基础版本</span></span><br><span class="line"><span class="keyword">package</span> com.qfedu.Thread.SellTicket1;</span><br><span class="line"><span class="comment">//v1版本</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    不要让类继承与Thread，继承Thread必然要提供四个线程对象</span></span><br><span class="line"><span class="comment">    这样就会出现无法控制票100张</span></span><br><span class="line"><span class="comment">    建议实现Runnable，以Runnable实现类方式创建线程处理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicket1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供成成员变量存储票的信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//执行买票操作</span></span><br><span class="line">        <span class="comment">//提供一个for循环，这个循环执行100次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//提供买票的逻辑</span></span><br><span class="line">            <span class="keyword">if</span>(tickets &gt; <span class="number">0</span>)    <span class="comment">//证明还票可以出售</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//休眠1秒在买票</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//买票</span></span><br><span class="line">                System.out.println(<span class="string">&quot;当前售票员[&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;]第&quot;</span>+<span class="string">&quot;[&quot;</span>+(tickets--)+<span class="string">&quot;]票&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果提供的是成员变量【保证存储成员变量的这个类所得到对象是必须唯一】</span></span><br><span class="line">        <span class="comment">//出现400张票问题[在构建线程对象时，提供四个Runnable接口实现类对象创建]</span></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">            Thread thread1 = new Thread(new SellTicket1(),&quot;刘德华&quot;);</span></span><br><span class="line"><span class="comment">            Thread thread2 = new Thread(new SellTicket1(),&quot;张学友&quot;);</span></span><br><span class="line"><span class="comment">            Thread thread3 = new Thread(new SellTicket1(),&quot;郭富城&quot;);</span></span><br><span class="line"><span class="comment">            Thread thread4 = new Thread(new SellTicket1(),&quot;吴奇隆&quot;);</span></span><br><span class="line"><span class="comment">            thread1.start();</span></span><br><span class="line"><span class="comment">            thread2.start();</span></span><br><span class="line"><span class="comment">            thread3.start();</span></span><br><span class="line"><span class="comment">            thread4.start();</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//在外界只创建一个Runnable接口实现类对象，保证对象是唯一的</span></span><br><span class="line">        <span class="type">SellTicket1</span> <span class="variable">sellTicket1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicket1</span>(); <span class="comment">//只会维护一份的票对象【100】张</span></span><br><span class="line">        <span class="comment">//利用这个对象初始化创建4个线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket1,<span class="string">&quot;刘德华&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket1,<span class="string">&quot;张学友&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket1,<span class="string">&quot;郭富城&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket1,<span class="string">&quot;吴奇隆&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="GetInstance"><a href="#GetInstance" class="headerlink" title="GetInstance"></a><center>GetInstance</center></h2><p>在主函数开始时调用，返回一个实例化对象，此对象是static的，在内存中保留着它的引用，即内存中有一块区域专门用来存放静态方法和变量，可以直接使用，调用多次返回同一个对象</p><p>GetInstance与new区别</p><p>&ensp;&ensp;&ensp;&ensp;如Object object &#x3D; new Object()，这时候，就必须要知道有第二个Object的存在，而第二个Object也常常是在当前的应用程序域中的，可以被直接调用的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qf.Demo03.test;</span><br><span class="line"><span class="comment">//提供了成员变量</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SellTicket2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供成员变量，变量是存储票信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    单设计模式的原则--》保证在外界获取对象时都是同一个对象【地址也是相同的】</span></span><br><span class="line"><span class="comment">    1.私有化构造方法</span></span><br><span class="line"><span class="comment">    2.提供一个私有化静态变量并对静态变量进行赋值【类型是本类类型提供对象创建】</span></span><br><span class="line"><span class="comment">    3.提供一个静态共有方法可以获取本类对象的唯一途径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SellTicket2</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="comment">//使用本类类型创建对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SellTicket2</span> <span class="variable">sellTicket2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicket2</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SellTicket2 <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> sellTicket2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//执行买票操作</span></span><br><span class="line">        <span class="comment">//提供一个for循环，这个循环执行100次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//提供买票的逻辑</span></span><br><span class="line">            <span class="keyword">if</span>(tickets &gt; <span class="number">0</span>)    <span class="comment">//证明还票可以出售</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//休眠1秒在买票</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//买票</span></span><br><span class="line">                System.out.println(<span class="string">&quot;当前售票员[&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;]第&quot;</span>+<span class="string">&quot;[&quot;</span>+(tickets--)+<span class="string">&quot;]票&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 提供了静态变量，这个类的创建对象方式就无所谓</span></span><br><span class="line">        <span class="type">SellTicket2</span> <span class="variable">sellTicket2</span> <span class="operator">=</span> SellTicket2.getInstance();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;刘德华&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;张学友&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;郭富城&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;吴奇隆&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>定义一个变量保证所有对象共享，无论外界如何创建线程对象【实现Runnable还是继承Thread类】，这里都可以保证所有兑现共享这个变量，可以提供一个static修饰变量即静态变量</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.Thread.SellTicket1;</span><br><span class="line"><span class="comment">//v1.1版本 ---&gt; 提供了静态变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicket2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供静态成员变量存储票的信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//执行买票操作</span></span><br><span class="line">        <span class="comment">//提供一个for循环，这个循环执行100次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//提供买票的逻辑</span></span><br><span class="line">            <span class="keyword">if</span>(tickets &gt; <span class="number">0</span>)    <span class="comment">//证明还票可以出售</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//休眠1秒在买票</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//买票</span></span><br><span class="line">                System.out.println(<span class="string">&quot;当前售票员[&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;]第&quot;</span>+<span class="string">&quot;[&quot;</span>+(tickets--)+<span class="string">&quot;]票&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 提供了静态变量，这个类的创建对象方式就无所谓</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SellTicket2</span>(),<span class="string">&quot;刘德华&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SellTicket2</span>(),<span class="string">&quot;张学友&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SellTicket2</span>(),<span class="string">&quot;郭富城&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SellTicket2</span>(),<span class="string">&quot;吴奇隆&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题2：在买票的时候会出现、重票、错票、排序顺序的混乱的问题</p><p>&ensp;&ensp;&ensp;&ensp;这个问题产生就是多线程并发争抢”临界资源”出现里临界资源不安全问题</p><h2 id="1、如何解决多线程并发访问临界资源，保证资源安全问题"><a href="#1、如何解决多线程并发访问临界资源，保证资源安全问题" class="headerlink" title="1、如何解决多线程并发访问临界资源，保证资源安全问题"></a><center>1、如何解决多线程并发访问临界资源，保证资源安全问题</center></h2><p>此时Java为了保证多线程并发访问临界资源线程安全问题，提供了一个处理机制，可以在处理临界资源代码中添加（同步锁&#x2F;对象锁&#x2F;同步代码块&#x2F;同步监听器），这里四个名称都是指的是同一个操作，可以添加“锁机制”，保证在同一个时刻的只有一个线程操作临界资源，保证临界资源安全</p><h2 id="2、synchronized关键字"><a href="#2、synchronized关键字" class="headerlink" title="2、synchronized关键字"></a><center>2、synchronized关键字</center></h2><p>synchronized翻译意思：同步</p><p>使用synchronized关键字进行同步操作，使用synchronized组成同步操作叫做【同步锁&#x2F;对象锁&#x2F;同步代码块】</p><p>语法 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(资源锁对象)</span><br><span class="line">&#123;</span><br><span class="line">    提供操作临界资源的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行原理： 利用了同一时间内【只能有一个线程对象持有当前资源锁对象】，只要线程不释放这个所资源对象，外界线程是无法执行线程逻辑资源代码，在同步代码块中执行线程进行休眠是不会释放CPU时间片到外界给其他线程，因为sleep方法是不会释放锁资源</p><p>需要注意还需要保证【<strong>资源锁对象必须是唯一的</strong>】，不唯一锁对象数无法进行同步操作</p><p>如果保证资源锁对象是唯一的？</p><p>个人建议：十分不推荐使用 this 作为锁资源对象，this可能锁不了，this代表的是当前对象，那么就意味着这个提供临界支援类必须是创建唯一的对象才可以，这样才可以保证this是唯一的</p><p>替代方案一：</p><p>&ensp;&ensp;&ensp;&ensp;在静态资源处理线程类中提供一个全局静态常量“锁资源”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">synchronized</span>(obj)</span><br><span class="line">&#123;</span><br><span class="line">    提供操作临界资源的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>替代方案二【推荐】</p><p>&ensp;&ensp;&ensp;&ensp;天生对象就是唯一的，Java中这个对象无论你如何操作，就可以保证他是唯一的地址都是同一个，String字符串类，直接使用字符串对象即可—-&gt;【使用 “” (双引号)创建】</p><p>提供字符串空串处理 —&gt; 即 提供字符串空串对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    提供操作临界资源的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用同步代码块修改买票的案例的</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.Thread.SynchronizedSellTicket1;</span><br><span class="line"><span class="comment">//v2版本 ---&gt; 提供了静态变量 和 同步代码块执行买票操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供静态成员变量存储票的信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//执行买票操作</span></span><br><span class="line">        <span class="comment">//提供一个for循环，这个循环执行100次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//提供买票的逻辑</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>) <span class="comment">//同步代码块</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) <span class="comment">//证明还票可以出售</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">try</span> </span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//休眠1秒在买票</span></span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="comment">//买票</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;当前售票员[&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;]第&quot;</span></span><br><span class="line">                                                    + <span class="string">&quot;[&quot;</span> + (tickets--) + <span class="string">&quot;]票&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 提供了静态变量，这个类的创建对象方式就无所谓</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SellTicket</span>(),<span class="string">&quot;刘德华&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SellTicket</span>(),<span class="string">&quot;张学友&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SellTicket</span>(),<span class="string">&quot;郭富城&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SellTicket</span>(),<span class="string">&quot;吴奇隆&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、同步方法-对象同步方法-成员同步方法"><a href="#3、同步方法-对象同步方法-成员同步方法" class="headerlink" title="3、同步方法&#x2F;对象同步方法&#x2F;成员同步方法"></a><center>3、同步方法&#x2F;对象同步方法&#x2F;成员同步方法</center></h2><p>使用synchronized关键字进行成员方法的修饰，这个方法就会成为<strong>同步方法</strong>将操作资源代码写入到这个方法中就可以进行同步操作了</p><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">访问权限修饰符 <span class="keyword">synchronized</span> 返回值类型 方法名(参数列表)</span><br><span class="line">&#123;</span><br><span class="line">    方法体；</span><br><span class="line">    <span class="keyword">return</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特别注意：使用是同步方法，所以这个方法使用锁资源对象是【this】，提供同步方法的这个类所创建对象必须是唯一的才可以锁住资源</strong></p><p>PS：到目前位置 方法定义中其他修饰符就已经全部介绍完毕</p><p>&ensp;&ensp;&ensp;&ensp;类中方法可以使用：【static、final、abstract、synchronized】</p><p>&ensp;&ensp;&ensp;&ensp;接口中方法可以使用：【abstract、static、default】</p><p><strong>修饰同步方法是该买票案例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.Thread.SynchronizedSellTicket1;</span><br><span class="line"><span class="comment">//v2.1版本 ---&gt; 提供了静态变量 和 同步方法进行买票</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicket2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供静态成员变量存储票的信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//执行买票操作</span></span><br><span class="line">        <span class="comment">//提供一个for循环，这个循环执行100次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//提供买票的逻辑 ---》调用同步方法即可</span></span><br><span class="line">            seller();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//同步方法 --&gt; 这个锁资源对象是this</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">seller</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//提供就是线程处理临界资源操作</span></span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) <span class="comment">//证明还票可以出售</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//休眠1秒在买票</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//买票</span></span><br><span class="line">            System.out.println(<span class="string">&quot;当前售票员[&quot;</span> +</span><br><span class="line">            Thread.currentThread().getName() + <span class="string">&quot;]第&quot;</span></span><br><span class="line">            + <span class="string">&quot;[&quot;</span> + (tickets--) + <span class="string">&quot;]票&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 提供了静态变量，这个类的创建对象方式就无所谓</span></span><br><span class="line">        <span class="comment">//同步方法提供类如果是线程类，需要保证线程类对象是唯一的</span></span><br><span class="line">        <span class="type">SellTicket2</span> <span class="variable">sellTicket2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicket2</span>();   <span class="comment">//这是保证线程类对象唯一</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;刘德华&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;张学友&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;郭富城&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;吴奇隆&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、类锁-类同步代码块-类同步方法-静态同步方法"><a href="#4、类锁-类同步代码块-类同步方法-静态同步方法" class="headerlink" title="4、类锁&#x2F;类同步代码块&#x2F;类同步方法&#x2F;静态同步方法"></a><center>4、类锁&#x2F;类同步代码块&#x2F;类同步方法&#x2F;静态同步方法</center></h2><p>如果使用是同步代码块的语法，就是将资源锁对象，从当前对象替换成类对象，通过类的方式获取对象【通反射获取】，静态同步方法就是使用static和synchronized同时修饰方法</p><p><strong>类锁&#x2F;类同步代码块</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(类名.class)    <span class="comment">// 类锁对象</span></span><br><span class="line">&#123;</span><br><span class="line">    操作临界资源代码即可</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类同步方法&#x2F;静态同步方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">访问权限修饰符 <span class="keyword">static</span> <span class="keyword">synchronized</span> 返回值类型 方法名(参数列表)</span><br><span class="line">&#123;</span><br><span class="line">    方法代码</span><br><span class="line">    <span class="keyword">return</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v2.2版本 ---&gt; 提供了静态变量 和 静态同步操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicket3</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供静态成员变量存储票的信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//执行买票操作</span></span><br><span class="line">        <span class="comment">//提供一个for循环，这个循环执行100次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//提供买票的逻辑 ---》调用同步方法即可</span></span><br><span class="line">            <span class="comment">//seller();</span></span><br><span class="line">            <span class="keyword">synchronized</span> (String.class)    <span class="comment">// 类锁</span></span><br><span class="line">            &#123; </span><br><span class="line">                <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) <span class="comment">//证明还票可以出售</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">try</span> </span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//休眠1秒在买票</span></span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="comment">//买票</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;当前售票员[&quot;</span> +</span><br><span class="line">                    Thread.currentThread().getName() + <span class="string">&quot;]第&quot;</span></span><br><span class="line">                    + <span class="string">&quot;[&quot;</span> + (tickets--) + <span class="string">&quot;]票&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态同步方法 --&gt; 这个锁资源就是当前类的对象【是唯一的】，通过类获取即 类.class</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">seller</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//提供就是线程处理临界资源操操作</span></span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) <span class="comment">//证明还票可以出售</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//休眠1秒再买票</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//卖票</span></span><br><span class="line">            System.out.println(<span class="string">&quot;当前售票员[&quot;</span> +Thread.currentThread().getName() + <span class="string">&quot;]第&quot;</span> </span><br><span class="line">                                                        + <span class="string">&quot;[&quot;</span> + (tickets--) + <span class="string">&quot;]票&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 提供了静态变量，这个类的创建对象方式就无所谓</span></span><br><span class="line">        <span class="comment">//同步方法提供类如果是线程类，需要保证线程类对象是唯一的</span></span><br><span class="line">        <span class="type">SellTicket3</span> <span class="variable">sellTicket2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicket3</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;刘德华&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;张学友&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;郭富城&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket2,<span class="string">&quot;吴奇隆&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>synchronized总结：</p><ol><li>在开发中常用肯定是对象锁【同步代码块】但是这个代码块的范围不要太大，不然的话会影响执行效率</li></ol><p>&ensp;&ensp;&ensp;&ensp;PS: 在什么位置对资源操作就在什么位置添加 同步代码块</p><ol start="2"><li>使用synchronized关键字之后线程就会变成安全，间接就将并行线程修改为串行线程，使用锁机制将线程变成 【一个一个站排执行效果】</li></ol><h1 id="知识点七：线程通信"><a href="#知识点七：线程通信" class="headerlink" title="知识点七：线程通信"></a><center>知识点七：线程通信</center></h1><p>到现目前位置线程与线程之间依旧是彼此独立，就算使用同步代码块，也是让线程执行有一定顺序，但是还是没有进行通信操作，如果需要遇到某个线程执行完毕之后需要通知另外一个线程继续执行，此时就需要使用到线程通信，可以在一个进程中开发多个线程，每个线程之间可以进行通信操作，从而协调性的完成某个进程中需要执行逻辑</p><p><strong>线程通信有一个标准的通信模型【生产者与消费者模式】</strong></p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012227153.png" alt="线程通信" style="zoom:50%;"><h2 id="1、完成生产者和消费者通信模型v1版本"><a href="#1、完成生产者和消费者通信模型v1版本" class="headerlink" title="1、完成生产者和消费者通信模型v1版本"></a><center>1、完成生产者和消费者通信模型v1版本</center></h2><p>Bank(银行类) —》 提供数据维护与使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基础的第一个版本 ---》 提供临界资源并提供操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bank</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        临界资源一共有两种提供方式【提供成员变量和提供静态变量】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;    <span class="comment">//存储前的临界变量</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        外界无论如何创建Bank类对象，都需要是唯一的，不然的话成员变量会跟着对象多少而进行创建</span></span><br><span class="line"><span class="comment">        提供对象唯一创建方式【单例设计模式】</span></span><br><span class="line"><span class="comment">        单例设计模式可以保证外界无论如何操作得到对象都是唯一单例设计模式的实现：</span></span><br><span class="line"><span class="comment">        1. 一定要私有化构造方法 --&gt; 防止外界调用构造方法创建对象</span></span><br><span class="line"><span class="comment">        2. 提供一个私有静态常量对象，这个对象就是单例类唯一创建对象</span></span><br><span class="line"><span class="comment">        3. 提供一个静态方法，获取这个创建好的对象，得到实例【外界只能通过这个方法获取对象】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Bank</span> <span class="variable">bank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> bank;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *生产者向共享资源中存储数据的方法【生产】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 存储钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        money = m+money;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;存了&quot;</span>+m+<span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *消费者向共享资源中存储数据的方法【消费】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 消费钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">popMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        money = money-m;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;取了&quot;</span>+m+<span class="string">&quot;余额是：&quot;</span>+money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产者【是一个线程提供数据存储操作】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供银行属性</span></span><br><span class="line">    <span class="keyword">private</span> Bank bank;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Bank bank)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.bank = bank;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//提供线程存储钱的操作 存储十次 每次1000元</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            bank.pushMoney(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者【是一个线程提供数据获取操作】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供银行属性</span></span><br><span class="line">    <span class="keyword">private</span> Bank bank;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(Bank bank)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.bank = bank;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//提供线程存获取的操作 获取十次 每次1000元</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            bank.popMoney(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供一个测试类Test进行测试操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.Thread.waitAndnotfiny;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//通过单例获取银行对象</span></span><br><span class="line">        <span class="type">Bank</span> <span class="variable">bank1</span> <span class="operator">=</span> Bank.getInstance();</span><br><span class="line">        <span class="comment">//2.创建线程对象并启动操作</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(bank1),<span class="string">&quot;花花&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(bank1),<span class="string">&quot;菲菲&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题1：现在执行速度太快了，看不到交替执行效果，让线程休眠1秒操作</p><p>问题2：虽然让线程休眠之后，出现了一个执行错乱的问题，因为多线程并发访问临界资源money，出现线程挣抢的问题，所以出现临界资源部不安全问题，添加同步代码块</p><p>Bank银行类需要修改为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.Thread.waitAndnotfiny;</span><br><span class="line"><span class="comment">//基础的第一个版本 ---》 提供临界资源并提供操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bank</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        临界资源一共有两种提供方式【提供成员变量和提供静态变量】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;<span class="comment">//存储前的临界变量</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        外界无论如何创建Bank类对象，都需要是唯一的，不然的话成员变量会跟着对象多少而进行创建</span></span><br><span class="line"><span class="comment">        提供对象唯一创建方式【单例设计模式】</span></span><br><span class="line"><span class="comment">        单例设计模式可以保证外界无论如何操作得到对象都是唯一</span></span><br><span class="line"><span class="comment">        单例设计模式的实现：</span></span><br><span class="line"><span class="comment">        1. 一定要私有化构造方法 --&gt; 防止外界调用构造方法创建对象</span></span><br><span class="line"><span class="comment">        2. 提供一个私有静态常量对象，这个对象就是单例类唯一创建对象</span></span><br><span class="line"><span class="comment">        3. 提供一个静态方法，获取这个创建好的对象，得到实例【外界只能通过这个方法获取对象】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Bank</span> <span class="variable">bank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> bank;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *生产者向共享资源中存储数据的方法【生产】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 存储钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                money = m + money;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;存了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *消费者向共享资源中存储数据的方法【消费】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 消费钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">popMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                money = money - m;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、完成生产者和消费者通信模型v2版本"><a href="#2、完成生产者和消费者通信模型v2版本" class="headerlink" title="2、完成生产者和消费者通信模型v2版本"></a><center>2、完成生产者和消费者通信模型v2版本</center></h2><p>使用了同步代码块+sleep方法，虽然让程序执行有序了也保证线程中操作临界资源过程也安全了，但是还是无法保证线程可以做到交替执行的效果【<strong>即生产者生产完数据之后通知消费者可以进行消费，消费者消费完数据之后通知生产者可以生产</strong>】，所以如何完成这个通信操作呢？</p><p>此时就需要使用Java中Object类中提供三个方法了</p><table><thead><tr><th align="center">线程通信方法</th><th align="center">方法说明</th></tr></thead><tbody><tr><td align="center">wait()</td><td align="center">执行该方法的线程对象会释放【同步锁资源】，JVM会把当前线程放到等待池中，等待其他线程唤醒操作</td></tr><tr><td align="center">notify()</td><td align="center">执行该方法的线程对象会在等待池【随机唤醒】一个等待的线程，把线程转移到锁池中等待，再次获取资源</td></tr><tr><td align="center">notifyAll()</td><td align="center">执行该方法的线程对象会在等地池中【唤醒所有的线程】，把线程转移到锁池中等待，再次获取资源</td></tr></tbody></table><p>&ensp;&ensp;&ensp;&ensp;就可以利用这三个方法进行线程通信操作了，<strong>特别注意调用通信方法必须是锁资源对象，否则会出现异常提示信息【在哪里调用等待方法就在位置被唤醒】</strong></p><p>线程通信执行流程：</p><p>&ensp;&ensp;&ensp;&ensp;假设<strong>A线程</strong>和<strong>B线程</strong>共同操作一个<strong>X锁对象</strong>，A、B线程可以通过X锁对象调用wait和notify方法进行如下线程通信操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当A线程执行到X锁对象时，A线程持有X锁对象，B线程是没有执行机会的，B线程在X对象的等待锁池中</span><br><span class="line">A线程在同步代码块种执行到X.wait方法时，A线程会释放X对象所资源，A线程会进入到X对象的等待锁池中</span><br><span class="line">B线程就会在等待锁池中得到A线程释放的X资源锁对象，B线程就开始执行操作</span><br><span class="line">B线程在同步代码块中执行到X.notify方法时，JVM把A线程从X对象等待池中，移动到等待X对象锁资源中得到锁资源</span><br><span class="line">B线程执行完毕之后释放锁资源，A线程就有机会获取到锁，继续执行同步方法</span><br></pre></td></tr></table></figure><p>修改Bank类提供线程通信操作者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.Thread.waitAndnotfiny.V2;</span><br><span class="line"><span class="comment">//通信的版本 ---》 提供临界资源并提供操作[添加线程通信和同步代码块+sleep方法]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bank</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        临界资源一共有两种提供方式【提供成员变量和提供静态变量】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;    <span class="comment">//存储前的临界变量</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        外界无论如何创建Bank类对象，都需要是唯一的，不然的话成员变量会跟着对象多少而进行创建</span></span><br><span class="line"><span class="comment">        提供对象唯一创建方式【单例设计模式】</span></span><br><span class="line"><span class="comment">        单例设计模式可以保证外界无论如何操作得到对象都是唯一</span></span><br><span class="line"><span class="comment">        单例设计模式的实现：</span></span><br><span class="line"><span class="comment">            1. 一定要私有化构造方法 --&gt; 防止外界调用构造方法创建对象</span></span><br><span class="line"><span class="comment">            2. 提供一个私有静态常量对象，这个对象就是单例类唯一创建对象</span></span><br><span class="line"><span class="comment">            3. 提供一个静态方法，获取这个创建好的对象，得到实例【外界只能通过这个方法获取对象】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Bank</span> <span class="variable">bank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> bank;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        在外界创建生产者与消费者线程对象中都是可以获取到CPU资源</span></span><br><span class="line"><span class="comment">        但是问题在于，如果消费者先获取到资源，但是没有数据不能消费</span></span><br><span class="line"><span class="comment">        所以就提供一个变量来存储状态的，通过对这个状态的判断决定执行哪个线程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *生产者向共享资源中存储数据的方法【生产】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 存储钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//添加线程通信操作</span></span><br><span class="line">                <span class="keyword">if</span>(isEmpty)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//如果条件为true值，就证明现在有数据，无需生产</span></span><br><span class="line">                    <span class="comment">//生产这个就进入到等待状态</span></span><br><span class="line">                    <span class="string">&quot;&quot;</span>.wait();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//因为if没有执行就证明，没有数据可以生产</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                money = m + money;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;存了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">                <span class="comment">//生产数据完毕之后需要修改状态信息</span></span><br><span class="line">                isEmpty = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//执行唤醒操作</span></span><br><span class="line">                <span class="string">&quot;&quot;</span>.notify();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *消费者向共享资源中存储数据的方法【消费】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 消费钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">popMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 增加线程通信操作</span></span><br><span class="line">                <span class="comment">//isEmpty状态值 false代表没有数据 true代表有属性</span></span><br><span class="line">                <span class="keyword">if</span>(!isEmpty)    <span class="comment">//没有数据的时候不能执行消费，等待生产</span></span><br><span class="line">                &#123; </span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                        没有数据isEmpty值是false，取非操作 !false --》 true if就执行等待</span></span><br><span class="line"><span class="comment">                        有数据isEmpty值是true ，取非操作 !true --》false if就不执行等待，进行消费</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="string">&quot;&quot;</span>.wait();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//if分支语句不执行就证明有数据，进行消费操作</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                money = money - m;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">                <span class="comment">//修改状态数据</span></span><br><span class="line">                isEmpty = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//进行唤醒操作</span></span><br><span class="line">                <span class="string">&quot;&quot;</span>.notify();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、分析执行流程"><a href="#3、分析执行流程" class="headerlink" title="3、分析执行流程"></a><center>3、分析执行流程</center></h2><ol><li>现有的两个线程生产者【花花】和消费者【菲菲】默认初始isEmpty状态都是false</li><li>消费者【菲菲】先获取到CPU时间片，持有所资源，判断if分支条件为!false,消费者【菲菲】就会释放锁资源并且进入到等待池中</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待池</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    生产者【花花】</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ol start="3"><li>等待池中生产者【花花】就会或得到执行CPU时间片，并且获取到锁资源，判断if分支条件false，证明没有数据，生产数据并且唤醒等待池中【菲菲】修改isEmpty值true，生产者线程就执行完毕了</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待池</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    消费者【菲菲】</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ol start="4"><li>此时生产者【花花】和消费者【菲菲】就会再次同时争抢CPU时间片和锁资源对象，假如生产者【花花】再次获取哦到CPU时间片和锁资源对象，执行线程逻辑，判断if分支条件为true，此时花花就会释放资源进入到等待池中</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待池</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    生产者【花花】</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ol start="5"><li>消费者【菲菲】必然获取到CPU时间片，执行操作逻辑判断条件!true 得到是false，就执行消费，并且修改状态为false，唤醒等待池中生产者，这样就完成交替执行效果</li></ol><p><strong>PS：以上这些操作就是典型的一对一生产者与消费者模型</strong></p><h1 id="知识点八：多对多通信模型"><a href="#知识点八：多对多通信模型" class="headerlink" title="知识点八：多对多通信模型"></a><center>知识点八：多对多通信模型</center></h1><p>提供线程对象创建操作， 这里从原有一对一的模式，变成多对多的模式，原来的一个生产者对应一个消费者，修改为了多个生产者对应多个消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//通过单例获取银行对象</span></span><br><span class="line">        <span class="type">Bank</span> <span class="variable">bank1</span> <span class="operator">=</span> Bank.getInstance();</span><br><span class="line">        <span class="comment">//2.创建线程对象并启动操作</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(bank1),<span class="string">&quot;花花1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(bank1),<span class="string">&quot;菲菲2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(bank1),<span class="string">&quot;花花3&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(bank1),<span class="string">&quot;菲菲4&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当将线程对象增多之后，执行多线程同时操作就出现两个问题“<strong>负数问题和死等待问题</strong>”</p><h2 id="1、负数问题"><a href="#1、负数问题" class="headerlink" title="1、负数问题"></a><center>1、负数问题</center></h2><p>现有线程【花花1（存)、菲菲2（取）、花花3（存）、菲菲4（取）】，模拟一个执行流程</p><ol><li>菲菲2先抢到线程，不能取，所以进入到等待队列中，释放CPU时间片和释放锁资源</li><li>菲菲4抢到线程资源，不能取，所以进入到等待列中，释放CPU时间片和释放锁资源</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待队列 菲菲2、菲菲4</span></span><br></pre></td></tr></table></figure><ol start="3"><li>花花1抢到线程，存储了数据，修改标记为true值，并唤醒等待队列中的线程的线程对象，现在使用唤醒机制notify方法【随机唤醒一个等待队列汇总线程对象】，假设唤醒了菲菲4</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待队列中 菲菲2</span></span><br><span class="line"><span class="comment">//外部争抢CPU操作的时间片 花花1、花花3、菲菲4</span></span><br><span class="line"><span class="comment">//临界资源中存储数据是 ---》 1000</span></span><br></pre></td></tr></table></figure><ol start="4"><li>菲菲4抢到了线程，在哪里等待就在哪里被唤醒，而且if分支语句特点，只会执行一次判断即if分支条件判断完成之后【不添加循环前提】，只会执行一次判断，菲菲4正好是在if分支语句中进行等待操作，醒来之后机会继续向后执行【它是不会在判断if分支语句】，菲菲4进行正常消费，修改标记为false，需要执行notify，唤醒等待队列菲菲2【菲菲2这个线程是通过wait进入到等待状态，它已经执行了if判断】</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待队列中 空</span></span><br><span class="line"><span class="comment">// 外部增强CPU操作者时间片 花花1、菲菲2【从等待状态恢复而来】、花花3、菲菲4</span></span><br><span class="line"><span class="comment">// 临界资源中存储的数据是 ----》 0 【因为菲菲4消费了】</span></span><br></pre></td></tr></table></figure><ol start="5"><li>菲菲2抢到了执行权，会在if分支语句继续执行操作，此时虽然标记已经修改为false，正常而言不应该消费的，但是if分支语句已经被执行过，所以不会进行判断继续执行，进行消费，修改标记，执行唤醒</li></ol><p>但是现在的数据是 0 在执行消费出现数据就是 -1000</p><p><strong>为了保证线程通信可以正常执行，建议在开发的时候，不要书写if作为状态判断操作，建议使用while循环语句替代if分支，while循环语句只有条件为false，才不执行，否者就继续执行，这样就可以让等待位置线程在次被唤醒之后可以再次判断状态操作，以防出现错误数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.Thread.waitAndnotfiny.V3;</span><br><span class="line"><span class="comment">//通信的版本【多对多】 ---》 提供临界资源并提供操作[添加线程通信和同步代码块+sleep方法]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bank</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    临界资源一共有两种提供方式【提供成员变量和提供静态变量】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;<span class="comment">//存储前的临界变量</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        外界无论如何创建Bank类对象，都需要是唯一的，不然的话成员变量会跟着对象多少而进行创建</span></span><br><span class="line"><span class="comment">        提供对象唯一创建方式【单例设计模式】</span></span><br><span class="line"><span class="comment">        单例设计模式可以保证外界无论如何操作得到对象都是唯一</span></span><br><span class="line"><span class="comment">        单例设计模式的实现：</span></span><br><span class="line"><span class="comment">        1. 一定要私有化构造方法 --&gt; 防止外界调用构造方法创建对象</span></span><br><span class="line"><span class="comment">        2. 提供一个私有静态常量对象，这个对象就是单例类唯一创建对象</span></span><br><span class="line"><span class="comment">        3. 提供一个静态方法，获取这个创建好的对象，得到实例【外界只能通过这个方法获取对象】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Bank</span> <span class="variable">bank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> bank;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        在外界创建生产者与消费者线程对象中都是可以获取到CPU资源</span></span><br><span class="line"><span class="comment">        但是问题在于，如果消费者先获取到资源，但是没有数据不能消费</span></span><br><span class="line"><span class="comment">        所以就提供一个变量来存储状态的，通过对这个状态的判断决定执行哪个线程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *生产者向共享资源中存储数据的方法【生产】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 存储钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//添加线程通信操作</span></span><br><span class="line">                <span class="comment">//只需要将if修改为while即可</span></span><br><span class="line">                <span class="keyword">while</span>(isEmpty)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//如果条件为true值，就证明现在有数据，无需生产</span></span><br><span class="line">                    <span class="comment">//生产这个就进入到等待状态</span></span><br><span class="line">                    <span class="string">&quot;&quot;</span>.wait();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//因为if没有执行就证明，没有数据可以生产</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                money = m + money;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;存了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">                <span class="comment">//生产数据完毕之后需要修改状态信息</span></span><br><span class="line">                isEmpty = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//执行唤醒操作</span></span><br><span class="line">                <span class="string">&quot;&quot;</span>.notify();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *消费者向共享资源中存储数据的方法【消费】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 消费钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">popMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 增加线程通信操作</span></span><br><span class="line">                <span class="comment">//isEmpty状态值 false代表没有数据 true代表有属性</span></span><br><span class="line">                <span class="comment">//只需要将if修改为while即可</span></span><br><span class="line">                <span class="keyword">while</span>(!isEmpty)    <span class="comment">//没有数据的时候不能执行消费，等待生产</span></span><br><span class="line">                &#123; </span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                        没有数据isEmpty值是false，取非操作 !false --》 true if就执行等待</span></span><br><span class="line"><span class="comment">                        有数据isEmpty值是true ，取非操作 !true --》false if就不执行等待，进行消费</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="string">&quot;&quot;</span>.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//if分支语句不执行就证明有数据，进行消费操作</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                money = money - m;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">                <span class="comment">//修改状态数据</span></span><br><span class="line">                isEmpty = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//进行唤醒操作</span></span><br><span class="line">                <span class="string">&quot;&quot;</span>.notify();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、死等待问题"><a href="#2、死等待问题" class="headerlink" title="2、死等待问题"></a><center>2、死等待问题</center></h2><p>所有线程都进入到等待池中无人唤醒</p><p><strong>PS：这个效果是需要特殊情况下才会出现【它属于一个极端情况】</strong></p><p><strong>这个原因的产生就是使用notfiy随机唤醒机制</strong></p><p>现有线程【花花1（存)、菲菲2（取）、花花3（存）、菲菲4（取）】模拟一个执行流程</p><ol><li>菲菲2先抢到线程，不能取，所以进入到等待池中，释放锁和CPU时间片</li><li>菲菲4抢到线程，不能取，所以进入到等待池中，释放锁和CPU时间片</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待队列中 菲菲2、菲菲4</span></span><br></pre></td></tr></table></figure><ol start="3"><li>花花1抢到线程，存储数据，修改标记为true并进行唤醒操作【随机唤醒】</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待队列中 菲菲2</span></span><br><span class="line"><span class="comment">//争抢CPU资源 花花1、花花3、菲菲4</span></span><br></pre></td></tr></table></figure><ol start="4"><li>花花1在次获取线程，不能存储，所以要进入到等待队列中，释放锁和CPU时间片</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待队列中 菲菲2、花花1 //争抢CPU资源 花花3、菲菲4</span></span><br></pre></td></tr></table></figure><ol start="5"><li>花花3抢到线程，不能存储，所以要进入到等待队列中，释放锁和CPU时间片</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待队列中 菲菲2、花花1、花花3 //争抢CPU资源 菲菲4</span></span><br></pre></td></tr></table></figure><ol start="6"><li>菲菲4抢到线程，取钱消费，修改标记为false，并进入唤醒操作【随机唤醒】 –》 菲菲2唤醒</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待队列汇总 花花1、花花3 //争抢CPU资源 菲菲4、菲菲2 ，现在状态时false</span></span><br></pre></td></tr></table></figure><ol start="7"><li>生产者都在等待队列中，外部都是消费这个，现在状态时false</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待队列中 花花1、花花3、菲菲4、菲菲2</span></span><br></pre></td></tr></table></figure><p>所有线程都进入到等待队列中，无人唤醒就出现死的等待问题</p><p>&ensp;&ensp;&ensp;&ensp;之所以会出现死等待原因就因为使用了notify的操作，它是随机唤醒，等待池中两个消费，外界两个生产【生产完毕，状态修改，无法唤醒】，或等待池中两个生产，外界两个消费【消费完毕，状态修改，无法唤醒】，<strong>建议使用notifyAll 替换 notfiy</strong>，进行全部唤醒，然后再进行条件判断执行操作，决定好是否存储与消费</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通信的版本 ---》 提供临界资源并提供操作[添加线程通信和同步代码块+sleep方法]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bank</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        临界资源一共有两种提供方式【提供成员变量和提供静态变量】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;<span class="comment">//存储前的临界变量</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        外界无论如何创建Bank类对象，都需要是唯一的，不然的话成员变量会跟着对象多少而进行创建</span></span><br><span class="line"><span class="comment">        提供对象唯一创建方式【单例设计模式】</span></span><br><span class="line"><span class="comment">        单例设计模式可以保证外界无论如何操作得到对象都是唯一</span></span><br><span class="line"><span class="comment">        单例设计模式的实现：</span></span><br><span class="line"><span class="comment">        1. 一定要私有化构造方法 --&gt; 防止外界调用构造方法创建对象</span></span><br><span class="line"><span class="comment">        2. 提供一个私有静态常量对象，这个对象就是单例类唯一创建对象</span></span><br><span class="line"><span class="comment">        3. 提供一个静态方法，获取这个创建好的对象，得到实例【外界只能通过这个方法获取对象】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Bank</span> <span class="variable">bank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> bank;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        在外界创建生产者与消费者线程对象中都是可以获取到CPU资源</span></span><br><span class="line"><span class="comment">        但是问题在于，如果消费者先获取到资源，但是没有数据不能消费</span></span><br><span class="line"><span class="comment">        所以就提供一个变量来存储状态的，通过对这个状态的判断决定执行哪个线程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *生产者向共享资源中存储数据的方法【生产】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 存储钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//添加线程通信操作</span></span><br><span class="line">                <span class="keyword">while</span>(isEmpty)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//如果条件为true值，就证明现在有数据，无需生产</span></span><br><span class="line">                    <span class="comment">//生产这个就进入到等待状态</span></span><br><span class="line">                    <span class="string">&quot;&quot;</span>.wait();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//因为if没有执行就证明，没有数据可以生产</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                money = m + money;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;存了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">                <span class="comment">//生产数据完毕之后需要修改状态信息</span></span><br><span class="line">                isEmpty = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//执行唤醒操作进行全部唤醒操作</span></span><br><span class="line">                <span class="string">&quot;&quot;</span>.notifyAll();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *消费者向共享资源中存储数据的方法【消费】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 消费钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">popMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;&quot;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 增加线程通信操作</span></span><br><span class="line">                <span class="comment">//isEmpty状态值 false代表没有数据 true代表有属性</span></span><br><span class="line">                <span class="keyword">while</span>(!isEmpty)    <span class="comment">//没有数据的时候不能执行消费，等待生产</span></span><br><span class="line">                &#123; </span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    没有数据isEmpty值是false，取非操作 !false --》 true if就执行等待</span></span><br><span class="line"><span class="comment">                    有数据isEmpty值是true ，取非操作 !true --》false if就不执行等待，进行消费</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="string">&quot;&quot;</span>.wait();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//if分支语句不执行就证明有数据，进行消费操作</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                money = money - m;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">                <span class="comment">//修改状态数据</span></span><br><span class="line">                isEmpty = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//进行唤醒操作修改为全部唤醒</span></span><br><span class="line">                <span class="string">&quot;&quot;</span>.notifyAll();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：如果在日后的开发中出现线程通信操作，建议判断状态标签的位置使用while关键字而不是if，进行唤醒操作建议使用notfiyAll而不是notify</strong></p><h2 id="3、扩展：Lock接口【显示锁】"><a href="#3、扩展：Lock接口【显示锁】" class="headerlink" title="3、扩展：Lock接口【显示锁】"></a><center>3、扩展：Lock接口【显示锁】</center></h2><p>Lock接口是Java5中新加入与Synchronized比较操作，它属于显示定义，结构更加灵活，提供了一个更加便捷的操作，相对比synchronized更加简洁易用</p><p>PS：这个锁资源Lock虽然语法更加简洁易用，但是它不能定义锁对象，Lock使用锁对象是【this】，<strong>使用Lock时就需要保证this的唯一性了</strong></p><p><strong>Lock锁如何操作？</strong></p><p>&ensp;&ensp;&ensp;&ensp;Lock是一个接口所以需要使用到他实现类进行锁的操作</p><p><strong>ReentrantLock</strong>提供两常用操作</p><table><thead><tr><th align="center">Lock锁方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">lock()</td><td align="center">添加锁(对象上锁)</td></tr><tr><td align="center">unlock()</td><td align="center">释放锁(对象所释放)</td></tr></tbody></table><p>&ensp;&ensp;&ensp;&ensp;以为Lock是一个显示锁对象，所有不能调用Object类中提供wait、notify、notifyAll方法进行线程通信，所以系统就提供了<strong>一个和Lock锁一起使用线程通信接口Condititon</strong></p><table><thead><tr><th align="center">通信方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">await()</td><td align="center">线程等待释放锁资源和CPU时间片</td></tr><tr><td align="center">signal()</td><td align="center">唤醒等待池中某一个线程对象【随机唤醒】</td></tr><tr><td align="center">signalAll()</td><td align="center">唤醒等待池中所有线程对象</td></tr></tbody></table><p>使用Lock锁替代Synchronized同步代码块进行数据操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="comment">//通信的版本【多对多】 ---》 提供临界资源并提供操作[添加线程Lock锁+sleep方法+线程通信]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankLock</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        临界资源一共有两种提供方式【提供成员变量和提供静态变量】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;<span class="comment">//存储前的临界变量</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        外界无论如何创建Bank类对象，都需要是唯一的，不然的话成员变量会跟着对象多少而进行创建</span></span><br><span class="line"><span class="comment">        提供对象唯一创建方式【单例设计模式】</span></span><br><span class="line"><span class="comment">        单例设计模式可以保证外界无论如何操作得到对象都是唯一</span></span><br><span class="line"><span class="comment">        单例设计模式的实现：</span></span><br><span class="line"><span class="comment">        1. 一定要私有化构造方法 --&gt; 防止外界调用构造方法创建对象</span></span><br><span class="line"><span class="comment">        2. 提供一个私有静态常量对象，这个对象就是单例类唯一创建对象</span></span><br><span class="line"><span class="comment">        3. 提供一个静态方法，获取这个创建好的对象，得到实例【外界只能通过这个方法获取对象】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">BankLock</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">BankLock</span> <span class="variable">bank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BankLock</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BankLock <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> bank;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//提供锁资源对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">//提供线程通信资源对象【它是接口不能new，使用lock对象调用newCondition创建】</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        在外界创建生产者与消费者线程对象中都是可以获取到CPU资源</span></span><br><span class="line"><span class="comment">        但是问题在于，如果消费者先获取到资源，但是没有数据不能消费</span></span><br><span class="line"><span class="comment">        所以就提供一个变量来存储状态的，通过对这个状态的判断决定执行哪个线程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *生产者向共享资源中存储数据的方法【生产】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 存储钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//synchronized (&quot;&quot;) //替换成lock锁资源对象</span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//添加线程通信操作</span></span><br><span class="line">                <span class="comment">//只需要将if修改为while即可</span></span><br><span class="line">                <span class="keyword">while</span>(isEmpty)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//如果条件为true值，就证明现在有数据，无需生产</span></span><br><span class="line">                    <span class="comment">//生产这个就进入到等待状态</span></span><br><span class="line">                    <span class="comment">// &quot;&quot;.wait();</span></span><br><span class="line">                    condition.await();    <span class="comment">//使用通信资源创建对象</span></span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//因为if没有执行就证明，没有数据可以生产</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                money = m + money;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;存了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">                <span class="comment">//生产数据完毕之后需要修改状态信息</span></span><br><span class="line">                isEmpty = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//执行唤醒操作</span></span><br><span class="line">                <span class="comment">//&quot;&quot;.notifyAll();</span></span><br><span class="line">                condition.signalAll();    <span class="comment">//使用通信资源创建对象</span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> </span><br><span class="line">            &#123;</span><br><span class="line">                lock.unlock(); <span class="comment">//锁资源释放</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *消费者向共享资源中存储数据的方法【消费】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m 消费钱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">popMoney</span><span class="params">(<span class="type">double</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//synchronized (&quot;&quot;) </span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 增加线程通信操作</span></span><br><span class="line">                    <span class="comment">//isEmpty状态值 false代表没有数据 true代表有属性</span></span><br><span class="line">                    <span class="comment">//只需要将if修改为while即可</span></span><br><span class="line">                    <span class="keyword">while</span>(!isEmpty)    <span class="comment">//没有数据的时候不能执行消费，等待生产</span></span><br><span class="line">                    &#123; </span><br><span class="line">                    </span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                            没有数据isEmpty值是false，取非操作 !false --》 true if就执行等待</span></span><br><span class="line"><span class="comment">                            有数据isEmpty值是true ，取非操作 !true --》false if就不执行等待，进行消费</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">                        <span class="comment">//&quot;&quot;.wait();</span></span><br><span class="line">                        condition.await();</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="comment">//if分支语句不执行就证明有数据，进行消费操作</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    money = money - m;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取了&quot;</span> + m + <span class="string">&quot;余额是：&quot;</span> + money);</span><br><span class="line">                    <span class="comment">//修改状态数据</span></span><br><span class="line">                    isEmpty = <span class="literal">false</span>;</span><br><span class="line">                    <span class="comment">//进行唤醒操作</span></span><br><span class="line">                    <span class="comment">// &quot;&quot;.notifyAll();</span></span><br><span class="line">                    condition.signalAll();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点九：线程声明周期"><a href="#知识点九：线程声明周期" class="headerlink" title="知识点九：线程声明周期"></a><center>知识点九：线程声明周期</center></h1><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012240972.png" alt="声明周期" style="zoom:50%;"><p>线程声明周期分为两条线:</p><ol><li>基础线程声明周期： 新建 —》 准备就绪 —》 运行状态 —》 死亡状态</li><li>对线程添加了一些操作造成线程阻塞现象的产生【sleep、join、wait、synchronized等等】</li></ol><p>新建 —》 准备就绪 —》 运行状态 —》【 阻塞状态 —》 准备就绪 —》 运行状态】 —》 死亡状态</p><p>PS：在阻塞状态没有消失之前</p><p>准备就绪 —》 运行状态 —》阻塞状态 —》 准备就绪 —》 运行状态 ….. 【会一直重复执行】</p><p>1、新建状态(new):使用new创建一个线程对象,仅仅在堆中分配内存空间,在调用start方法之前.</p><p>&ensp;&ensp;&ensp;&ensp;新建状态下,线程压根就没有启动,仅仅只是存在一个线程对象而已.</p><p>&ensp;&ensp;&ensp;&ensp;Thread t &#x3D; new Thread();&#x2F;&#x2F;此时t就属于新建状态</p><p>&ensp;&ensp;&ensp;&ensp;当新建状态下的线程对象调用了start方法,此时从新建状态进入可运行状态</p><p>&ensp;&ensp;&ensp;&ensp;线程对象的start方法只能调用一次,否则报错:IllegalThreadStateException</p><p>2、可运行状态(runnable):分成两种状态，ready和running。分别表示就绪状态和运行状态</p><p>&ensp;&ensp;&ensp;&ensp;就绪状态:线程对象调用start方法之后,等待JVM的调度(此时该线程并没有运行).</p><p>&ensp;&ensp;&ensp;&ensp;运行状态:线程对象获得JVM调度,如果存在多个CPU,那么允许多个线程并行运行</p><p>3、阻塞状态(blocked):正在运行的线程因为某些原因放弃CPU,暂时停止运行,就会进入阻塞状态.</p><p>&ensp;&ensp;&ensp;&ensp;此时JVM不会给线程分配CPU,直到线程重新进入就绪状态,才有机会转到运行状态.</p><p>&ensp;&ensp;&ensp;&ensp;阻塞状态只能先进入就绪状态,不能直接进入运行状态</p><p>&ensp;&ensp;&ensp;&ensp;阻塞状态的两种情况:</p><p>&ensp;&ensp;&ensp;&ensp;（1）当A线程处于运行过程时,试图获取同步锁时,却被B线程获取.此时JVM把当前A线程存到对象的锁池中,A线程进入阻塞状态.</p><p>&ensp;&ensp;&ensp;&ensp;（2）当线程处于运行过程时,发出了IO请求时,此时进入阻塞状态</p><p>4、等待状态(waiting)(等待状态只能被其他线程唤醒):此时使用的无参数的wait方法,</p><p>&ensp;&ensp;&ensp;&ensp;（1）当线程处于运行过程时,调用了wait()方法,此时JVM把当前线程存在对象等待池中</p><p>5、计时等待状态(timed waiting)(使用了带参数的wait方法或者sleep方法)</p><p>&ensp;&ensp;&ensp;&ensp;(1)当线程处于运行过程时,调用了wait(long time)方法,此时JVM把当前线程存在对象等待池中.</p><p>&ensp;&ensp;&ensp;&ensp;(2)当前线程执行了sleep(long time)方法.</p><p>6、终止状态(terminated):通常称为死亡状态，表示线程终止.</p><p>&ensp;&ensp;&ensp;&ensp;(1)正常执行完run方法而退出(正常死亡).</p><p>&ensp;&ensp;&ensp;&ensp;(2)遇到异常而退出(出现异常之后,程序就会中断)(意外死亡)</p><p>线程一旦终止,就不能再重启启动,否则报错(IllegalThreadStateException).</p><p>在Thread类中过时的方法(因为存在线程安全问题,所以弃用了【真心好用，绝对不能用】)</p><p>&ensp;&ensp;&ensp;&ensp;void suspend() :暂停当前线程</p><p>&ensp;&ensp;&ensp;&ensp;void resume() :恢复当前线程</p><p>&ensp;&ensp;&ensp;&ensp;void stop() :结束当前线程</p><h1 id="知识点十：拓展"><a href="#知识点十：拓展" class="headerlink" title="知识点十：拓展"></a><center>知识点十：拓展</center></h1><h2 id="1、线程池【重点】"><a href="#1、线程池【重点】" class="headerlink" title="1、线程池【重点】"></a><center>1、线程池【重点】</center></h2><h3 id="（1）线程池概念"><a href="#（1）线程池概念" class="headerlink" title="（1）线程池概念"></a>（1）线程池概念</h3><p>如果有非常的多的任务需要多线程来完成，且每个线程执行时间不会太长，这样频繁的创建和销毁线程。</p><p>频繁创建和销毁线程会比较耗性能。有了线程池就不要创建更多的线程来完成任务，因为线程可以重用</p><p>线程池用维护者一个队列，队列中保存着处于等待（空闲）状态的线程。不用每次都创建新的线程</p><h3 id="（2）线程池实现原理"><a href="#（2）线程池实现原理" class="headerlink" title="（2）线程池实现原理"></a>（2）线程池实现原理</h3><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012242641.png" alt="实现原理" style="zoom:50%;"><h3 id="（3）线程池中常见的类"><a href="#（3）线程池中常见的类" class="headerlink" title="（3）线程池中常见的类"></a>（3）线程池中常见的类</h3><p>常用的线程池接口和类(所在包java.util.concurrent)</p><p>Executor：线程池的顶级接口。</p><p>ExecutorService：线程池接口，可过submit(Runnable task) 提交任务代码</p><p>Executors工厂类：通过此类可以获得一个线程池</p><table><thead><tr><th align="center">方法名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">newFixedThreadPool(int nThreads)</td><td align="center">获取固定数量的线程池。参数：指定线程池中线程的数量</td></tr><tr><td align="center">newCachedThreadPool()</td><td align="center">获得动态数量的线程池，如不够则创建新的，无上限</td></tr></tbody></table><p><strong>创建方法一：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qf.demo.thread1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作者：星仔</span></span><br><span class="line"><span class="comment"> * 描述：永无Bug</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建一个线程池对象   创建了一个固定数量3个的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);   <span class="comment">//返回ExecutorService对象</span></span><br><span class="line">        <span class="comment">//2.通过线程池对象调用sumit方法来提交线程任务</span></span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable1</span>());   <span class="comment">//传入实现runnable接口的类</span></span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable2</span>());</span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable3</span>());</span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable4</span>());</span><br><span class="line">        <span class="comment">//3.结束线程池</span></span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable3</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">20</span>; i &lt; <span class="number">30</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable4</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">30</span>; i &lt; <span class="number">40</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建方式二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qf.demo.thread1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作者：星仔</span></span><br><span class="line"><span class="comment"> * 描述：永无Bug</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo02</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建一个线程池对象   创建一个带缓存的连接池对象</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//2.通过线程池对象，提交线程任务，并启动线程执行任务</span></span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;--&gt;&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;--&gt;&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;--&gt;&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//3.关闭连接池</span></span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（4）Callable接口"><a href="#（4）Callable接口" class="headerlink" title="（4）Callable接口"></a>（4）Callable接口</h3><p>JDK5加入，与Runnable接口类似，实现之后代表一个线程任务。</p><p>Callable具有泛型返回值、可以声明异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt; V &gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不使用返回值和Runnable的作用一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qf.demo.thread1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作者：星仔</span></span><br><span class="line"><span class="comment"> * 描述：永无Bug</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建一个线程对象</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//2.通过线程池对象提交线程任务，并启动线程执行任务</span></span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.关闭线程对象</span></span><br><span class="line">        es.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>   <span class="comment">//Callable接口的泛型表示call方法返回值的类型</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qf.demo.thread1;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作者：星仔</span></span><br><span class="line"><span class="comment"> * 描述：永无Bug</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableDemo02</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建一个线程对象</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//2.通过线程池对象提交线程任务，并启动线程执行任务</span></span><br><span class="line">        Future&lt;String&gt; future = es.submit(<span class="keyword">new</span> <span class="title class_">MyCallable2</span>());   <span class="comment">//保存线程的返回结果</span></span><br><span class="line">        System.out.println(future.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.关闭线程对象</span></span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable2</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;这是call方法返回值&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qf.demo.thread1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作者：星仔</span></span><br><span class="line"><span class="comment"> * 描述：永无Bug</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableDemo03</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//需求：线程A 计算1~50 线程B 51~100  最终得到结果</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        Future&lt;Integer&gt; f1 = es.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">51</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    sum += i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Future&lt;Integer&gt; f2 = es.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">51</span>; i &lt; <span class="number">101</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    sum += i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;结果为:&quot;</span> + (f1.get() + f2.get()));</span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（5）Future接口"><a href="#（5）Future接口" class="headerlink" title="（5）Future接口"></a>（5）Future接口</h3><p>Future接口表示将要执行完任务的结果。</p><p>get()以阻塞形式等待Future中的异步处理结果（call()的返回值）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCallable2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Runnable接口和Callable接口的区别？</span></span><br><span class="line"><span class="comment">    * 1、这两个接口都可以当做线程任务提交并执行</span></span><br><span class="line"><span class="comment">    * 2、Callable接口执行完线程任务之后有返回值，而Runnable接口没有返回值</span></span><br><span class="line"><span class="comment">    * 3、Callable接口中的call方法已经抛出了异常，而Runnable接口不能抛出编译异常</span></span><br><span class="line"><span class="comment">    * Future接口：</span></span><br><span class="line"><span class="comment">    * 用于接口Callable线程任务的返回值。</span></span><br><span class="line"><span class="comment">    * get()方法当线程任务执行完成之后才能获取返回值，这个方法是一个阻塞式的方法</span></span><br><span class="line"><span class="comment">    *随堂案例：</span></span><br><span class="line"><span class="comment">    * 使用两个线程，并发计算1-100的和， 一个线程计算1~50,另一个线程计算51~100， 最终汇总结果</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException,</span><br><span class="line">ExecutionException </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1、创建线程池对象</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//2、通过线程池提交线程并执行任务</span></span><br><span class="line">        Future&lt;String&gt; future = es.submit(<span class="keyword">new</span> <span class="title class_">MyCallable1</span>());</span><br><span class="line">        <span class="comment">//获取线程任务的返回值</span></span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;哈哈哈哈哈哈&quot;</span>);</span><br><span class="line">        <span class="comment">//3、关闭线程池</span></span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable1</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&gt;&quot;</span>+i);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;这是Callable线程任务的返回值&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（6）读写锁"><a href="#（6）读写锁" class="headerlink" title="（6）读写锁"></a>（6）读写锁</h3><p>ReentrantReadWriteLock：</p><p>&ensp;&ensp;&ensp;&ensp;一种支持一写多读的同步锁，读写分离，可分别分配读锁、写锁。</p><p>&ensp;&ensp;&ensp;&ensp;支持多次分配读锁，使多个读操作可以并发执行。</p><p>互斥规则：</p><p>&ensp;&ensp;&ensp;&ensp;写-写：互斥，阻塞</p><p>&ensp;&ensp;&ensp;&ensp;读-写：互斥，读阻塞写、写阻塞读。</p><p>&ensp;&ensp;&ensp;&ensp;读-读：不互斥、不阻塞。</p><p>&ensp;&ensp;&ensp;&ensp;在读操作远远高于写操作的环境中，可在保障线程安全的情况下，提高运行效率</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qf.demo.thread2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作者：星仔</span></span><br><span class="line"><span class="comment"> * 描述：永无Bug</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriterLockDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//记录开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//1.创建线程池对象</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//2.提交8个读操作任务，提交2个写操作任务</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        <span class="type">ReadThread</span> <span class="variable">readThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReadThread</span>(user);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            es.submit(readThread);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="type">WriteThread</span> <span class="variable">writeThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WriteThread</span>(user);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            es.submit(writeThread);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.结束线程池</span></span><br><span class="line">        es.shutdown();</span><br><span class="line">        <span class="comment">//es.isTerminated();    获取当前线程池的状态，如果线程池钟的任务执行结束，那么返回true，否则返回false</span></span><br><span class="line">        <span class="comment">//System.out.println(es.isTerminated());</span></span><br><span class="line">        <span class="comment">//我们希望以下的代码在线程任务执行结束之后再执行.利用代码空转来判断</span></span><br><span class="line">        <span class="keyword">while</span> (!es.isTerminated())</span><br><span class="line">        &#123;&#125;</span><br><span class="line">        <span class="comment">//记录结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时&quot;</span> + (end-start) + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写线程</span></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">WriteThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    User user;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WriteThread</span><span class="params">(User user)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        user.setName(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReadThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    User user;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReadThread</span><span class="params">(User user)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        user.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//读写锁</span></span><br><span class="line">    <span class="type">ReentrantReadWriteLock</span> <span class="variable">rrwl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="comment">//读锁</span></span><br><span class="line">    ReentrantReadWriteLock.<span class="type">ReadLock</span> <span class="variable">readLock</span> <span class="operator">=</span> rrwl.readLock();</span><br><span class="line">    <span class="comment">//写锁</span></span><br><span class="line">    ReentrantReadWriteLock.<span class="type">WriteLock</span> <span class="variable">writeLock</span> <span class="operator">=</span> rrwl.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读操作</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读和写都需要花一秒，而读和读是不影响的，读和写的互斥的，写和写是互斥的</span></span><br><span class="line"><span class="comment">//class User</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    private String name;</span></span><br><span class="line"><span class="comment">//    Lock lock = new ReentrantLock();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    //写操作</span></span><br><span class="line"><span class="comment">//    public void setName(String name)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        lock.lock();</span></span><br><span class="line"><span class="comment">//        try</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            Thread.sleep(1000);</span></span><br><span class="line"><span class="comment">//            this.name = name;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        catch (InterruptedException e)</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        finally</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            lock.unlock();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    //读操作</span></span><br><span class="line"><span class="comment">//    public String getName()</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        lock.lock();</span></span><br><span class="line"><span class="comment">//        try</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            Thread.sleep(1000);</span></span><br><span class="line"><span class="comment">//            return name;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        catch (InterruptedException e)</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        finally</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            lock.unlock();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        return null;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><h3 id="（7）重入锁"><a href="#（7）重入锁" class="headerlink" title="（7）重入锁"></a>（7）重入锁</h3><p>重入锁:在同步锁中可以继续加入同步锁(锁对象是同一个)</p><p>&ensp;&ensp;&ensp;&ensp;synchronized和Lock锁都可以实现锁的重入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestReentrantLock</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 重入锁:在同步锁中可以继续加入同步锁(锁对象是同一个)</span></span><br><span class="line"><span class="comment">    * synchronized和Lock锁都可以实现锁的重入</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        a();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//当前锁对象为this</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        b();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//当前锁对象为this</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        c();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">c</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（8）公平锁"><a href="#（8）公平锁" class="headerlink" title="（8）公平锁"></a>（8）公平锁</h3><p>公平锁和非公平锁</p><p>&ensp;&ensp;&ensp;&ensp;非公平锁：优先使用上一个线程接着执行下面的线程任务</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;synchronized是非公平锁的实现，无法实现公平锁</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;lock锁默认是非公平锁，如果想要实现公平锁，那么需要在构造方法设置为true</p><p>&ensp;&ensp;&ensp;&ensp;公平锁：让每个线程都公平去执行线程任务</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;lock锁可以实现公平锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Lock锁实现公平锁 参数为true表示是公平锁，默认是false表示非公平锁</span></span><br><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;知识点一：Thread线程基础&quot;&gt;&lt;a href=&quot;#知识点一：Thread线程基础&quot; class=&quot;headerlink&quot; title=&quot;知识点一：Thread线程基础&quot;&gt;&lt;/a&gt;&lt;center&gt;知识点一：Thread线程基础&lt;/center&gt;&lt;/h1&gt;&lt;p&gt;有</summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>23.IO流</title>
    <link href="http://example.com/post/3e1167ea.html"/>
    <id>http://example.com/post/3e1167ea.html</id>
    <published>2023-12-30T05:11:05.000Z</published>
    <updated>2024-03-01T12:21:57.526Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识点一：概念"><a href="#知识点一：概念" class="headerlink" title="知识点一：概念"></a><center>知识点一：概念</center></h1><p><strong>PS：IO很简单主要记忆的就是IO中进行文件读写操作</strong></p><p>Java中IO流的作用：IO流在Java中作用就是将内存中数据写入到磁盘进行保存，程序运行时将磁盘中的数据读取到内存中进行处理</p><p>在Java中在没有学习到IO流之前，在程序中所有处理数据都是在内存中进行存储的【栈和堆】，在内存中存储的好处在于【执行效率高】坏处【数据无法持久存储】</p><p>内存中存储体现在于【DVD操作系统】：所有数据使用集合存储之后依旧是在内存中进行存储，每次执行程序时，都会在内存从新初始化集合中数据，这样就造成无论你如何修改集合中数据，只要程序重新运行数据使用保持原始状态</p><p>所以需要将内存中数据保存到磁盘中进行持久保存【将内存中数据写成文件中内容进行保存操作】，如果将内存中数据写到磁盘中，就需要使用到IO流【使用输出流】，数据存存储在磁盘文件之后，程序运行时需要加载磁盘中文件数据【将磁盘文件中内容读取到内存中进行处理】，如果需要将磁盘中文件内读取到内存中，就需要使用到IO流【使用输入流】</p><p>什么是IO流？</p><p>I —》 顾名思义 —》IN(读取、输入、读入) –》将磁盘中文件内容读取到内存中</p><p>O—》 顾名思义 –》OUT(输出、写出、写入) —》将内存中数据写入到磁盘文件中</p><p><strong>IO流就是内存与磁盘【存储设备】之间数据传输通道</strong></p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011942738.png" alt="传输过程" style="zoom:33%;"><p>在程序中所有的数据都是以流的方式进行传输与保存，程序需要数据时使用输入流读取数据，当程序需要保存数据时使用输出流保存数据</p><p>除了对数据保存之外，实际在网页中的文件上传与下载操作就是IO流完成</p><p><strong>PS：IO操作属于“长连接”，需要管理这个连接操作，如果不管理这个连接操作，会造成IO流操作会持续在内存中存在，会造成内存浪费，所以在不使用IO操作下，一定要关闭IO流</strong></p><h1 id="知识点二：Java中提供常用IO流"><a href="#知识点二：Java中提供常用IO流" class="headerlink" title="知识点二：Java中提供常用IO流"></a><center>知识点二：Java中提供常用IO流</center></h1><p>IO流其实就是建立起内存与硬盘【存设备】之间数据传输通道，通过这个通道可以将数据进行读取与写入操作，这个就是IO流本质</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403011943586.png" alt="输入输出关系" style="zoom:50%;"><p>可以根据IO流进行简单的分类</p><p>根据流的流向：</p><p>&ensp;&ensp;&ensp;&ensp;输入流： 把存储在磁盘中数据读取到内存中</p><p>&ensp;&ensp;&ensp;&ensp;输出流 : 把内存中数据写入到磁盘中</p><p>根据流中数据：</p><p>&ensp;&ensp;&ensp;&ensp;字节流： 无论是输入还是输出流中数据都是byte类型</p><p>&ensp;&ensp;&ensp;&ensp;字符流： 无论是输入还是输出流中数据都是char类型</p><h1 id="知识点三：字节输入输出流"><a href="#知识点三：字节输入输出流" class="headerlink" title="知识点三：字节输入输出流"></a><center>知识点三：字节输入输出流</center></h1><p>这个流中数据类型就是byte，这个流既可以进行输入操作【读取】，也可以进行输出操作【写出】</p><h2 id="1、InputStream【字节输入流】"><a href="#1、InputStream【字节输入流】" class="headerlink" title="1、InputStream【字节输入流】"></a><center>1、InputStream【字节输入流】</center></h2><p>InputStream流是所有字节输入流的父类，所有字节输入流都要直接或间接继承InputStream</p><p>这个流是一个抽象类不能直接创建对象，所以需要使用到这个流的子类来完成对字节输入流操作</p><p>在API文档中提供创建语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InputStream</span> <span class="keyword">extends</span> <span class="title class_">Object</span> <span class="keyword">implements</span> <span class="title class_">Closeable</span></span><br></pre></td></tr></table></figure><p>在API文档中已知实现之类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AudioInputStream, ByteArrayInputStream,<span class="string">&quot;FileInputStream&quot;</span>, FilterInputStream, InputStream,</span><br><span class="line">ObjectInputStream, PipedInputStream,SequenceInputStream, StringBufferInputStream</span><br></pre></td></tr></table></figure><p>这里多子类中，使用那个之类来操作呢？学习流目的在于什么？–》将内存数据写出到磁盘中【持久保存】，程序需要使用时将磁盘中文件存储内容读取到内存中，整个操作过程中都需要使用磁盘文件，所以就需要操作一个处理文件的流来进行操作 –》需要使用其之类FileInputStream</p><h2 id="2、FileInputSteam【文件字节输入流】"><a href="#2、FileInputSteam【文件字节输入流】" class="headerlink" title="2、FileInputSteam【文件字节输入流】"></a><center>2、FileInputSteam【文件字节输入流】</center></h2><p>FileInputStream是InputStream字节入的子类，这个流主要提供是对文件读取操作，这个文件是泛指【指代的是：所有文档二进制文件（文本文件、音频、视频、压缩包、图片等等）】，都可以通过</p><p>FileInputStream进行读取操作，FileInputSteam是字节输入流所以流中数据是【<strong>byte类型</strong>】</p><p>在API文档中提供创建定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStream</span> <span class="keyword">extends</span> <span class="title class_">InputStream</span></span><br></pre></td></tr></table></figure><p>PS：Java中提供原生流【系统API中定义好流】只能对文本文件中内容进行操作即【txt】文件，无法对Office文件记性操作，如果需要对这些文件进行操作需要导入【第三方jar包（别人封装好实现）】</p><h3 id="（1）核心构造方法"><a href="#（1）核心构造方法" class="headerlink" title="（1）核心构造方法"></a>（1）核心构造方法</h3><table><thead><tr><th align="center">构造方法</th></tr></thead><tbody><tr><td align="center">FileInputStream(File file) 通过一个File对象创建FileInputStream字节输入流对象</td></tr><tr><td align="center">FileInputStream(String name) 通过一个String对象(文件的路径)创建FileInputStream字节输入流对象</td></tr></tbody></table><p>PS：这两个构造方法创建出对象方式是一样的，只是参数不一样，个人选取</p><h3 id="（2）核心API方法"><a href="#（2）核心API方法" class="headerlink" title="（2）核心API方法"></a>（2）核心API方法</h3><table><thead><tr><th align="center">返回值类型</th><th align="center">方法说明</th></tr></thead><tbody><tr><td align="center">int</td><td align="center">read() 一次读取一个字节的数据</td></tr><tr><td align="center">int</td><td align="center">read(byte[] bs) 一次读取参数字节数组长度的数据并存储在字节数组中[常用]</td></tr><tr><td align="center">int</td><td align="center">read(byte[] bs, int off, int len) 一次读取字节数组长度的数据,根据len读取实际内容长度,并从off位置开始入写到字节数组中</td></tr><tr><td align="center">void</td><td align="center">close() IO流式一个长连接,所以需要需要关闭流对象【常用】</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStreamAPIDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//文件字节输入流操作</span></span><br><span class="line">        <span class="comment">//1.提供文件字节输入流对象创建</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            这个构造方法中一共提供两种参数</span></span><br><span class="line"><span class="comment">            第一种传入File --&gt;FileInputStream fis = new FileInputStream(new File(&quot;绝对或相对文件路径&quot;));</span></span><br><span class="line"><span class="comment">            第二种传入String类型参数 --》 String类型赋值时一个路径</span></span><br><span class="line"><span class="comment">            FileInputStream fis = new FileInputStream(&quot;绝对或相对文件路径&quot;);</span></span><br><span class="line"><span class="comment">            在创建文件字节输入流对象同时需要处理创建对象时提供 编译时异常</span></span><br><span class="line"><span class="comment">                         Unhandled exception:java.io.FileNotFoundException</span></span><br><span class="line"><span class="comment">            今天---》使用try-catch进行处理 ---》 特殊用途</span></span><br><span class="line"><span class="comment">            明天---》 throws处理 --》 开发通用</span></span><br><span class="line"><span class="comment">            后续流开发如果出现异常行，自行选择处理方式</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//先声明流资源对象赋值为null值</span></span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//IO流的链接是长链接，所以在不使用IO流前提下要进行关闭操作</span></span><br><span class="line">            <span class="comment">//在try代码块进行流对象具体赋值操作</span></span><br><span class="line">            fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dir/file1.txt&quot;</span>));</span><br><span class="line">            <span class="comment">//读取文件中数据的read方法都有编译时异常Unhandled exception: java.io.IOException</span></span><br><span class="line">            <span class="comment">//1. 一次读取一个字节的内容--》几乎与不使用</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> fis.read();    <span class="comment">//返回文件内容中对应的ASCII，所以要看到读取内容效果需要强制类型转换</span></span><br><span class="line">            System.out.println(<span class="string">&quot;一次读取一个字节的内容是:&quot;</span>+ ((<span class="type">char</span>)read));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//2. 一次读取参数中字节数组长度内容，并且将内容存存储到字节数组中 --》【常用】</span></span><br><span class="line">            <span class="comment">//2.1 需要提供一个字节数组</span></span><br><span class="line">            <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">            <span class="comment">//2.2通过字节输入流对象调用read方法参数是字节数组</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                千万不要理解为:通过fis流对象读取字节数组bs中内容【错误理解】</span></span><br><span class="line"><span class="comment">                真正含义:通过fis流对象读取文件中内容，读取文件中内容是参数bs数组长度，并且将读取到内容存储到bs数组中</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            fis.read(bs);</span><br><span class="line">            <span class="comment">//因为byte类型数组，存储都是整数，所以存储都是文件内容中字符对应十进制形式</span></span><br><span class="line">            System.out.println(Arrays.toString(bs)); <span class="comment">//相当于查看字节数内容，但是不是具体文件中内容</span></span><br><span class="line">            <span class="comment">//利用String这个类构造方法将字节数组转换成字符串查看内容</span></span><br><span class="line">            System.out.println(<span class="string">&quot;读取文件中内容是：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(bs));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//3.一次读取参数中字节数组长度内容并且存储在字节数组中，根据off参数指定下标为开始写入数据，</span></span><br><span class="line">            <span class="comment">// 再根据len参数为基础进行实际读取内容长度作为写入数组中内容长度</span></span><br><span class="line">            <span class="comment">//3.1提供一个byte类型数组</span></span><br><span class="line">            <span class="type">byte</span>[] bs2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>];</span><br><span class="line">            <span class="comment">//3.2在通过文件字节输入流对象调用read方法进行读取</span></span><br><span class="line">            fis.read(bs2,<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line">            System.out.println(Arrays.toString(bs2));</span><br><span class="line">            System.out.println(<span class="string">&quot;读取文件中内容是:&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(bs2));</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (Exception e) </span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//无论try代码块是否出现异常，finally语句代码块都会执行，多用于资源释放 ---》 管理流就是资源释放</span></span><br><span class="line">            <span class="comment">//因为是在try外界创建对象赋值为null，如果赋值成功会存在堆中地址，这样才有关闭价值</span></span><br><span class="line">            <span class="keyword">if</span>(Objects.nonNull(fis))    <span class="comment">//判断数据是否为null</span></span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//释放流资源--》关闭流 --&gt;close方法也有一个编译时异常Unhandled exception: java.io.IOException</span></span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题：如果使用FileInputStream文件字节输入流读取一个文件，这个文件大小未知（文件存储内容不确定），使用刚刚讲解API中 read(byte[]bs) 进行文件内容读取，此时提供byte数组应该多大？，如何获取到文件中所有内容？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStreamLoopReadFile</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供文件字节输入流对象【因为InputStream是</span></span><br><span class="line">        FileInputStream父类，所以可以利用多态创建】</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dir/FileInputStreamAPIDemo.java&quot;</span>));</span><br><span class="line">            <span class="comment">//提供字节数组 ---》 1024 --&gt;给读取文件数组中大小即 1024</span></span><br><span class="line">            <span class="comment">//在开发中如果使用流进行操作，提供byte类型数组或char类型数组使用初始化大小默认给1024</span></span><br><span class="line">            <span class="comment">//如果1024并不能满足你读取文件内容需求，建议倍数递增</span></span><br><span class="line">            <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//因为给定初始容量1024，但是不能完全读取文件中所有内容</span></span><br><span class="line">            <span class="comment">//is.read(bs);</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                只需要让读取文件中内容操作重复执行就行--》提供循环让is.read可以去重复去读文件内容</span></span><br><span class="line"><span class="comment">                提供死循环确实可以让读取操作重复执行，但是需要提供读取文件停止方式，不然话程序执行是不合理</span></span><br><span class="line"><span class="comment">                只需要知道是否读取到文件的末尾，就可以停止循环操作了，如何得到读取到文件末尾的操作？</span></span><br><span class="line"><span class="comment">                read 方法在读取文件数据时，如果读取到文件的末尾返回-1作为提示</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">                //提供一个变量len 存储read读取到长度</span></span><br><span class="line"><span class="comment">                int len = 0;</span></span><br><span class="line"><span class="comment">                while(true)</span></span><br><span class="line"><span class="comment">                &#123;</span></span><br><span class="line"><span class="comment">                    len = is.read(bs);</span></span><br><span class="line"><span class="comment">                    if(len == -1)</span></span><br><span class="line"><span class="comment">                    &#123;</span></span><br><span class="line"><span class="comment">                        break;</span></span><br><span class="line"><span class="comment">                    &#125; </span></span><br><span class="line"><span class="comment">                    System.out.println(new String(bs));</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                通过文件字节读取到数据之后进行打印，发现输出内容末尾的位置多出了一些内容，但是在源文件中是不存在</span></span><br><span class="line"><span class="comment">                当调用read方法读取文件中内容时，是按照bs数组的长度进行读取，然后写入到bs数组中，这是一次读取</span></span><br><span class="line"><span class="comment">                下一次循环读取时，也会按照bs数组的长度进行读取，然后是覆盖写入到bs数组中，即不会清除原有数组中存的内容</span></span><br><span class="line"><span class="comment">                而是直接覆盖进新读取到文件内容到数组</span></span><br><span class="line"><span class="comment">                例如：现在读取文件大小是 4063字节 存储数据数组的大小1024字节</span></span><br><span class="line"><span class="comment">                第一次读取时 4063-1024 --》剩余字节 3039 但是读取到 1024字节内容</span></span><br><span class="line"><span class="comment">                第二次读取时 3039-1024 --》剩余字节 2015 但是读取到 1024字节内容</span></span><br><span class="line"><span class="comment">                第二次读取时 2015-1024 --》剩余字节 991 但是读取到 1024字节内容</span></span><br><span class="line"><span class="comment">                第四次读取时 读取字节是991 并没有填充满1024 --》 实际读取991个字节</span></span><br><span class="line"><span class="comment">                991个字节覆盖到byte数组中之后 会剩余33个字节没有进行覆盖内容</span></span><br><span class="line"><span class="comment">                所以通过new String方式打印数组内容时，就会将33个没有覆盖内容数据打印出来</span></span><br><span class="line"><span class="comment">                read(byte[] bs)这个方法的返回值不仅可以返回读取到文件末尾-1值</span></span><br><span class="line"><span class="comment">                                而且这个方法还可以返回读取到实际文件内容长度的实际值</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">//提供流循环读取文件内容的while循环书写方式</span></span><br><span class="line">            <span class="comment">//需要提供一个存储实际读取文件内容长度变量【包括文件末尾值】</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((len = is.read(bs))!=-<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//循环内部对数组中存储内容进行操作</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    第一个参数是存储数据数组</span></span><br><span class="line"><span class="comment">                    第二个参数是从数组中什么位置开始获取数据【默认值是0(使用是下标值)】</span></span><br><span class="line"><span class="comment">                    第三个参数 实际读取文件内容长度，因为可以避免输出书中没有被覆盖掉内容</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bs,<span class="number">0</span>,len));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (Exception e) </span><br><span class="line">        &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Objects.nonNull(is))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、OutputStream字节输出流"><a href="#3、OutputStream字节输出流" class="headerlink" title="3、OutputStream字节输出流"></a><center>3、OutputStream字节输出流</center></h2><p>OutputStream字节输出流是所有字节输出的父类，所有字节输入出流都是直接或间接继承OutputStream类</p><p>根据API文档中提供类创建方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">OutputStream</span> <span class="keyword">extends</span> <span class="title class_">Object</span> <span class="keyword">implements</span> <span class="title class_">Closeable</span>, Flushable</span><br></pre></td></tr></table></figure><p>OutputStream是抽象类无法直接创建对象使用，所以需要提供子类来完成对流操作</p><p>根据API文档中提供子类有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteArrayOutputStream, *FileOutputStream*,</span><br><span class="line">FilterOutputStream, ObjectOutputStream, OutputStream, PipedOutputStream</span><br></pre></td></tr></table></figure><p>根据现在操作数据原则，将数据从磁盘文件读取到内容，将内存中数据写出到磁盘文件中，始终要处理是File文件，所以使用<strong>子类是FileOutputStream文件字节输出流</strong></p><h2 id="4、FileOutputStream文件字节输出流"><a href="#4、FileOutputStream文件字节输出流" class="headerlink" title="4、FileOutputStream文件字节输出流"></a><center>4、FileOutputStream文件字节输出流</center></h2><p>FileOutputStream文件字节输出流类是OutputStream的子类，这个类主要用用于将内存中存储数据写入到磁盘文件中进行保存操作，这里的文件是泛指【<strong>指代是二进制文件（文本文件、音频、视频、图片、压缩包等等）</strong>】都可以使用FileOutputStream这个流对象将数据写入到磁盘中</p><p>根据API文档中说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileOutputStream</span> <span class="keyword">extends</span> <span class="title class_">OutputStream</span></span><br></pre></td></tr></table></figure><p><strong>核心构造方法</strong></p><table><thead><tr><th align="center">构造方法</th></tr></thead><tbody><tr><td align="center">FileOutputStream(File file) 通过一个File对象(封装的文件路径)创建文件字节输出流对象</td></tr><tr><td align="center">FileOutputStream(File file, boolean append)通过一个File对象(封装的文件路径)创建文件字节输出流对象,并根据第二个参数的值决定是否是对文件进行追加写入数据 true是追加 false 不追加</td></tr><tr><td align="center">FileOutputStream(String name) 通过一个String对象(封装的文件路径)创建文件字节输出流对象</td></tr><tr><td align="center">FileOutputStream(String name, boolean append)通过一个String对象(封装的文件路径)创建文件字节输出流对象,并根据第二个参数的值决定是否是对文件进行追加写入数据 true是追加 false不追加</td></tr></tbody></table><h3 id="（1）核心API方法"><a href="#（1）核心API方法" class="headerlink" title="（1）核心API方法"></a>（1）核心API方法</h3><table><thead><tr><th align="center">void</th><th align="center"><strong>close() 关闭此文件输出流并释放与此流有关的所有系统资源 【常用】</strong></th></tr></thead><tbody><tr><td align="center">void</td><td align="center">write(byte[] b) 将以字节数组长度的内容写入到磁盘文件中</td></tr><tr><td align="center">void</td><td align="center"><strong>write(byte[] b, int off, int len) 将实际len长度的内容****从数组b中off位置开始写入到磁盘文件中【常用】</strong></td></tr><tr><td align="center">void</td><td align="center">write(int b) 一次写一个字节的内容写入到磁盘文件中</td></tr><tr><td align="center">void</td><td align="center"><strong>flush() 加快流的流速,强制清空缓冲区中数据</strong>【加快输出效果（在使用网络流的时候一定要添加）】</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileOutputStreamAPIDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建文件字节输出流对象【一个参数的版本】</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            一个参数的版本参数可以传递两种方式</span></span><br><span class="line"><span class="comment">            第一种：传入File对象 --》fos = new FileOutputStream(new File(&quot;绝对或相对路径文件&quot;));</span></span><br><span class="line"><span class="comment">            第二种：传入String类型对象(代表的是文件的路径)</span></span><br><span class="line"><span class="comment">                                fos = new FileOutputStream(&quot;绝对或相对路径文件&quot;);</span></span><br><span class="line"><span class="comment">            在创建文件字节输出流对象时，需要处理编译时异常 Unhandled exception: java.io.FileNotFoundException</span></span><br><span class="line"><span class="comment">            处理方式 要么 try-catch 要么 throws</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                创建文件字节输出流对象【两个参数的版本】</span></span><br><span class="line"><span class="comment">                第一个参数可以是File对象或String类型对象，只要提供文件绝对或相对路径</span></span><br><span class="line"><span class="comment">                第二个参数需要注意是一个boolean类型参数，传入true时会开启追加写入操作</span></span><br><span class="line"><span class="comment">                    new FileOutputStream(&quot;绝对或相对路径文件&quot;,true);</span></span><br><span class="line"><span class="comment">                或者</span></span><br><span class="line"><span class="comment">                    new FileOutputStream(new File(&quot;绝对或相对路径文件&quot;),true);</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">//写出数据到磁盘中时，磁盘中可以不存在这个文件，在写数据时会自动创建这个文件</span></span><br><span class="line">            fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;dir/file2.txt&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//常用写出方法中都存在一个编译时异常Unhandledexception: java.io.IOException</span></span><br><span class="line">            <span class="comment">//1.一次向文件中写入一个字节的数据</span></span><br><span class="line">            <span class="comment">//fos.write(65);     //参数是int类型对应ASCII值的字符</span></span><br><span class="line">            <span class="comment">//不是“连续”向文件中写入内容，而是再次向file2.txt内容时，覆盖写入</span></span><br><span class="line">            <span class="comment">//2.向文件中一次性写过字节数组中的所有内容</span></span><br><span class="line">            <span class="comment">//getBytes()--&gt;将字符串转换为字节数组</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                如果是分批写入数据，为了防止文件中内容被后一次书写数据进行覆盖，</span></span><br><span class="line"><span class="comment">                可以使用FileOutputStream中构造方法【两个参数版本】，开启追加写入</span></span><br><span class="line"><span class="comment">                一般追加写入的作用都是生成日志文件，记录用户写入一些数据到文件中，一般不追加的比较常用</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            fos.write(<span class="string">&quot;BCDEFGHIJKLMN&quot;</span>.getBytes());    <span class="comment">//getBytes()将字符串转换成字节数组</span></span><br><span class="line">            <span class="comment">//3.从字节数组中将内容写入到文件中，从off参数提供的位置读取数据开始写，写len提供长度内容</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                第一个参数是存储数据字节数组</span></span><br><span class="line"><span class="comment">                第二个参数是从字节数组什么位置开始读取和写出数据【默认0（下标）】</span></span><br><span class="line"><span class="comment">                第三个参数实际写出内容长度（一般会配合输入流中read方法获取实际长度进行写出）</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            fos.write(<span class="string">&quot;BCDEFGHIJKLMN&quot;</span>.getBytes(),<span class="number">6</span>,<span class="string">&quot;HIJKMLN&quot;</span>.length());</span><br><span class="line">            <span class="comment">//执行刷新操作</span></span><br><span class="line">            fos.flush();</span><br><span class="line">            System.out.println(<span class="string">&quot;老子写完了！！！&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (FileNotFoundException e) </span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (IOException e) </span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">finally</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Objects.nonNull(fos))    <span class="comment">//也可以是 fos != null</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//存在一个编译时异常要处理</span></span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、图片拷贝案例"><a href="#5、图片拷贝案例" class="headerlink" title="5、图片拷贝案例"></a><center>5、图片拷贝案例</center></h2><p>利用文件字节输入输出流完成图片拷贝操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.InputStreamAndOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileCopy</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供文件字节输入输出流对象</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dir/1_io.jpg&quot;</span>));</span><br><span class="line">            os = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;desc/1_io.jpg&quot;</span>));</span><br><span class="line">            <span class="comment">//2.一定明确在使用是什么流【字节或字符】-》提供对应数组进行数据存储与接收</span></span><br><span class="line">            <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];    <span class="comment">//提供存储读取数据的字节数组</span></span><br><span class="line">            <span class="comment">//3. 提供一个变量存储读取文件实际内容长度【存储读取到文件末尾-1的值】</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//4.提供流的循环读写操作【读和写都是有编译时异常的要处理】</span></span><br><span class="line">            <span class="keyword">while</span>((len = is.read(bs))!=-<span class="number">1</span>)    <span class="comment">//循环读取数据并存储在bs数组中</span></span><br><span class="line">            &#123; </span><br><span class="line">                <span class="comment">//将存储在bs数组中数据写出到磁盘文件中</span></span><br><span class="line">                os.write(bs,<span class="number">0</span>,len);</span><br><span class="line">            &#125; </span><br><span class="line">            os.flush();    <span class="comment">//刷新</span></span><br><span class="line">            System.out.println(<span class="string">&quot;老子写完了！！！&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (FileNotFoundException e) </span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (IOException e) </span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">finally</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//谁先创建谁最后关闭</span></span><br><span class="line">            <span class="keyword">if</span>(Objects.nonNull(os))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(is))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、利用字节流将文件中的内容进行拷贝赋值操作"><a href="#6、利用字节流将文件中的内容进行拷贝赋值操作" class="headerlink" title="6、利用字节流将文件中的内容进行拷贝赋值操作"></a><center>6、利用字节流将文件中的内容进行拷贝赋值操作</center></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.InputStreamAndOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileCopy2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供字节输入输出流对象</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dir/1.txt&quot;</span>));</span><br><span class="line">            ois = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;desc/1.txt&quot;</span>));</span><br><span class="line">            <span class="comment">//2.明确使用是字节流还是字符流</span></span><br><span class="line">            <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//3.提供循环读写操作【处理编译时异常】</span></span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = fis.read(bs))!=-<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// ois.write(bs,0,len);</span></span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bs,<span class="number">0</span>,len));</span><br><span class="line">            &#125; </span><br><span class="line">            ois.flush();</span><br><span class="line">            System.out.println(<span class="string">&quot;老子写完了！！！&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (FileNotFoundException e) </span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (IOException e) </span><br><span class="line">        &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">finally</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Objects.nonNull(ois))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    ois.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(Objects.nonNull(fis))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结:字节输入输出流在文件进行操作，因为字节流中使用数据类型byte类型主要针对是二进制的文件，所以<strong>字节流主要对的是【图片、音频、视频、压缩包】这类的二进制文件</strong>，在读取和写出文本文件时，会在处理文件时出现一些乱码问题�，所以字节流主要是处理二进制文件而使用，如果处理文件文件的数据就不太建议使用字节流来完成操作，就是因为容易出现乱码问题�</p><h1 id="知识点四：字符输入输出流"><a href="#知识点四：字符输入输出流" class="headerlink" title="知识点四：字符输入输出流"></a><center>知识点四：字符输入输出流</center></h1><p>字符输入输出流是专门用于对文本文件进行操作流，用于弥补字节流对文本文件操作时容易出现乱码的为题，所以用字符输入输出流对文本文件进行处理操作</p><h2 id="1、Reader字符输入流"><a href="#1、Reader字符输入流" class="headerlink" title="1、Reader字符输入流"></a><center>1、Reader字符输入流</center></h2><p>Reader是字符输入的父类，所有字符输入流都要直接或间接继承与Reader类，因为这个流是字符流，所以流中数据是char，要提供数组也是char类型数组</p><p>根据API文档中描述可以发现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Reader</span> <span class="keyword">extends</span> <span class="title class_">Object</span> <span class="keyword">implements</span> <span class="title class_">Readable</span>, Closeable</span><br></pre></td></tr></table></figure><p>提供已知的之类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader, CharArrayReader, FilterReader, InputStreamReader, PipedReader, StringReader</span><br></pre></td></tr></table></figure><p>操作文件FileReader这个类并不是Reader的直接子类，而是间接子类，操作文件FileReader类是继承与InputStreamReader这个类，InputStreamReader这个类是Reader直接子类，可以利用FileReader进行文件操作</p><h2 id="2、FileReader文件字符输入流"><a href="#2、FileReader文件字符输入流" class="headerlink" title="2、FileReader文件字符输入流"></a><center>2、FileReader文件字符输入流</center></h2><p>FileReader是Reader的间接子类，FileReader的直接父类是InputStreamReader，InputStreamReader这个类提供文件编码集和缓冲区操作，API文档中也说明【此类的构造方法假定默认字符编码和默认字节缓冲区大小都是适当的】</p><p>通过流操作文本文件时，文本文件是存在编码集的，在使用FileReader类操作是使用就是默认编码集，这个默认编码集是根据系统进行获取，编码集的目的【提供文件的编码让文件可以达到统一性Unicode(UTF-8)】</p><p>在使用字节流时，API文档中是没有描述字节流具备缓冲区，但是在使用字符流的时，API文档提供缓冲区的概念，当使用流写出数据时，有一个方法<strong>flush方法</strong>，这个方法就是专门针对缓冲区进行设计，提供缓冲这个概念可以大大提高，流的使用效率</p><p>在API文档中提供FileReader中定义描述</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReader</span> <span class="keyword">extends</span> <span class="title class_">InputStreamReader</span></span><br></pre></td></tr></table></figure><p><strong>常用构造方法</strong></p><table><thead><tr><th align="center">构造方法摘要</th></tr></thead><tbody><tr><td align="center">FileReader(File file) 通过一个File对象(封装着文件路径)创建一个FileReader对象进行数据读取</td></tr><tr><td align="center">FileReader(String fileName) 通过一个String对象(封装着文件路径)创建一个FileReader对象进行数据读取</td></tr></tbody></table><h3 id="（1）常用API方法"><a href="#（1）常用API方法" class="headerlink" title="（1）常用API方法"></a>（1）常用API方法</h3><table><thead><tr><th align="center">方法摘要</th><th align="center"></th></tr></thead><tbody><tr><td align="center">void</td><td align="center"><strong>close() 关闭该流并释放与之关联的所有资源</strong></td></tr><tr><td align="center">int</td><td align="center">read() 读取单个字符</td></tr><tr><td align="center">int</td><td align="center"><strong>read(char[] cbuf) 读取字符数组长度的内容(常用)</strong></td></tr><tr><td align="center">int</td><td align="center">read(char[] cbuf, int off, int len) 将读取len的长度内容写入到cbuf数组中并且从off的位置开始在数组中写入</td></tr></tbody></table><p>PS:直接参考FileInputStream即可，只要将byte数组换char数组就可以了</p><h2 id="3、Writer字符输出流"><a href="#3、Writer字符输出流" class="headerlink" title="3、Writer字符输出流"></a><center>3、Writer字符输出流</center></h2><p>Writer字符输入流是所有字符输入流父类，所有字符输入流都要直接或间接继承与Writer，因为这个流是字符流，所以流中数据是char类型，需要提供char类型数组</p><p>根据API文档中描述</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Writer</span> <span class="keyword">extends</span> <span class="title class_">Object</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, Closeable, Flushable</span><br></pre></td></tr></table></figure><p>它是一个抽象类不能直接创建流对象进行操作，所以需要使用到其子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BufferedWriter, CharArrayWriter, FilterWriter, OutputStreamWriter, PipedWriter, PrintWriter, StringWriter</span><br></pre></td></tr></table></figure><p>操作文件的FileWriter这个类不是Writer的直接子类，而是间接子类，但是FileWriter可以完成对文件写出操作</p><h2 id="4、FileWriter文件字符输出流"><a href="#4、FileWriter文件字符输出流" class="headerlink" title="4、FileWriter文件字符输出流"></a><center>4、FileWriter文件字符输出流</center></h2><p>FileWriter是Writer的间接子类，FileWriter的直接父类是OutputStreamWriter，OutputStreamWriter个类提供文件编码集和缓冲区操作，API文档中也说明【此类的构造方法假定默认字符编码和默认字节缓冲区大小都是适当的】</p><p>通过流操作文本文件时，文本文件时存在编码集的，在使用FileWriter类操作时使用就是默认编码集，这个默认编码集是根据系统进行获取，编码集的目的【提供文件的编码让文件可以达到统一性Unicode(UTF-8)】</p><p>在使用字节流时，API文档中是没有描述字节流具备缓冲区，但是在使用字符流的时，API文档提供缓冲区的概念，当使用流写出数据时，有一个方法flush方法，这个方法就是专门针对缓冲区进行设计，提供缓冲这个概念可以大大提高，流的使用效率</p><h3 id="（1）常用构造方法"><a href="#（1）常用构造方法" class="headerlink" title="（1）常用构造方法"></a>（1）常用构造方法</h3><table><thead><tr><th align="center">常用构造方法</th></tr></thead><tbody><tr><td align="center">FileWriter(File file) 构建了一个文件对象FileWriter对象</td></tr><tr><td align="center">FileWriter(File file, boolean append) 构建了一个文件对象FileWriter对象</td></tr><tr><td align="center">FileWriter(String fileName) 构造给定文件名的FileWriter对象</td></tr><tr><td align="center">FileWriter(String fileName, boolean append) 构造FileWriter对象给出一个文件名与一个布尔值，指示是否附加写入的数据</td></tr></tbody></table><p>PS:构建方法中多了一个第二参数，是boolean参数值作用就是提供文件追加写入操作，当设置参数为true时，当前写入文件中数据操作就是追加写入【主要适合：记录日志的工作】，如果是连续写出数据，可以不开启这个操作</p><h3 id="（2）常用API方法"><a href="#（2）常用API方法" class="headerlink" title="（2）常用API方法"></a>（2）常用API方法</h3><table><thead><tr><th align="center">void</th><th align="center">close() 关闭此流，但要先刷新它</th></tr></thead><tbody><tr><td align="center">void</td><td align="center">flush() 刷新该流的缓冲</td></tr><tr><td align="center">void</td><td align="center">write(char[] cbuf) 写入字符数组</td></tr><tr><td align="center">void</td><td align="center">write(char[] cbuf, int off, int len) 从cbuf数组读取数据并写入到文件中,len是实际写出数据长度,off是从cbuf数组中什么位置开始写出 (使用字符数组时核心方法)</td></tr><tr><td align="center">void</td><td align="center">write(int c) 写入单个字符</td></tr><tr><td align="center">void</td><td align="center">write(String str) 写入字符串(非常有用的核心方法)</td></tr></tbody></table><p>PS: 在写出数据到文件中时，只有字符流中会提供一个参数为String类型write方法，这个方法可以帮我们便捷将数据写出到文件中，这个方法极其重要</p><p>FileWriter操作可以完全参考FileOutputStream这个类，基本上是一模一样，只不过将byte类型转换char类型即可</p><h2 id="5、使用字符输入输出流进行文本文件的拷贝操作"><a href="#5、使用字符输入输出流进行文本文件的拷贝操作" class="headerlink" title="5、使用字符输入输出流进行文本文件的拷贝操作"></a><center>5、使用字符输入输出流进行文本文件的拷贝操作</center></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.ReaderAndWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReaderAndFileWriterCopyFile</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供字符输入输出流对象创建</span></span><br><span class="line">        <span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//在创建对象时要处理编译时异常Unhandled exception: java.io.FileNotFoundException 处理方法和字节流一样</span></span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dir/1.txt&quot;</span>));</span><br><span class="line">            writer = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;desc/2.txt&quot;</span>));</span><br><span class="line">            <span class="comment">//2.一定要明确使用是什么流--》字符流</span></span><br><span class="line">            <span class="type">char</span>[] buf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//3. 提供循环读写操作</span></span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = reader.read(buf))!=-<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buf,<span class="number">0</span>,len));</span><br><span class="line">                <span class="comment">//writer.write(buf,0,len);</span></span><br><span class="line">            &#125; </span><br><span class="line">            writer.flush();</span><br><span class="line">            System.out.println(<span class="string">&quot;老子写完了！！！！&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (IOException e) </span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">finally</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Objects.nonNull(writer))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    writer.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(reader))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    reader.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、使用字符输入输出流进行图片的拷贝操作"><a href="#6、使用字符输入输出流进行图片的拷贝操作" class="headerlink" title="6、使用字符输入输出流进行图片的拷贝操作"></a><center>6、使用字符输入输出流进行图片的拷贝操作</center></h2><p>打开拷贝之后图片，观察拷贝之后图片与原来图片的大小</p><p>使用字符流进行图片复制拷贝操作是不可以完成，图片出现问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.ReaderAndWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReaderAndFileWriterCopyFile2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供字符输入输出流对象创建</span></span><br><span class="line">        <span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//在创建对象时要处理编译时异常Unhandled exception: java.io.FileNotFoundException</span></span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dir/1_io.jpg&quot;</span>));</span><br><span class="line">            writer = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;desc/2_io.jpg&quot;</span>));</span><br><span class="line">            <span class="comment">//2.一定要明确使用是什么流--》字符流</span></span><br><span class="line">            <span class="type">char</span>[] buf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//3. 提供循环读写操作</span></span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = reader.read(buf))!=-<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                writer.write(buf,<span class="number">0</span>,len);</span><br><span class="line">            &#125; </span><br><span class="line">            writer.flush();</span><br><span class="line">            System.out.println(<span class="string">&quot;老子写完了！！！！&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (IOException e) </span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">finally</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Objects.nonNull(writer))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    writer.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(reader))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    reader.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e)</span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点五：字节流和字符流之间区别"><a href="#知识点五：字节流和字符流之间区别" class="headerlink" title="知识点五：字节流和字符流之间区别"></a><center>知识点五：字节流和字符流之间区别</center></h1><p>字节流和字符流是有本质上区别：</p><ol><li>流中数据是不同，字节流流中的数据是byte而字符流流中数据是char</li><li>根据流中不同数据类型所以字节流主要处理是二进制文件【图片、音频、视频、压缩包的等等】也可以处理【文本文件】但是容易出现乱码，而字符流主要是处理文本文件提供流，它是无处理二进制文件的</li><li>字节流和字符流之间还有一个很大区别</li></ol><p>&ensp;&ensp;&ensp;&ensp;字节流在操作流的过程中是【没有使用缓冲区】，直接对文件本身进行操作</p><p>&ensp;&ensp;&ensp;&ensp;字符流在操作流的过程中是【使用了缓冲区】，通过缓冲区进行进行对文件操作</p><p><strong>什么是缓冲区？</strong></p><p>&ensp;&ensp;&ensp;&ensp;缓冲区可以理解为一段特殊区域，某些情况下，如果一个程序频繁的操作一个资源（如文件或数据库），则会出现性能下降的问题，此时为了提升性能，就可以将内存中部分数据读取到一个内存区域中，以后直接从这个区域进行数据去读，这样化就可以提升系统的性能，那么这个提供区域就是“缓冲区”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span></span><br><span class="line">Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            在同等条件下进行操作</span></span><br><span class="line"><span class="comment">            创建文件字节输出流和文件字符输出流对象，将数据通过流写入到文件中</span></span><br><span class="line"><span class="comment">            创建了字节和字符文件输出流对象，进行数据书写到文件中并关闭了流资源，此时外界文件中是可以存在数据</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">            OutputStream os = new FileOutputStream(new File(&quot;desc/字节流文件.txt&quot;));</span></span><br><span class="line"><span class="comment">            os.write(&quot;Hello World&quot;.getBytes());</span></span><br><span class="line"><span class="comment">            os.close();</span></span><br><span class="line"><span class="comment">            Writer writer = new FileWriter(new File(&quot;desc/字符流文件.txt&quot;));</span></span><br><span class="line"><span class="comment">            //自有字符流中提供可以将字符串写入到文件中方法</span></span><br><span class="line"><span class="comment">            writer.write(&quot;Hello world&quot;);</span></span><br><span class="line"><span class="comment">            writer.close();</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//-------------------------------------------------------------------------------------</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            在同等条件下进行操作            创建文件字节输出流和文件字符输出流对象，将数据通过流写入到文件中，但是不添加close方法</span></span><br><span class="line"><span class="comment">            字节流可以将数据直接写出到磁盘文件中，在没有使用close方法前提下程序正常结束也可以将流中数据写入到文件中</span></span><br><span class="line"><span class="comment">            字符流在没有使用close方法的前提下，程序正常结束是没有办法将数据写入到文件中的</span></span><br><span class="line"><span class="comment">            就是因为 字符流使用 缓冲区技术即使用“缓冲区”</span></span><br><span class="line"><span class="comment">            在字符流操作过程中，所有字符都是在“内存中形成”的，在输出前会将“所有的暂时保存在内存中内容”输出到文件中</span></span><br><span class="line"><span class="comment">            使用close这个方法在在关闭流资源自后会将缓冲区中数据输出文件中(有flush功能)，所以字符流就要更加要关闭流资源</span></span><br><span class="line"><span class="comment">            但是为了防止忘记书写close方法，并且共缓冲区的利用率，Java对所有输出流都提供了一个方法flush</span></span><br><span class="line"><span class="comment">            flush这个方法可以强制的刷新出缓冲区中数据，所以就算没有关闭流资源可以将字符流中数据写出到文件中</span></span><br><span class="line"><span class="comment">            所以建议在所有写出数据操作中添加flush这个方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;desc/字节流文件.txt&quot;</span>));</span><br><span class="line">        os.write(<span class="string">&quot;Hello World&quot;</span>.getBytes());</span><br><span class="line">        <span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;desc/字符流文件.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//自有字符流中提供可以将字符串写入到文件中方法</span></span><br><span class="line">        writer.write(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">        writer.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用字符流还是使用字节流？</p><p>&ensp;&ensp;&ensp;&ensp;区分场景而言文本文件使用字符流，二进制文件使用字节流，但是字节流处理场景明显要比字符流多，所以建议优先使用字节流处理数据，如果数据是文本文件在考虑转换流操作</p><h1 id="知识点六：字符编码"><a href="#知识点六：字符编码" class="headerlink" title="知识点六：字符编码"></a><center>知识点六：字符编码</center></h1><p>阶段1:</p><p>&ensp;&ensp;&ensp;&ensp;所以规定使用的字节的最高位是0.每一个字节都是以【0~127之间的数字来表示】,比如A对应65,a对应97.这就是美国标准信息交换码【ASCII】.</p><p>‘A’<del>‘Z’ ‘a’</del>‘z’ ‘0’~‘9’</p><p><strong>阶段2:</strong></p><p>&ensp;&ensp;&ensp;&ensp;随着计算机在全球的普及,很多国家和地区都把自己的字符引入了计算机,比如汉字.</p><p>&ensp;&ensp;&ensp;&ensp;此时发现一个字节能表示数字范围太小,不能包含所有的中文汉字那么就规定使用两个字节来表示一个汉字.</p><p>&ensp;&ensp;&ensp;&ensp;规定:原有的ASCII字符的编码保持不变,仍然使用一个字节表示,为了区别一个中文字符和ASCII码字符中文字符的每个字节最高位规定为1(中文的二进制是负数).这个规范就是【GB2312】编码,后来在GB2312的基础上增加了更多的中文字符,比如汉字,也就出现了【GBK】.</p><p>阶段3:</p><p>&ensp;&ensp;&ensp;&ensp;新的问题,在中国是认识汉字的,但是如果把汉字传递给其他国家,该国家的码表中没有收录汉字,其实就显示另一个符号或者乱码为了解决各个国家因为本地化字符编码带来的影响,咱们就把全世界所有的符号统一进行编码-【Unicode万国码】编码.此时某一个字符在全世界任何地方都是固定的,比如【哥】,在任何地方都是以十六进制的【54E5】来表示.Unicode的编码字符都占有【2个字节大小】</p><p>常用字符编码集</p><p>&ensp;&ensp;&ensp;&ensp;ASCII码： 占一个字节，只能包含128个符号，不能表示汉字</p><p>&ensp;&ensp;&ensp;&ensp;ISO-8859-1【latin-1】占一个字节，收录的是西欧语言，不能表示汉字 —》properties</p><p>&ensp;&ensp;&ensp;&ensp;ANSI【GB2312】占两个字节，在简体中文操作系统中ANSI就是值的GB2312(淘汰了)</p><p>&ensp;&ensp;&ensp;&ensp;GB18030&#x2F;GBK 占两个字节，支持中文</p><p>&ensp;&ensp;&ensp;&ensp;UTF-8：是一种针对Unicode的可变长字符编码，又称万国码，UTF-8是Unicode的实现方式之一，这个编码兼容ASCII码 UTF-8表示汉字’\u0000’~’\uffff’</p><p>ps：在UTF家族中提供了其他编码 UTF-8E ，UTF-16 ,UTF-32， 这里有一个特殊编码集千万不要使用，这个编码集是MS公司搞出来UTF-8 BOM，默认3个字节一个汉字【不要使用】</p><h1 id="知识点七：InputStreamReader-字节字符转换输入流"><a href="#知识点七：InputStreamReader-字节字符转换输入流" class="headerlink" title="知识点七：InputStreamReader 字节字符转换输入流"></a><center>知识点七：InputStreamReader 字节字符转换输入流</center></h1><p>字节字符转换输入流的作用：<strong>将字节流转换为字符流，并且可以设置文件编码集</strong></p><p>“特别说明：<strong>InputStreamReader的父类是Reader类，所以这个流中数据是char类型</strong>”</p><p>&ensp;&ensp;&ensp;&ensp;“<strong>InputStreamReader是FileReader的直接父类</strong>”</p><h2 id="1、核心构造方法"><a href="#1、核心构造方法" class="headerlink" title="1、核心构造方法"></a><center>1、核心构造方法</center></h2><table><thead><tr><th align="center">常用构造方法</th></tr></thead><tbody><tr><td align="center">InputStreamReader(InputStream in) 通过参数InputStream流的对象构建InputStreamReader流对象并使用的是默认编码集</td></tr><tr><td align="center">InputStreamReader(InputStream in, Charset cs) 通过参数</td></tr><tr><td align="center">InputStream流的对象构建InputStreamReader流对象并用过Charset设置读取文件编码集</td></tr><tr><td align="center">InputStreamReader(InputStream in, String charsetName)通过参数InputStream流的对象构建InputStreamReader流并用过字符串设置读取文件编码集</td></tr></tbody></table><p>PS： 转换输入流，所以构建InputStreamReader对象时，需要提供一个字节输入流作为转换对象</p><p>通过InputStreamReader可以设置编码集，设置编码集方式是通过InputStreamReader构造方法中第二参数进行设置，这里设置有两种方式</p><p>&ensp;&ensp;&ensp;&ensp;第一种方式：使用Charset类型进行设置 —》 Charset.forName(“编码集名字”)</p><p>&ensp;&ensp;&ensp;&ensp;第二种方式：使用String类型进行设置 —》 “编码集名字”</p><h2 id="2、核心API方法"><a href="#2、核心API方法" class="headerlink" title="2、核心API方法"></a><center>2、核心API方法</center></h2><table><thead><tr><th align="center"></th><th align="center">常用方法</th></tr></thead><tbody><tr><td align="center">void</td><td align="center">close() 关闭流并释放与它相关联的任何系统资源</td></tr><tr><td align="center">String</td><td align="center">getEncoding() 返回此流使用的字符编码的名称。(在读取文件的同时读取文件编码集)</td></tr><tr><td align="center">int</td><td align="center">read() 读取单个字符</td></tr><tr><td align="center">int</td><td align="center">read(char[] cbuf, int offset, int length) 将字符读入一个数组的一部分</td></tr><tr><td align="center">int</td><td align="center">read(char[] cbuf) 将读取的数据存储到字符数组中</td></tr></tbody></table><h1 id="知识点八：OutputStreamWriter-字节字符转换输出流"><a href="#知识点八：OutputStreamWriter-字节字符转换输出流" class="headerlink" title="知识点八：OutputStreamWriter 字节字符转换输出流"></a><center>知识点八：OutputStreamWriter 字节字符转换输出流</center></h1><p>字节字符转换输出流作用:将字符流转换为字节流输出，并可以设置编码集</p><p>特别注意:”<strong>OutputStreamWriter的父类是Writer,所以这个流中数据是char类型</strong></p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;”<strong>OutputStreamWriter是FileWriter的父类</strong>“</p><h2 id="1、核心构造方法-1"><a href="#1、核心构造方法-1" class="headerlink" title="1、核心构造方法"></a><center>1、核心构造方法</center></h2><table><thead><tr><th align="center">常用构造方法</th></tr></thead><tbody><tr><td align="center">OutputStreamWriter(OutputStream out) 通过OutputStream对象创建OutputStreamWriter对象并使用默认编码集写出数据</td></tr><tr><td align="center">OutputStreamWriter(OutputStream out, Charset cs) 通过OutputStream对象创建OutputStreamWriter对象并使用Charset设置写出文件编码集</td></tr><tr><td align="center">OutputStreamWriter(OutputStream out, StringcharsetName) 通过OutputStream对象创建OutputStreamWriter对象并使用String类型设置写出文件编码集</td></tr></tbody></table><p>PS： 转换输出流，所以构建OutputStreamWriter对象时，需要提供一个字节输出流作为转换对象</p><p>通过OutputStreamWriter可以设置编码集，设置编码集方式是通过OutputStreamWriter构造方法中第二参数进行设置，这里设置有两种方式</p><p>&ensp;&ensp;&ensp;&ensp;第一种方式：使用Charset类型进行设置 —》 Charset.forName(“编码集名字”)</p><p>&ensp;&ensp;&ensp;&ensp;第二种方式：使用String类型进行设置 —》 “编码集名字”</p><h2 id="2、核心的API方法"><a href="#2、核心的API方法" class="headerlink" title="2、核心的API方法"></a><center>2、核心的API方法</center></h2><table><thead><tr><th align="center"></th><th align="center">常用方法</th></tr></thead><tbody><tr><td align="center">void</td><td align="center">close() 关闭流，冲洗它</td></tr><tr><td align="center">void</td><td align="center">flush() 冲流</td></tr><tr><td align="center">String</td><td align="center">getEncoding() 返回此流使用的字符编码的名称</td></tr><tr><td align="center">void</td><td align="center">write(char[] cbuf, int off, int len) 写入一个字符数组的一部分</td></tr><tr><td align="center">void</td><td align="center">write(int c) 写一个字符</td></tr><tr><td align="center">void</td><td align="center">write(String str, int off, int len) 写入字符串的一部分</td></tr></tbody></table><p>PS： 因为OutputStreamWriter是父类Writer方法，所以也会继承到Writer方法中参数为String类方法，所以提供直接输出字符串的方法</p><p><strong>这两流的操作可以完全操作FileRader和FileWriter进行操作</strong></p><p>需求：使用转换流在设置编码集的前提下进行文件的赋值与粘贴</p><ol><li>读取文件使用UTF-8编码集进行，输出文件时将文件编码集修改为GBK</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.BufferedInputStreamAndBufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileEncodingCopyDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//使用转换流进行文件的编码集设置操作</span></span><br><span class="line">        <span class="comment">//1.提供创建字节字符转换输入输出流对象</span></span><br><span class="line">        <span class="comment">//在创建转换流对象时，是存在一个编译时异常 UnsupportedEncodingException【不支持设置编码集】</span></span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dir/1.txt&quot;</span>)),<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">//只有读对了才可以写对</span></span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;desc/1.txt&quot;</span>)),</span><br><span class="line">        Charset.forName(<span class="string">&quot;GBK&quot;</span>));</span><br><span class="line">        <span class="comment">//2.这两个转换流是父类都是字符类型，所以流中的数据都是char类型</span></span><br><span class="line">        <span class="type">char</span>[] buf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//提供一个变量存储实际读取到文件长度【包括文件末尾-1的返回值】</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//3.循环读取数据并将当前数据输出</span></span><br><span class="line">        <span class="keyword">while</span>((len = isr.read(buf))!=-<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            osw.write(buf,<span class="number">0</span>,len);</span><br><span class="line">        &#125; </span><br><span class="line">        osw.flush();</span><br><span class="line">        osw.close();</span><br><span class="line">        isr.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;老子写完了！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需求：仿照上面代码提供一个通用方法可以设置文件编码集并且使用转换流进行拷贝与粘贴操作</p><ol><li>读取文件使用UTF-8编码集进行，输出文件时将文件编码集修改为GBK</li><li>读取文件使用GBK编码集进行，输出文件时将文件编码集修改为UTF-8</li><li>使用GBK编码集读取一个UTF-8文件，输出文件时使用UTF-8编码集输出</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.BufferedInputStreamAndBufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileEncodingCopyDemo2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 1. 读取文件是UTF-8，写出文件GBK</span></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">            copyFile(new File(&quot;dir/1.txt&quot;),&quot;UTF-8&quot;,new File(&quot;desc/1.txt&quot;),&quot;GBK&quot;);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//2. 读取文件是GBK ，写出文件是UTF-8编码</span></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">            copyFile(new File(&quot;desc/1.txt&quot;),&quot;GBK&quot;, new File(&quot;dir/UFT-8文件.txt&quot;),&quot;UTF-8&quot;);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// 3. 读取一个UTF-8的编码文件使用GBK编码，写出文件是使用UTF-8写出</span></span><br><span class="line">        copyFile(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dir/UFT-8文件.txt&quot;</span>),<span class="string">&quot;GBK&quot;</span>, <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;desc/将UFT-8文件设置为GBK之后修</span></span><br><span class="line"><span class="string">                                                                                改为UTF-8.txt&quot;</span>),<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 设置文件编码集进行赋值粘贴的方法</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> srcFile 源文件</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> srcCharset 源文件编码集</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> descFile 目标文件</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> descCharset 目标文件编码集</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@throws</span> Exception 代表方法所有要抛出的编译时异常</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFile</span><span class="params">(File srcFile,String srcCharset,File descFile,String descCharset)</span><span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供字节字符转换输入输出流对象</span></span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile),srcCharset);</span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(descFile),descCharset);</span><br><span class="line">        <span class="comment">//2.使用的是什么流，流中数据是什么 --》 他们都是字符流</span></span><br><span class="line">        <span class="type">char</span>[] buf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = isr.read(buf))!=-<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            osw.write(buf,<span class="number">0</span>,len);</span><br><span class="line">        &#125; </span><br><span class="line">        osw.flush();</span><br><span class="line">        osw.close();</span><br><span class="line">        isr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>转换流的总结：</strong></p><p>&ensp;&ensp;&ensp;&ensp;<strong>转换流的目的在于提供了字节与字符流之间的一种转换效果，我们可以通过转换流将字符流和字节流进行转化，除此之外还可以设置文件的编码集进行文件的读取和写出操作</strong>，这样可以完成文件的编码集转换操作【文件编码集的转换操作原则是：只有读取文件时编码集设置正确，才可在写出文件时将编码集设置正确】</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012007515.png" alt="字符流转字节流" style="zoom: 67%;"><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012008623.png" alt="字节流转字符流" style="zoom:67%;"><h1 id="知识点九：缓冲流"><a href="#知识点九：缓冲流" class="headerlink" title="知识点九：缓冲流"></a><center>知识点九：缓冲流</center></h1><p>有了缓冲流之后，不建议使用原始流进行操作，缓冲流效率是远远高于原始流，缓冲流提供缓冲区让流可以进行操作</p><p>原始流指的是：InputStream和OutputStream 或者 Reader和Writer不使用缓冲区的流</p><p>PS：需要注意的是 字符流 默认使用了缓冲区，所以和缓冲流的效果差不多</p><h2 id="1、字节缓冲流"><a href="#1、字节缓冲流" class="headerlink" title="1、字节缓冲流"></a><center>1、字节缓冲流</center></h2><p>字节缓冲流是针对原始字节流而提供一种流，这个中流可以更加高效处理流中操作</p><p><strong>BufferedInputStream字节缓冲输入流 和 BufferedOutputStrem 字节缓冲输出流</strong></p><p>BufferedInputStream字节缓冲输入流是InputStream字节输入流的子类，这个流提供一个缓冲区，这个缓冲区可以帮组流进行数据缓冲与操作，<strong>这个缓冲区的大小默认是8192K</strong>,提供BufferedInputStream这个流可以包装一个普通字节输入流进行缓冲操作，这个缓冲区大小是可以用过BufferedInputStream构造方法进行设置，但是<strong>这个缓冲区的设置不要低于8192，设置时按照1024倍数设置即可</strong></p><h3 id="（1）BufferedInputStream常用构造方法"><a href="#（1）BufferedInputStream常用构造方法" class="headerlink" title="（1）BufferedInputStream常用构造方法"></a>（1）BufferedInputStream常用构造方法</h3><table><thead><tr><th align="center">常用构造方法</th></tr></thead><tbody><tr><td align="center">BufferedInputStream(InputStream in) 创建一个BufferedInputStream 和保存它的参数，输入流 in ，供以后使用</td></tr><tr><td align="center">BufferedInputStream(InputStream in, int size) 创建一个具有指定的缓冲区大小 BufferedInputStream ，并保存它的参数，输入流 in ，供以后使用</td></tr></tbody></table><p>PS：缓冲流的使用其实就是对原始流进行二次“包装”，让原始就具备一个缓冲区可以快速进行流操作，所以构建字节缓冲输入流对象时，<strong>需要提供一个“InputStream字节输入流对象”</strong>，不仅如此还可以设置缓冲区的默认大小，<strong>不要低于8192这个数据，设置时按照1024倍数设置即可</strong>，缓冲流输入流是唯一支持字节输入流父类中提供mark和reset方法【但是没有任何效果】</p><h3 id="（2）BufferedInputStream常用API方法"><a href="#（2）BufferedInputStream常用API方法" class="headerlink" title="（2）BufferedInputStream常用API方法"></a>（2）BufferedInputStream常用API方法</h3><table><thead><tr><th align="center"></th><th align="center">常用方法</th></tr></thead><tbody><tr><td align="center">void</td><td align="center">close() <strong>关闭此输入流并释放与流关联的任何系统资源</strong></td></tr><tr><td align="center">int</td><td align="center">read() 看到的 InputStream 的 read 方法一般合同</td></tr><tr><td align="center">int</td><td align="center">read(byte[] b) <strong>读取文件存储到数组中</strong>【常用】</td></tr><tr><td align="center">int</td><td align="center">read(byte[] b, int off, int len) 从这个字节的输入流读取到指定的字节数组中的字节，从给定的偏移量开始</td></tr><tr><td align="center">boolean</td><td align="center">markSupported() 如果输入流的支持 mark 和reset 方法【无用】</td></tr><tr><td align="center">void</td><td align="center">mark(int readlimit) 看到的 InputStream 的mark 方法一般合同【无用】</td></tr><tr><td align="center">void</td><td align="center">reset() 看到的 InputStream 的 reset 方法一般合同【无用】</td></tr></tbody></table><p>&ensp;&ensp;&ensp;&ensp;BufferedOutputStream字节缓冲输出流是OutputStream字节输出流子类，这个流提供一个缓冲区，这个缓冲区可以帮组流进行数据缓冲与操作，<strong>这个缓冲区的大小默认是8192K</strong>,提供BufferedOutputStream这个流可以包装一个普通字节输出流进行缓冲操作，这个缓冲区大小是可以用过BufferedOutputStream构造方法进行设置，<strong>但是这个缓冲区的设置不要低于8192，设置时按照1024倍数设置即可</strong></p><h3 id="（3）BufferedOutputStream常用构造方法"><a href="#（3）BufferedOutputStream常用构造方法" class="headerlink" title="（3）BufferedOutputStream常用构造方法"></a>（3）BufferedOutputStream常用构造方法</h3><table><thead><tr><th align="center">常用构造方法</th></tr></thead><tbody><tr><td align="center">BufferedOutputStream(OutputStream out) 创建一个新的缓冲输出流，将数据写入到指定的基本输出流中</td></tr><tr><td align="center">BufferedOutputStream(OutputStream out, int size) 创建一个新的缓冲输出流，用指定的缓冲区大小写数据到指定的基本输出流中</td></tr></tbody></table><p>PS：缓冲流的使用其实就是对原始流进行二次“包装”，让原始就具备一个缓冲区可以快速进行流操作，所以构建字节缓冲输出流对象时，<strong>需要提供一个“OutputStream字节输出流对象”</strong>，不仅如此还可以设置缓冲区的默认大小，<strong>不要低于8192这个数据，设置时按照1024倍数设置即可</strong></p><h3 id="（4）BufferedOutputStream常用API方法"><a href="#（4）BufferedOutputStream常用API方法" class="headerlink" title="（4）BufferedOutputStream常用API方法"></a>（4）BufferedOutputStream常用API方法</h3><table><thead><tr><th align="center"></th><th align="center">常用方法</th></tr></thead><tbody><tr><td align="center">void</td><td align="center">flush() 刷新缓冲输出流</td></tr><tr><td align="center">void</td><td align="center">write(byte[] b, int off, int len) 写 len 字节指定字节数组中的起始偏移 off 这个缓冲输出流</td></tr><tr><td align="center">void</td><td align="center">write(int b) 将指定的字节写入该缓冲输出流中</td></tr><tr><td align="center">void</td><td align="center">close() 关闭此输出流并释放与此流关联的任何系统资源</td></tr></tbody></table><p>PS:字节缓冲输入输出流没有任何特殊方法，这个操作可以完全参考FileInputStream 和FileOutputStream</p><p>字节缓冲输入输出流就是提供缓冲区提高操作效率而已</p><p>性能对比： 使用缓冲字节流和普通字节流进行 大于2GB文件拷贝操作计算时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span></span><br><span class="line">com.qfedu.BufferedInputStreamAndBufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileCopyTest</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span></span><br><span class="line">Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//提供一个开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">beginTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//先提供字节输入输出流拷贝操作</span></span><br><span class="line">     <span class="comment">//copyFileToByte(new File(&quot;C:\\Users\\jkmaster\\Desktop\\23_IO流1.zip&quot;),new File(&quot;C:\\abc\\23_IO流1.zip&quot;));</span></span><br><span class="line">        <span class="comment">//在提供缓冲字节输入输出流拷贝操作</span></span><br><span class="line">        copyFileToBufferedByte(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\jkmaster\\Desktop\\23_IO流1.zip&quot;</span>),</span><br><span class="line">                                                                        <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\abc\\23_IO流1.zip&quot;</span>));</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//System.out.println(&quot;缓冲字节输入输出流拷贝文件的时间</span></span><br><span class="line">                                                    <span class="comment">//是：&quot;+(endTime-beginTime)+&quot;毫秒&quot;);5869毫秒 --》约等于 6秒</span></span><br><span class="line">        <span class="comment">//System.out.println(&quot;普通字节输入输出流拷贝文件的时间</span></span><br><span class="line">                                                   <span class="comment">//是：&quot;+(endTime-beginTime)+&quot;毫秒&quot;);21387毫秒 --》约等于 21秒</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 普通字节输入输出流拷贝文件操作</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> srcFile 源文件</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> descFile 目标文件</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> Exception 抛出所有编译时异常信息    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFileToByte</span><span class="params">(File srcFile, File descFile)</span><span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供字节输入输出对象</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(descFile);</span><br><span class="line">        <span class="comment">//2.提供byte类型数组</span></span><br><span class="line">        <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//3.提供一个变量存储读取实际文件长度【读取文件末尾-1值】</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = is.read(bs))!=-<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            os.write(bs,<span class="number">0</span>,len);</span><br><span class="line">        &#125; </span><br><span class="line">        os.flush();</span><br><span class="line">        os.close();</span><br><span class="line">        is.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;字节输入输出流拷贝文件结束！&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 提供缓冲字节输入输出流拷贝文件操作</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> srcFile 源文件</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> descFile 目标文件</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> Exception 抛出所有编译时异常信息    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFileToBufferedByte</span><span class="params">(File srcFile, File descFile)</span><span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供缓冲字节输入输出对象</span></span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile));</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(descFile));</span><br><span class="line">        <span class="comment">//2.提供byte类型数组</span></span><br><span class="line">        <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//3.提供一个变量存储读取实际文件长度【读取文件末尾-1值】</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = bis.read(bs))!=-<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            bos.write(bs,<span class="number">0</span>,len);</span><br><span class="line">        &#125; </span><br><span class="line">        bos.flush();</span><br><span class="line">        bos.close();</span><br><span class="line">        bis.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;缓冲字节输入输出流拷贝文件结束！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//PS：能用缓冲流就用缓冲流，不要使用普通字节流</span></span><br></pre></td></tr></table></figure><h2 id="2、字符缓冲流"><a href="#2、字符缓冲流" class="headerlink" title="2、字符缓冲流"></a><center>2、字符缓冲流</center></h2><p>PS：这个流才是我们真记忆，他符合内容数据写入到磁盘，在从磁盘将数据读取到内容使用流</p><p>字符缓冲流对于将内存中数据写入到磁盘中和将磁盘中数据读取到内容中有非常好支持，所以只要是这样数据操作就一定使用这个流</p><p>字符缓冲流也是缓冲流，所有字符缓冲输入输出流都具备缓冲区，默认大小也是8192K，如果要修改缓冲区大小需要比8192K大，并且是提供1024倍数进行修改</p><p>BufferedReader缓冲字符输入流是Reader字节输入的子类，提供8192K缓冲区，可以包装一个普通的字符输入流提高操作效率</p><h3 id="（1）BufferedReader常用构造方法"><a href="#（1）BufferedReader常用构造方法" class="headerlink" title="（1）BufferedReader常用构造方法"></a>（1）BufferedReader常用构造方法</h3><table><thead><tr><th align="center">构造方法</th></tr></thead><tbody><tr><td align="center">BufferedReader(Reader in) 创建一个使用默认大小输入缓冲区的缓冲字符输入流</td></tr><tr><td align="center">BufferedReader(Reader in, int sz) 创建一个使用指定大小的输入缓冲区的缓冲字符输入流</td></tr></tbody></table><p>PS：BuffereReader是缓冲字符输入流，所以需要提供一个字符输入流作为对象传入到缓冲字符输入流中进行对象创建，除此之外提供修改默认缓冲区大小</p><h3 id="（2）BufferedReader常用API方法"><a href="#（2）BufferedReader常用API方法" class="headerlink" title="（2）BufferedReader常用API方法"></a>（2）BufferedReader常用API方法</h3><table><thead><tr><th align="center"></th><th align="center">常用方法</th></tr></thead><tbody><tr><td align="center">string</td><td align="center">readLine() 读一行文本【强烈推荐】</td></tr></tbody></table><p>说明：</p><ol><li>BufferedReader是一个流，所以也需要调用close方法</li><li>BufferedReader读取数据方式一共有两种：</li></ol><p>&ensp;&ensp;&ensp;&ensp;2.1 使用原始字符输入流的方式进行数据读取 –》 提供char数组，使用read方法读取数据【不推荐】</p><p>&ensp;&ensp;&ensp;&ensp;2.2 使用BufferedReader中独有的方法进行数据读取 —》 readLine方法【强烈推荐】</p><p> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;readLine这个方法是返回读取一次文本中内一行内容，这个方法的返回值是String</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.BufferedReaderAndBufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedReaderDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建字符缓冲输入流BufferedReader对象</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dir/UFT-8文件.txt&quot;</span>)));</span><br><span class="line">        <span class="comment">//2.提供两种读取数据的方式</span></span><br><span class="line">        <span class="comment">//2.1 使用char数组的方式进行读取</span></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">            char[] buf = new char[1024];</span></span><br><span class="line"><span class="comment">            int len;</span></span><br><span class="line"><span class="comment">            while((len = br.read(buf))!=-1)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                System.out.println(new String(buf,0,len));</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//2.1 使用 readLine进行数据读取，一次读取文件中一行内容</span></span><br><span class="line">        <span class="comment">//2.1.1 提供一个String类型变量接收读取到数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            readLine方法读取文件中每一个行内容时，一共有两种数据返回形态</span></span><br><span class="line"><span class="comment">            读取到数据就返回String类型字符串读，取到文件末尾就返回null值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">while</span>((content = br.readLine()) != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//可以在这个循环中对content得到String字符串数据即文件中读取到内容进行操作</span></span><br><span class="line">            System.out.println(content);</span><br><span class="line">        &#125; </span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（3）BufferedWriter缓冲字符输出流"><a href="#（3）BufferedWriter缓冲字符输出流" class="headerlink" title="（3）BufferedWriter缓冲字符输出流"></a>（3）BufferedWriter缓冲字符输出流</h3><p>BufferedWritrer缓冲字符输出流是Writer字符输出流子类，并且提供一个默认缓冲区大小为8192K，提供给包装普通字符输出流对象使用对字符输出流操作</p><h4 id="常用构造方法"><a href="#常用构造方法" class="headerlink" title="常用构造方法"></a>常用构造方法</h4><table><thead><tr><th align="center">常用构造方法</th></tr></thead><tbody><tr><td align="center">BufferedWriter(Writer out) 创建一个使用默认大小输出缓冲区的缓冲字符输出流</td></tr><tr><td align="center">BufferedWriter(Writer out, int sz) 创建一个新的缓冲字符输出流，该流使用给定大小的输出缓冲区</td></tr></tbody></table><p>PS：BufferedWriter缓冲字符输出流是包装一个字符输出流对象，所以参数需要一个字符出流对象进行传入创建，并且可以设置默认缓冲区的大小，不建议低于8192K大小，提供设置默认值时要是1024的倍数</p><h4 id="常用API方法"><a href="#常用API方法" class="headerlink" title="常用API方法"></a>常用API方法</h4><table><thead><tr><th align="center">void</th><th align="center">write(String str) 写一个字符串【这个方法是专门应对readLine方法写出的】</th></tr></thead><tbody><tr><td align="center">void</td><td align="center">newLine() 写行分隔符</td></tr></tbody></table><p>说明：</p><ol><li>BufferedWriter提供字符缓冲输出流操作，所以支持flush和close方法</li><li>BufferedWriter提供数据写出操作，提供两种方式应对BufferedReader的操作</li></ol><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;2.1 如果BufferedReader使用是char类型数组进行数据读取操作BufferedWriter就提 ·writer(char[] buf,int off,int len)将数据写出</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;2.2 如果BufferedReader使用是readLine这个方法进行数据读取操作者BufferedWriter就提供 write(String str) 将数据写出</p><p><strong>PS: 使用write(String str) 将数据写出时需要配合使用newLine()这个方法以保证写出文件正确格式</strong></p><p>需求： 使用缓冲字符输入输出流对象进行数据拷贝操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyFileDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span></span><br><span class="line">Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供缓冲字符输入输出流对象</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dir/UFT-8文件.txt&quot;</span>)));</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;desc/file文件.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//1.提供char数组方式进行写入写出操作</span></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">            char[] buf = new char[1024];</span></span><br><span class="line"><span class="comment">            int len;</span></span><br><span class="line"><span class="comment">            while((len = br.read(buf))!=-1)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                bw.write(buf,0,len);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//2.使用newLine来进行数据写入写出操作</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>((str = br.readLine()) != <span class="literal">null</span>)    <span class="comment">//readLine这个方式不读取换行操作，不读取回车&quot;\n&quot;</span></span><br><span class="line">        &#123;</span><br><span class="line">        </span><br><span class="line">            bw.write(str);</span><br><span class="line">            <span class="comment">//所以为了保证写出数据的格式完整性</span></span><br><span class="line">            bw.newLine(); <span class="comment">//添加换行操作即添加&quot;\n&quot;</span></span><br><span class="line">        &#125; </span><br><span class="line">        bw.flush();</span><br><span class="line">        bw.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结:</p><p>&ensp;&ensp;&ensp;&ensp;Java中提供缓冲流的效率是远远高于普通（原始）流，因为缓冲流提供缓冲区操作，<strong>缓冲字节输入输出流针对是二进制文件【视频、音频、图片、压缩包】等等，缓冲字符输入输出流针对的是文本文件，主要完成就是将内存中数据写入到文件中，将文件中数据在读取会内容，提供这个操作</strong></p><p>案例：使用字符输入流从控台读取数据【不用Scanner】，写入到文件中【默认记录聊天数据】，写出数据时使用</p><p>System.out打印到文件中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qfedu.BufferedReaderAndBufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadScannerToFile</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//不使用Scanner进行数据操作</span></span><br><span class="line">        <span class="comment">//可以提供字符缓冲输入流进行控制台数据读取</span></span><br><span class="line">        <span class="comment">//之所以可以在控制台获取到数据主要是因为使用标准字节输入流--》System.in</span></span><br><span class="line">        <span class="comment">//如果使用这种方法获取数据方式很单一只有readLine</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            使用System这个类中 setOut方法改变打印数据流向--》标准输出流重定向</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//需要提供一个字节打印流对象，提供流输出数据位置</span></span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;desc/聊天记录.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//修改打印流的流向</span></span><br><span class="line">        System.setOut(ps);</span><br><span class="line">        <span class="comment">//提供循环进行数据获取</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyyMM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//提供一个Date对象获取当前时间</span></span><br><span class="line">            <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">            <span class="comment">//读取控制台数据</span></span><br><span class="line">            content = br.readLine();</span><br><span class="line">            <span class="comment">//约定如果输入886结束程序</span></span><br><span class="line">            <span class="keyword">if</span>(content.equals(<span class="string">&quot;886&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//就将数据写入到文件中</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">time</span> <span class="operator">=</span> sdf.format(date);</span><br><span class="line">            <span class="comment">//System.out.println(time);</span></span><br><span class="line">            System.out.println(content);</span><br><span class="line">        &#125; </span><br><span class="line">        br.close();</span><br><span class="line">        ps.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//ps:已经将System.out的输出指定到文件中，如果需要将输出在指定会控制台打印如何做？</span></span><br></pre></td></tr></table></figure><h2 id="3、资源文件Properties"><a href="#3、资源文件Properties" class="headerlink" title="3、资源文件Properties"></a><center>3、资源文件Properties</center></h2><p>Properties文件是继承与Hashtable，Properties文件中存储数据方式就是以【key-value键值对】进行，对这个文件操作是将需要使用数据存储在value中，提供key可以访问外界访问到key获取到需要value值</p><p>Properties文件是可以通过代码进行创建，也可以在外界直接创建这个文件但是文件后缀名必须【.properties】这个文件被称之为资源文件，可以向这个文件中提供一些常用的配置信息【JDBC链接信息，Spring的配置信息、SpringBoot配置信息】等等，这个文件默认编码集是ISO-8859-1，所以不支持使用代码的形式创建文件中出现中文，如果出现中文是以Unicode码进行展示的。直接创建文件是支持写入中文但是要以注释形式存在</p><p><strong>案例：使用流方式来创建Properties文件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesFileDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//在控制台上获取一些数据，存储在properties文件中</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="comment">//文件后缀名字必须是.properties</span></span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;dir/config.properties&quot;</span>));</span><br><span class="line">        <span class="comment">//1.提供Properties对象的创建</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">//循环获取到控制台输入的数据</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入key值：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">            <span class="comment">//当key值获取到over的时候停止循环操作</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;over&quot;</span>.equals(key))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            System.out.println(<span class="string">&quot;请输入value值：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">            <span class="comment">//调用Properties中方法将key-value键值对存储到 Properties对象中</span></span><br><span class="line">            p.setProperty(key,value);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//将存储在Properties对象中数据写入到文件中，properties文件中 #号是注释的意思</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            store方法需要传递输出流对象【字符或字节都可以】</span></span><br><span class="line"><span class="comment">            第二个参数是 注释--》通过代码写出文件中文是无法正确展示的，所以建议使用英文</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        p.store(bw,<span class="string">&quot;我是注释!!!&quot;</span>);</span><br><span class="line">        bw.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>案例：使用流读取Properties文件【常用】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="comment">//读取资源文件的工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesUtil</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.提供一个私有静态Properties对象获取文件中数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Properties properties;</span><br><span class="line">    <span class="comment">//2.加载文件操作一般都会提前加载，而不是当用户使用到时候在加载</span></span><br><span class="line">    <span class="keyword">static</span>    <span class="comment">//使用静态代码块进行资源加载，只会执行一次不会出现重复加载问题</span></span><br><span class="line">    &#123; </span><br><span class="line">        </span><br><span class="line">        properties = <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            调用load方法加载资源文件，将资源文件中内容读取到properties对象中</span></span><br><span class="line"><span class="comment">            这个方法参数既可以是字节流也可以是字符流</span></span><br><span class="line"><span class="comment">            这个操作会存在编译时异常，static静态代码块中是不能throws，只能try-catch</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;dir/config.properties&quot;</span>));</span><br><span class="line">        &#125; </span><br><span class="line">            <span class="keyword">catch</span> (IOException e) </span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;资源文件加载失败，无法加载：&quot;</span>+e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        提供一个方法可以获取Properties资源文件中值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getValue</span><span class="params">(String key)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//通过key值获取到vlaue值        </span></span><br><span class="line">        <span class="keyword">return</span> properties.getProperty(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;获取用户名字请输入username:&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> input.next();</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> PropertiesUtil.getValue(username);</span><br><span class="line">        System.out.println(<span class="string">&quot;用户名：&quot;</span>+value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结Properties核心方法：</p><ol><li>创建对象—》new Properties();</li><li>存储key和value键值对 —》setProperty(key,value)</li><li>创建Properties文件 —》 store(字节或字符输出流对象，”文件内容注释”)</li><li>读取Properties文件 —》 load(字节或字符输入流对象)</li><li>获取value值 —》 getProperty(key)</li></ol><h2 id="4、序列化和反序列化【对象流】"><a href="#4、序列化和反序列化【对象流】" class="headerlink" title="4、序列化和反序列化【对象流】"></a><center>4、序列化和反序列化【对象流】</center></h2><p>序列化和反序列化？</p><p>&ensp;&ensp;&ensp;&ensp;<strong>对象序列化</strong> : <strong>把一个【对象转换二进制数据】这种方式称之为序列化</strong>，序列化之后对象可以方便实现对象【<strong>存储与传输</strong>】</p><p><strong>&ensp;&ensp;&ensp;&ensp;对象反序列化</strong>：<strong>把一个【二进制数据转换成对象】这种方式称之为反序列化</strong>,通过反序列化操作就可以得到存储在文件中对象内的数据了</p><p><strong>Serializable接口</strong></p><p>&ensp;&ensp;&ensp;&ensp;如果需要将某个对象进行序列化操作，那么这个对象描述类就需要实现<strong>Serializable接口</strong>，这样才可以允许对当前对象进行序列化和反序列化</p><p>&ensp;&ensp;&ensp;&ensp;API文档中对Serializable接口的说明： 类通过实现java.io.Serializable 接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。可序列化类的所有子类型本身都是可序列化的。序列化接口没有方法或字段，仅用于标识可序列化的语义</p><img src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202403012018417.png" alt="兼容问题" style="zoom:50%;"><h3 id="（1）对象字节输入输出流"><a href="#（1）对象字节输入输出流" class="headerlink" title="（1）对象字节输入输出流"></a>（1）对象字节输入输出流</h3><p>使用对象字节输入流读取文件称之为【反序列化】，从磁盘文件中将对象读取到内存使用是【ObjectInputStream】</p><p>使用对象字节输出流写出文件称之为【序列化】，从内存将对象写入到文件中使用是【ObjectOutputStream】</p><p><strong>ObjectOutputStream常用构造方法和常用方法</strong></p><table><thead><tr><th align="center"></th><th align="center">常用构造方法</th></tr></thead><tbody><tr><td align="center">public</td><td align="center">ObjectOutputStream(OutputStream out)创建一个对象写入到指定的输出流，参数需要是一个字节输出流对象</td></tr></tbody></table><table><thead><tr><th align="center"></th><th align="center">常用方法</th></tr></thead><tbody><tr><td align="center">void</td><td align="center">writeObject(Object obj) 将对象写入到对象流中【对象的序列化】</td></tr></tbody></table><p>因为需要将对象序列化到文件中所以构造方法中需要提供字节输出流对象，配套使用是FileOutputStream，核心方法就是序列化对象，所以使用writeObject方法，还支持很多其他的写入方法，但是使用较少，支持关闭和刷新流</p><p><strong>ObjectInputStream常用的构造方法和常用方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">常用构造方法</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ObjectInputStream</span><span class="params">(InputStream in)</span></span><br><span class="line">创建一个对象输入流读取从指定的输入流，参数需要一个字节输入流对象</span><br><span class="line">常用方法</span><br><span class="line">Object <span class="title function_">readObject</span><span class="params">()</span> 从对象输入流读取对象【反序列化】 </span><br><span class="line">读取的是文件中内容，所以参数需要一个字节输入流对象，匹配使用是FileInputStream，核心方法就是反序列化对象，</span><br><span class="line">所以使用readObject这个方法，特别注意返回值类型时Object，这个流也需要关闭</span><br></pre></td></tr></table></figure><p>案例：单个对象序列和反序列化操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">        <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">        <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">        <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//java.io.NotSerializableException: com.qfedu.serializable.Student</span></span><br><span class="line">        <span class="comment">//出现这个异常原因是因为没有实现：Serializable接口</span></span><br><span class="line">        <span class="comment">// Student student = new Student(&quot;成龙&quot;,68);</span></span><br><span class="line">        <span class="comment">// serializableObject(student);</span></span><br><span class="line">        deSerializableObject();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">        对象序列化操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serializableObject</span><span class="params">(Student student)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建序列化对象的流对象</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;dir/序列化单个对象的文件&quot;</span>));</span><br><span class="line">        <span class="comment">//2.代用writeObject方法进行序列化操作</span></span><br><span class="line">        oos.writeObject(student);</span><br><span class="line">        System.out.println(<span class="string">&quot;序列化成功！&quot;</span>);</span><br><span class="line">        oos.close();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">        对象反序列化操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deSerializableObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供反序列化流对象</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;dir/序列化单个对象的文件&quot;</span>));</span><br><span class="line">        <span class="comment">//2.调用readObject方法反序列化操作</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> ois.readObject();    <span class="comment">//这个方法返回值是Boject类型，如果需要对数据进行具体化操作需要对象向下转型</span></span><br><span class="line">        System.out.println(<span class="string">&quot;验证o对象是否是Student类型：&quot;</span>+(o <span class="keyword">instanceof</span> Student));</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>案例：多个对象序列化和反序列化【创建5个Student对象进行序列化和反序列化操作要求在同一个文件中（一个文件5个对象）】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">//多个对象序列化与反序列化操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;Student&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三1&quot;</span>,<span class="number">19</span>),<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三2&quot;</span>,<span class="number">20</span>), <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三3&quot;</span>,<span class="number">21</span>),</span><br><span class="line">                           <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三4&quot;</span>,<span class="number">22</span>), <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三5&quot;</span>,<span class="number">23</span>),<span class="literal">null</span>);<span class="comment">//追加null就是结尾证明没有数据了</span></span><br><span class="line">        <span class="comment">//serializableMoreObject(list);</span></span><br><span class="line">        <span class="comment">//deSerializableMoreObject();</span></span><br><span class="line">        <span class="comment">// --------------------------------------------------</span></span><br><span class="line">        <span class="comment">//serializableMoreObject2(list);</span></span><br><span class="line">        deSerializableMoreObject2();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//提供第一个处理方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serializableMoreObject</span><span class="params">(List&lt;Student&gt; list)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;dir/多个对象序列化文件&quot;</span>));</span><br><span class="line">        <span class="comment">//此时要序列化操作，但是现在所有的对象都是存在List集合中，所以直接序列化集合即可</span></span><br><span class="line">        <span class="comment">//这个操作只是取巧，不是多个对象序列化， 只是序列化了一个List集合对象</span></span><br><span class="line">        oos.writeObject(list);</span><br><span class="line">        oos.flush();</span><br><span class="line">        oos.close();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deSerializableMoreObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;dir/多个对象序列化文件&quot;</span>));</span><br><span class="line">        <span class="comment">//readObject这个方法的返回值是Object类型，所以需要操作数据时需要向下转型</span></span><br><span class="line">        List&lt;Student&gt; stus = ((List&lt;Student&gt;)ois.readObject());</span><br><span class="line">        <span class="keyword">for</span> (Student student : stus) </span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(student);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//----------------------------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">//第二种序列化和反序列化方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serializableMoreObject2</span><span class="params">(List&lt;Student&gt; list)</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;dir/多个对象序列化文件2&quot;</span>));</span><br><span class="line">        <span class="comment">//此时要序列化操作，但是现在所有的对象都是存在List集合中，需要从集合中获取所有对象</span></span><br><span class="line">        <span class="keyword">for</span> (Student student : list) </span><br><span class="line">        &#123;</span><br><span class="line">            oos.writeObject(student); <span class="comment">//这样才是5对象序列化</span></span><br><span class="line">        &#125; </span><br><span class="line">        oos.flush();</span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deSerializableMoreObject2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;dir/多个对象序列化文件2&quot;</span>));</span><br><span class="line">        <span class="comment">//提供一个集合存储读取对象数据</span></span><br><span class="line">        List&lt;Student&gt; stus = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            readObject这个方法的返回值是Object类型，所以需要操作数据时需要向下转型</span></span><br><span class="line"><span class="comment">            因为文件中存储的5个对象，如果对象么有值使用什么代表--》null值</span></span><br><span class="line"><span class="comment">            利用这个原则进行数据读取操作</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            使用这种读取方式readObject提示一个EOFException含义</span></span><br><span class="line"><span class="comment">            此异常主要被数据输入流用来表明到达流的末尾</span></span><br><span class="line"><span class="comment">            证明是争取读取到文件中每一个数据并且读取到文件末尾，才会出现这个异常</span></span><br><span class="line"><span class="comment">            在while循环中提供判断是无法生效，它是无法获取到文件末尾的null，即没有这个null</span></span><br><span class="line"><span class="comment">            只能以异常形式停止，所以如何处理这个问题，会在集合存储的最后一个位置添加一个null作为结尾</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">while</span>((obj = ois.readObject())!=<span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            stus.add(((Student)obj));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">            while(true)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                try </span></span><br><span class="line"><span class="comment">                &#123;</span></span><br><span class="line"><span class="comment">                    obj = ois.readObject();</span></span><br><span class="line"><span class="comment">                    stus.add(((Student)obj));</span></span><br><span class="line"><span class="comment">                &#125; </span></span><br><span class="line"><span class="comment">                catch (EOFException e) </span></span><br><span class="line"><span class="comment">                &#123;</span></span><br><span class="line"><span class="comment">                    break;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        ois.close();</span><br><span class="line">        stus.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;知识点一：概念&quot;&gt;&lt;a href=&quot;#知识点一：概念&quot; class=&quot;headerlink&quot; title=&quot;知识点一：概念&quot;&gt;&lt;/a&gt;&lt;center&gt;知识点一：概念&lt;/center&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;PS：IO很简单主要记忆的就是IO中进行文件读写操</summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
</feed>
