<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>17.面向对象 | 星仔人生录</title><meta name="keywords" content="Java语言"><meta name="author" content="星仔"><meta name="copyright" content="星仔"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="17.面向对象"><meta name="application-name" content="17.面向对象"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="17.面向对象"><meta property="og:url" content="http://example.com/post/76fa8c0d.html"><meta property="og:site_name" content="星仔人生录"><meta property="og:description" content="知识点一：面向对象的编程思想面向对象程序设计(Object Oriented Programming)  什么是编程思想？ 思想：其实思想就是你大脑中对某些事务的思维，通过思维完成这些事务 编程思想：就是你大脑中对代码中需要完成思维逻辑所提供一种思维，编程思想就是编程思路 在开发中我们接触比较经典编"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402292029940.WebP"><meta property="article:author" content="星仔"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402292029940.WebP"><meta name="description" content="知识点一：面向对象的编程思想面向对象程序设计(Object Oriented Programming)  什么是编程思想？ 思想：其实思想就是你大脑中对某些事务的思维，通过思维完成这些事务 编程思想：就是你大脑中对代码中需要完成思维逻辑所提供一种思维，编程思想就是编程思路 在开发中我们接触比较经典编"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/post/76fa8c0d"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: undefined,
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: {"enable":true,"ck":"3HZ1UVjhMEV6g7Lg","LingQueMonitorID":"3HZ1UVjhMEV6g7Lg"},
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: {"mode":"cdn","api":"https://img2color-go.vercel.app/api?img=","cover_change":true},
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🏠 智能家居小能手","🔨 设计开发一条龙","🤝 专修交互与设计","🏃 脚踏实地行动派","🧱 团队小组发动机","💢 壮汉人狠话不多"]},
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 星仔","link":"链接: ","source":"来源: 星仔人生录","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '星仔人生录',
  title: '17.面向对象',
  postAI: '',
  pageFillDescription: '知识点一：面向对象的编程思想, 知识点二：类和对象的概述, 类的概述, 对象的概述, 类和对象的关系, 知识点三：类、对象, 1、类的定义, 2、对象的创建与使用, 创建对象的语法：, 3、单个对象在内存中存储, 4、多个对象在内存中存储, 5、多个对象指向同一个对象在内存那种存储, 知识点四：成员变量和局部变量, 知识点六：构造方法, 1、定义, 2、语法, 3、注意的事项, 重载, 知识点七：对象的内存分配, 知识点九：三大特征, 1、封装, Getter和Setter方法, this关键字, 1）调用本类属性, 2）调用本类方法, 3）调用本类的构造方法, 标准类的制作, 2、继承, 1）含义, 2）语法, 好处和特点, 不能被继承情况, 以继承角度完成练习：, 4）super关键字, 定义, 作用, 5）方法重写, 定义, 应用, 注解：@Override, 重写完成要求：, 方法重载与方法重写的区别, 继承中子类实例化过程, 子类继承父类之后内存存储, 3、多态, 1）定义, 里氏代转换原则, 2）特点, 3）多态产生条件, 4）向上向下转型, 5）instanceOf关键字, 6）多态的引用场景, 知识点十：三个修饰符, 1、abstract关键字, 1）含义, 2）抽象类含义：被abstract修饰的类称之为抽象类, 3）抽象方法, 2、static关键字, 1）含义, 2）作用, 3）静态和成员之间的区别, 4）static修饰成员变量, 5）static修饰成员方法, 静态方法被使用时注意事项, 6）静态代码块, 含义, 特点, 3、final关键字, 1）含义, 2）作用, 使用final修饰符修饰局部变量, 使用final修饰符修饰成员变量和静态变量, final修饰成员变量, final修饰静态变量, 使用final关键字修饰成员方法知识点一面向对象的编程思想面向对象程序设计什么是编程思想思想其实思想就是你大脑中对某些事务的思维通过思维完成这些事务编程思想就是你大脑中对代码中需要完成思维逻辑所提供一种思维编程思想就是编程思路在开发中我们接触比较经典编程思想一种面向过程和一种面向对象面向对象编程思想是从面向过程转变而来所以面向对象中也会掺杂着面向过程面向过程的编程思想强调的是过程必须清楚每一个步骤然后按照步骤一步一步去实现面向对象的编程思想强调的是对象通过调用对象的行为来实现功能从而完成需求面向对象并不是我们自己一步一步去操作实现举例对比说明同样是处理洗衣服事物面向过程角度而言把衣服脱下来找一个盆放点洗衣粉加点水浸泡分钟揉一揉清洗衣服拧干晾起来面向对象角度而言把衣服托脱下来找一个对象女朋友男朋友让他去完成洗同样是要吃饭面向过程角度而言买菜洗菜炒菜吃面向对象角度而言找一个饭店点一份外卖付钱从程序角度来思考需求打印数组中存储数据打印格式为元素元素元素先提供一个数据以面相过程的角度而言一步一步进行打印操作以面向对象角度而言只需要找到可以打印数组数据对象即可总结无论是面向过程还是面向对象都是一种编程思想就是你编写代码的思维逻辑区别在于面向过程注重的是步骤必须清楚每一个步骤按照步骤一步一步去实现面向对象注重的是对象无需清楚每一个步骤只需要使用对象调用行为来完成需求即可面向过程在之前学习知识点时候就已经慢慢的在学习使用面向对象的这个编程思想如何在代码中体现如何在代码中写出自己的面向对象思想如果在代码中要体现面向对象编程思想需要提供类和对象通过类对对象进行描述在通过对象完成思维逻辑知识点二类和对象的概述类的概述什么是类类是用来描述一类具有共同属性和行为事物的统称所以其实类在客观现实世界中是不存在是抽象的只是用来描述信息例如人类描述人的狗类描述狗手机类描述手机动物类描述动物类提供描述使用的这个描述要是共有属性和行为统称在一起称为类上图中所表述意义在于每一个单独个体具备共有属性和行为抽取出来形成一个描述这个描述就是就类上图中描述就是人类属性和行为属性就是该事物的状态信息人类身高体重年龄性别等等行为就是该事物能够做什么人类说话吃喝睡觉等等总结需要将现实生活中描述类的操作转变为代码在编程中进行体现明确类是用来描述一群具有共同属性和行为事物的统称类是一个抽象的看不见摸不着用来描述信息的操作类的组成属性成员变量行为成员方法成员变量是什么它就是定义在类中用来描述现实生活中属性的在代码中体现就是定义变量成员方法是什么方法其实就是对某些事物的处理途径将某些处理事物的代码放置到一个大括号中然后对这个大括号起一个名字外界只需要使用这个名字就要可以完成对事物的操作方法就是对你实现功能代码进行一个封装操作外界只需要调用方法名就可以完成处理事物逻辑在某些语言中将方法称之为函数但是在中我们建议称之为方法只有面向过程语言才称之为函数而是面向对象语言称之为方法只要在代码中定义一个类并在类中提供属性和行为就可以进行现实生活中事物的描述成员方法就是不使用进行修饰的方法类具备的操作就是描述操作并不具备具体处理事物的能力就需要将类具现化出来所以提供对象来具现化类对象的概述对象是类的一个实例具体存在的例子具体存在的看得见的摸得着并且具备该类事物的属性和行为对象的属性对象的属性具有特定值对象的行为对象可以操作的行为人类人的描述提供对象进行具体的体现班班老师狗类狗的描述提供对象进行具体的体现柯基狗狗手机类描述手机提供对象进行具体的体现华为手机举例对象你手上手机属性华为核内存存储空间支持对象属性就是具体的值因为类描述的时候属性是没有具体数据值行为可以打电话上网发短信等等对象可以具体完成哪些操作总结对象就是类的实例具体存在的看得见摸得着对象属性具有具体数据值的对象的行为其实就是可以使用的功能中面向对象思想就是需要你在代码中提供类和对象来完成是现实生活中的思维逻辑类是对象的操作对象是类的具现化来完成事物操作过程类和对象的关系类是对一类具有共同属性和行为的事物统称是抽象的对象是一类事物的具体是实例看得见摸得着真实存在的实体是具体的总结类是对象的抽象对象是类的实例化总结对象是根据类创建出来的类可以看成是对象的数据类型所以类是中引用类型现如今为止引用类型数组类他们所创建出来的空间都是在堆中的类中有什么属性和行为对象就具备哪些属性和行为因为类对对象描述现在所说的这些都是概念性的东西在现实生活中对象是真实存在如果要处理某些事物只需要找到对应对象就可以完成这个事物面向对象思想但是编写代码的程序是不具备这些类和对象所以我们就需要用过上述这些概念进行描述与操作从现在开始完后所有开发使用都是面向对象的思想来进行的而且面向对象是最符合人类思维的一种途径现在的编码结构也是以面向对象为切入点进行模块式的开发知识点三类对象类的定义类的是描述一群具有共同属性和行为的操作类的组成属性该类事物的状态信息在类中以成员变量形式来体现行为该类事物有什么功能在类中提供成员方法来体现现阶段在定义一个类来描述事物就需要提供属性和行为即成员变量和成员成方法类的格式类名提供描述属性属性在类中体现就是成员变量就是在类中定义一个变量多个权限修饰符访问权限修饰符数据类型变量名提供描述行为行为在类中体现就是成员方法和之前学习方法定义是一样只不多去掉了关键字访问权限修饰符返回值类型方法名参数列表执行代码你要操作什么代码演示需求定义一个手机类类名类中属性有品牌价格类中行为有打电话发短信从现在开始编写面向对象编程思想时候需要注意对创建类就存在分类操作在面向对象中类有两个基础分类一个是叫做描述类这个类主要提供对对象描述使用类提供描述中所需要定义操作这个类是不提供方法一个是叫做执行类这个类主要数提供面向对象编程实现具体执行操作类这个类会将描述类进行具现化提供对象来处理业务逻辑所以这个类会提供方法这个这个类就是一个描述类所以不提供方法在类中定义属性即成员变量是支持中全套的权限修饰符现阶段可以使用权限修饰符有公有的默认的不提供任何全新修饰符书写因为在写面向对象时会使用到一个描述操作此时类型就比较适合使用简单介绍在中是一个类是引用类型的代表代码中所有字符串对象只要在代码中使用提供操作就是类的对象如果成员变量使用类型如何进行赋值操作例如华为需求定义一个手机类类名类中属性有品牌价格这个成员变量就是权限修饰符这个成员变量就是默认权限修饰符类中行为有打电话发短信这个方法就是成员方法不使用修饰手机可以打电话发送的信息是发送信息成功对象的创建与使用创建对象的语法语法类名对象名类名类其实就是对象的数据类型类是引用类型佐证使用关键字例如相当于创建类的对象对象数据类型是相当于创建类的对象对象数据类型是相当于创建类的对象对象数据类型是类中提供对象所描述属性和行为通过类创建对象之后对象就可以使用类中所提供属性和行为即可以通过对象访问成员变量和成员方法访问类中成员变量获取成员变量的值对象名成员变量名对成员变量进行赋值对象名成员变量名值访问类中成员方法对象名成员方法的名字提供参数赋值需求创建类对象并对类中提供属性和行为进行操作这个类主要就是提供这个描述的操作使用的所以这个类就是执行类要添加方法创建这个类的对象对成员变量进行访问手机的品牌手机的价格之前在学习中已经接触了局部变量即定义在方法体内部变量就是局部变量但是在方法体内部定义局部变量必须进行初始化之后才可以进行使用作用域仅限在方法体内部成员变量是定义在类中的声明在类中成员变量是存在默认值的即只提供定义操作没有提供赋值操作那么这个变量也可以使用并且有默认值存在成员变量的默认值会根据数据类型来决定整数类型默认值小数类型和默认值字符类型默认值一个不可见空字符布尔类型默认值引用类型自定义类数组默认值对成员变量进行赋值操作华为手机的品牌手机的价格使用对象对成员方法进行访问操作你好欢迎使用单个对象在内存中存储总结只要是创建对象使用关键字就会在堆中开辟一段空间只要调用方法就会在栈中开辟一段空间用来执行该方法栈中空间是系统回收操作堆中空间是提供垃圾回收机制进行回收操作姓名年龄行为学习正在努力的学习创建类的对象利用学生对象打印成员变量的值姓名年龄利用学生对象对成员变量进行赋值操作小明姓名年龄打印学生对象打印学生对象方式理解为学生对象地址在堆中地址证明这个对象时属于类的没有任何意义就是一个连接符号学生对象记录的堆中开辟空间地址学生对象多个对象在内存中存储总结一个类是可以创建多个对象的多个对象在堆中存储都有不同内存划分就是多个对象都使用关键字创建成员变量是存储在各自的内存区域中成员方法是多个对象共一份类文件只有一个凡是使用关键字创建的对象都会在堆中开辟一段新的存储空间对象和对象之的关系是相互独立的只要是使用关键字创建出来创建类的对象利用学生对象打印成员变量的值姓名年龄利用学生对象对成员变量进行赋值操作小明姓名年龄打印学生对象打印学生对象方式理解为学生对象地址在堆中地址证明这个对象时属于类的没有任何意义就是一个连接符号学生对象记录的堆中开辟空间地址学生对象在利用类创建一个对象并访问成员变量姓名年龄多个对象指向同一个对象在内存那种存储总结当多个对象的引用指向同一个内存空间时对象所记录地址都是一样的只要有任何一个对象修改了内存中数据随之无论使用哪一个对象进行数据获取都是修改之后的数据当创建多个对象时如果你需要某个对象与另外一个对象的空间是一致只需要将其中创建好的对象存储空间地址赋值给另外一个对象即可此时引用就是同一个空间当创建多个对象时需要对象彼此之间互相独立不干扰只需使用关键字分别创建即可就可以在堆中开辟不同存储空间了创建类的对象利用学生对象打印成员变量的值姓名年龄利用学生对象对成员变量进行赋值操作小明姓名年龄打印学生对象打印学生对象方式理解为学生对象地址在堆中地址证明这个对象时属于类的没有任何意义就是一个连接符号学生对象记录的堆中开辟空间地址学生对象不在使用类创建对象而是使用创建对象对另外一个对象进行赋值姓名年龄知识点四成员变量和局部变量成员变量实例变量定义在类的里面方法的外面的变量称之为成员变量局部变量定义在方法内部的变量称为局部变量成员变量和局部变量的区别位置不同成员变量在类中方法外局部变量在方法内部初始值不同变量必须要初始化才能使用成员变量系统会赋值默认值与之前讲的数组一致局部变量没有默认值作用域不同成员变量在类中都可以使用局部变量只能在作用域中使用在它所在的中重名问题成员变量不能重名局部变量在不同作用域中是可以重名的如果当局部变量和成员变量重名的时候中遵循就近原则生命周期不同成员变量变量会随着对象的销毁而销毁对象什么时候销毁呢中垃圾回收机制语句变量当变量出了作用域就会被销毁知识点六构造方法定义构造方法是一个特殊的方法主要是完成对象的创建和对象数据的初始化方法构造方法的提供主要是为了可以保证对象可以正确创建以及对成员变量的从初始化的操作在不使用构造方法之前对类中所提供成员变量进行赋值的只能通过对象一个一个的进行赋值如果类中成员变量过多这个操作是很繁琐因为对象创建过程中是需要进行内存开辟空间构造方法可以保证类所创建对象可以正确创建出来在实际开发中构造方法主要有两类一类被称之为无参构造方法和一类被称之为有参构造方法语法类名访问权限修饰符数据类型变量名属性访问权限修饰符返回值类型方法名参数列表行为方法体访问权限修饰符类名无参构造方法访问权限修饰符类名参数列表有参构造方法提供类中属性成员变量的初始化操作构造方法的说明构造方法只能在类中定义无法在其他位置提供定义构造方法使用权限修饰符常用除此之外在某些特殊情况下可以将构造方法使用私有的进行修饰构造方法的方法名与类名必须是相同的构造反方没有返回值类型甚至都不需要使用进行表示更不可能在构造方法中使用关键字无参构造方法的调用类名对象名类名有参构造方法的调用类名对象名类名实参实参例需求提供一个类属性姓名年龄性别行为吃在提供类中构造方法定义属性描述姓名年龄性别行为的描述在同一个类中成员方法是可以直接访问本类中提供成员变量和其他成员方法正在吃饭提供类的无参构造方法无参构造方法方法的参数列表不做任何参数定义在实际开发中无参构造方法主要是定义的作用基本上在构造方法体中很少进行初始操作如果在无参构造方法进行属性的初始化所有调用无参构造方法创建对象都会都会具备这个属性值给属性进行初始化操作手动进行赋值提供类的有参构造方法的有参构造方法一定会提供参数列表这个参数列表如何定义给那些类中属性进行赋值初始化参数列表就定义那些数据定义参数需要和类中属性数据类型是一直这样方便进行赋值操作这个操作就是使用参数对类中属性进行初始化赋值操作使用类中无参构造方法分别构建两个对象调用类中提供属性对象中的属性值都是午餐构造里面的值对象中的属性值使用类中有参构造方法在创建对象的同时对属性进行初始化小红女小括号中提供具体数据调用就是有参构造方法打印对象中属性值注意的事项如果在类中并没有明确提供构造方法的定义此时系统将提供一个默认无参构造方法让创建对象时使用这个类中并没有明确提供构造方法但是系统会为提供一个默认的无参构造方法如果在类中明确提供了构造方法无论是有参还无参此时系统提供的默认构造方法将消失不在提供对外操作明确提供一个有参构造方法系统无参构造方法将无法在次调用如果需要使用无参构造方法必须手动提供调用这个类中无参构造方法进行对象创建提供错误提示一个类中是可以提供多个构造方法但是在同一个类中有一个要求定义方法签名方法名参数列表不能重复那么为什么还可以提供一个无参构造方法和一个有参构造方法呢重载这里我们利用到一个方法的概念特点这个特点叫做方法的重载在同一个类中定义方法签名是不允许重复但是利用重载这个概念完成方法名相同操作无参构造方法与有参构造方法的名字是相同但是没有报错虽然名字相同但是参数列表是不同就会触发重载操作重载的要求只要满足以下三者之一就可以成为重载方法名相同但是参数列表不同定义的顺序不同就可以称之为重载方法名相同但是参数列表不同定义的数据类型不同就可以称之为重载方法名相同但是参数列表不同定义的个数不同就可以称之为重载所以当前类中所提供的无参构造方法与有参构造方法就是方法的重载可以利用这个特性提供多个方法构造方法必须与类同名必须没有返回值类型并且也不可以不可以使用关键字为了保证类与类之间继承关系为了保证合理定义一般会在一个描述类中提供一个有参和无参的构造方法有参构造方法一般是针对类中所有属性记性初始化操作类中基本提供方式无参构造方法有参构造方法还可以利用重载的特点进行多个构造方法的提供因人而异因项目要求而异重载这个概念也适用于其他方法知识点七对象的内存分配知识点九三大特征面向对象这个编程思想是贴近与现实生活逻辑一种编程思想在这个编程思想中利用三个特征完成面向对象的编程逻辑面向对象中的三大特征封装继承和多态这三者体现了什么封装性封装就是一个事物包裹起来使外界不了解它内部的情况在面向对象中封装就把相关的数据和代码结合成一个有机的整体形成数据和代码操作的封装体提供一个对外部暴露的接口可以方便外界使用这个封装继承性从已有类中创建新类的过程提供继承信息的被称之为父类得到继承信息称之为子类父子之间存在一个关系就是继承继承可以使中类与类之间形成一个层次机构利用这个继承简便的进行代码的开发多态性多态是允许程序中出现多种状态的对象同一个事物被不同对象所触发得到结果不同就称之为多态主要体现就是对象的转型操作以上的三个特征会在编程中所有体现从而完善面向对象编程封装需求创建一个类对类提供属性姓名和年龄然后再执行类中创建类对象对属性进行操作及打印小花猫的名字猫的年龄但是对属性进行赋值操作首先下面这个语法在开发中是没有问题是可以对属性进行负数赋值操作属性是数据类型数据类型可以存储数据范围亿亿之间赋值这个很明显是满足这个存储范围操作的语法是没有问题在客观现实生活中猫的年龄是绝对不可能出现负数的如果在实际开发中让外界可以直接对成员变量进行访问操作是会存在安全隐患的猫的年龄在开发中如果我们直接访问成员变量可能会出现安全隐患在代码中属性赋值操作就已经出现问题应该如何解决解决方式提供变量不对外直接访问的途径即对属性进行封装操作在学习类的时候在定义属性成员变量时可以对属性进行权限修饰符的使用现在接触的权限修饰符主要所有公有和默认包权限使用他们修饰之后外界还是可以进行访问的所以想让属性不在提供对方直接访问使用封装概念来完成操作可以使用一个权限修饰符私有这权限修饰符是所有权限修饰符中在最低权限利用对成员变量的修饰以达到封装的目的解决方法修改类代码对属性提供修饰属性的私有化就是封装的体现面向对象的封装其实就是一个编程的要求将信息隐藏起来把不需要外界知道的信息隐藏尽可能隐藏对象功能实现细节向外直接提供他可以访问方法保证外界无法破坏原有内部信息这就是封装特性在写面向对象思想时封装效果体现其实已经在在写类的时候就已经是封装的效果类就是将属性和方法封装在一个类中除了这种体现方式之外可以对属性进行私有化操作即使用进行修饰主要的目的是为了保证成员变量安全所以私有化成员变量只是封装特定一个体现而已封装确实可以保证属性的安全性外界无法直接破坏内部存储信息的途径但是正常使用属性时也无法完成所以封装中还有有一句话很重要向外直接提供他可以访问方法和方法当对属性提供权限修饰符时确实让属性更加安全体现封装的一个特点但是并不是完全封装特性展示封装细节之后还是要提供一种访问方式如果属性使用进行修饰之后就要对属性配套提供对应和方法因为属性已经被修饰了提供和方法的目的是为了提供操作属性途径所以这两方法必然使用修饰方法定义方式返回值类型属性名解释说明方法主要的作用就是提供获取属性方法这个方法必须有返回值类型这个返回值类型如何定义你提供方法获取的是哪个属性值这个方法的返回值类型就与属性的属性类型一致即可方法名是固定的叫做是固定代表是方法获取属性值用是你通过获取哪个属性这个就是属性字外界使用方法时可以通过方法名得知使用是哪个属性这个方法的参数列表定义是空的没有任何参数定义这个方法必须添加关键字这个方法是获取属性值如果不数据如何得到值这个方法定义返回值类型所以方法必须添加关键字对应操作关键字后面跟值是什么你获取的是哪个属性值就哪个属性方法定义方式参数列表使用定义参数对属性进行赋值解释说明方法的主要作用就是对进行赋值操作因为方法是对属性赋值所以这个方法不需要返回值类型所以方法使用定义这个名字是固定的主要说明这个方法是方法对属性赋值使用是针对堆那个属性赋值就是那个属性名字这样一来外界调用这个方法时就可以得知对那个属性的操作这里一定需要定义参数列表因为方法主要作用是赋值所以需要通过方法参数对属性进行赋值操作你对那个属性记性赋值那么这个参数列表定义就与属性定义相同即可方法体提供的是对属性的赋值操作利用参数对属性赋值一定没有关键字修改类提供和方法属性的私有化就是封装的体现提供修饰属性的和方法获取属性值属性进行赋值操作非法拦截您提供年龄不合法无法赋值小花猫的名字猫的年龄猫的年龄关键字需求定义一个类提供属性和并且私有化提供有参无参构造方法提供和方法并且要求在定义有参和方法是定参数列表名需要和属性名一致创建一个对象分别使用有参无参构造方法完成在调用修改任何属性值并提供方法打印出来使用无参构造方法创建对象通过对象调用方法进行属性赋值操作小明的姓名使用有参构造方法创建对象小红的姓名的年龄执行完代码之后打印属性值发现的姓名的姓名的年龄打印出来属性值都是默认值这是为什么呢在说这个问题之前介绍一个关键字这个关键字可以在当前类中使用主要使用在构造方法和成员方法中关键字在类中代表什么代表的是当前对象谁触发谁就是调用本类属性在本类中调用本类的属性关键字可以省略但是如果局部变量和成员变量同名时若时属性名则是调用成员变量若直接属性名则是调用局部变量就近原则调用本类方法在调用本类的方法的时候关键字完全可以省略不写调用本类的构造方法在构造方法里调用另外一个构造方法注意点在构造方法中用再调用本类的其它构造方法的时候这一行代码必须出现在构造方法的第一行避免在构造方法中调用自身这个构造这会出现无穷递归关键字的作用可以通过关键字访问当前类中成员变量进行操作成员变量可以通过关键字访问当前类中成员方法进行操作成员方法参数赋值可以通过关键字在当前类中构造方法中访问其他的本类构造方法访问本类的无参构造方法参数赋值访问本类的有参构造方法特别说明这个调用构造方法的方式只能在构造方法中使用并且必须在构造方法体中第一句不允许构造通过关键字调用自身构造方法可以通过关键字作为方法参数传递代表当前对象上述的作用中只有一个对于我们开发是有用的其余的都是已经很少使用甚至不用使用关键字访问成员变量在构造方法中和方法中区分成员变量和参数名字使用关键字修改类在这个构造方法中使用关键字调用本类的其他构造方法很少使用不允许使用关键字调用自身构造方法必须在构造方法中第一行不允许在它之前出现任何其他代码小白不允许构造互相调用不允许在无参中调用有参在有参中调用无参原因就是出现在这个赋值操作过程中中如何认定一个变量属于谁使用是就近原则离谁最近就是谁这个变量和参数列表中是最近的所以这个赋值操作其实就是在用参数对参数进行赋值根本就没有属性进行赋值操作虽然这个与属性是同名但是根本就没有操作到没有办法区分属性名与参数名相同时那个是属性那个是参数出现了二义性使用关键字调用成员变量的方式区分成员变量名字和参数的名字提供两个成员方法成员方法使用关键字访问本类中成员变量和成员方法本类属性但是实际开发中可以省略不写上下代码操作是完全一样下面的操作属于上面操作的简化实际在底层依旧是在执行和本类属性总结关键字使用方式是有很多的的但是使用应用主要还是会使用成员变量方法进行与相同参数名的区分操作其余的功能进本上很少在使用标准类的制作中我们要定义一个类是有一个标准这个标准叫做是语言编写类第一种规范符合的类要求类必须是公有的属性需要使用修饰并且提供有参和无参构造方法还要提供成员变量的和方法这样类就称之为标准类进入后选选全部生成全参构造方法进入后选不用选生成无参构造进入后选选全部生成公共访问返回值类型方法名参数列表方法体总结在通过题意针对某些类进行定义时尽量使用标准类定义的要求私有属性有参无参构造方法和方法进行类的定义剩余的可以根据实际需求动态在类中记性增删添加即可继承含义继承是面向对象三大特征之一也是面向对象编程中不可缺少的一个操作继承是一个比较好理解的概念和现实生活中继承是相同在中继承概念在中指的是一个类可以继承自另外一个类被继承的类叫做父类基类超类继承其他类的类叫做子类派生类继承之后子类中就拥有父类中所有可见的成员成员变量和成员方法子类就不需要在重复定义了不仅如此子类还可以提供自身独有的成员变量和成员方法提供继承概念可以最大限度提高代码之间复用性减少代码冗余相同代码重复利用并且可以让类与类之间产生关联案例西游记中角色定义唐僧姓名性别年龄念经悟空姓名性别年龄七十二变打妖怪八戒姓名性别年龄三十六变调戏嫦娥沙僧姓名性别年龄挑担求救白龙马姓名性别年龄走提供创建类的分析设计唐生类属性有个姓名性别年龄定义成成员变量行为念经定成方法设计悟空类属性有个姓名性别年龄定义成成员变量行为七十二变打妖怪设计八戒类属性有个姓名性别年龄定义成成员变量行为三十六变调戏嫦娥设计沙僧类属性有个姓名性别年龄定义成成员变量行为挑担求救设计白龙马类属性有个姓名性别年龄定义成成员变量行为走当前个类中有相同的属性都是需要定义三个属性分贝为姓名性别年龄只是当前每个类中行为不同而已语法在中需要完成继承操作需要使用到一个关键字表示继承关键字的本身含义是扩展的意思但是为了复合国人学习编程习惯所以翻译成继承提供继承信息的是父类如何定义你平时如何定义类就如何定义父类父类名字成员变量构造方法和方法成员方法得到继承信息的是子类如何定义子类名字父类名字类与类之间继承子类可以得到父类所有的可见属性和方法不是用修饰从父类继承而来就无需重复定义直接使用即可除此之外子类还可以提供子类自身定义的成员变量构造方法和方法成员方法在开发中父类就是一个模板类给所有子类提供一些基础信息属性和行为所以父类基本上是不会直接创建对象子类是继承父类而来所以子类会比父类更加强大不仅可以得到父类提供属性和行为而且子类自身也可以继续定义属性和行为在开发中多是以子类作为创建对象依据来进行操作在中所有类与类之间关系都是单一继承一个子类只能有一个直接父类例如这种定义在中不被允许的父类父类或者或者都是错误语法中一个类是不允许直接继承多个父类的即多继承虽然中类不存在多继承的这种效果但是中类允间接继承多重或多层继承例如语法说明类是父类对于类而言是类父类是的子类对于类而言是类父类是的子类因为类是继承与类而类是继承与类所有类是的间接父类也是类间接子类通俗的看待类就是爷爷类就父亲类就是孙子其实你在中所有开发了类基本上都是继承关系类也会存在间接继承的问题中提供了一个超级根类所有的类都是直接或间接的继承于每当在项目中创建一个类的时候此时都是隐式的继承与这个类例如定义了一个类虽然表面上看着就是一个类但是实际上它是等价于中是没有多继承那么如果编写代码时明确继承与某一个类那么会发生什么明确继承之后原有继承类操作就会被覆盖提供给父类继承形成间接继承效果只要提供一个类都是要继承与类的就选明确继承了某个类但是父类也是要继承与类所以类都是直接或间接继承与先写父类还是先写子类一般的在开发时都会对你开发程序予以设计这个设计中就会确定父类与子类只需要通过这设计方案提供父类与子类实现就可以完成操作在开发中发现某些类之间存在一些联系和一些固定属性和行为可以二次封装出父类个人开发建议尽量根据需求分析出是否存在父类如果存在就提供实现如果不存在就正常开发就可以好处和特点好处实现代码的复用避免代码的冗余特点子类继承父类子类可以继承父类中的属性和方法子类可以拥有自己独有的属性和方法单继承即在中一个子类只能继承一个父类但一个父类可以拥有多个子类多重继承即一个父类还可以继承另外一个类中最大的父类的是如果一个类没有显示的写出那么这个继承类不能被继承情况使用修饰的属性和方法不能被子类继承构造方法不能被继承构造方法是用来创建类的对象父类中使用默认的修饰符的修饰的属性和方法在不同包的子类中不能被继承以继承角度完成练习贵妇从宠物店购买了宠物狗宠物猫某天家里举行聚会向朋友介绍起自家豢养的宠物的情形训练提示设计宠物狗类属性有个姓名性别年龄品种行为吃睡觉设计宠物狗类属性有个姓名性别年龄品种行为吃卖萌设计贵妇类属性有姓名思考是有可以将狗和猫作为贵妇的属性存在如果作为属性那么如何在贵妇中提供方法介绍自己的从宠物狗和宠物猫父类宠物类这个类中提供宠物狗和宠物猫共有属性和行为共有属性姓名性别年龄品种在代码中可以利用编译器快捷的生成构造方法和快捷键帮组我们生成需要构造方法和所有宠物中都有一个吃的行为正在吃宠物猫类无需再中在定义属性和吃行为因为继承所以子类可以得到属性和行为吃饱之后正在卖萌宠物狗子类无需再中在定义属性和吃行为因为继承所以子类可以得到属性和行为提供一个咬人行为即可吃饱之后正准备咬人贵妇类在一个类中使用另外一个类属性和行为时如何处理第一种在使用类中将另外一个类作为本类属性存在好处因为是属性所以在整个类中和类外都可以访问操作使用范围广泛坏处需要满足一些客观现实规律第二种在使用类中提供一个方法一般是成员方法将另外一个类作为本方法的参数定义使用好处可以不用受到一些客观现实规律约束坏处使用范围仅限于方法的内部在其他位置无法使用提供两个行为介绍宠物猫和宠物狗是一个类类型引用类型在方法中对应的类再把出来的对象名传进来这里就相当于猫的名字猫的性别猫的年龄猫的品种这个方法在类中并无定义是从父类继承而来猫的名字猫的性别猫的年龄猫的品种这个方法在类中并无定义是从父类继承而来测试小花母美短小白公柯基这里就把对应的对象名引用类型传过去这里就把对应的对象名引用类型传过去问题子类中如果需要对属性初始化如何提供构造方法想在创建子类的同时就完成对属性初始化操作如何完成父类中提供了一个吃的方法但是狗与猫之间吃的东西是不同的需要在狗类中描述狗吃肉需要在猫类中描述猫吃鱼父类提供的方法实现就不能满足子类需求了子类如何处理继承而来方法不能满足子类需求关键字定义关键字它只能在子类中使用并且关键字相当于是提供一个父类的引用关键字一共有三个功能在子类可以通过关键字调用父类提供成员变量父类定义成员变量名在子类可以通过关键字调用父类提供成员方法父类定义成员方法名参数赋值这个操作是最主要的途径在子类的构造方法中调用父类的构造方法来进行属性初始化调用就是父类无参构造方法参数赋值调用父类的有参构造方法必须在子类构造方法的第一句作用调用父类的属性如果当子类和父类中没有重名属性时那么和关键字表示的属性是一致的都是调用父类的如果当子类和父类中有重名属性时那么属性名表示父类的属性属性名表示子类的属性调用父类的方法如果当子类和父类中没有重名方法时那么和关键字表示的方法是一致的都是调用父类的如果当子类和父类中有重名方法时那么方法名表示父类的方法方法名表示子类的方法调用父类的构造方法注意创建子类对象之前必须要先创建父类的对象调用的是父类的无参构造是可以完全省略的省不省略都会执行建议保留父类的无参构造调用父类的有参构造要放到构造方法第一行和不能同时出现父类提供构造方法提供和方法子类子类继承父类之后可以得到父类中所有的可见属性和行为非子类还可以提供自己独有属性和行为发生继承之后子类是不可以继承父类构造方法所以子类需要提供自己的构造方法子类依旧要提供有参和无参构造方法子类的有参构造方法如何提供子类的构造方法一般会将从父类得到属性和子类的属性都进行创建对象初始化所以建议在子类构造方法中提供父类得到属性和子类的属性同一操作如何对父类初始化呢使用父类中提供方法对父类属性初始化问题在于如果属性过多子类构造方法就要大量调用方法此时就可以使用关键字调用父类的构造方法来辅助子类初始化继承属性调用无参构造方法调用父类的有参构造方法非常推荐使用这种方式进行属性初始化操作简便易懂其他开发人员如何查看你编写代码发现这个构造方法时就可以知道那些属性是父类提供关键字初始化那些属性是子类提供使用成员方法调用父类中属性调用父类中成员方法总结关键字在子类中最大作用就是调用父类的构造方法辅助子类完成属性初始化关键字与关键字的不同关键字可以使用在任何类中并且可以作为方法参数传递关键字只能使用在子类中并且不可以作为方法参数传递关键字代表的是当前对象关键字代表的是父类对象的引用方法重写定义当父类提供成员方法实现无法满足子类需求时子类可以在本类中提供父类成员方法重新实现的操作子类中有与父类相同签名的方法称之为方法重写相同签名方法名相同参数相同返回值相同访问修饰符子类要比父类更宽泛看上面表格应用因为父类的方法无法满足子类的需求所以需要重写父类的方法子类方法重写的格式子类中出现重写父类方法操作是父类方法如何定义子类方法就如何定义只是子类将原有方法的实现重新完成重写方法名回车一旦子类发生重写父类方法之后外界在调用方法必然执行子类重写之后的方法无法在调用到父类原有方法非要看到父类方法的原有实现外界方式实现即在子类外部查看提供父类对象创建并使用父类对象调用方法极少使用内界方法实现即在子类内部查看使用关键字调用父类原有方法即可注解建议在重写方法的时候加上注解作用检测是否是满足方法重写必须满足重写的要求否则报错注意父类中的是私有方法子类无法重写私有方法不能被继承所以不能被重写需求创建一个父类鸟类父类就提供一个方法在创建两个子类麻雀类和鸵鸟类父类鸟类提供一个飞翔方法可以飞翔子类麻雀子类可以得到父类提供公有方法子类鸵鸟子类可以得到父类提供公有方法提供对父类方法重写操作最简单的原则父类方法如何定义子类重写时就如何定义只要提供不同的实现即可这就是当前子类重写父类方法的操作定义注解作用就是提供给编译器说明子类有重写父类方法这种方式就可以调用到父类方法的原有实现只需要在这个方法中提供子类自己实现方式即可重写我不会飞但是跑的很快测试麻雀可以飞翔是没问题的但是鸵鸟是不会飞的所以如果鸵鸟这个对象调用方法打印出可以可以飞翔和明显不符合要求的触发了一个原则父类提供方法无法满足子类需求子类可以重写父类方法子类一旦重写父类方法之后在调用方法必然是子类重写之后的实现啊重写完成要求若父类的方法使用或修饰中任意一个修饰符修饰那么子类都不可以重写这个方法重写方法必须所有继承关系没有继承关系两个类是不可以重写对方方法重写成员成员方法方法签名必须相同方法签名方法名参数列表子类重写父类方法是提供原有父类方法返回值类型的子类类型或同类型在重写时子类提供方法访问权限修饰符要大于等于父类的方法权限修饰符在重写时父类的方法提供异常类抛出子类提供异常类型必须相同类型或子类类型方法重载与方法重写的区别位置方法名返回值类型参数列表访问修饰符方法重载本类一致无关不一致无关方法重写子类一致一致一致子类更宽继承中子类实例化过程在中继承实例化过程是遵守现实客观规律现实生活中一定是先有你父亲再有你父类父类的无参构造方法调用父类的有参构造方法调用子类提供子类构造方法子类的无参构造按方法被调用使用方法对进行子类的有参构造方法被调用测试分别使用子类的无参和有参构造方法创建对象发生子类继承父类之后在创建子类对象过程时是先调用父类无参构造方法然后再调用子类的构造方法创建对象先创建父类的对象在创建子类对象继承之后子类的实例化过程子类的构造方法中会默认调用父类无参构造方法所以父类要提供无参构造方法让子类只可以正确的创建对象某些情况下缺失父类忘记了提供无参构造方法但是提供其他的构造方法是否可以辅助子类构造对象呢可以如果父类没有明确提供无参构造方法但是提供其他的有参构造方法子类只需要在本类中构造方法位置明确调用父类的构造方法即可使用关键字子类实例化完整说明子类在继承父类之后子类中提供构造方法是默认调用父类无参构造方法来辅助创建对象若父类没有明确提供无参构造方法可以使用关键调用父类其他的构造方法在子类构造方法中辅助创建对象所以子类对象创建一定是先创建父类对象在创建子类对象子类继承父类之后内存存储继承体系内存图原理父类的空间优于子类对象产生在每次创建子类对象时先初始化父类空间在创建其子类对象本身目的在与子类对象中包含了其对应的父类空间便可以包含父类的成员如果父类成员非修饰则子类可以随意使用父类成员代码体现在子类的构造方法调用时是默认调用父类无参构造方法的当子类调用方法的原则时优先扫描子类中是否存在当前方法定义和重写的如果子类存在这方法就调用子类方法如果子类不存在次方法到调用父类方法如果子类中出现与父类中重名属性是不存在属性重写概念对象执行调用时优先扫描子类中所存在属性如果子类定义类就获取子类属性如果子类中没有扫描父类中继承而来属性多态定义多态在中定义原则同一个事物被不同对象所触发得到结果不同就称之为多态在生活中比如跑的动作小猫小狗和大象跑去起来都是不一样的再比如飞的动作昆虫鸟和飞机飞起来也是不一样的所以可见同一个行为通过不同事物可以体现出不同的行为这就是多态的描述在现实生活中家里饲养了一些宠物养了宠物狗叫声汪汪汪养了宠物猫叫声喵喵喵在中将多态体现在代码中行为有哪些方法多态方法多态的体现就是重载同一个方法被不同参数所触发得到方法的结果不同就是方法多态对象多态同一个方法对不同对象触发可以得到不用表现形式发生对象多态有一个必要前提必须存在继承或实现关系需要有子类重写方法的实现可以让多态先更加完善对象多态中对于我们开发而言最主要的就是里氏代转换原则通过这个原则可以发挥多态最大效力里氏代转换原则里氏代转换原则在程序最主要体现就是提供了子类与父类之间的转换操作这里这个操作就可以动态概念改变当前对象从而满足不同开发需求如果要体现里氏代转换原则是有一个必要前提需要存在继承或实现关系即类与类之间必须是继承关系类与接口之间是实现关系没有任何联系的类是无法完成这个操作例如类和类这两两个类都是独立的那么类和了就不能完成里氏代转换原则特点编译看左边运行看右边如果发生多态那么无法调用子类独有的方法编译看左边左边是父类如果发生多态那么调用的一定是子类重写的方法运行看右边多态产生条件必须要有继承必须要有方法重写必须要父类的引用指向子类的对象向上向下转型向上转型父类引用指向子类对象语法父类类型对象名字子类类型此时这个类子类就会被默认提升为父类类型当前对象只能调用父类中提供属性和行为无法调用子类中提供自有属性和行为这也是开发中唯一创建父类对象一种方式不会使用父类直接创建对象即父类类型对象名父类类型向下转型将父类引用强转成子类类型语法子类类型对象名子类类型提升为父类类型对象此时这个对象就会被转换为原来子类类型当前对象即可以调用父类中提供可见属性和行为也可以调用子类自有属性和行为如果发生多态那么无法调用子类独有的方法如果要调用子类独有的方法那么必须发生向下转型前提是先发生过向上转型否则会报错关键字可以利用这个关键字检查提升之后对象是否是某一个子类类型对象即当前提升之后对象是否属于某个子类类型语法提升之后对象子类类型上面这个表达式就会帮组你判断提升之后对象是否属于但当前提供子类类型返回值为证明当前对象是由当前子类类型提升而来证明当前对象不是当前子类类型提升而来父类动物类子类狗类子类猫类测试提供对象向上转型父类引用可以接收一个子类的引用此时会将类型对象提升为父类类型此时只能调用父类中属性和行为不能调用子类自己属性和行为如果子类重写父类的方法提升之后对象调用方法执行时依旧执行子类重写效果方法是子类自身的并不是父类的提供对象向下转型将一个提升为父类类型对象转换为原有子类类型操作就叫做对象向下转型此时会将提升之后父类对象转换为原有子类类型转型之后不仅可以调用子类的属性和方法而且也可以调用父类属性和方法对象向下转型会存在一个问题如果转型失败会出现一个异常问题而这个问题不会在编译阶段进行提示只能在运行时提示此时明显是类型提升的并不是所以这个操作是有问题但是编译阶段是不会提示错误系统就会提示强制类型转换异常所以为了避免这个问题发生可以使用这个关键字进行转换对象判断判断对象是否是类型对象是不是不是类型无法进行对象向下转型综上所述在进行对象向下转型时为了保证对象可以正确转换到对应子类类型中建议使用关键字进行对象子类类型检查在进行检查时会配合语句使用如果检查成功就会在语句执行代码中进行向下转型操作使用仅限在大括号内部提高范围使用就建议将对象声明定义在语句外部在实际开发如果你能确定子类类型是什么那么就不写操作以上这些就是多态的一些操作点和概念多态主要就是提供可扩展和可维护性好处就可以利用多态让方法使用起来更加高效子类类型都可以可以辅助抽象类和接口创建对象弊端在于如果利用父类作为方法参数类型或返回值类型的时候返回和接受的属性都会被向上转型为父类类型子类的自己的属性和方法就不能调用这样会牺牲一部分灵活性如何弥补就是向下转型多态的引用场景方法的参数方法的返回值例设计一个员工类其中有计算员工薪水方法根据不同的员工计算薪水的方法不同员工类型薪水构成经理底薪奖金销售人员底薪提成普通员工底薪补贴设计一个测试类场景如下年终领导找员工谈话让员工介绍介绍自己的薪水分析在公司除了老板都是员工经理销售普通员工都是员工既然这三者经理销售普通员工都是员工可以根据他们共有属性和行为提供一个统一父类分别在使用这三者经理销售普通员工进行与父类至今继承关系从而到需要属性和行为设一个方法年终领导让员工介绍自己如果没有多态之前三个员工就需要提供是三个自我介绍方法公司员工暴增人又到一年年末自我介绍提供个方法方法管理与维护都是十分麻烦此时可以将方法提供为最大通用性只提供一个方法进行员工介绍利用多态的特点将参数设计为父类类型这样一来只要继承父类员工类都可以进入到这个方法中进行执行操作员工父类提供共有的属性和行为底薪员工姓名经理普通员工和销售都有自己计算薪水方法父类中提供一个方法让子类来进行重写操作因为这个方法必然被子类重写所以就不提供具体实现由子类自己进行重写操作子类经理类提供介绍字节薪水的方式是经理底薪奖金综合工资子类销售类提供介绍字节薪水的方式是销售底薪奖金综合工资子类普通员工类提供介绍字节薪水的方式是普通员工底薪奖金综合工资测试类进行员工信息测试操作提供老板经理销售和普通员工对象进行操作张三大宝李四普通实现利用多态的对象向上转型操作方法中参数是父类类型他可以接收当前这个父类类型的所有子类引用此时方法参数类型是父类类型参数赋值是子类类型所以参数赋值时就形成了即张三在不使用多态的前提下如果不使用多态就会面临一个问题如果员工个数增加了这里就需要添加多个方法随着员工增加与删减这样我们方法所在类就会被进行频繁的修改这样并不利于方法管理与维护多态的就出现了可以利用多态的特点将多态进行方法参数或返回值类型设置这样就可以提高代码的通用性和重用性此时并不需要设置多个方法只需要提供一个方法方法参数设置为父类类型利用多态中对象向上转型操作就可以得到具体实现知识点十三个修饰符关键字含义抽象的抽象类含义被修饰的类称之为抽象类特点抽象类不能直接创建对象即不能通过抽象类类名的方式完成因为抽象类中会存在抽象方法这个抽象方法没有方法体如果抽象类可以使用抽象类类名的方式完成那么抽象类和抽象方法就没有存在的意义了抽象类中是可以选择性包含抽象方法的如果包含了抽象方法的抽象类被子类继承时子类需要重写抽象父类中抽象方法其他的成员方法也可以选择性重写如果没有包含抽象方法的抽象类被子类继承时子类可以选择性重写其他方法抽象类提供目的是为了保证父类的完成操作的前提下让父类具备一些其他功能抽象方法和防止直接创建对象所以抽象类需要提供构造方法抽象类的提供就是为了让子类继承而提供的所以抽象类是允许多态概念的使用作用抽象类定义方式其实就是父类的定义方法会在抽象类中提供所有父类的操作抽象类在类中主要的作用就是作为父类存在抽象类就是一个特殊父类语法格式类名这个类就是抽象类父类如何定义抽象类的内部就如何定义成员变量构造方法成员方法静态变量静态方法方法重写抽象方法抽象类就是多了一个关键字的父类建议在以后开发中如果确定这个类是一个父类就建议优先声明成抽象类抽象类可以像普通类一样使用可以继承可以实现可以定义类中所有定义的东西但是就是不允许直接创建抽象类对象即抽象类类名对象抽象类类名抽象类是它支持多态创建抽象类葵花宝典抽象方法含义使用关键字修饰并且没有方法体存在在抽象类中叫做抽象方法特点抽象方法必须出现在抽象类中抽象方法不能有方法体方法的实现并且在小括号后面添加抽象方法必须要在非抽象子类中重写抽象方法修饰符不能使用和只要使用这三个修饰符这个方法就无法在进行重写实现了所以就失去抽象方法的目的了抽象方法的格式返回值类型方法名参数列表抽象类和抽象方法什么时候用抽象类我们一般用比较少未来更多是使用接口在接口中全部都是抽象方法抽象方法的作用就是为了让子类去重写练习设计一个公司抽象类具有抽象方法营业休息设计一个快递公司类作为公司类的子类设计一个顺丰快递类作为快递类的子类需求实例化一个顺丰快递的对象从控制台录入一个以内的数据如果数据在点之间顺丰营业否则顺丰快递公司休息提供一个公司的抽象类营业的抽象方法休息的抽象方法快递公司在需求中并没有做任何特殊说明此时可以将这个类作为一个抽象类使用一个抽象类继承与另外一个抽象类当前这个抽象子类可以选择性实现或者不实现抽象父类中抽象方法不是先父类抽象方法原因是因为这个也是抽象类也可以存储抽象方法所以抽象子类可以选择性实现抽象方法顺丰快递公司子类如果使用一个普通类继承与抽象类必须实现抽象类中所提供抽象方法正在营业欢迎光临下班休息下次再来类测试类请输入时间顺丰快递关键字含义静态的作用修饰成员变量成员方法成员变量代码块内部类静态和成员之间的区别修饰成员变量当关键字修饰成员变量时该变量被称为静态变量类变量该类的每个对象都对这个变量是共享的状态任何对象都可以改变静态变量中存储的数据改变之后其他对象将修改之后值但可以在不创建该类对象化的前提下操作这个静态变量这个才是正确操作方式当关键字修饰成员变量时该变量被称为静态变量类变量该类的每个对象都对这个变量是共享的状态任何对象都可以改变静态变量中存储的数据改变之后其他对象将修改之后值但可以在不创建该类对象化的前提下操作这个静态变量这个才是正确操作方式定义方式访问权限修饰符数据类型变量名访问方式不推荐方式对象静态变量名推荐方式如果是在当前类中访问本类的静态变量静态变量名如果是在其他类中访问类的静态变量类名静态变量名演示案例提供两个变量一个成员变量和静态变量在不同类中访问静态变量静态变量是存在默认值所有静态变量存储在类所创建对象都是共享这个静态变量张三可以通过对象静态变量方式访问静态变量的但是推荐推荐提示的警告信息不建议的中国这个对象的国籍修饰成员方法被修饰成员方法被称之为静态方法类方法该静态方法可以使用类名直接调用语法访问权限修饰符返回值类型方法名参数列表执行语句访问方式不推荐方式对象静态方法名字参数赋值推荐方式如果在同一个类中访问本类定义静态方法时静态方法名字参数赋值如果在其他类中访问类中静态方法是类名静态方法名字参数赋值静态方法被使用时注意事项静态方法中不允许出现关键字静态方法中只能直接访问静态变量和其他的静态方法静态方法中是不可以直接访问成员变量和成员方法如果在静态方法中访问成员变量或成员方法需要创建当前类的对象通过对象才可以访问案例演示演示类中静态方法提供成员变量和成员方法在成员方法中访问成员变量和成员方法还有静态变量和静态方法注释的原则是防止死递归可以使用和关键字提供静态变量和静态方法在静态方法中访问成员变量和成员方法还有静态变量和静态方法注释的原则是防止死递归在静态方法中是不可以直接访问成员变量和方法不可以使用和关键字如果要访问成员变量和成员方法那么就必须创建对象静态代码块含义可以用于修饰代码块称之为静态代码块代码块指的是在程序中出现的一个代码片段直接使用包裹静态代码块指的是用修饰的代码块特点静态代码块在类加载的时候自动执行无需手动调用代码块会按照先后顺序一次执行优先于代码块构造方法执行静态代码块只会在类加载的时候执行一次初始化的时候使用利用修饰代码块来执行一些耗时的操作优先执行类加载的触发时机创建类的对象时候创建子类对象的时候先要创建其父类对象在调用类中的静态属性和静态方法的时候类中提供的静态方法方法的时候放射无参构造方法静态代码块在普通类定义操作的时候是很少使用静态的方式来完成在有开发项目中通常会需要使用到一些全局变量和全局方法这些全局变量和全局方法会被单独定义在一个类中并且都使用进行修饰可以访问外界直接对变量和方法访问这样类叫做工具类在创建工具类需要提供一个包包中提供工具类的名字或像就是一个工具类工具类的特点是类中变量必须是修饰静态变量类中方法必须是修饰静态方法而且这个类不提供对象创建这样类就是工具类关键字含义不可变不可改变最终不可以修改修饰关键字主要可以用途修饰类变量和方法作用修饰的类特点使用修饰的类不能被继承太监类修饰的方法特点使用修饰的方法不能被重写但是可以被继承修饰的属性称之为常量特点常量必须要赋值常量的最后赋值时机非静态常量没有修饰的直接赋值在代码块中赋值在构造方法中赋值注意如果一个类有多个构造方法那么必须在每一个构造方法中赋值静态常量使用修饰的直接赋值在静态代码块中赋值常量不能修改基本类型值不能改变引用类型地址不能改变使用修饰符修饰局部变量局部变量是定义在方法内部变量就是局部变量使用关键字修饰局部变量修饰变量同时并赋值此时就会定义常量不可以被修改语法数据类型变量名这个变量名要大写代表是常量值错误提示不能修改使用修饰修饰变量先定义在赋值只能赋值一次数据类型变量名这个变量名要大写代表是常量变量名这个变量名要大写代表是常量值的错误提示不允许进行二次赋值使用修饰符修饰成员变量和静态变量当使用修饰符修饰完毕之后就会形成常量不允许再次修改存储数据修饰成员变量使用修饰符修饰成员变量错误提示信息不允许修改这个值修饰静态变量这个中修饰方式是比较常见在一些工具类中或者正常类中定义一个不可以改变量并且所有对象共享就可以使用这种方式修饰静态变量会变成静态常量一共有两种创建于赋值方式先定义在使用静态代码块进行赋值操作字符串使用关键字修饰成员方法使用关键字修饰成员方法此时这个方法会变成最终方法此方法不可以被子类重写但是子类可以继承关键字修饰成员方法的时机父类只提供方法继承但是不允许子类重写就可以使用关键字定义一个修饰的方法子类只能继承不能重写的错误提示信息提示这个方式使用修饰无法重写但是允许继承',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-16 17:46:42',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"><link rel="alternate" href="/atom.xml" title="星仔人生录" type="application/atom+xml">
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://img.picgo.net/2024/08/19/4b247c9cf52c5a9f23c6008ffd35b2387faa57d2ad36eca2.png"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">星仔人生录</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 百宝箱</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://link3.cc/xinzai_x"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 个人资源</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/32%E5%8D%95%E7%89%87%E6%9C%BA/" style="font-size: 1.05rem;">32单片机<sup>12</sup></a><a href="/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/" style="font-size: 1.05rem;">51单片机<sup>9</sup></a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 1.05rem;">C语言<sup>13</sup></a><a href="/tags/GitHub-Picgo%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/" style="font-size: 1.05rem;">GitHub+Picgo图片上传<sup>1</sup></a><a href="/tags/GitHub%E5%90%8C%E6%AD%A5gitee%E5%B9%B6%E9%83%A8%E7%BD%B2/" style="font-size: 1.05rem;">GitHub同步gitee并部署<sup>1</sup></a><a href="/tags/IDE%E4%B8%8EMX%E5%BA%93%E6%96%87%E4%BB%B6%E5%AE%89%E8%A3%85%E8%B7%AF%E5%BE%84%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AE%BE%E7%BD%AE/" style="font-size: 1.05rem;">IDE与MX库文件安装路径自定义设置<sup>1</sup></a><a href="/tags/Java%E8%AF%AD%E8%A8%80/" style="font-size: 1.05rem;">Java语言<sup>26</sup></a><a href="/tags/ST-LINK%E6%9C%AA%E8%83%BD%E4%B8%B2%E5%8F%A3keil%E8%AF%86%E5%88%AB%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" style="font-size: 1.05rem;">ST-LINK未能串口keil识别解决方案<sup>1</sup></a><a href="/tags/STM32CubeIDE%E4%BB%A3%E7%A0%81%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8F/" style="font-size: 1.05rem;">STM32CubeIDE代码字体大小<sup>1</sup></a><a href="/tags/office%E6%97%A0%E6%B3%95%E5%88%9D%E5%A7%8B%E5%8C%96VisualBasic/" style="font-size: 1.05rem;">office无法初始化VisualBasic<sup>1</sup></a><a href="/tags/win10%E6%A1%8C%E9%9D%A2%E5%9B%BE%E6%A0%87%E5%8F%98%E7%99%BD/" style="font-size: 1.05rem;">win10桌面图标变白<sup>1</sup></a><a href="/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/" style="font-size: 1.05rem;">个人博客迁移<sup>1</sup></a><a href="/tags/%E4%BA%91%E5%9B%BE%E5%BA%8A/" style="font-size: 1.05rem;">云图床<sup>1</sup></a><a href="/tags/%E5%8A%A0%E9%80%9Fgithub%E5%8D%9A%E5%AE%A2%E8%AE%BF%E9%97%AE/" style="font-size: 1.05rem;">加速github博客访问<sup>1</sup></a><a href="/tags/%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/" style="font-size: 1.05rem;">博客使用手册<sup>1</sup></a><a href="/tags/%E5%8D%9A%E5%AE%A2%E5%8A%A0%E9%80%9F%E5%9B%BE%E5%BA%8A/" style="font-size: 1.05rem;">博客加速图床<sup>1</sup></a><a href="/tags/%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/" style="font-size: 1.05rem;">图片压缩在线工具<sup>1</sup></a><a href="/tags/%E5%B0%8F%E7%8B%BC%E6%AF%AB%E8%BE%93%E5%85%A5%E6%B3%95/" style="font-size: 1.05rem;">小狼毫输入法<sup>1</sup></a><a href="/tags/%E6%8F%92%E4%BB%B6/" style="font-size: 1.05rem;">插件<sup>1</sup></a><a href="/tags/%E6%94%BF%E6%B2%BB/" style="font-size: 1.05rem;">政治<sup>14</sup></a><a href="/tags/%E8%A7%A3%E5%86%B3443%E7%AB%AF%E5%8F%A3%E8%A2%ABvmware%E5%8D%A0%E7%94%A8/" style="font-size: 1.05rem;">解决443端口被vmware占用<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%9F%BA%E7%A1%80/" style="font-size: 1.05rem;">计算机程序与基础<sup>1</sup></a><a href="/tags/%E8%B5%84%E6%BA%90%E6%90%9C%E7%B4%A2/" style="font-size: 1.05rem;">资源搜索<sup>1</sup></a><a href="/tags/%E9%AD%94%E6%B3%95/" style="font-size: 1.05rem;">魔法<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/08/"><span class="card-archive-list-date">八月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">24</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">8</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/03/"><span class="card-archive-list-date">三月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/02/"><span class="card-archive-list-date">二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/01/"><span class="card-archive-list-date">一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">十二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">54</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E8%AF%AD%E8%A8%80/" itemprop="url">Java语言</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/Java%E8%AF%AD%E8%A8%80/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>Java语言</span></a></span></div></div><h1 class="post-title" itemprop="name headline">17.面向对象</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-12-30T05:06:59.000Z" title="发表于 2023-12-30 13:06:59">2023-12-30</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-08-16T09:46:42.055Z" title="更新于 2024-08-16 17:46:42">2024-08-16</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为揭阳"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>揭阳</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402292029940.WebP"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/post/76fa8c0d.html"><header><a class="post-meta-categories" href="/categories/Java%E8%AF%AD%E8%A8%80/" itemprop="url">Java语言</a><a href="/tags/Java%E8%AF%AD%E8%A8%80/" tabindex="-1" itemprop="url">Java语言</a><h1 id="CrawlerTitle" itemprop="name headline">17.面向对象</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">星仔</span><time itemprop="dateCreated datePublished" datetime="2023-12-30T05:06:59.000Z" title="发表于 2023-12-30 13:06:59">2023-12-30</time><time itemprop="dateCreated datePublished" datetime="2024-08-16T09:46:42.055Z" title="更新于 2024-08-16 17:46:42">2024-08-16</time></header><h1 id="知识点一：面向对象的编程思想"><a href="#知识点一：面向对象的编程思想" class="headerlink" title="知识点一：面向对象的编程思想"></a><center>知识点一：面向对象的编程思想</center></h1><p>面向对象程序设计(Object Oriented Programming) </p>
<p>什么是编程思想？</p>
<p>思想：其实思想就是你大脑中对某些事务的思维，通过思维完成这些事务</p>
<p>编程思想：就是你大脑中对代码中需要完成思维逻辑所提供一种思维，编程思想就是编程思路</p>
<p>在开发中我们接触比较经典编程思想一种面向过程和一种面向对象</p>
<p>PS：面向对象编程思想是从面向过程转变而来，所以面向对象中也会掺杂着面向过程</p>
<p>面向过程的编程思想：</p>
<p>强调的是过程，必须清楚每一个步骤，然后按照步骤一步一步去实现</p>
<p>面向对象的编程思想：</p>
<p>强调的是对象，通过调用对象的行为来实现功能，从而完成需求，面向对象并不是我们自己一步一步去操作实现</p>
<p>举例对比说明：</p>
<p>同样是处理洗衣服事物</p>
<p>&ensp;&ensp;&ensp;&ensp;面向过程角度而言：把衣服脱下来 –》找一个盆–》放点洗衣粉–》加点水–》浸泡10分钟–》揉一揉–》清洗衣服–》拧干–》晾起来</p>
<p>&ensp;&ensp;&ensp;&ensp;面向对象角度而言：把衣服托脱下来 –》找一个对象【女朋友&#x2F;男朋友】让他去完成【洗】</p>
<p>同样是要吃饭</p>
<p>&ensp;&ensp;&ensp;&ensp;面向过程角度而言：买菜–》洗菜–》炒菜–》吃</p>
<p>&ensp;&ensp;&ensp;&ensp;面向对象角度而言：找一个饭店&#x2F;点一份外卖 –》 付钱</p>
<p>从Java程序角度来思考：需求：打印数组中存储数据，打印格式为[元素1，元素2，元素3，….]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">printArray</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.先提供一个数据</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">67</span>&#125;;</span><br><span class="line">        <span class="comment">//以面相过程的角度而言，一步一步进行打印操作</span></span><br><span class="line">        System.out.print(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span> ; i&lt;arr.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i != arr.length-<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(arr[i]+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(arr[i]+<span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//以面向对象角度而言，只需要找到可以打印数组数据对象即可</span></span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>&ensp;&ensp;&ensp;&ensp;无论是面向过程还是面向对象都是一种编程思想【就是你编写代码的思维逻辑】，区别在于</p>
<p>&ensp;&ensp;&ensp;&ensp;面向过程：注重的是步骤，必须清楚每一个步骤，按照步骤一步一步去实现</p>
<p>&ensp;&ensp;&ensp;&ensp;面向对象：注重的是对象，无需清楚每一个步骤，只需要使用对象调用行为来完成需求即可</p>
<p>&ensp;&ensp;&ensp;&ensp;面向过程在之前学习知识点时候就已经慢慢的在学习使用，面向对象的这个编程思想，如何在代码中体现，如何在代码中写出自己的面向对象思想？—》如<strong>果在代码中要体现面向对象编程思想，需要提供类和对象，通过类对对象进行描述，在通过对象完成思维逻辑</strong></p>
<h1 id="知识点二：类和对象的概述"><a href="#知识点二：类和对象的概述" class="headerlink" title="知识点二：类和对象的概述"></a><center>知识点二：类和对象的概述</center></h1><h2 id="类的概述"><a href="#类的概述" class="headerlink" title="类的概述"></a><center>类的概述</center></h2><p>什么是类？</p>
<p>&ensp;&ensp;&ensp;&ensp;类是用来描述一类具有共同属性和行为事物的统称，所以其实类在客观现实世界中是不存在，是</p>
<p>抽象的，只是用来描述信息</p>
<p>例如：</p>
<p>&ensp;&ensp;&ensp;&ensp;人类 —》 描述人的 狗类 —》描述狗 手机类—》描述手机 动物类 —》 描述动物类提供描述使用的，这个描述要是共有属性和行为统称在一起—》称为类</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271923636.WebP" alt="类举例" style="zoom:33%;">

<p>上图中所表述意义在于，每一个单独个体具备共有属性和行为，抽取出来，形成一个描述，这个描述就是就类， 上图中描述就是人类</p>
<p>属性和行为？</p>
<p>&ensp;&ensp;&ensp;&ensp;属性： 就是该事物的状态信息 –》人类：身高、体重、年龄、性别等等</p>
<p>&ensp;&ensp;&ensp;&ensp;行为：就是该事物能够做什么 –》 人类：说话、吃、喝、睡觉等等</p>
<p>总结：</p>
<p>&ensp;&ensp;&ensp;&ensp;需要将现实生活中描述类的操作转变为代码在编程中进行体现，，明确类是用来描述一群具有共</p>
<p>同属性和行为事物的统称，类是一个抽象的，看不见，摸不着，用来描述信息的操作</p>
<p>类的组成：</p>
<p>&ensp;&ensp;&ensp;&ensp;属性 —》 成员变量</p>
<p>&ensp;&ensp;&ensp;&ensp;行为 —》 成员方法</p>
<p>成员变量是什么？</p>
<p>&ensp;&ensp;&ensp;&ensp;它就是定义在类中用来描述现实生活中属性的，在代码中体现就是定义变量</p>
<p>成员方法是什么？</p>
<p>&ensp;&ensp;&ensp;&ensp;方法其实就是对某些事物的处理途径，将某些处理事物的代码放置到一个大括号中，然后对这个大括号起一个名字，外界只需要使用这个名字就要可以完成对事物的操作</p>
<p>&ensp;&ensp;&ensp;&ensp;方法就是对你实现功能代码进行一个封装操作，外界只需要调用方法名就可以完成处理事物逻辑</p>
<p>PS：在某些语言中将方法称之为函数，但是在Java中我们建议称之为方法，只有面向过程语言才称之为函数，而Java是面向对象语言称之为方法</p>
<p>只要在代码中定义一个类，并在类中提供属性和行为就可以进行现实生活中事物的描述</p>
<p>PS：成员方法就是不使用static进行修饰的方法类具备的操作就是描述操作，并不具备具体处理事物的能力，就需要将类具现化出来，所以提供对象来具现化类</p>
<h2 id="对象的概述"><a href="#对象的概述" class="headerlink" title="对象的概述"></a><center>对象的概述</center></h2><p>对象是类的一个实例【具体存在的例子】，具体存在的，看得见的摸得着，并且具备该类事物的属性和行为</p>
<p>对象的属性：对象的属性具有特定值</p>
<p>对象的行为：对象可以操作的行为</p>
<p>人类： 人的描述</p>
<p>&ensp;&ensp;&ensp;&ensp;提供对象进行具体的体现： 班班老师</p>
<p>狗类：狗的描述</p>
<p>&ensp;&ensp;&ensp;&ensp;提供对象进行具体的体现： 柯基狗狗</p>
<p>手机类：描述手机</p>
<p>&ensp;&ensp;&ensp;&ensp;提供对象进行具体的体现：华为手机</p>
<p>举例：</p>
<p>&ensp;&ensp;&ensp;&ensp;对象：你手上手机</p>
<p>&ensp;&ensp;&ensp;&ensp;属性: 华为，19999， 4核CPU ，256G内存 1TB存储空间 支持10G</p>
<p>&ensp;&ensp;&ensp;&ensp;对象属性就是具体的值，因为类描述的时候属性是没有具体数据值</p>
<p>&ensp;&ensp;&ensp;&ensp;行为： 可以打电话，上网，发短信等等。对象可以具体完成哪些操作</p>
<p>总结：</p>
<p>&ensp;&ensp;&ensp;&ensp;对象就是类的实例，具体存在的，看得见摸得着，对象属性具有具体数据值的，对象的行为其实就是可以使用的功能</p>
<p>&ensp;&ensp;&ensp;&ensp;Java中面向对象思想，就是需要你在代码中提供类和对象来完成是现实生活中的思维逻辑，类是对象的操作，对象是类的具现化来完成事物操作过程</p>
<h2 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a><center>类和对象的关系</center></h2><p>类是对一类具有共同属性和行为的事物统称，是抽象的</p>
<p>对象是一类事物的具体是实例，看得见，摸得着，真实存在的实体，是具体的</p>
<p>总结：类是对象的抽象，对象是类的实例化</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271923275.WebP" alt="类和对象的关系" style="zoom:50%;">

<p>总结：</p>
<p>对象是根据类创建出来的，类可以看成是对象的【数据类型】，所以类是Java中引用类型</p>
<p>PS：现如今为止：引用类型：数组、类、Scanner</p>
<p>&ensp;&ensp;&ensp;&ensp;他们所创建出来的空间都是在“堆中的”</p>
<p>类中有什么属性和行为，对象就具备哪些属性和行为，因为类对对象描述</p>
<p>&ensp;&ensp;&ensp;&ensp;现在所说的这些都是概念性的东西，在现实生活中，对象是真实存在，如果要处理某些事物，只需要找到对应对象就可以完成这个事物【面向对象思想】，但是编写代码的程序是不具备这些类和对象，所以我们就需要用过上述这些概念，进行描述与操作</p>
<p>PS：从现在开始完后所有开发使用都是面向对象的思想来进行的，而且面向对象是最符合人类思维的一种途径，现在的编码结构也是以面向对象为切入点进行模块式的开发</p>
<h1 id="知识点三：类、对象"><a href="#知识点三：类、对象" class="headerlink" title="知识点三：类、对象"></a><center>知识点三：类、对象</center></h1><h2 id="1、类的定义"><a href="#1、类的定义" class="headerlink" title="1、类的定义"></a><center>1、类的定义</center></h2><p>类的是描述一群具有共同属性和行为的操作</p>
<p><strong>类的组成</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;属性：该类事物的状态信息，在类中以成员变量形式来体现</p>
<p>&ensp;&ensp;&ensp;&ensp;行为：该类事物有什么功能，在类中提供成员方法来体现</p>
<p>现阶段在定义一个类来，描述事物就需要提供属性和行为即成员变量和成员成方法</p>
<p><strong>类的格式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供描述属性 ---》 属性在类中体现就是【成员变量（PS：就是在类中定义一个变量多个权限修饰符）】</span></span><br><span class="line">    访问权限修饰符 数据类型 变量名;</span><br><span class="line">    <span class="comment">//提供描述行为 ---》 行为在类中体现就是【成员方法（和之前学习方法定义是一样，只不多去掉了static关键字）】</span></span><br><span class="line">    访问权限修饰符 返回值类型 方法名(参数列表)</span><br><span class="line">    &#123;</span><br><span class="line">        执行代码【你要操作什么】</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码演示：需求：定义一个手机类，类名【phone】，类中属性有：品牌（brand）、价格（price）,类中行为有 打电话（call），发短信（sendMessage）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    从现在开始编写面向对象编程思想时候需要注意对创建类就存在分类操作</span></span><br><span class="line"><span class="comment">    在面向对象中类有两个基础分类：</span></span><br><span class="line"><span class="comment">    一个是叫做 “描述类” 这个类主要提供对对象描述使用类【提供描述中所需要定义操作】 </span></span><br><span class="line"><span class="comment">    这个类是不提供 main 方法</span></span><br><span class="line"><span class="comment">    一个是叫做 ”执行类“ 这个类主要数提供面向对象编程实现具体执行操作类，</span></span><br><span class="line"><span class="comment">    这个类会将描述类进行具现化提供对象</span></span><br><span class="line"><span class="comment">    来处理业务逻辑，所以这个类会提供 main 方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//这个phone这个类就是一个描述类，所以不提供main方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        在类中定义属性即成员变量是支持Java中全套的权限修饰符</span></span><br><span class="line"><span class="comment">        现阶段可以使用权限修饰符有 public【公有的】 default/package【默认的(不提供任何全新修饰符书写)】</span></span><br><span class="line"><span class="comment">        PS:因为在写面向对象时，会使用到一个描述操作，此时String类型就比较适合使用</span></span><br><span class="line"><span class="comment">        简单介绍String：String在Java中是一个类是引用类型的代表Java代码中所有字符串对象</span></span><br><span class="line"><span class="comment">        只要在代码中 使用 &quot;&quot; 提供操作 就是String类的对象</span></span><br><span class="line"><span class="comment">        如果成员变量使用String类型如何进行赋值操作</span></span><br><span class="line"><span class="comment">        例如： String brand = &quot;华为&quot;;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//需求：定义一个手机类，类名【phone】，类中属性有：品牌（brand）、价格（price）</span></span><br><span class="line">    <span class="keyword">public</span> String brand; <span class="comment">//这个成员变量就是public权限修饰符</span></span><br><span class="line">    <span class="type">int</span> price; <span class="comment">//这个成员变量就是默认权限修饰符</span></span><br><span class="line">    <span class="comment">// 类中行为有 打电话（call），发短信（sendMessage）</span></span><br><span class="line">    <span class="comment">//这个方法就是成员方法，不使用static修饰</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;手机可以打电话&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sendMessage</span><span class="params">(String content)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送的信息是:&quot;</span>+content);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;发送信息成功&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、对象的创建与使用"><a href="#2、对象的创建与使用" class="headerlink" title="2、对象的创建与使用"></a><center>2、对象的创建与使用</center></h2><h3 id="创建对象的语法："><a href="#创建对象的语法：" class="headerlink" title="创建对象的语法："></a>创建对象的语法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法：</span></span><br><span class="line">    类名 对象名 = <span class="keyword">new</span> 类名(); ---》类其实就是对象的数据类型，类是引用类型【佐证：使用<span class="keyword">new</span>关键字】</span><br><span class="line"><span class="comment">//例如：</span></span><br><span class="line">    <span class="type">Phone</span> <span class="variable">huawei</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>(); --》相当于创建Phone类的对象huawei，huawei对象数据类型是phoen</span><br><span class="line">    <span class="type">Dog</span> <span class="variable">xiaobia</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(); --》相当于创建Dog类的对象xiaobai，xiaobai对象数据类型是Dog</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in); --》 相当于创建Scanner类的对象</span><br><span class="line">input，input对象数据类型是Scanner</span><br><span class="line"><span class="comment">//类中提供对象所描述属性和行为，通过类创建对象之后，对象就可以使用类中所提供属性和行为即可以通过对象访问成员变量和成员方法</span></span><br><span class="line">    访问类中成员变量</span><br><span class="line">        获取成员变量的值 ---》 对象名.成员变量名;</span><br><span class="line">        对成员变量进行赋值 ---》 对象名.成员变量名 = 值;</span><br><span class="line">    访问类中成员方法</span><br><span class="line">        对象名.成员方法的名字(提供参数赋值);</span><br></pre></td></tr></table></figure>

<p>需求：创建Phone类对象，并对类中提供属性和行为进行操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个类主要就是提供Phone这个描述的操作使用的，所以这个类就是执行类，要添加main方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhoneTest</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.创建Phone这个类的对象</span></span><br><span class="line">        <span class="type">Phone</span> <span class="variable">huwei</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        <span class="comment">//对成员变量进行访问</span></span><br><span class="line">        System.out.println(<span class="string">&quot;手机的品牌：&quot;</span>+huwei.brand);</span><br><span class="line">        System.out.println(<span class="string">&quot;手机的价格：&quot;</span>+huwei.price);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            之前在学习中已经接触了局部变量，即定义在方法体内部变量就是局部变量</span></span><br><span class="line"><span class="comment">            但是在方法体内部定义局部变量，必须进行初始化之后才可以进行使用，作用域仅限在方法体内部</span></span><br><span class="line"><span class="comment">            成员变量是定义在类中的，声明在类中成员变量是存在默认值的即只提供定义操作没有提供赋值操作</span></span><br><span class="line"><span class="comment">            那么这个变量也可以使用并且有默认值存在</span></span><br><span class="line"><span class="comment">            成员变量的默认值会根据数据类型来决定</span></span><br><span class="line"><span class="comment">            整数类型【byte、short、int、long】 --》默认值:0</span></span><br><span class="line"><span class="comment">            小数类型【float 和 double】 ---》 默认值: 0.0</span></span><br><span class="line"><span class="comment">            字符类型【char】 ---》 默认值 一个不可见空字符</span></span><br><span class="line"><span class="comment">            布尔类型【boolean】 ---》 默认值 false</span></span><br><span class="line"><span class="comment">            引用类型【自定义类、数组、Scanner、String....】 ---》 默认值 null</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//对成员变量进行赋值操作</span></span><br><span class="line">        huwei.brand = <span class="string">&quot;华为&quot;</span>;</span><br><span class="line">        huwei.price = <span class="number">19999</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;手机的品牌：&quot;</span>+huwei.brand+<span class="string">&quot;手机的价格：&quot;</span>+ huwei.price);</span><br><span class="line">        <span class="comment">//使用对象对成员方法进行访问操作</span></span><br><span class="line">        huwei.call();</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> huwei.sendMessage(<span class="string">&quot;你好欢迎使用&quot;</span>);</span><br><span class="line">        System.out.println(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、单个对象在内存中存储"><a href="#3、单个对象在内存中存储" class="headerlink" title="3、单个对象在内存中存储"></a><center>3、单个对象在内存中存储</center></h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271924171.WebP" alt="单个对象在内存中存储"></p>
<p>总结：只要是创建对象【使用new关键字】，就会在堆中开辟一段空间</p>
<p>&ensp;&ensp;&ensp;&ensp;只要调用方法，就会在栈中开辟一段空间，用来执行该方法</p>
<p>&ensp;&ensp;&ensp;&ensp;栈中空间是系统回收操作，堆中空间是Java提供GC【垃圾回收机制】进行回收操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> </span><br><span class="line">&#123;</span><br><span class="line">    String name;<span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> age;<span class="comment">//年龄</span></span><br><span class="line">    <span class="comment">//行为 ---》 学习</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在努力的学习Java......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentTest</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1. 创建Student类的对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">xiaoming</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="comment">//2. 利用学生对象打印成员变量的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+xiaoming.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;年龄：&quot;</span>+xiaoming.age);</span><br><span class="line">        <span class="comment">//3. 利用学生对象对成员变量进行赋值操作</span></span><br><span class="line">        xiaoming.name = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">        xiaoming.age = <span class="number">18</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+xiaoming.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;年龄：&quot;</span>+xiaoming.age);</span><br><span class="line">        <span class="comment">//打印学生对象</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            打印学生对象方式 ---&gt; Student@1b6d3586 --&gt; 理解为学生对象地址【在堆中地址】</span></span><br><span class="line"><span class="comment">            Student ---&gt; 证明xiaoming这个对象时属于Student类的</span></span><br><span class="line"><span class="comment">            @ ---&gt; 没有任何意义就是一个连接符号</span></span><br><span class="line"><span class="comment">            1b6d3586 ---&gt; 学生对象记录的堆中开辟空间地址</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;学生对象：&quot;</span>+xiaoming);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、多个对象在内存中存储"><a href="#4、多个对象在内存中存储" class="headerlink" title="4、多个对象在内存中存储"></a><center>4、多个对象在内存中存储</center></h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271924816.WebP" alt="多个对象在内存中存储"></p>
<p>总结: 一个类是可以创建多个对象的，多个对象在堆中存储，都有不同内存划分【就是多个对象都使用new关键字创建】，<strong>成员变量是存储在各自的内存区域中，成员方法是多个对象共一份【类文件只有一个】</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;凡是使用new关键字创建的对象都会在堆中开辟一段新的存储空间</p>
<p>&ensp;&ensp;&ensp;&ensp;对象和对象之的关系是相互独立的【只要是使用new关键字创建出来】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentTest2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1. 创建Student类的对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">xiaoming</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="comment">//2. 利用学生对象打印成员变量的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+xiaoming.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;年龄：&quot;</span>+xiaoming.age);</span><br><span class="line">        <span class="comment">//3. 利用学生对象对成员变量进行赋值操作</span></span><br><span class="line">        xiaoming.name = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">        xiaoming.age = <span class="number">18</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+xiaoming.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;年龄：&quot;</span>+xiaoming.age);</span><br><span class="line">        <span class="comment">//打印学生对象</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            打印学生对象方式 ---&gt; Student@1b6d3586 --&gt; 理解为学生对象地址【在堆中地址】</span></span><br><span class="line"><span class="comment">            Student ---&gt; 证明xiaoming这个对象时属于Student类的</span></span><br><span class="line"><span class="comment">            @ ---&gt; 没有任何意义就是一个连接符号</span></span><br><span class="line"><span class="comment">            1b6d3586 ---&gt; 学生对象记录的堆中开辟空间地址</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;学生对象：&quot;</span>+xiaoming);</span><br><span class="line">        xiaoming.study();</span><br><span class="line">        <span class="comment">//在利用Student类创建一个xiaohong对象，并访问成员变量</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">xiaohong</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+xiaohong.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;年龄：&quot;</span>+xiaohong.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、多个对象指向同一个对象在内存那种存储"><a href="#5、多个对象指向同一个对象在内存那种存储" class="headerlink" title="5、多个对象指向同一个对象在内存那种存储"></a><center>5、多个对象指向同一个对象在内存那种存储</center></h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271924888.WebP" alt="多个对象指向同一个对象在内存存储"></p>
<p>总结： 当多个对象的引用指向同一个内存空间时【对象所记录地址都是一样的】，只要有任何一个对象修改了内存中数据，随之无论使用哪一个对象进行数据获取，都是修改之后的数据</p>
<p>当创建多个对象时，如果你需要某个对象与另外一个对象的空间是一致，只需要将其中创建好的对象存储空间地址赋值给另外一个对象即可，此时引用就是同一个空间</p>
<p>当创建多个对象时，需要对象彼此之间互相独立不干扰，只需使用new关键字分别创建即可， 就可以在堆中开辟不同存储空间了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentTest3</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1. 创建Student类的对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">xiaoming</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="comment">//2. 利用学生对象打印成员变量的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+xiaoming.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;年龄：&quot;</span>+xiaoming.age);</span><br><span class="line">        <span class="comment">//3. 利用学生对象对成员变量进行赋值操作</span></span><br><span class="line">        xiaoming.name = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">        xiaoming.age = <span class="number">18</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+xiaoming.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;年龄：&quot;</span>+xiaoming.age);</span><br><span class="line">        <span class="comment">//打印学生对象</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            打印学生对象方式 ---&gt; Student@1b6d3586 --&gt; 理解为学生对象地址【在堆中地址】</span></span><br><span class="line"><span class="comment">            Student ---&gt; 证明xiaoming这个对象时属于Student类的</span></span><br><span class="line"><span class="comment">            @ ---&gt; 没有任何意义就是一个连接符号</span></span><br><span class="line"><span class="comment">            1b6d3586 ---&gt; 学生对象记录的堆中开辟空间地址</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;学生对象：&quot;</span>+xiaoming);</span><br><span class="line">        xiaoming.study();</span><br><span class="line">        <span class="comment">//不在使用Student类创建对象，而是使用创建xiaoming对象对另外一个xiaohong对象进行赋值</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">xiaohong</span> <span class="operator">=</span> xiaoming;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+xiaohong.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;年龄：&quot;</span>+xiaohong.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="知识点四：成员变量和局部变量"><a href="#知识点四：成员变量和局部变量" class="headerlink" title="知识点四：成员变量和局部变量"></a><center>知识点四：成员变量和局部变量</center></h1><p>成员变量（实例变量）：定义在类的里面，方法的外面的变量称之为成员变量</p>
<p>局部变量：定义在方法内部的变量称为局部变量</p>
<p>成员变量和局部变量的区别：</p>
<p>&ensp;&ensp;&ensp;&ensp;1、位置不同</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;成员变量：在类中、方法外</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;局部变量：在方法内部</p>
<p>&ensp;&ensp;&ensp;&ensp;2、初始值不同（变量必须要初始化才能使用）</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;成员变量：系统会赋值默认值（与之前讲的数组一致）</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;局部变量：没有默认值</p>
<p>&ensp;&ensp;&ensp;&ensp;3、作用域不同</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;成员变量：在类中都可以使用</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;局部变量：只能在作用域中使用（在它所在的{ }中）</p>
<p>&ensp;&ensp;&ensp;&ensp;4、重名问题</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;成员变量不能重名，局部变量在不同作用域中是可以重名的</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;如果当局部变量和成员变量重名的时候，Java中遵循就近原则</p>
<p>&ensp;&ensp;&ensp;&ensp;5、生命周期不同</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;成员变量：变量会随着对象的销毁而销毁。对象什么时候销毁呢（Java中GC垃圾回收机制）</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;语句变量：当变量出了作用域就会被销毁</p>
<h1 id="知识点六：构造方法"><a href="#知识点六：构造方法" class="headerlink" title="知识点六：构造方法"></a><center>知识点六：构造方法</center></h1><h2 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a><center>1、定义</center></h2><p>&ensp;&ensp;&ensp;&ensp;构造方法是一个特殊的方法，主要是完成对象的创建和对象数据的初始化方法</p>
<p>&ensp;&ensp;&ensp;&ensp;构造方法的提供主要是为了可以保证对象可以正确创建，以及对成员变量的从初始化的操作，在不使用构造方法之前，对类中所提供成员变量进行赋值的，只能通过对象，一个一个的进行赋值，如果类中成员变量过多，这个操作是很繁琐，因为对象创建过程中，是需要进行内存开辟空间，构造方法可以保证类所创建对象可以正确创建出来</p>
<p>PS：在实际开发中构造方法主要有两类，一类被称之为“<strong>无参构造方法</strong>”和一类被称之为“<strong>有参构造方法</strong>”</p>
<h2 id="2、语法"><a href="#2、语法" class="headerlink" title="2、语法"></a><center>2、语法</center></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名</span><br><span class="line">&#123;</span><br><span class="line">    访问权限修饰符 数据类型 变量名; <span class="comment">//属性</span></span><br><span class="line">    访问权限修饰符 返回值类型 方法名(参数列表)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//行为</span></span><br><span class="line">        方法体 ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125; </span><br><span class="line">    访问权限修饰符 类名()    <span class="comment">//无参构造方法</span></span><br><span class="line">    &#123; </span><br><span class="line">    &#125; </span><br><span class="line">    访问权限修饰符 类名(参数列表)    <span class="comment">//有参构造方法</span></span><br><span class="line">    &#123;        </span><br><span class="line">        提供类中属性【成员变量】的初始化操作</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">        构造方法的说明：</span></span><br><span class="line"><span class="comment">        1.构造方法只能在类中定义，无法在其他位置提供定义</span></span><br><span class="line"><span class="comment">        2.构造方法使用权限修饰符【常用public】，除此之外在某些特殊情况下可以将构造方法使用private【私有的】进行修饰</span></span><br><span class="line"><span class="comment">        3.构造方法的方法名与类名必须是相同的</span></span><br><span class="line"><span class="comment">        4.构造反方没有返回值类型，甚至都不需要使用void进行表示，更不可能在构造方法中使用return关键字</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//无参构造方法的调用</span></span><br><span class="line">    类名 对象名 = <span class="keyword">new</span> 类名();</span><br><span class="line">    <span class="comment">//有参构造方法的调用</span></span><br><span class="line">    类名 对象名 = <span class="keyword">new</span> 类名(实参<span class="number">1</span>,实参<span class="number">2</span>,.....);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例：需求：提供一个Person类，属性【姓名，年龄，性别】，行为【吃】，在提供类中构造方法定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//属性描述</span></span><br><span class="line">    String name; <span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> age; <span class="comment">//年龄</span></span><br><span class="line">    String gender; <span class="comment">//性别</span></span><br><span class="line">    <span class="comment">//行为的描述</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            在同一个类中，成员方法是可以直接访问本类中提供成员变量和其他成员方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.out.println(name+<span class="string">&quot;正在吃饭...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//提供Person类的无参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>    <span class="comment">// 无参构造方法【方法的参数列表不做任何参数定义】</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            PS：在实际开发中，无参构造方法主要是定义的作用，基本上在构造方法体中很少进行初始操作</span></span><br><span class="line"><span class="comment">            如果在无参构造方法进行属性的初始化，所有调用无参构造方法创建对象都会都会具备这个属性值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//给属性进行初始化操作 --》 手动进行赋值</span></span><br><span class="line">        name = <span class="string">&quot;xiaoming&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提供Person类的有参构造方法</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Person的有参构造方法一定会提供参数列表？ 这个参数列表如何定义？</span></span><br><span class="line"><span class="comment">        给那些类中属性进行赋值【初始化】，参数列表就定义那些数据</span></span><br><span class="line"><span class="comment">        定义参数需要和类中属性数据类型是一直，这样方便进行赋值操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String n,<span class="type">int</span> a, String g)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这个操作就是使用参数对类中属性进行初始化赋值操作</span></span><br><span class="line">        name = n;</span><br><span class="line">        age = a;</span><br><span class="line">        gender = g;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PersonTest</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonTest</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//使用Person类中无参构造方法【分别构建两个对象】</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="comment">//调用Person类中提供name属性</span></span><br><span class="line">        System.out.println(<span class="string">&quot;person1对象中的name属性值：&quot;</span> + person1.name);    <span class="comment">//都是午餐构造里面的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;person2对象中的name属性值：&quot;</span> + person2.name);</span><br><span class="line">        <span class="comment">//使用Person类中有参构造方法在创建对象的同时对属性进行初始化</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小红&quot;</span>,<span class="number">18</span>,<span class="string">&quot;女&quot;</span>);<span class="comment">//小括号中提供具体数据，调用就是有参构造方法</span></span><br><span class="line">        <span class="comment">//打印person3对象中属性值</span></span><br><span class="line">        System.out.println(person3.name + <span class="string">&quot; &quot;</span> + person3.age + <span class="string">&quot; &quot;</span> + person3.gender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、注意的事项"><a href="#3、注意的事项" class="headerlink" title="3、注意的事项"></a><center>3、注意的事项</center></h2><p>1）如果在类中并没有明确提供构造方法的定义，此时<strong>系统将提供一个默认无参构造方法，让创建对象时使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Man</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Man这个类中并没有明确提供构造方法</span></span><br><span class="line">    String name;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//但是系统会为Man提供一个默认的无参构造方法</span></span><br><span class="line">        <span class="type">Man</span> <span class="variable">man</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）如果在类中<strong>明确提供了构造方法【无论是有参还无参】此时系统提供的默认构造方法将消失，不在提供对外操作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Man2</span> </span><br><span class="line">&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="comment">//明确提供一个有参构造方法【系统无参构造方法将无法在次调用，如果需要使用无参构造方法必须手动提供】</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Man2</span><span class="params">(String n)</span></span><br><span class="line">    &#123;</span><br><span class="line">        name = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//调用Man2这个类中无参构造方法进行对象创建</span></span><br><span class="line">        <span class="comment">//IDEA提供错误提示&quot;Man2(java.lang.String)&#x27; in &#x27;Man2&#x27; cannot be applied to&#x27;()&#x27;&quot;</span></span><br><span class="line">        <span class="comment">//Man2 man2 = new Man2();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）一个类中是可以提供多个构造方法，但是在同一个类中有一个要求，定义方法签名【方法名+参数列表】不能重复，那么为什么还可以提供一个无参构造方法和一个有参构造方法呢？</p>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p><strong>这里我们利用到一个方法的概念【特点】 —》 这个特点叫做方法的“重载【overload】”</strong></p>
<p>在同一个类中，定义方法签名是不允许重复，但是利用重载这个概念完成方法名相同操作【无参构造方法与有参构造方法的名字是相同，但是没有报错】，虽然名字相同，但是参数列表是不同就会触发重载操作</p>
<p>重载的要求，只要满足以下<strong>三者之一</strong>就可以成为重载</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1.方法名相同但是参数列表不同，定义的顺序不同，就可以称之为重载</strong></p>
<p><strong>&ensp;&ensp;&ensp;&ensp;2.方法名相同但是参数列表不同，定义的数据类型不同，就可以称之为重载</strong></p>
<p><strong>&ensp;&ensp;&ensp;&ensp;3.方法名相同但是参数列表不同，定义的个数不同，就可以称之为重载</strong></p>
<p>所以，当前类中所提供的<strong>无参构造方法与有参构造方法就是方法的重载，可以利用这个特性提供多个方法</strong></p>
<p>4）构造方法必须与类同名，必须没有返回值类型，并且void也不可以，不可以使用return关键字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Man3</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        为了保证类与类之间继承关系，为了保证JavaBean合理定义</span></span><br><span class="line"><span class="comment">        一般会在一个描述类中提供一个有参和无参的构造方法</span></span><br><span class="line"><span class="comment">        有参构造方法，一般是针对类中所有属性记性初始化操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//类中基本提供方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Man3</span><span class="params">()</span></span><br><span class="line">    &#123; <span class="comment">//无参构造方法</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Man3</span><span class="params">(String n,<span class="type">int</span> a)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//有参构造方法</span></span><br><span class="line">        name = n;</span><br><span class="line">        age = a;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//还可以利用重载的特点，进行多个构造方法的提供【因人而异，因项目要求而异】</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Man3</span><span class="params">(String n)</span></span><br><span class="line">    &#123;</span><br><span class="line">        name = n;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Man3</span><span class="params">(<span class="type">int</span> a)</span></span><br><span class="line">    &#123;</span><br><span class="line">        age = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>PS：重载这个概念也适用于其他方法</strong></p>
<h1 id="知识点七：对象的内存分配"><a href="#知识点七：对象的内存分配" class="headerlink" title="知识点七：对象的内存分配"></a><center>知识点七：对象的内存分配</center></h1><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271925009.WebP" alt="对象内存分配" style="zoom: 50%;">

<h1 id="知识点九：三大特征"><a href="#知识点九：三大特征" class="headerlink" title="知识点九：三大特征"></a><center>知识点九：三大特征</center></h1><p>面向对象这个编程思想是贴近与现实生活逻辑一种编程思想，在这个编程思想中利用三个特征完成面向对象的编程逻辑，面向对象中的三大特征：“<strong>封装、继承和多态</strong>”</p>
<p>这三者体现了什么？</p>
<p>封装性:封装就是一个事物包裹起来，使外界不了解它内部的情况，在面向对象中，封装就把相关的数据和代码结合成一个有机的整体，形成数据和代码操作的封装体，提供一个对外部暴露的接口，可以方便外界使用这个封装</p>
<p>继承性：从已有类中创建新类的过程，提供继承信息的被称之为父类，得到继承信息称之为子类，父子之间存在一个关系就是【继承】，继承可以使Java中类与类之间形成一个层次机构，利用这个继承简便的进行代码的开发。</p>
<p>多态性： 多态是允许程序中出现多种状态的对象。同一个事物被不同对象所触发，得到结果不同就称之为多态【主要体现就是对象的转型操作】</p>
<p>以上的三个特征会在编程中所有体现，从而完善面向对象编程</p>
<h2 id="1、封装"><a href="#1、封装" class="headerlink" title="1、封装"></a><center>1、封装</center></h2><p>需求：创建一个Cat类，对Cat类提供属性【姓名和年龄】，然后再执行类中创建Cat类对象对属性进行操作及打印</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> </span><br><span class="line">&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String n, <span class="type">int</span> a)</span></span><br><span class="line">    &#123;</span><br><span class="line">        name = n;</span><br><span class="line">        age = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CatTest</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        cat.age = <span class="number">1</span>;</span><br><span class="line">        cat.name = <span class="string">&quot;小花&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫的名字：&quot;</span>+cat.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;猫的年龄：&quot;</span>+cat.age);</span><br><span class="line">        <span class="comment">//但是 --&gt; 对age属性进行赋值操作</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            首先下面这个语法在开发中是没有问题，是可以对age属性进行负数赋值操作</span></span><br><span class="line"><span class="comment">            age属性是int数据类型 ，int数据类型可以存储数据范围【-21亿~21亿】之间</span></span><br><span class="line"><span class="comment">            赋值这个-1 很明显是满足这个存储范围操作的【语法是没有问题】</span></span><br><span class="line"><span class="comment">            在客观现实生活中，猫的年龄是绝对不可能出现 负数的</span></span><br><span class="line"><span class="comment">            如果在实际开发中，让外界可以直接对成员变量进行访问操作，是会存在安全隐患的</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        cat.age = -<span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫的年龄：&quot;</span>+cat.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在开发中如果我们直接访问成员变量，可能会出现安全隐患，在代码中age属性赋值操作就已经出</p>
<p>现问题，应该如何解决？</p>
<p>解决方式: 提供变量不对外直接访问的途径【即对属性进行封装操作】</p>
<p>&ensp;&ensp;&ensp;&ensp;在学习类的时候在定义属性【成员变量】时，可以对属性进行权限修饰符的使用，现在接触的权限修饰符主要所有【<strong>public（公有） 和 default&#x2F;package（默认&#x2F;包权限）</strong>】，使用他们修饰之后外界还是可以进行访问的，所以想让属性不在提供对方直接访问【使用封装概念来完成操作】 –》可<strong>以使用一个权限修饰符【private（私有）】，这权限修饰符是所有权限修饰符中在最低权限，利用private对成员变量的修饰以达到封装的目的</strong></p>
<p>解决方法：修改Cat类代码对属性提供private修饰</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> </span><br><span class="line">&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age; <span class="comment">//属性的私有化就是封装的体现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String n, <span class="type">int</span> a)</span></span><br><span class="line">    &#123;</span><br><span class="line">        name = n;</span><br><span class="line">        age = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;面向对象的封装其实就是一个编程的要求，将信息隐藏起来，把不需要外界知道的信息隐藏，尽可能隐藏对象功能实现细节，向外直接提供他可以访问方法，保证外界无法破坏原有内部信息，这就是封装特性</p>
<p>&ensp;&ensp;&ensp;&ensp;在写面向对象思想时，封装效果体现其实已经在，在写类的时候就已经是封装的效果，类就是将属性和方法封装在一个类中，除了这种体现方式之外，可以对属性进行私有化操作即使用private进行修饰，主要的目的是为了保证成员变量安全，所以<strong>private私有化成员变量只是封装特定一个体现而已</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;封装确实可以保证age属性的安全性，外界无法直接破坏内部存储信息的途径，但是正常使用age属性时，也无法完成，所以封装中还有有一句话很重要“<strong>向外直接提供他可以访问方法</strong>”</p>
<h3 id="Getter和Setter方法"><a href="#Getter和Setter方法" class="headerlink" title="Getter和Setter方法"></a>Getter和Setter方法</h3><p>&ensp;&ensp;&ensp;&ensp;当对属性提供private权限修饰符时，确实让属性更加安全体现封装的一个特点，但是并不是完全封装特性展示，“<strong>封装细节之后还是要提供一种访问方式</strong>”</p>
<p>如果属性使用private进行修饰之后，就要对属性配套提供对应Getter和Setter方法</p>
<p>&ensp;&ensp;&ensp;&ensp;因为属性已经被private修饰了，提供Getter和Setter方法的目的是为了提供操作属性途径，所以这两方法必然使用public修饰</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Getter方法定义方式</span></span><br><span class="line"><span class="comment">    public 返回值类型 getXXX()</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        return 属性名;</span></span><br><span class="line"><span class="comment">    &#125; </span></span><br><span class="line"><span class="comment">解释说明：</span></span><br><span class="line"><span class="comment">    1. Getter方法主要的作用就是提供获取属性方法</span></span><br><span class="line"><span class="comment">    2. 这个方法必须有【返回值类型】，这个【返回值类型】如何定义？ --》 你提供get方法获取的</span></span><br><span class="line"><span class="comment">    是哪个属性值，这个方法的【返回值类型】就与属性的【属性类型】一致即可</span></span><br><span class="line"><span class="comment">    3. 方法名是固定的叫做【getXXX】---》get是固定代表是Getter方法获取属性值用---》</span></span><br><span class="line"><span class="comment">        XXX是你通过get获取哪个属性，这个XXX就是属性字</span></span><br><span class="line"><span class="comment">    外界使用get方法时，可以通过方法名得知使用是哪个属性</span></span><br><span class="line"><span class="comment">    4. 这个方法的参数列表定义是空的，没有任何参数定义</span></span><br><span class="line"><span class="comment">    5. 这个方法必须添加return关键字</span></span><br><span class="line"><span class="comment">        5.1 这个get方法是获取属性值，如果不return数据如何得到值</span></span><br><span class="line"><span class="comment">        5.2 这个方法定义返回值类型，所以方法必须添加return关键字对应操作</span></span><br><span class="line"><span class="comment">            return关键字后面跟值是什么？你获取的是哪个属性值， return就哪个属性</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Setter方法定义方式</span></span><br><span class="line"><span class="comment">    public void setXXX(参数列表)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        使用定义参数对属性进行赋值</span></span><br><span class="line"><span class="comment">    &#125; </span></span><br><span class="line"><span class="comment">解</span></span><br><span class="line"><span class="comment">释说明：</span></span><br><span class="line"><span class="comment">    1. Setter方法的主要作用就是对进行赋值操作</span></span><br><span class="line"><span class="comment">    2. 因为Set方法是对属性赋值，所以这个方法不需要返回值类型，所以方法使用void定义</span></span><br><span class="line"><span class="comment">    3. setXXX这个名字是固定的，set主要说明这个方法是Setter方法对属性赋值使用，XXX是针对堆</span></span><br><span class="line"><span class="comment">    那个属性赋值，XXX就是那个属性名字，这样一来外界调用这个方法时就可以得知对那个属性的操作</span></span><br><span class="line"><span class="comment">    4. 这里一定需要定义【参数列表】，因为set方法主要作用是赋值，所以需要通过方法参数对属性进</span></span><br><span class="line"><span class="comment">        行赋值操作，你对那个属性记性赋值 那么这个参数列表定义就与属性定义相同即可</span></span><br><span class="line"><span class="comment">    5. set方法体提供的是对属性的赋值操作【利用参数对属性赋值】</span></span><br><span class="line"><span class="comment">    6. 一定没有return关键字</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>修改Cat类提供Getter和Setter方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> </span><br><span class="line">&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age; <span class="comment">//属性的私有化就是封装的体现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String n, <span class="type">int</span> a)</span></span><br><span class="line">    &#123;</span><br><span class="line">        name = n;</span><br><span class="line">        age = a;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//提供private修饰属性的Getter和Setter方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span></span><br><span class="line">    &#123; <span class="comment">//获取属性值</span></span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> a)</span></span><br><span class="line">    &#123; <span class="comment">// 属性进行赋值操作</span></span><br><span class="line">    <span class="comment">//非法拦截</span></span><br><span class="line">        <span class="keyword">if</span>(a &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;您提供年龄不合法，无法赋值！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            age = a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CatTest</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        cat.setAge(<span class="number">1</span>);</span><br><span class="line">        cat.name = <span class="string">&quot;小花&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫的名字：&quot;</span>+cat.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;猫的年龄：&quot;</span>+cat.getAge());</span><br><span class="line">        </span><br><span class="line">        cat.setAge(-<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;猫的年龄：&quot;</span>+cat.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><p>&ensp;&ensp;&ensp;&ensp;需求：定义一个User类提供属性name和age并且私有化，提供有参无参构造方法，提供Getter和Setter方法，并且要求，在定义有参和Set方法是，定参数列表名需要和属性名一致，创建一个User对象，分别使用有参、无参构造方法完成，在调用set修改任何属性值，并提供get方法打印出来？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name ,<span class="type">int</span> age)</span></span><br><span class="line">    &#123;</span><br><span class="line">        name = name;</span><br><span class="line">        age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserTest</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.使用无参构造方法 ---》 创建User对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        <span class="comment">//通过user对象调用setName方法进行name属性赋值操作</span></span><br><span class="line">        user.setName(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user的姓名：&quot;</span>+user.getName());</span><br><span class="line">        <span class="comment">//2.使用有参构造方法 ---》创建User对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;小红&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user2的姓名：&quot;</span>+user2.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;user2的年龄：&quot;</span>+user2.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行完代码之后，打印属性值发现</p>
<p>&ensp;&ensp;&ensp;&ensp;user的姓名：null</p>
<p>&ensp;&ensp;&ensp;&ensp;user2的姓名：null</p>
<p>&ensp;&ensp;&ensp;&ensp;user2的年龄：0</p>
<p>打印出来属性值都是默认值，这是为什么呢？</p>
<p>&ensp;&ensp;&ensp;&ensp;在说这个问题之前，介绍一个【关键字this】，这个关键字可以在当前类中使用，主要使用在【构造方法和成员方法】中，this关键字在类中代表什么？【代表的是当前对象–》谁触发，谁就是this】</p>
<h4 id="1）调用本类属性"><a href="#1）调用本类属性" class="headerlink" title="1）调用本类属性"></a>1）调用本类属性</h4><p>在本类中调用本类的属性，this关键字可以省略，但是如果局部变量和成员变量同名时，若时 this.属性名  则是调用成员变量，若直接  属性名，则是调用局部变量（就近原则）</p>
<h4 id="2）调用本类方法"><a href="#2）调用本类方法" class="headerlink" title="2）调用本类方法"></a>2）调用本类方法</h4><p>在调用本类的方法的时候，this关键字完全可以省略不写</p>
<h4 id="3）调用本类的构造方法"><a href="#3）调用本类的构造方法" class="headerlink" title="3）调用本类的构造方法"></a>3）调用本类的构造方法</h4><p>在构造方法里调用另外一个构造方法</p>
<p>注意点：</p>
<p>&ensp;&ensp;&ensp;&ensp;a）在构造方法中用 this 再调用本类的其它构造方法的时候，这一行代码必须出现在构造方法的第一行</p>
<p>&ensp;&ensp;&ensp;&ensp;b）避免在构造方法中调用自身这个构造，这会出现无穷递归。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">this关键字的作用:</span><br><span class="line">    1. 可以通过this关键字访问当前类中成员变量进行操作 ---》 this.成员变量</span><br><span class="line">    2. 可以通过this关键字访问当前类中成员方法进行操作 ---》 this.成员方法（参数赋值）;</span><br><span class="line">    3. 可以通过this关键字在当前类中构造方法中访问其他的本类构造方法</span><br><span class="line">        ----》 this();【访问本类的无参构造方法】 ----》this(参数赋值);【访问本类的有参构造方法】</span><br><span class="line">        ----》 特别说明: 这个调用构造方法的方式只能在构造方法中使用，并且必须在构造方法体中第一句</span><br><span class="line">                不允许构造通过this关键字调用自身构造方法</span><br><span class="line">    4. 可以通过this关键字作为方法参数传递【代表当前对象】</span><br><span class="line">*/</span><br><span class="line">ps：上述的作用中只有一个对于我们开发是有用的，其余的都是已经很少使用甚至不用</span><br><span class="line">    ---》使用this关键字访问成员变量 ，在构造方法中和setter方法中区分成员变量和参数名字</span><br></pre></td></tr></table></figure>

<p>使用this关键字修改User类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//name = &quot;1&quot;;</span></span><br><span class="line">        <span class="comment">//在这个构造方法中使用this关键字调用本类的其他构造方法【很少使用】</span></span><br><span class="line">        <span class="comment">//this(); //不允许使用this关键字调用自身构造方法</span></span><br><span class="line">        <span class="comment">//必须在构造方法中第一行，不允许在它之前出现任何其他代码</span></span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;小白&quot;</span>,<span class="number">18</span>); <span class="comment">//不允许构造互相调用【不允许在无参中调用有参，在有参中调用无参】</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name ,<span class="type">int</span> age)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*原因就是出现在这个赋值操作过程中，Java中如何认定一个变量属于谁？</span></span><br><span class="line"><span class="comment">        使用是就近原则，name离谁最近name就是谁，name这个变量和参数列表中name是最近的</span></span><br><span class="line"><span class="comment">        所以这个赋值操作其实 就是在用参数name 对参数name进行赋值，根本就没有属性name进行赋值操作</span></span><br><span class="line"><span class="comment">        虽然这个name 与属性name是同名，但是根本就没有操作到，IDEA没有办法区分属性名与参数名相同时</span></span><br><span class="line"><span class="comment">        那个是属性，那个是参数 ---》出现了二义性</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//使用this关键字调用成员变量的方式区分 成员变量名字和参数的名字</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//提供两个成员方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show成员方法&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showInfos</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//使用this关键字访问本类中成员变量和成员方法</span></span><br><span class="line">    System.out.println(<span class="string">&quot;本类name属性：&quot;</span>+<span class="built_in">this</span>.name);</span><br><span class="line">    <span class="built_in">this</span>.show();</span><br><span class="line">    <span class="comment">//但是，实际开发中可以省略this不写 ，上下代码操作是完全一样</span></span><br><span class="line">    <span class="comment">//下面的操作属于上面操作的简化，实际在底层依旧是在执行 this.name 和 this.show()</span></span><br><span class="line">    System.out.println(<span class="string">&quot;本类name属性：&quot;</span>+name);</span><br><span class="line">    show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：this关键字使用方式是有很多的的，但是使用应用主要还是会使用【this.成员变量】方法进行与相同参数名的区分操作，其余的功能进本上很少在使用</p>
<h3 id="标准类的制作"><a href="#标准类的制作" class="headerlink" title="标准类的制作"></a>标准类的制作</h3><p>&ensp;&ensp;&ensp;&ensp;Java中我们要定义一个类是有一个标准，这个标准叫做JavaBean，JavaBean是Java语言编写类第一种规范，符合JavaBean的类，要求<strong>类必须是公有的</strong>，<strong>属性需要使用private修饰</strong>，并且<strong>提供有参和无参构造方法</strong>，还要提供<strong>成员变量的set和get方法</strong> —》 这样类就称之为JavaBean标准类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">     <span class="keyword">private</span> String name;</span><br><span class="line">     <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line">    <span class="comment">//进入后：选Constructor  + 选全部 + ok = 生成全参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Product</span><span class="params">(<span class="type">int</span> id, String name, <span class="type">double</span> price)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进入后：选Constructor + 不用选 + Select None = 生成无参构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Product</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进入后：选Getter and Setter + 选全部 + ok = 生成公共访问</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getPrice</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">double</span> price)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> 返回值类型 方法名(参数列表)</span><br><span class="line">    &#123;</span><br><span class="line">        方法体;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：在通过题意针对某些类进行定义时，尽量使用JavaBean标准类定义的要求【私有属性、有参无参构造方法、Getter和Setter方法】进行类的定义，剩余的可以根据实际需求动态在类中记性增删添加即可</p>
<h2 id="2、继承"><a href="#2、继承" class="headerlink" title="2、继承"></a><center>2、继承</center></h2><h3 id="1）含义"><a href="#1）含义" class="headerlink" title="1）含义"></a>1）含义</h3><p>&ensp;&ensp;&ensp;&ensp;继承是面向对象三大特征之一，也是面向对象编程中不可缺少的一个操作，继承是一个比较好理解的概念和现实生活中继承是相同</p>
<p>&ensp;&ensp;&ensp;&ensp;在Java中继承概念: 在Java中指的是“一个类”可以“继承自”另外一个类，“被继承的类”叫做“父类&#x2F;基类&#x2F;超类”，“继承其他类的类”叫做 “子类&#x2F;派生类”，继承之后“子类”中就拥有“父类”中所有【可见】的成员【成员变量和成员方法】，子类就不需要在重复定义了，不仅如此子类还可以提供自身独有的【成员变量和成员方法】提供继承概念可以最大限度提高代码之间复用性【减少代码冗余、相同代码重复利用】，并且可以让类与类之间产生关联</p>
<p>案例:西游记中角色定义:</p>
<p>&ensp;&ensp;&ensp;&ensp;唐僧: 姓名&#x2F;性别&#x2F;年龄&#x2F; 念经</p>
<p>&ensp;&ensp;&ensp;&ensp;悟空: 姓名&#x2F;性别&#x2F;年龄&#x2F; 七十二变, 打妖怪</p>
<p>&ensp;&ensp;&ensp;&ensp;八戒: 姓名&#x2F;性别&#x2F;年龄&#x2F; 三十六变, 调戏嫦娥</p>
<p>&ensp;&ensp;&ensp;&ensp;沙僧: 姓名&#x2F;性别&#x2F;年龄&#x2F; 挑担, 求救</p>
<p>&ensp;&ensp;&ensp;&ensp;白龙马:姓名&#x2F;性别&#x2F;年龄&#x2F; 走</p>
<p>提供创建类的分析：</p>
<ol>
<li>设计唐生类，属性有3个【姓名&#x2F;性别&#x2F;年龄】，定义成成员变量，行为念经定成方法</li>
<li>设计悟空类，属性有3个【 姓名&#x2F;性别&#x2F;年龄】，定义成成员变量，行为七十二变, 打妖怪</li>
<li>设计八戒类，属性有3个【 姓名&#x2F;性别&#x2F;年龄】，定义成成员变量 ，行为 三十六变, 调戏嫦娥</li>
<li>设计沙僧类，属性有3个【姓名&#x2F;性别&#x2F;年龄】，定义成成员变量 ，行为 挑担, 求救</li>
<li>设计白龙马类，属性有3个【姓名&#x2F;性别&#x2F;年龄】，定义成成员变量 ，行为走</li>
</ol>
<p>当前5个类中有相同的属性都是需要定义三个属性分贝为【姓名&#x2F;性别&#x2F;年龄】，只是当前每个类中行为不同而已</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271925657.WebP" alt="继承解析"></p>
<h3 id="2）语法"><a href="#2）语法" class="headerlink" title="2）语法"></a>2）语法</h3><p>在Java中需要完成继承操作，需要使用到一个关键字【extends】 表示继承</p>
<p>PS： extends关键字的本身含义是“扩展的意思”，但是为了复合国人学习编程习惯，所以翻译成继承</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提供继承信息的是父类 --》如何定义【你平时如何定义类就如何定义父类】</span></span><br><span class="line"><span class="keyword">public</span> class 父类名字&#123;</span><br><span class="line">    成员变量;</span><br><span class="line">    构造方法;</span><br><span class="line">    Getter和Setter方法;</span><br><span class="line">    成员方法 ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//得到继承信息的是子类 --》 如何定义</span></span><br><span class="line"><span class="keyword">public</span> class 子类名字 extends 父类名字&#123; </span><br><span class="line">    <span class="comment">//类与类之间继承</span></span><br><span class="line">    子类可以得到父类所有的可见属性和方法【不是用<span class="keyword">private</span>修饰】</span><br><span class="line">    从父类继承而来就无需重复定义，直接使用即可</span><br><span class="line">    除此之外，子类还可以提供子类自身定义的</span><br><span class="line">    成员变量;</span><br><span class="line">    构造方法;</span><br><span class="line">    Getter和Setter方法;</span><br><span class="line">    成员方法 ;</span><br><span class="line">&#125; </span><br><span class="line">    在开发中父类就是一个模板类，给所有子类提供一些基础信息【属性和行为】，所以父类基本上是不</span><br><span class="line">    会直接创建对象，子类是继承父类而来，所以子类会比父类更加强大，不仅可以得到父类提供【属性和</span><br><span class="line">    行为】，而且子类自身也可以继续定义【属性和行为】，在开发中多是以子类作为创建对象依据来进行操作</span><br><span class="line">    <span class="comment">//在Java中所有类与类之间关系都是【单一继承】，一个子类只能有一个直接父类</span></span><br><span class="line">    例如：这种定义在Java中不被允许的</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125; <span class="comment">//父类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span>&#123;&#125; <span class="comment">//父类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span>,B 或者 <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span> B</span><br><span class="line">    或者 <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">B</span> ---》 都是错误语法</span><br><span class="line">    <span class="comment">//Java中一个类是不允许直接继承多个父类的即多继承</span></span><br><span class="line">    <span class="comment">//虽然Java中类不存在多继承的这种效果，但是Java中类允【间接继承（多重或多层继承）】</span></span><br><span class="line">    例如：</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123;&#125;</span><br><span class="line">    语法说明： A类是父类，对于B类而言A是B类父类，B是A的子类</span><br><span class="line">    对于C类而言B是C类父类，C是B的子类</span><br><span class="line">    因为B类是继承与A类，而C类是继承与B类，所有A类是C的间接父类，C也是A类间接子类</span><br><span class="line">    通俗的看待：A类就是爷爷 B类就父亲 C类就是孙子</span><br><span class="line">    其实你在Java中所有开发了类基本上都是继承关系类，也会存在间接继承的问题，Java中提供了一</span><br><span class="line">    个超级（根）类【Object】，Java所有的类都是直接或间接的继承于Object</span><br><span class="line">    每当在项目中创建一个类的时候，此时Java都是隐式的继承与Object这个类</span><br><span class="line">    例如：</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125; <span class="comment">//定义了一个A类，虽然表面上看着就是一个A类，但是实际上它是等价于</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">Object</span>&#123;&#125;</span><br><span class="line">    Java中是没有多继承，那么如果编写代码时明确继承与某一个类，那么 <span class="keyword">extends</span> <span class="title class_">Object</span> 会发生什么 </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> </span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123;&#125; <span class="comment">//明确继承之后，原有继承Object类操作就会被覆盖，提供给父</span></span><br><span class="line">    类继承，形成间接继承效果，只要提供一个类都是要继承与Object类的，就选明确继承了某个类，但</span><br><span class="line">    是父类也是要继承与Object类，所以类都是直接或间接继承与Object</span><br></pre></td></tr></table></figure>

<p>PS:先写父类还是先写子类</p>
<p>&ensp;&ensp;&ensp;&ensp;一般的，在开发时都会对你开发程序予以设计，这个设计中就会确定父类与子类，只需要通过这设计方案提供父类与子类实现就可以完成操作</p>
<p>&ensp;&ensp;&ensp;&ensp;在开发中发现某些类之间存在一些联系和一些固定属性和行为，可以二次封装出父类个人开发建议：尽量根据需求分析出是否存在父类，如果存在就提供实现，如果不存在就正常开发就可以</p>
<h4 id="好处和特点"><a href="#好处和特点" class="headerlink" title="好处和特点"></a>好处和特点</h4><p>好处：实现代码的复用，避免代码的冗余</p>
<p>特点：</p>
<p>&ensp;&ensp;&ensp;&ensp;a）子类继承父类，子类可以继承父类中的属性和方法</p>
<p>&ensp;&ensp;&ensp;&ensp;b）子类可以拥有自己独有的属性和方法</p>
<p>&ensp;&ensp;&ensp;&ensp;c）单继承，即在java中一个子类只能继承一个父类，但一个父类可以拥有多个子类</p>
<p>&ensp;&ensp;&ensp;&ensp;d）多重继承，即一个父类还可以继承另外一个类，java中最大的父类的是Object（如果一个类没有显示的写出extends，那么这个继承Object类）</p>
<h4 id="不能被继承情况"><a href="#不能被继承情况" class="headerlink" title="不能被继承情况"></a>不能被继承情况</h4><p>&ensp;&ensp;&ensp;&ensp;a）使用 修饰的属性和方法不能被子类继承</p>
<p>&ensp;&ensp;&ensp;&ensp;b）构造方法不能被继承（构造方法是用来创建类的对象）</p>
<p>&ensp;&ensp;&ensp;&ensp;c）父类中使用默认的修饰符的修饰的属性和方法在不同包的子类中不能被继承 </p>
<h4 id="以继承角度完成练习："><a href="#以继承角度完成练习：" class="headerlink" title="以继承角度完成练习："></a>以继承角度完成练习：</h4><p>贵妇从宠物店购买了宠物狗、宠物猫，某天，家里举行聚会，向朋友介绍起自家豢养的宠物的情形。</p>
<p>训练提示</p>
<p>&ensp;&ensp;&ensp;&ensp;a）设计宠物狗类，属性有4个【姓名，性别，年龄，品种】，行为【吃、睡觉】</p>
<p>&ensp;&ensp;&ensp;&ensp;b）设计宠物狗类，属性有4个【姓名，性别，年龄，品种】，行为【吃、卖萌】</p>
<p>&ensp;&ensp;&ensp;&ensp;c）设计贵妇类，属性有姓名，思考是有可以将狗和猫作为贵妇的属性存在，如果作为属性，那么如何在贵妇中提供方法介绍自己的从宠物狗和宠物猫</p>
<p>&#x2F;&#x2F;父类宠物类，这个类中提供宠物狗和宠物猫共有属性和行为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pet</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//共有属性【姓名、性别、年龄、品种】</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String kind;</span><br><span class="line">    <span class="comment">//在Java代码中可以利用编译器快捷的生成 构造方法、Get和Set</span></span><br><span class="line">    <span class="comment">//快捷键 alt+Insert ---》帮组我们生成需要【构造方法、Get和Set】</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pet</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pet</span><span class="params">(String name, String gender, <span class="type">int</span> age, String kind)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.kind = kind;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGender</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGender</span><span class="params">(String gender)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getKind</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> kind;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setKind</span><span class="params">(String kind)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.kind = kind;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//所有宠物中都有一个吃的行为</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;正在吃&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>宠物猫类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PetCat</span> <span class="keyword">extends</span> <span class="title class_">Pet</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//无需再PetCat中在定义 属性和吃行为 【因为继承Pet，所以子类可以得到属性和行为】</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meng</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(getName()+<span class="string">&quot;吃饱之后正在卖萌....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>宠物狗子类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PetDog</span> <span class="keyword">extends</span> <span class="title class_">Pet</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//无需再PetDog中在定义 属性和吃行为 【因为继承Pet，所以子类可以得到属性和行为】</span></span><br><span class="line">    <span class="comment">//提供一个咬人行为即可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bite</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(getName()+<span class="string">&quot;吃饱之后正准备咬人....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>贵妇类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    在一个类中使用另外一个类属性和行为时，如何处理？</span></span><br><span class="line"><span class="comment">    第一种： 在使用类中，将另外一个类作为本类属性存在</span></span><br><span class="line"><span class="comment">        好处：因为是属性所以在整个类中和类外都可以访问操作【使用范围广泛】</span></span><br><span class="line"><span class="comment">        坏处：需要满足一些客观现实规律</span></span><br><span class="line"><span class="comment">    第二种： 在使用类中， 提供一个方法【一般是成员方法】将另外一个类作为本方法的参数定义使用</span></span><br><span class="line"><span class="comment">        好处：可以不用受到一些客观现实规律约束</span></span><br><span class="line"><span class="comment">        坏处：使用范围仅限于方法的内部，在其他位置无法使用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lady</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Lady</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Lady</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        eturn name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//提供两个行为：介绍宠物猫和宠物狗</span></span><br><span class="line">    <span class="comment">//PetCat cat:是一个类类型(引用类型)，在mian方法中new对应的类再把new出来的对象名传进来，这里就相当于PetCat cat = new PetCat();     </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showInfosPetCat</span><span class="params">(PetCat cat)</span>    </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫的名字：&quot;</span>+cat.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;猫的性别：&quot;</span>+cat.getGender());</span><br><span class="line">        System.out.println(<span class="string">&quot;猫的年龄：&quot;</span>+cat.getAge());</span><br><span class="line">        System.out.println(<span class="string">&quot;猫的品种：&quot;</span>+cat.getKind());</span><br><span class="line">        cat.eat(); <span class="comment">//这个方法在PetCat类中并无定义，是从父类继承而来</span></span><br><span class="line">        cat.meng();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showInfosPetDog</span><span class="params">(PetDog dog)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫的名字：&quot;</span>+dog.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;猫的性别：&quot;</span>+dog.getGender());</span><br><span class="line">        System.out.println(<span class="string">&quot;猫的年龄：&quot;</span>+dog.getAge());</span><br><span class="line">        System.out.println(<span class="string">&quot;猫的品种：&quot;</span>+dog.getKind());</span><br><span class="line">        dog.eat(); <span class="comment">//这个方法在PetCat类中并无定义，是从父类继承而来</span></span><br><span class="line">        dog.bite();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">PetCat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PetCat</span>();</span><br><span class="line">        cat.setName(<span class="string">&quot;小花&quot;</span>);</span><br><span class="line">        cat.setAge(<span class="number">1</span>);</span><br><span class="line">        cat.setGender(<span class="string">&quot;母&quot;</span>);</span><br><span class="line">        cat.setKind(<span class="string">&quot;美短&quot;</span>);</span><br><span class="line">        <span class="type">PetDog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PetDog</span>();</span><br><span class="line">        dog.setName(<span class="string">&quot;小白&quot;</span>);</span><br><span class="line">        dog.setAge(<span class="number">1</span>);</span><br><span class="line">        dog.setGender(<span class="string">&quot;公&quot;</span>);</span><br><span class="line">        dog.setKind(<span class="string">&quot;柯基&quot;</span>);</span><br><span class="line">        <span class="type">Lady</span> <span class="variable">lady</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lady</span>();</span><br><span class="line">        lady.showInfosPetCat(cat);<span class="comment">//这里就把对应的对象名(引用类型)传过去</span></span><br><span class="line">        lady.showInfosPetDog(dog);<span class="comment">//这里就把对应的对象名(引用类型)传过去</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题:</p>
<p>&ensp;&ensp;&ensp;&ensp;a）子类中如果需要对属性初始化，如何提供构造方法，想在创建子类的同时就完成对属性初始化操作，如何完成？</p>
<p>&ensp;&ensp;&ensp;&ensp;b）父类中提供了一个吃的方法eat，但是狗与猫之间吃的东西是不同的，需要在狗类中描述狗吃肉，需要在猫类中描述猫吃鱼，父类提供的方法实现就不能满足子类需求了，子类如何处理继承而来方法不能满足子类需求？</p>
<h3 id="4）super关键字"><a href="#4）super关键字" class="headerlink" title="4）super关键字"></a>4）super关键字</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>super关键字，它只能在子类中使用，并且super关键字相当于是提供一个父类的引用</p>
<p>super关键字一共有三个功能：</p>
<p>&ensp;&ensp;&ensp;&ensp;在子类可以通过super关键字调用父类提供成员变量 —》super.父类定义成员变量名</p>
<p>&ensp;&ensp;&ensp;&ensp;在子类可以通过super关键字调用父类提供成员方法 —》 super.父类定义成员方法名(参数赋值);</p>
<p>&ensp;&ensp;&ensp;&ensp;PS：这个操作是最主要的途径</p>
<p>&ensp;&ensp;&ensp;&ensp;在子类的构造方法中调用父类的构造方法来进行属性初始化</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;—》super() 调用就是父类无参构造方法 </p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;—》super(参数赋值) 调用父类的有参构造方法</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;—》必须在子类构造方法的第一句</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>&ensp;&ensp;&ensp;&ensp;a）调用父类的属性</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;如果当子类和父类中没有重名属性时，那么super和this关键字表示的属性是一致的，都是调用父类的</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;如果当子类和父类中有重名属性时，那么 super.属性名 表示：父类的属性，this.属性名 表示：子类的属性</p>
<p>&ensp;&ensp;&ensp;&ensp;b）调用父类的方法</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;如果当子类和父类中没有重名方法时，那么super和this关键字表示的方法是一致的，都是调用父类的</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;如果当子类和父类中有重名方法时，那么 super.方法名 表示：父类的方法，this.方法名 表示：子类的方法</p>
<p>&ensp;&ensp;&ensp;&ensp;c）调用父类的构造方法</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;注意：创建子类对象之前，必须要先创建父类的对象</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;（a）super();调用的是父类的无参构造。是可以完全省略的，省不省略都会执行(建议：保留父类的无参构造)</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;（b）super调用父类的有参构造，要放到构造方法第一行。super和this不能同时出现 	</p>
<p>父类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="type">char</span> gender;</span><br><span class="line">    <span class="comment">//提供构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">char</span> gender)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//提供Get和Set方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">getGender</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGender</span><span class="params">(<span class="type">char</span> gender)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">extends</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        子类继承父类之后，可以得到父类中所有的可见属性和行为【非private】</span></span><br><span class="line"><span class="comment">        子类还可以提供自己独有属性和行为</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        发生继承之后 子类是不可以继承父类构造方法，所以子类需要提供自己的构造方法</span></span><br><span class="line"><span class="comment">        子类依旧要提供有参和无参构造方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Man</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        子类的有参构造方法如何提供，子类的构造方法一般会将从父类得到属性和子类的属性都进行创建对象</span></span><br><span class="line"><span class="comment">初始化</span></span><br><span class="line"><span class="comment">        所以建议在子类构造方法中 提供父类得到属性和子类的属性同一操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Man</span><span class="params">(String name, <span class="type">char</span> gender,<span class="type">int</span> age)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如何对父类初始化呢？ --&gt; 使用父类中提供set方法对父类属性初始化</span></span><br><span class="line">        <span class="comment">// setName(name); //问题在于 如果属性过多，子类构造方法就要大量调用set方法</span></span><br><span class="line">        <span class="comment">//此时就可以使用super关键字调用父类的构造方法来辅助子类初始化继承属性</span></span><br><span class="line">        <span class="comment">//super(); //调用无参构造方法</span></span><br><span class="line">        <span class="built_in">super</span>(name,gender);<span class="comment">// 调用父类的有参构造方法</span></span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            PS：非常推荐使用这种方式进行属性初始化操作，简便易懂其他开发人员如何查看你编写代码</span></span><br><span class="line"><span class="comment">            发现这个构造方法时，就可以知道那些属性是父类提供【super关键字初始化】，那些属性</span></span><br><span class="line"><span class="comment">是子类提供【使用this】</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125; </span><br><span class="line">        <span class="comment">//成员方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//调用父类中属性</span></span><br><span class="line">        System.out.println(<span class="built_in">super</span>.gender);</span><br><span class="line">        <span class="comment">//调用父类中成员方法</span></span><br><span class="line">        <span class="built_in">super</span>.getGender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：super关键字在子类中最大作用就是调用父类的构造方法，辅助子类完成属性初始化</p>
<p>this关键字与Super关键字的不同？</p>
<ol>
<li>this关键字可以使用在任何类中，并且可以作为方法参数传递</li>
<li>super关键字只能使用在子类中，并且不可以作为方法参数传递</li>
<li>this关键字代表的是当前对象， super关键字代表的是父类对象的引用</li>
</ol>
<h3 id="5）方法重写"><a href="#5）方法重写" class="headerlink" title="5）方法重写"></a>5）方法重写</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>&ensp;&ensp;&ensp;&ensp;当父类提供成员方法实现，无法满足子类需求时，子类可以在本类中提供父类成员方法重新实现的操作，子类中有与父类相同签名的方法 称之为 方法重写 </p>
<p>&ensp;&ensp;&ensp;&ensp;相同签名：方法名相同、参数相同、返回值相同、	访问修饰符（子类要比父类更宽泛(看上面表格)）</p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>&ensp;&ensp;&ensp;&ensp;因为父类的方法无法满足子类的需求，所以需要重写父类的方法 </p>
<p>&ensp;&ensp;&ensp;&ensp;子类方法重写的格式：子类中出现重写父类方法操作是，父类方法如何定义，子类方法就如何定义，只是子类将原有方法的实现重新完成(重写方法名回车)</p>
<p>&ensp;&ensp;&ensp;&ensp;一旦子类发生重写父类方法之后，外界在调用方法必然执行子类重写之后的方法，无法在调用到父类原有方法</p>
<p>PS：非要看到父类方法的原有实现：</p>
<p>&ensp;&ensp;&ensp;&ensp;外界方式实现即在子类外部查看：提供父类对象创建，并使用父类对象调用方法【极少使用】</p>
<p>&ensp;&ensp;&ensp;&ensp;内界方法实现即在子类内部查看：使用super关键字调用父类原有方法即可</p>
<h4 id="注解：-Override"><a href="#注解：-Override" class="headerlink" title="注解：@Override"></a>注解：@Override</h4><p>&ensp;&ensp;&ensp;&ensp;建议在重写方法的时候，加上注解</p>
<p>&ensp;&ensp;&ensp;&ensp;作用：检测是否是满足方法重写。必须满足重写的要求，否则报错</p>
<p>&ensp;&ensp;&ensp;&ensp;注意：父类中的是私有方法，子类无法重写（私有方法不能被继承，所以不能被重写）</p>
<p>&ensp;&ensp;&ensp;&ensp;需求: 创建一个父类鸟类（Brid），父类就提供一个方法fly，在创建两个子类麻雀类和鸵鸟类</p>
<p>父类鸟类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bird</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供一个飞翔方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;可以飞翔&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类麻雀</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sparrow</span> <span class="keyword">extends</span> <span class="title class_">Bird</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//子类可以得到父类提供公有fly方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类鸵鸟</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ostich</span> <span class="keyword">extends</span> <span class="title class_">Bird</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//子类可以得到父类提供公有fly方法</span></span><br><span class="line">    <span class="comment">//提供对父类fly方法重写操作【最简单的原则，父类方法如何定义，</span></span><br><span class="line">    <span class="comment">// 子类重写时就如何定义，只要提供不同的实现即可】</span></span><br><span class="line">    <span class="comment">//这就是当前子类重写父类方法的操作定义</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//注解，作用就是提供给编译器说明子类有重写父类方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// super.fly(); ---》 这种方式就可以调用到父类方法的原有实现</span></span><br><span class="line">        <span class="comment">//只需要在这个方法中提供子类自己实现方式即可---》 重写</span></span><br><span class="line">        System.out.println(<span class="string">&quot;我不会飞，但是跑的很快！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Sparrow</span> <span class="variable">sparrow</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sparrow</span>();</span><br><span class="line">        <span class="type">Ostich</span> <span class="variable">ostich</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ostich</span>();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            麻雀可以飞翔是没问题的，但是鸵鸟是不会飞的，所以如果鸵鸟这个对象调用</span></span><br><span class="line"><span class="comment">            fly方法打印出可以“可以飞翔”和明显不符合要求的</span></span><br><span class="line"><span class="comment">            触发了一个原则，父类提供方法无法满足子类需求，子类可以重写父类方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        sparrow.fly();</span><br><span class="line">        <span class="comment">//子类一旦重写父类方法之后在调用方法，必然是子类重写之后的实现啊</span></span><br><span class="line">        ostich.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="重写完成要求："><a href="#重写完成要求：" class="headerlink" title="重写完成要求："></a>重写完成要求：</h4><ol>
<li><p>若<strong>父类的方法使用private、static或final修饰中任意一个修饰符修饰，那么子类都不可以重写这个方法</strong></p>
</li>
<li><p>重写方法必须所有继承关系，没有继承关系两个类是不可以重写对方方法</p>
</li>
<li><p>重写成员成员方法方法签名必须相同【方法签名&#x3D;方法名+参数列表】</p>
</li>
<li><p>子类重写父类方法是，提供原有父类方法返回值类型的子类类型或同类型</p>
</li>
<li><p>在重写时，子类提供方法访问权限修饰符要大于等于父类的方法权限修饰符</p>
</li>
<li><p>在重写时,父类的方法提供异常类抛出，子类提供异常类型必须相同类型或子类类型</p>
</li>
</ol>
<h4 id="方法重载与方法重写的区别"><a href="#方法重载与方法重写的区别" class="headerlink" title="方法重载与方法重写的区别"></a>方法重载与方法重写的区别</h4><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">位置</th>
<th align="center">方法名</th>
<th align="center">返回值类型</th>
<th align="center">参数列表</th>
<th align="center">访问修饰符</th>
</tr>
</thead>
<tbody><tr>
<td align="center">方法重载</td>
<td align="center">本类</td>
<td align="center">一致</td>
<td align="center">无关</td>
<td align="center">不一致</td>
<td align="center">无关</td>
</tr>
<tr>
<td align="center">方法重写</td>
<td align="center">子类</td>
<td align="center">一致</td>
<td align="center">一致</td>
<td align="center">一致</td>
<td align="center">子类更宽</td>
</tr>
</tbody></table>
<h4 id="继承中子类实例化过程"><a href="#继承中子类实例化过程" class="headerlink" title="继承中子类实例化过程"></a>继承中子类实例化过程</h4><p>&ensp;&ensp;&ensp;&ensp;PS:在Java中继承实例化过程是遵守现实客观规律，现实生活中一定是先有你父亲再有你</p>
<p>父类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;父类的无参构造方法调用&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类的有参构造方法调用&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供子类构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类的无参构造按方法被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//使用set方法对age进行</span></span><br><span class="line">        setAge(age);</span><br><span class="line">        System.out.println(<span class="string">&quot;子类的有参构造方法被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//分别使用子类的无参和有参构造方法创建对象</span></span><br><span class="line">        <span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">        <span class="type">Son</span> <span class="variable">son1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;发生子类继承父类之后，在创建子类对象过程时，<strong>是先调用父类无参构造方法，然后再调用子类的构造方法创建对象，先创建父类的对象，在创建子类对象，继承之后子类的实例化过程</strong></p>
<p><strong>&ensp;&ensp;&ensp;&ensp;子类的构造方法中【会默认调用父类无参构造方法】，所以父类要提供无参构造方法，让子类只可以正确的创建对象</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;某些情况下缺失父类忘记了提供无参构造方法，但是提供其他的构造方法，是否可以辅助子类构造对象呢？ —》 可以，如果父类没有明确提供无参构造方法，但是<strong>提供其他的有参构造方法，子类只需要在本类中构造方法位置明确调用父类的构造方法即可—》使用super关键字</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;子类实例化完整说明：子类在继承父类之后，<strong>子类中提供构造方法是默认调用父类无参构造方法来辅助创建对象，若父类没有明确提供无参构造方法，可以使用super关键调用父类其他的构造方法在子类构造方法中辅助创建对象，所以子类对象创建一定是先创建父类对象，在创建子类对象</strong></p>
<h4 id="子类继承父类之后内存存储"><a href="#子类继承父类之后内存存储" class="headerlink" title="子类继承父类之后内存存储"></a>子类继承父类之后内存存储</h4><p>&ensp;&ensp;&ensp;&ensp;继承体系内存图原理–》父类的空间优于子类对象产生</p>
<p>&ensp;&ensp;&ensp;&ensp;在每次创建子类对象时，先初始化父类空间，在创建其子类对象本身，目的在与子类对象中包含了其对应的父类空间，便可以包含父类的成员，如果父类成员非private修饰，则子类可以随意使用父类成员，代码体现在子类的构造方法调用时，是默认调用父类无参构造方法的</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271926956.WebP" alt="子类继承父类之后内存存储"></p>
<p>&ensp;&ensp;&ensp;&ensp;当子类调用方法的原则时，优先扫描子类中是否存在当前方法【定义和重写的】，如果子类存在这方法就调用子类方法，如果子类不存在次方法到调用父类方法</p>
<p>&ensp;&ensp;&ensp;&ensp;如果子类中出现与父类中重名属性，是不存在【属性重写概念】，对象执行调用时，优先扫描子类中所存在属性，如果子类定义类就获取子类属性，如果子类中没有扫描父类中继承而来属性</p>
<h2 id="3、多态"><a href="#3、多态" class="headerlink" title="3、多态"></a><center>3、多态</center></h2><h3 id="1）定义"><a href="#1）定义" class="headerlink" title="1）定义"></a>1）定义</h3><p>&ensp;&ensp;&ensp;&ensp;多态在Java中定义原则：同一个事物被不同对象所触发，得到结果不同就称之为多态</p>
<p>&ensp;&ensp;&ensp;&ensp;在生活中，比如跑的动作，小猫、小狗和大象，跑去起来都是不一样的，再比如飞的动作，昆虫、鸟和飞机，飞起来也是不一样的，所以可见，同一个行为，通过不同事物，可以体现出不同的行为，这就是多态的描述</p>
<p>在现实生活中家里饲养了一些宠物</p>
<p>&ensp;&ensp;&ensp;&ensp;养了宠物狗： 叫声 —-》 汪汪汪</p>
<p>&ensp;&ensp;&ensp;&ensp;养了宠物猫： 叫声 —-》 喵喵喵</p>
<p>在Java中将多态体现在代码中行为有哪些？</p>
<p>【方法多态】：方法多态的体现就是“重载”,同一个方法被不同参数所触发，得到方法的结果不同就是方法多态</p>
<p>【对象多态】：同一个方法，对不同对象触发可以得到不用表现形式</p>
<p><strong>&ensp;&ensp;&ensp;&ensp;发生对象多态有一个必要前提</strong>：<strong>必须存在【继承或实现】关系</strong>、需要有子类重写方法的实现【可以让多态先更加完善】</p>
<p>&ensp;&ensp;&ensp;&ensp;对象多态中对于我们开发而言最主要的就是【里氏代转换原则】，通过这个原则可以发挥多态最大效力</p>
<h3 id="里氏代转换原则"><a href="#里氏代转换原则" class="headerlink" title="里氏代转换原则"></a>里氏代转换原则</h3><p>&ensp;&ensp;&ensp;&ensp;里氏代转换原则在程序最主要体现就是提供了【子类与父类之间的转换操作】，这里这个操作就可以动态概念改变当前对象，从而满足不同开发需求</p>
<p>&ensp;&ensp;&ensp;&ensp;如果要体现里氏代转换原则，是有一个必要前提【需要存在【继承或实现】关系】</p>
<p>&ensp;&ensp;&ensp;&ensp;即类与类之间必须是继承关系 类与接口之间是实现关系</p>
<p>&ensp;&ensp;&ensp;&ensp;没有任何联系的类是无法完成这个操作</p>
<p>&ensp;&ensp;&ensp;&ensp;例如： 类Dog和类Person，这两两个类都是独立的，那么Dog类和Person了就不能完成里氏代转换原则</p>
<h3 id="2）特点"><a href="#2）特点" class="headerlink" title="2）特点"></a>2）特点</h3><p>&ensp;&ensp;&ensp;&ensp;编译看左边，运行看右边</p>
<p>&ensp;&ensp;&ensp;&ensp;如果发生多态，那么无法调用子类独有的方法（编译看左边（左边是父类））</p>
<p>&ensp;&ensp;&ensp;&ensp;如果发生多态，那么调用的一定是子类重写的方法（运行看右边）</p>
<h3 id="3）多态产生条件"><a href="#3）多态产生条件" class="headerlink" title="3）多态产生条件"></a>3）多态产生条件</h3><p>&ensp;&ensp;&ensp;&ensp;（1）必须要有继承</p>
<p>&ensp;&ensp;&ensp;&ensp;（2）必须要有方法重写</p>
<p>&ensp;&ensp;&ensp;&ensp;（3）必须要父类的引用指向子类的对象</p>
<h3 id="4）向上向下转型"><a href="#4）向上向下转型" class="headerlink" title="4）向上向下转型"></a>4）向上向下转型</h3><p><strong>&ensp;&ensp;&ensp;&ensp;向上转型</strong>：父类引用指向子类对象</p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父类类型 对象名字 = <span class="keyword">new</span> 子类类型();</span><br></pre></td></tr></table></figure>

<p>此时这个类子类就会被默认提升为父类类型，当前对象只能调用父类中提供属性和行为，无法调用子类中提供自有属性和行为</p>
<p>PS：这也是开发中唯一创建父类对象一种方式，不会使用父类直接创建对象</p>
<p>【即 父类类型 对象名 &#x3D; new 父类类型();】</p>
<p><strong>&ensp;&ensp;&ensp;&ensp;向下转型</strong>：将父类引用强转成子类类型</p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">子类类型 对象名 = (子类类型)提升为父类类型对象;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;此时这个对象就会被转换为原来子类类型，当前对象即可以调用父类中提供可见属性和行为，也可以调用子类自有属性和行为</p>
<p>&ensp;&ensp;&ensp;&ensp;如果发生多态，那么无法调用子类独有的方法。如果要调用子类独有的方法，那么必须发生向下转型，前提是先发生过向上转型，否则会报错</p>
<h3 id="5）instanceOf关键字"><a href="#5）instanceOf关键字" class="headerlink" title="5）instanceOf关键字"></a>5）instanceOf关键字</h3><p>&ensp;&ensp;&ensp;&ensp;可以利用instanceof这个关键字检查 提升之后对象是否是某一个子类类型对象即【当前提升之后对象是否属于某个子类类型】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">    提升之后对象 <span class="keyword">instanceof</span> 子类类型</span><br><span class="line">    </span><br><span class="line">上面这个表达式就会帮组你判断，提升之后对象是否属于但当前提供子类类型</span><br><span class="line">    返回值为 <span class="literal">true</span> 【证明当前对象是由当前子类类型提升而来】</span><br><span class="line">            <span class="literal">false</span> 【证明当前对象不是当前子类类型提升而来】</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类动物类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name, String gender)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGender</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGender</span><span class="params">(String gender)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//子类狗类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name,String gender,<span class="type">int</span> age)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(name,gender);</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//子类猫类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String kind;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String name, String gender, String kind)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(name,gender);</span><br><span class="line">        <span class="built_in">this</span>.kind = kind;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getKind</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> kind;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setKind</span><span class="params">(String kind)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.kind = kind;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.提供对象向上转型</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            父类引用可以接收一个子类的引用</span></span><br><span class="line"><span class="comment">            此时会将Dog类型对象提升为父类Animal类型</span></span><br><span class="line"><span class="comment">            此时只能调用父类中属性和行为，不能调用子类自己属性和行为</span></span><br><span class="line"><span class="comment">            如果子类重写父类的方法，提升之后对象调用方法执行时，依旧执行子类重写效果</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        animal.getName();</span><br><span class="line">        <span class="comment">//animal.getAge(); //getAge方法是子类自身的，并不是父类的</span></span><br><span class="line">        <span class="comment">//2.提供对象向下转型</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            将一个提升为父类类型对象转换为原有子类类型操作就叫做对象向下转型</span></span><br><span class="line"><span class="comment">            此时会将提升之后父类对象animal转换为原有子类类型Dog</span></span><br><span class="line"><span class="comment">            转型之后不仅可以调用子类的属性和方法，而且也可以调用父类属性和方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog)animal;</span><br><span class="line">        dog.getName();</span><br><span class="line">        dog.getAge();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对象向下转型会存在一个问题，如果转型失败会出现一个异常问题，而这个问题不会在编译阶段进行提示只能在运行时提示</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//此时明显animal是Dog类型提升的，并不是Cat，所以这个操作是有问题，但是编译阶段是不会提示错误</span></span><br><span class="line">        <span class="comment">//系统就会提示 ClassCastException --&gt; 强制类型转换异常</span></span><br><span class="line">        <span class="comment">// Cat cat = (Cat)animal;</span></span><br><span class="line">        <span class="comment">//所以为了避免这个问题发生，可以使用instanceof这个关键字进行转换对象判断</span></span><br><span class="line">        <span class="keyword">if</span>(animal <span class="keyword">instanceof</span> Cat)</span><br><span class="line">        &#123; <span class="comment">//判断animal对象是否是Cat类型对象 ---》 true 是 / false 不是</span></span><br><span class="line">            <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (Cat)animal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;animal不是Cat类型无法进行对象向下转型&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;综上所述：在进行对象向下转型时，为了保证对象可以正确转换到对应子类类型中，建议使用instanceof关键字进行，对象子类类型检查，在进行检查时会配合if语句使用，如果检查成功就会在if语句执行代码中进行向下转型操作，使用仅限在if大括号内部，提高范围使用就建议将对象声明定义在if语句外部</p>
<p>&ensp;&ensp;&ensp;&ensp;PS：在实际开发，如果你能确定子类类型是什么，那么就不写instanceof操作</p>
<p>&ensp;&ensp;&ensp;&ensp;以上这些就是多态的一些操作点和概念,多态主要就是提供可扩展和可维护性,好处就可以利用多态让方法使用起来更加高效(子类类型都可以),可以辅助抽象类和接口创建对象,弊端在于如果利用父类作为方法参数类型或返回值类型的时候,返回和接受的属性都会被向上转型为父类类型,子类的自己的属性和方法就不能调用,这样会牺牲一部分灵活性,如何弥补就是向下转型</p>
<h3 id="6）多态的引用场景"><a href="#6）多态的引用场景" class="headerlink" title="6）多态的引用场景"></a>6）多态的引用场景</h3><p>&ensp;&ensp;&ensp;&ensp;（1）方法的参数</p>
<p>&ensp;&ensp;&ensp;&ensp;（2）方法的返回值</p>
<p>例：</p>
<p>设计一个员工类，其中有计算员工薪水方法，根据不同的员工计算薪水的方法不同</p>
<p>&ensp;&ensp;&ensp;&ensp;员工类型 薪水构成</p>
<p>&ensp;&ensp;&ensp;&ensp; &#x3D;&#x3D; &#x3D;&#x3D; &#x3D;&#x3D; &#x3D;&#x3D; &#x3D;&#x3D; &#x3D;&#x3D; &#x3D;&#x3D; &#x3D;&#x3D; &#x3D;&#x3D; &#x3D;&#x3D;&#x3D;</p>
<p>&ensp;&ensp;&ensp;&ensp;经理 底薪+奖金</p>
<p>&ensp;&ensp;&ensp;&ensp;销售人员 底薪+提成</p>
<p>&ensp;&ensp;&ensp;&ensp;普通员工 底薪+补贴</p>
<p>设计一个测试类，场景如下，年终，领导找员工谈话，让员工介绍介绍自己的薪水</p>
<p>分析：</p>
<ol>
<li>在公司除了老板都是员工，经理、销售、普通员工都是员工</li>
<li>既然这三者【经理、销售、普通员工】都是员工，可以根据他们共有属性和行为提供一个统一父类</li>
<li>分别在使用这三者【经理、销售、普通员工】进行与父类至今继承关系从而到需要属性和行为</li>
<li>设一个方法年终领导让员工介绍自己，如果没有多态之前，三个员工就需要提供是三个自我介绍方法【公司员工暴增300人，又到一年年末自我介绍 —》提供300个方法（方法管理与维护都是十分麻烦）】，此时可以将方法提供为最大通用性，只提供一个方法进行员工介绍， 利用多态的特点，将参数设计为父类类型，这样一来只要继承父类员工类，都可以进入到这个方法中进行执行操作</li>
</ol>
<p>员工父类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供共有的属性和行为</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> money; 		<span class="comment">//底薪</span></span><br><span class="line">    <span class="keyword">private</span> String name;	<span class="comment">//员工姓名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(<span class="type">int</span> money, String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMoney</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoney</span><span class="params">(<span class="type">int</span> money)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">        经理、普通员工和销售都有自己计算薪水方法</span></span><br><span class="line"><span class="comment">        父类中提供一个方法，让子类来进行重写操作</span></span><br><span class="line"><span class="comment">        因为这个方法必然被子类重写，所以就不提供具体实现，由子类自己进行重写操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showMoney</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类经理类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> jiangjin;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">(<span class="type">int</span> money, String name, <span class="type">int</span> jiangjin)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(money, name);</span><br><span class="line">        <span class="built_in">this</span>.jiangjin = jiangjin;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getJiangjin</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> jiangjin;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setJiangjin</span><span class="params">(<span class="type">int</span> jiangjin)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.jiangjin = jiangjin;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//提供介绍字节薪水的方式</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showMoney</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(getName()+<span class="string">&quot;是经理,底薪：&quot;</span> + getMoney()+<span class="string">&quot; 奖金：&quot;</span></span><br><span class="line">                        +jiangjin+<span class="string">&quot; 综合工资：&quot;</span>+</span><br><span class="line">(getMoney()+jiangjin));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类销售类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sales</span> <span class="keyword">extends</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> ticheng;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sales</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sales</span><span class="params">(<span class="type">int</span> money, String name, <span class="type">int</span> ticheng)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(money, name);</span><br><span class="line">        <span class="built_in">this</span>.ticheng = ticheng;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getticheng</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">return</span> ticheng;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setticheng</span><span class="params">(<span class="type">int</span> ticheng)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.ticheng = ticheng;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//提供介绍字节薪水的方式</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showMoney</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(getName()+<span class="string">&quot;是销售,底薪：&quot;</span></span><br><span class="line">        +getMoney()+<span class="string">&quot; 奖金：&quot;</span>+ticheng+<span class="string">&quot; 综合工资：&quot;</span>+(getMoney()+ticheng));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类普通员工类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Staff</span> <span class="keyword">extends</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> butie;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Staff</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Staff</span><span class="params">(<span class="type">int</span> money, String name, <span class="type">int</span> butie)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(money, name);</span><br><span class="line">        <span class="built_in">this</span>.butie = butie;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getbutie</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> butie;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setbutie</span><span class="params">(<span class="type">int</span> butie)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.butie = butie;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//提供介绍字节薪水的方式</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showMoney</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(getName()+<span class="string">&quot;是普通员工,底薪：&quot;</span></span><br><span class="line">            +getMoney()+<span class="string">&quot; 奖金：&quot;</span>+butie+<span class="string">&quot; 综合工资：&quot;</span>+(getMoney()+butie));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Boss测试类进行员工信息测试操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BossTest</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//提供老板、经理、销售和普通员工对象进行操作</span></span><br><span class="line">        <span class="type">BossTest</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BossTest</span>();</span><br><span class="line">        <span class="type">Manager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>(<span class="number">1000</span>,<span class="string">&quot;张三&quot;</span>,<span class="number">2000</span>);</span><br><span class="line">        <span class="type">Sales</span> <span class="variable">sales</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sales</span>(<span class="number">100</span>,<span class="string">&quot;大宝&quot;</span>,<span class="number">10000</span>);</span><br><span class="line">        <span class="type">Staff</span> <span class="variable">staff</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Staff</span>(<span class="number">10000</span>,<span class="string">&quot;李四&quot;</span>,<span class="number">200000</span>);</span><br><span class="line">        <span class="comment">//普通实现</span></span><br><span class="line">        <span class="comment">// boss.showInfosManager(manager);</span></span><br><span class="line">        <span class="comment">// boss.showInfosSales(sales);</span></span><br><span class="line">        <span class="comment">// boss.showInfosStaff(staff);</span></span><br><span class="line">        <span class="comment">//利用多态的对象向上转型操作，方法中参数是父类类型，他可以接收当前这个父类类型的所有子类引用</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时 方法参数类型是Employee父类类型 参数赋值是 子类类型manager</span></span><br><span class="line"><span class="comment">            所以参数赋值时就形成了 Employee employee = manager 即 Employee employee =</span></span><br><span class="line"><span class="comment">new Manager(1000,&quot;张三&quot;,2000);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        boss.showInfosEmployee(manager);</span><br><span class="line">        boss.showInfosEmployee(sales);</span><br><span class="line">        boss.showInfosEmployee(staff);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//在不使用多态的前提下【如果不使用多态就会面临一个问题，如果员工个数增加了，这里就需要添加多个方法】</span></span><br><span class="line">    <span class="comment">// 随着员工增加与删减，这样我们方法所在类就会被进行频繁的修改，这样并不利于方法管理与维护</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showInfosManager</span><span class="params">(Manager manager)</span></span><br><span class="line">    &#123;</span><br><span class="line">        manager.showMoney();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showInfosSales</span><span class="params">(Sales sales)</span></span><br><span class="line">    &#123;</span><br><span class="line">        sales.showMoney();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showInfosStaff</span><span class="params">(Staff sales)</span></span><br><span class="line">    &#123;</span><br><span class="line">        sales.showMoney();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">        多态的就出现了，可以利用多态的特点将多态进行方法参数或返回值类型设置，这样就可以提高代码的通</span></span><br><span class="line"><span class="comment">用性和重用性</span></span><br><span class="line"><span class="comment">        此时并不需要设置多个方法，只需要提供一个方法，方法参数设置为父类类型</span></span><br><span class="line"><span class="comment">        利用多态中对象向上转型操作，就可以得到具体实现</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showInfosEmployee</span><span class="params">(Employee employee)</span></span><br><span class="line">    &#123;</span><br><span class="line">        employee.showMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="知识点十：三个修饰符"><a href="#知识点十：三个修饰符" class="headerlink" title="知识点十：三个修饰符"></a><center>知识点十：三个修饰符</center></h1><h2 id="1、abstract关键字"><a href="#1、abstract关键字" class="headerlink" title="1、abstract关键字"></a><center>1、abstract关键字</center></h2><h3 id="1）含义-1"><a href="#1）含义-1" class="headerlink" title="1）含义"></a>1）含义</h3><p>抽象的</p>
<h3 id="2）抽象类含义：被abstract修饰的类称之为抽象类"><a href="#2）抽象类含义：被abstract修饰的类称之为抽象类" class="headerlink" title="2）抽象类含义：被abstract修饰的类称之为抽象类"></a>2）抽象类含义：被abstract修饰的类称之为抽象类</h3><p>特点：</p>
<ol>
<li>抽象类不能直接创建对象，即不能通过new 抽象类类名()的方式完成，因为抽象类中会存在抽象方法，这个抽象方法没有方法体，如果抽象类可以使用new 抽象类类名()的方式完成，那么抽象类和抽象方法就没有存在的意义了</li>
<li>抽象类中是可以选择性包含抽象方法的，如果包含了抽象方法的抽象类被子类继承时，子类需要重写抽象父类中抽象方法【其他的成员方法也可以选择性重写】，如果没有包含抽象方法的抽象类被子类继承时，子类可以选择性重写其他方法</li>
<li>抽象类提供目的是为了保证父类的完成操作的前提下，让父类具备一些其他功能【抽象方法和防止直接创建对象】，所以抽象类需要提供构造方法</li>
<li>抽象类的提供就是为了让子类继承而提供的，所以抽象类是允许多态概念的使用</li>
</ol>
<p>作用：</p>
<p>&ensp;&ensp;&ensp;&ensp;抽象类定义方式其实就是父类的定义方法，会在抽象类中提供所有父类的操作，抽象类在类中主要的作用就是作为父类存在</p>
<p>PS:抽象类就是一个特殊父类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法格式：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> class 类名    <span class="comment">//这个类就是抽象类</span></span><br><span class="line">&#123; </span><br><span class="line">    父类如何定义，抽象类的内部就如何定义</span><br><span class="line">    成员变量</span><br><span class="line">    构造方法</span><br><span class="line">    成员方法</span><br><span class="line">    静态变量</span><br><span class="line">    静态方法</span><br><span class="line">    方法重写</span><br><span class="line">    抽象方法</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//抽象类就是多了一个abstract关键字的父类</span></span><br></pre></td></tr></table></figure>

<p>PS：建议在以后开发中，<strong>如果确定这个类是一个父类就建议优先声明成“抽象类”</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;抽象类可以像普通类一样使用可以继承，可以实现，可以定义类中所有定义的东西，但是就是不允许直接创建抽象类对象【即 抽象类类名 对象 &#x3D; new 抽象类类名();】,抽象类是它支持多态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建抽象类葵花宝典</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SunflowerBible</span> </span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3）抽象方法"><a href="#3）抽象方法" class="headerlink" title="3）抽象方法"></a>3）抽象方法</h3><p>含义：使用abstract关键字修饰并且没有方法体，存在在抽象类中叫做抽象方法</p>
<p>特点：</p>
<p>&ensp;&ensp;&ensp;&ensp;（1）抽象方法必须出现在抽象类中</p>
<p>&ensp;&ensp;&ensp;&ensp;（2）抽象方法不能有方法体（方法的实现{}）并且在小括号后面添加【;】</p>
<p>&ensp;&ensp;&ensp;&ensp;（3）抽象方法必须要在非抽象子类中重写</p>
<p>&ensp;&ensp;&ensp;&ensp;（4）抽象方法修饰符不能使用private、static和final，只要使用这三个修饰符，这个方法就无法在进行重写实现了，所以就失去抽象方法的目的了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象方法的格式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> 返回值类型 方法名(参数列表);</span><br></pre></td></tr></table></figure>

<p>抽象类和抽象方法什么时候用？</p>
<p>&ensp;&ensp;&ensp;&ensp;抽象类我们一般用比较少，未来更多是使用接口</p>
<p>&ensp;&ensp;&ensp;&ensp;在接口中全部都是抽象方法，抽象方法的作用就是为了让子类去重写</p>
<p>练习：</p>
<p>&ensp;&ensp;&ensp;&ensp;设计一个公司抽象类，具有抽象方法 – 营业，休息</p>
<p>&ensp;&ensp;&ensp;&ensp;设计一个快递公司类作为公司类的子类</p>
<p>&ensp;&ensp;&ensp;&ensp;设计一个顺丰快递类，作为快递类的子类</p>
<p>&ensp;&ensp;&ensp;&ensp;需求：实例化一个顺丰快递的对象，从控制台录入一个24以内的数据，如果数据在8~18点之间，顺丰营业。否则，顺丰快递公司休息</p>
<p>提供一个公司的抽象类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Company</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String companyName;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Company</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Company</span><span class="params">(String companyName)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.companyName = companyName;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCompanyName</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> companyName;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCompanyName</span><span class="params">(String companyName)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.companyName = companyName;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//营业的抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//休息的抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>快递公司在需求中并没有做任何特殊说明</p>
<p>此时可以将这个类作为一个抽象类</p>
<p>使用一个抽象类继承与另外一个抽象类，当前这个抽象子类可以选择性实现或者不实现抽象父类中抽象方法</p>
<p>不是先父类抽象方法原因，是因为这个也是抽象类，也可以存储抽象方法所以抽象子类可以选择性实现抽象方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CourierServicesCompany</span> <span class="keyword">extends</span> <span class="title class_">Company</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CourierServicesCompany</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CourierServicesCompany</span><span class="params">(String companyName)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(companyName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顺丰快递公司子类</p>
<p>如果使用一个普通类继承与抽象类，必须实现抽象类中所提供抽象方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SFCompany</span> <span class="keyword">extends</span> <span class="title class_">CourierServicesCompany</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SFCompany</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SFCompany</span><span class="params">(String companyName)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(companyName);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(getCompanyName()+<span class="string">&quot;正在营业，欢迎光临.....&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    System.out.println(getCompanyName()+<span class="string">&quot;下班休息，下次再来.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Test类（测试类）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入时间:&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">time</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">        <span class="type">SFCompany</span> <span class="variable">sfCompany</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SFCompany</span>(<span class="string">&quot;顺丰快递&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(time &gt;= <span class="number">8</span> &amp;&amp; time &lt;= <span class="number">18</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sfCompany.open();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            sfCompany.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、static关键字"><a href="#2、static关键字" class="headerlink" title="2、static关键字"></a><center>2、static关键字</center></h2><h3 id="1）含义-2"><a href="#1）含义-2" class="headerlink" title="1）含义"></a>1）含义</h3><p>静态的</p>
<h3 id="2）作用"><a href="#2）作用" class="headerlink" title="2）作用"></a>2）作用</h3><p>修饰：成员变量、成员方法、成员变量、代码块、内部类</p>
<h3 id="3）静态和成员之间的区别"><a href="#3）静态和成员之间的区别" class="headerlink" title="3）静态和成员之间的区别"></a>3）静态和成员之间的区别</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402271926050.WebP" alt="静态和成员之间的区别"></p>
<h3 id="4）static修饰成员变量"><a href="#4）static修饰成员变量" class="headerlink" title="4）static修饰成员变量"></a>4）static修饰成员变量</h3><p>&ensp;&ensp;&ensp;&ensp;当 static 关键字修饰成员变量时，该变量被称为静态变量【类变量】,该类的<strong>每个对象都对这个变量是共享的状态</strong>，任何对象都可以改变静态变量中存储的数据，改变之后其他对象将修改之后值，但可以在不创建该类对象化的前提下操作这个静态变量【这个才是正确操作方式】当 static 关键字修饰成员变量时，该变量被称为静态变量【类变量】,该类的每个对象都对这个变量是共享的状态，任何对象都可以改变静态变量中存储的数据，改变之后其他对象将修改之后值，但可以在不创建该类对象化的前提下操作这个静态变量【这个才是正确操作方式】</p>
<p>定义方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问权限修饰符 <span class="keyword">static</span> 数据类型 变量名;</span><br></pre></td></tr></table></figure>

<p>访问方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不推荐方式 ---》 对象.静态变量名</span><br><span class="line">推荐方式 ---》如果是在当前类中访问本类的静态变量 ---》静态变量名</span><br><span class="line">        ---》如果是在其他类中访问类的静态变量 ---》 类名.静态变量名</span><br></pre></td></tr></table></figure>

<p>演示案例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChinesePeople</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提供两个变量一个成员变量和静态变量</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">static</span> String country;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//在不同类中访问静态变量[静态变量是存在默认值]</span></span><br><span class="line">        System.out.println(ChinesePeople.country);</span><br><span class="line">        <span class="comment">// 所有静态变量存储在类所创建对象都是共享这个静态变量</span></span><br><span class="line">        <span class="type">ChinesePeople</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChinesePeople</span>();</span><br><span class="line">        p1.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            可以通过对象.静态变量方式访问静态变量的，但是推荐推荐</span></span><br><span class="line"><span class="comment">            IDEA提示的警告信息：</span></span><br><span class="line"><span class="comment">            Static member &#x27;com.qfedu.Static.ChinesePeople.country&#x27; accessed via</span></span><br><span class="line"><span class="comment">            instance reference</span></span><br><span class="line"><span class="comment">            不建议的</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        p1.country = <span class="string">&quot;中国&quot;</span>;</span><br><span class="line">        <span class="type">ChinesePeople</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChinesePeople</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;p2这个对象的国籍：&quot;</span>+p2.country);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5）static修饰成员方法"><a href="#5）static修饰成员方法" class="headerlink" title="5）static修饰成员方法"></a>5）static修饰成员方法</h3><p>&ensp;&ensp;&ensp;&ensp;被static修饰成员方法被称之为静态方法【类方法】，该静态方法可以使用类名直接调用</p>
<p>语法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">访问权限修饰符 <span class="keyword">static</span> 返回值类型 方法名(参数列表)</span><br><span class="line">&#123;</span><br><span class="line">    执行语句</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不推荐方式 ---》 对象.静态方法名字(参数赋值);</span><br><span class="line">推荐方式 ---》 如果在同一个类中，访问本类定义静态方法时 ---》 静态方法名字(参数赋值);</span><br><span class="line">        ---》 如果在其他类中，访问类中静态方法是 ---》 类名.静态方法名字(参数赋值);</span><br></pre></td></tr></table></figure>

<h4 id="静态方法被使用时注意事项"><a href="#静态方法被使用时注意事项" class="headerlink" title="静态方法被使用时注意事项"></a>静态方法被使用时注意事项</h4><ol>
<li>静态方法中不允许出现this关键字</li>
<li>静态方法中只能直接访问静态变量和其他的静态方法</li>
<li><strong>静态方法中是不可以直接访问成员变量和成员方法</strong></li>
</ol>
<p><strong>&ensp;&ensp;&ensp;&ensp;如果在静态方法中访问成员变量或成员方法，需要创建当前类的对象，通过对象才可以访问</strong></p>
<p>案例演示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticMethod</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//演示类中静态方法</span></span><br><span class="line">    <span class="comment">//提供成员变量和成员方法</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//在成员方法中 访问 成员变量 和成员方法 还有静态变量和静态方法</span></span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(age);</span><br><span class="line">        display();</span><br><span class="line">        <span class="comment">//show(); ---》注释的原则是防止死递归</span></span><br><span class="line">        <span class="comment">//可以使用this和super关键字</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//提供静态变量和静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//在静态方法中 访问 成员变量 和成员方法 还有静态变量和静态方法</span></span><br><span class="line">        System.out.println(age);</span><br><span class="line">        <span class="comment">// display(); ---》注释的原则是防止死递归</span></span><br><span class="line">        <span class="comment">//在静态方法中是不可以直接访问成员变量和方法，不可以使用this和super关键字</span></span><br><span class="line">        <span class="comment">//如果要访问成员变量和成员方法，那么就必须创建对象</span></span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">            System.out.println(name);</span></span><br><span class="line"><span class="comment">            show();</span></span><br><span class="line"><span class="comment">        */</span>        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6）静态代码块"><a href="#6）静态代码块" class="headerlink" title="6）静态代码块"></a>6）静态代码块</h3><h4 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h4><p>&ensp;&ensp;&ensp;&ensp;static可以用于修饰代码块，称之为静态代码块</p>
<p>&ensp;&ensp;&ensp;&ensp;代码块：指的是在程序中出现的一个代码片段，直接使用{}包裹</p>
<p>&ensp;&ensp;&ensp;&ensp;静态代码块：指的是用static修饰的代码块</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>&ensp;&ensp;&ensp;&ensp;静态代码块在类加载的时候自动执行，无需手动调用，代码块会按照先后顺序一次执行，优先于代码块、构造方法执行，静态代码块只会在类加载的时候执行一次（初始化的时候使用）。</p>
<p>PS：利用static修饰代码块来执行一些“耗时的操作”，优先执行</p>
<p>类加载的触发时机</p>
<p>&ensp;&ensp;&ensp;&ensp;（1）创建类的对象时候（new）</p>
<p>&ensp;&ensp;&ensp;&ensp;（2）创建子类对象的时候（先要创建其父类对象）</p>
<p>&ensp;&ensp;&ensp;&ensp;（3）在调用类中的静态属性和静态方法的时候</p>
<p>&ensp;&ensp;&ensp;&ensp;（4）Class类中提供的静态方法 Class.forName() 方法的时候（放射）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticBlock</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StaticBlock</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参构造方法&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">StaticBlock</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">StaticBlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;在普通类定义操作的时候，是很少使用静态的方式来完成，在有开发项目中，通常会需要使用到一些“全局变量”和“全局方法”，这些全局变量和全局方法会被单独定义在一个类中，并且都使用static进行修饰，可以访问外界直接对变量和方法访问，这样类叫做工具类，在创建工具类需要提供一个包util，包中提供工具类的名字 XXXUtil 或 XXXTools</p>
<p>&ensp;&ensp;&ensp;&ensp;像：Arrays就是一个工具类，工具类的特点是类中变量必须是static修饰静态变量，类中方法必须是static修饰静态方法，而且这个类不提供对象创建，这样类就是工具类</p>
<h2 id="3、final关键字"><a href="#3、final关键字" class="headerlink" title="3、final关键字"></a><center>3、final关键字</center></h2><h3 id="1）含义-3"><a href="#1）含义-3" class="headerlink" title="1）含义"></a>1）含义</h3><p>&ensp;&ensp;&ensp;&ensp;不可变，不可改变，最终，不可以修改，修饰关键字主要可以用途修饰【类，变量和方法】</p>
<h3 id="2）作用-1"><a href="#2）作用-1" class="headerlink" title="2）作用"></a>2）作用</h3><p>修饰的类</p>
<p>&ensp;&ensp;&ensp;&ensp;特点：使用final修饰的类不能被继承（太监类）</p>
<p>修饰的方法</p>
<p>&ensp;&ensp;&ensp;&ensp;特点：使用final修饰的方法不能被重写，但是可以被继承</p>
<p>修饰的属性</p>
<p>&ensp;&ensp;&ensp;&ensp;称之为：常量</p>
<p>&ensp;&ensp;&ensp;&ensp;特点：</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1、常量必须要赋值</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;常量的最后赋值时机：</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;a、非静态常量（没有static修饰的）</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1)直接赋值</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;2)在代码块中赋值</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;3)在构造方法中赋值(注意：如果一个类有多个构造方法，那么必须在每一个构造方法中赋值)</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;b、静态常量（使用static修饰的）</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1)直接赋值</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;2)在静态代码块中赋值</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;2、常量不能修改</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;基本类型值不能改变</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;引用类型地址不能改变</p>
<h3 id="使用final修饰符修饰局部变量"><a href="#使用final修饰符修饰局部变量" class="headerlink" title="使用final修饰符修饰局部变量"></a>使用final修饰符修饰局部变量</h3><p>&ensp;&ensp;&ensp;&ensp;局部变量是定义在方法内部变量就是局部变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用final关键字修饰局部变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalVarDemo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            final修饰变量同时并赋值【此时就会定义常量，不可以被修改】</span></span><br><span class="line"><span class="comment">            语法： final 数据类型 变量名(这个变量名要大写代表是常量) = 值</span></span><br><span class="line"><span class="comment">       */</span>                        </span><br><span class="line">        <span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14</span>;</span><br><span class="line">        <span class="comment">//IDEA 错误提示 Cannot assign a value to final variable &#x27;PI&#x27;</span></span><br><span class="line">        <span class="comment">//不能修改使用final修饰PI</span></span><br><span class="line">        <span class="comment">//PI = 3.15;</span></span><br><span class="line">        <span class="comment">//final修饰变量先定义，在赋值【只能赋值一次】</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            final 数据类型 变量名(这个变量名要大写代表是常量);</span></span><br><span class="line"><span class="comment">            变量名(这个变量名要大写代表是常量) = 值;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> age;</span><br><span class="line">        age = <span class="number">18</span>;</span><br><span class="line">        <span class="comment">//IDEA的错误提示 Variable &#x27;age&#x27; might already have been assigned to</span></span><br><span class="line">        <span class="comment">//不允许进行二次赋值</span></span><br><span class="line">        <span class="comment">//age = 20;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用final修饰符修饰成员变量和静态变量"><a href="#使用final修饰符修饰成员变量和静态变量" class="headerlink" title="使用final修饰符修饰成员变量和静态变量"></a>使用final修饰符修饰成员变量和静态变量</h3><p>&ensp;&ensp;&ensp;&ensp;当使用final修饰符修饰完毕之后，就会形成常量，不允许再次修改存储数据</p>
<h3 id="final修饰成员变量"><a href="#final修饰成员变量" class="headerlink" title="final修饰成员变量"></a>final修饰成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalVarDemo2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用final修饰符修饰成员变量</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">FinalVarDemo2</span>().PI);</span><br><span class="line">        <span class="comment">//IDEA错误提示信息Cannot assign a value to final variable &#x27;PI&#x27; 不允许修改这个值</span></span><br><span class="line">        <span class="comment">//new FinalVarDemo2().PI = 3.15;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="final修饰静态变量"><a href="#final修饰静态变量" class="headerlink" title="final修饰静态变量"></a>final修饰静态变量</h3><p>&ensp;&ensp;&ensp;&ensp;这个中修饰方式是比较常见，在一些工具类中或者正常类中定义一个不可以改变量，并且所有对象共享，就可以使用这种方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalVarDemo3</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//final修饰静态变量会变成静态常量</span></span><br><span class="line">    <span class="comment">//一共有两种创建于赋值方式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14</span>;</span><br><span class="line">    <span class="comment">//先定义，在使用静态代码块进行赋值操作</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String STR;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        STR = <span class="string">&quot;字符串&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用final关键字修饰成员方法"><a href="#使用final关键字修饰成员方法" class="headerlink" title="使用final关键字修饰成员方法"></a>使用final关键字修饰成员方法</h3><p>&ensp;&ensp;&ensp;&ensp;使用final关键字修饰成员方法，此时这个方法会变成【最终方法】，此方法不可以被子类重写，但是子类可以继承</p>
<p>&ensp;&ensp;&ensp;&ensp;final关键字修饰成员方法的时机：父类只提供方法继承，但是不允许子类重写就可以使用final关键字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义一个final修饰的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类只能继承不能重写&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//IDEA的错误提示信息 cannot override &#x27;show()&#x27; in &#x27;com.qfedu.Final.Father&#x27;;</span></span><br><span class="line">        <span class="comment">// overridden method is final</span></span><br><span class="line">        <span class="comment">//提示这个方式使用final修饰无法重写，但是允许继承</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://img.picgo.net/2024/08/19/4b247c9cf52c5a9f23c6008ffd35b2387faa57d2ad36eca2.png" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://img.picgo.net/2024/08/19/4b247c9cf52c5a9f23c6008ffd35b2387faa57d2ad36eca2.png" title="头像" alt="头像"></a><div class="post-copyright__author_name">星仔</div><div class="post-copyright__author_desc">珍惜当下 不负此生</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/post/76fa8c0d.html">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/post/76fa8c0d.html')">17.面向对象</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/post/76fa8c0d.html"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=17.面向对象&amp;url=http://example.com/post/76fa8c0d.html&amp;pic=https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402292029940.WebP" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">星仔人生录</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/Java%E8%AF%AD%E8%A8%80/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>Java语言<span class="tagsPageCount">26</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://img.picgo.net/2024/08/18/b00d09a505b4c64d80be90a32eefd8a84d5e1e15395f28e1.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/86a3300e.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402292029940.WebP" onerror="onerror=null;src='https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">16.数组</div></div></a></div><div class="next-post pull-right"><a href="/post/fe7ab1f0.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402292029940.WebP" onerror="onerror=null;src='https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">18.接口</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/post/ca0fcd03.html" title="1.IDEA快捷键"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402292029940.WebP" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-12-30</div><div class="title">1.IDEA快捷键</div></div></a></div><div><a href="/post/6a2c2bbd.html" title="10.转义字符和访问修饰符"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402292029940.WebP" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-12-30</div><div class="title">10.转义字符和访问修饰符</div></div></a></div><div><a href="/post/75e75572.html" title="11.数据类型转换"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402292029940.WebP" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-12-30</div><div class="title">11.数据类型转换</div></div></a></div><div><a href="/post/74955f2f.html" title="12.表达式"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402292029940.WebP" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-12-30</div><div class="title">12.表达式</div></div></a></div><div><a href="/post/ded373.html" title="13.运算符"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402292029940.WebP" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-12-30</div><div class="title">13.运算符</div></div></a></div><div><a href="/post/43a94ea1.html" title="14.语句"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/xinzai-x/MyPic/img/202402292029940.WebP" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-12-30</div><div class="title">14.语句</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://img.picgo.net/2024/08/19/4b247c9cf52c5a9f23c6008ffd35b2387faa57d2ad36eca2.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://emotion.acs.pw/emotion/Arcaea/184064226.png" alt="status"/></div></div><div class="author-info__description">分享科技与生活</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">星仔</h1><div class="author-info__desc">珍惜当下 不负此生</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://blog.csdn.net/qq_65047384?spm=1000.2115.3001.5343" target="_blank" title="CSDN"><i class="anzhiyufont anzhiyu-icon-copyright"></i></a><a class="social-icon faa-parent animated-hover" href="https://www.bilibili.com/" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://img.picgo.net/2024/08/19/7769745c3a8abda4b76a2c8767c011c4ccc3bcc6d25362ee.webp) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://img.picgo.net/2024/08/19/7229edbc2326d9f1a077d9f251d15dfc93e3d4fe574b7ca8.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3"><span class="toc-number">1.</span> <span class="toc-text">知识点一：面向对象的编程思想</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C%EF%BC%9A%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">知识点二：类和对象的概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">类的概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="toc-number">2.2.</span> <span class="toc-text">对象的概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.3.</span> <span class="toc-text">类和对象的关系</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89%EF%BC%9A%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.</span> <span class="toc-text">知识点三：类、对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.</span> <span class="toc-text">1、类的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-number">3.2.</span> <span class="toc-text">2、对象的创建与使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AF%AD%E6%B3%95%EF%BC%9A"><span class="toc-number">3.2.1.</span> <span class="toc-text">创建对象的语法：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%8D%95%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E5%82%A8"><span class="toc-number">3.3.</span> <span class="toc-text">3、单个对象在内存中存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%A4%9A%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E5%82%A8"><span class="toc-number">3.4.</span> <span class="toc-text">4、多个对象在内存中存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E5%A4%9A%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%8C%87%E5%90%91%E5%90%8C%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E9%82%A3%E7%A7%8D%E5%AD%98%E5%82%A8"><span class="toc-number">3.5.</span> <span class="toc-text">5、多个对象指向同一个对象在内存那种存储</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B%EF%BC%9A%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">4.</span> <span class="toc-text">知识点四：成员变量和局部变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E5%85%AD%EF%BC%9A%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">知识点六：构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%AE%9A%E4%B9%89"><span class="toc-number">5.1.</span> <span class="toc-text">1、定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E8%AF%AD%E6%B3%95"><span class="toc-number">5.2.</span> <span class="toc-text">2、语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%B3%A8%E6%84%8F%E7%9A%84%E4%BA%8B%E9%A1%B9"><span class="toc-number">5.3.</span> <span class="toc-text">3、注意的事项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD"><span class="toc-number">5.3.1.</span> <span class="toc-text">重载</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%83%EF%BC%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">6.</span> <span class="toc-text">知识点七：对象的内存分配</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B9%9D%EF%BC%9A%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="toc-number">7.</span> <span class="toc-text">知识点九：三大特征</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%B0%81%E8%A3%85"><span class="toc-number">7.1.</span> <span class="toc-text">1、封装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Getter%E5%92%8CSetter%E6%96%B9%E6%B3%95"><span class="toc-number">7.1.1.</span> <span class="toc-text">Getter和Setter方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">7.1.2.</span> <span class="toc-text">this关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E8%B0%83%E7%94%A8%E6%9C%AC%E7%B1%BB%E5%B1%9E%E6%80%A7"><span class="toc-number">7.1.2.1.</span> <span class="toc-text">1）调用本类属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E8%B0%83%E7%94%A8%E6%9C%AC%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">7.1.2.2.</span> <span class="toc-text">2）调用本类方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E8%B0%83%E7%94%A8%E6%9C%AC%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">7.1.2.3.</span> <span class="toc-text">3）调用本类的构造方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E7%B1%BB%E7%9A%84%E5%88%B6%E4%BD%9C"><span class="toc-number">7.1.3.</span> <span class="toc-text">标准类的制作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E7%BB%A7%E6%89%BF"><span class="toc-number">7.2.</span> <span class="toc-text">2、继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E5%90%AB%E4%B9%89"><span class="toc-number">7.2.1.</span> <span class="toc-text">1）含义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E8%AF%AD%E6%B3%95"><span class="toc-number">7.2.2.</span> <span class="toc-text">2）语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A5%BD%E5%A4%84%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-number">7.2.2.1.</span> <span class="toc-text">好处和特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E8%83%BD%E8%A2%AB%E7%BB%A7%E6%89%BF%E6%83%85%E5%86%B5"><span class="toc-number">7.2.2.2.</span> <span class="toc-text">不能被继承情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E7%BB%A7%E6%89%BF%E8%A7%92%E5%BA%A6%E5%AE%8C%E6%88%90%E7%BB%83%E4%B9%A0%EF%BC%9A"><span class="toc-number">7.2.2.3.</span> <span class="toc-text">以继承角度完成练习：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89super%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">7.2.3.</span> <span class="toc-text">4）super关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">7.2.3.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">7.2.3.2.</span> <span class="toc-text">作用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%BC%89%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="toc-number">7.2.4.</span> <span class="toc-text">5）方法重写</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-number">7.2.4.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">7.2.4.2.</span> <span class="toc-text">应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%EF%BC%9A-Override"><span class="toc-number">7.2.4.3.</span> <span class="toc-text">注解：@Override</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E5%AE%8C%E6%88%90%E8%A6%81%E6%B1%82%EF%BC%9A"><span class="toc-number">7.2.4.4.</span> <span class="toc-text">重写完成要求：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E4%B8%8E%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.2.4.5.</span> <span class="toc-text">方法重载与方法重写的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E5%AD%90%E7%B1%BB%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="toc-number">7.2.4.6.</span> <span class="toc-text">继承中子类实例化过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E7%B1%BB%E7%BB%A7%E6%89%BF%E7%88%B6%E7%B1%BB%E4%B9%8B%E5%90%8E%E5%86%85%E5%AD%98%E5%AD%98%E5%82%A8"><span class="toc-number">7.2.4.7.</span> <span class="toc-text">子类继承父类之后内存存储</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%A4%9A%E6%80%81"><span class="toc-number">7.3.</span> <span class="toc-text">3、多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E5%AE%9A%E4%B9%89"><span class="toc-number">7.3.1.</span> <span class="toc-text">1）定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8C%E6%B0%8F%E4%BB%A3%E8%BD%AC%E6%8D%A2%E5%8E%9F%E5%88%99"><span class="toc-number">7.3.2.</span> <span class="toc-text">里氏代转换原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E7%89%B9%E7%82%B9"><span class="toc-number">7.3.3.</span> <span class="toc-text">2）特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E5%A4%9A%E6%80%81%E4%BA%A7%E7%94%9F%E6%9D%A1%E4%BB%B6"><span class="toc-number">7.3.4.</span> <span class="toc-text">3）多态产生条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89%E5%90%91%E4%B8%8A%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B"><span class="toc-number">7.3.5.</span> <span class="toc-text">4）向上向下转型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%BC%89instanceOf%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">7.3.6.</span> <span class="toc-text">5）instanceOf关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%EF%BC%89%E5%A4%9A%E6%80%81%E7%9A%84%E5%BC%95%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">7.3.7.</span> <span class="toc-text">6）多态的引用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E5%8D%81%EF%BC%9A%E4%B8%89%E4%B8%AA%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">8.</span> <span class="toc-text">知识点十：三个修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81abstract%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">8.1.</span> <span class="toc-text">1、abstract关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E5%90%AB%E4%B9%89-1"><span class="toc-number">8.1.1.</span> <span class="toc-text">1）含义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%90%AB%E4%B9%89%EF%BC%9A%E8%A2%ABabstract%E4%BF%AE%E9%A5%B0%E7%9A%84%E7%B1%BB%E7%A7%B0%E4%B9%8B%E4%B8%BA%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">8.1.2.</span> <span class="toc-text">2）抽象类含义：被abstract修饰的类称之为抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">8.1.3.</span> <span class="toc-text">3）抽象方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">8.2.</span> <span class="toc-text">2、static关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E5%90%AB%E4%B9%89-2"><span class="toc-number">8.2.1.</span> <span class="toc-text">1）含义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E4%BD%9C%E7%94%A8"><span class="toc-number">8.2.2.</span> <span class="toc-text">2）作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E9%9D%99%E6%80%81%E5%92%8C%E6%88%90%E5%91%98%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.2.3.</span> <span class="toc-text">3）静态和成员之间的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89static%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">8.2.4.</span> <span class="toc-text">4）static修饰成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%BC%89static%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">8.2.5.</span> <span class="toc-text">5）static修饰成员方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E8%A2%AB%E4%BD%BF%E7%94%A8%E6%97%B6%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">8.2.5.1.</span> <span class="toc-text">静态方法被使用时注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%EF%BC%89%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">8.2.6.</span> <span class="toc-text">6）静态代码块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AB%E4%B9%89"><span class="toc-number">8.2.6.1.</span> <span class="toc-text">含义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">8.2.6.2.</span> <span class="toc-text">特点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">8.3.</span> <span class="toc-text">3、final关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E5%90%AB%E4%B9%89-3"><span class="toc-number">8.3.1.</span> <span class="toc-text">1）含义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E4%BD%9C%E7%94%A8-1"><span class="toc-number">8.3.2.</span> <span class="toc-text">2）作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8final%E4%BF%AE%E9%A5%B0%E7%AC%A6%E4%BF%AE%E9%A5%B0%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">8.3.3.</span> <span class="toc-text">使用final修饰符修饰局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8final%E4%BF%AE%E9%A5%B0%E7%AC%A6%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">8.3.4.</span> <span class="toc-text">使用final修饰符修饰成员变量和静态变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">8.3.5.</span> <span class="toc-text">final修饰成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final%E4%BF%AE%E9%A5%B0%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">8.3.6.</span> <span class="toc-text">final修饰静态变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8final%E5%85%B3%E9%94%AE%E5%AD%97%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">8.3.7.</span> <span class="toc-text">使用final关键字修饰成员方法</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/bd740709.html" title="11.SPI通信"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://img.picgo.net/2024/08/18/b00d09a505b4c64d80be90a32eefd8a84d5e1e15395f28e1.jpeg" onerror="this.onerror=null;this.src='https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png'" alt="11.SPI通信"/></a><div class="content"><a class="title" href="/post/bd740709.html" title="11.SPI通信">11.SPI通信</a><time datetime="2024-08-17T08:28:32.000Z" title="发表于 2024-08-17 16:28:32">2024-08-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/acb77072.html" title="10.DMA"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://img.picgo.net/2024/08/18/b00d09a505b4c64d80be90a32eefd8a84d5e1e15395f28e1.jpeg" onerror="this.onerror=null;this.src='https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png'" alt="10.DMA"/></a><div class="content"><a class="title" href="/post/acb77072.html" title="10.DMA">10.DMA</a><time datetime="2024-08-16T07:49:08.000Z" title="发表于 2024-08-16 15:49:08">2024-08-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/52772f76.html" title="9.DAC(数字信号转模拟信号)"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://img.picgo.net/2024/08/18/b00d09a505b4c64d80be90a32eefd8a84d5e1e15395f28e1.jpeg" onerror="this.onerror=null;this.src='https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png'" alt="9.DAC(数字信号转模拟信号)"/></a><div class="content"><a class="title" href="/post/52772f76.html" title="9.DAC(数字信号转模拟信号)">9.DAC(数字信号转模拟信号)</a><time datetime="2024-08-15T14:22:06.000Z" title="发表于 2024-08-15 22:22:06">2024-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/f0812160.html" title="8.看门狗(WDG)"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://img.picgo.net/2024/08/18/b00d09a505b4c64d80be90a32eefd8a84d5e1e15395f28e1.jpeg" onerror="this.onerror=null;this.src='https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png'" alt="8.看门狗(WDG)"/></a><div class="content"><a class="title" href="/post/f0812160.html" title="8.看门狗(WDG)">8.看门狗(WDG)</a><time datetime="2024-08-15T14:05:49.000Z" title="发表于 2024-08-15 22:05:49">2024-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/e8bc8f26.html" title="7.实时时钟(RTC)"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://img.picgo.net/2024/08/18/b00d09a505b4c64d80be90a32eefd8a84d5e1e15395f28e1.jpeg" onerror="this.onerror=null;this.src='https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png'" alt="7.实时时钟(RTC)"/></a><div class="content"><a class="title" href="/post/e8bc8f26.html" title="7.实时时钟(RTC)">7.实时时钟(RTC)</a><time datetime="2024-08-14T13:12:02.000Z" title="发表于 2024-08-14 21:12:02">2024-08-14</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="星仔" target="_blank">星仔</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">95</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">9</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.csdn.net/qq_65047384?spm=1000.2115.3001.5343" title="CSDN"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="/img/favicon.ico" alt="CSDN"/><span class="back-menu-item-text">CSDN</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://www.bilibili.com/" title="哔哩哔哩"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="/img/favicon.ico" alt="哔哩哔哩"/><span class="back-menu-item-text">哔哩哔哩</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">资源下载</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://www.sscha.com/" title="商查查"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://img.picgo.net/2024/08/19/404fa2edc3bcbef6c8f.png&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="商查查"/><span class="back-menu-item-text">商查查</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 百宝箱</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://link3.cc/xinzai_x"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 个人资源</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/32%E5%8D%95%E7%89%87%E6%9C%BA/" style="font-size: 0.88rem;">32单片机<sup>12</sup></a><a href="/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/" style="font-size: 0.88rem;">51单片机<sup>9</sup></a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 0.88rem;">C语言<sup>13</sup></a><a href="/tags/GitHub-Picgo%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/" style="font-size: 0.88rem;">GitHub+Picgo图片上传<sup>1</sup></a><a href="/tags/GitHub%E5%90%8C%E6%AD%A5gitee%E5%B9%B6%E9%83%A8%E7%BD%B2/" style="font-size: 0.88rem;">GitHub同步gitee并部署<sup>1</sup></a><a href="/tags/IDE%E4%B8%8EMX%E5%BA%93%E6%96%87%E4%BB%B6%E5%AE%89%E8%A3%85%E8%B7%AF%E5%BE%84%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AE%BE%E7%BD%AE/" style="font-size: 0.88rem;">IDE与MX库文件安装路径自定义设置<sup>1</sup></a><a href="/tags/Java%E8%AF%AD%E8%A8%80/" style="font-size: 0.88rem;">Java语言<sup>26</sup></a><a href="/tags/ST-LINK%E6%9C%AA%E8%83%BD%E4%B8%B2%E5%8F%A3keil%E8%AF%86%E5%88%AB%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" style="font-size: 0.88rem;">ST-LINK未能串口keil识别解决方案<sup>1</sup></a><a href="/tags/STM32CubeIDE%E4%BB%A3%E7%A0%81%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8F/" style="font-size: 0.88rem;">STM32CubeIDE代码字体大小<sup>1</sup></a><a href="/tags/office%E6%97%A0%E6%B3%95%E5%88%9D%E5%A7%8B%E5%8C%96VisualBasic/" style="font-size: 0.88rem;">office无法初始化VisualBasic<sup>1</sup></a><a href="/tags/win10%E6%A1%8C%E9%9D%A2%E5%9B%BE%E6%A0%87%E5%8F%98%E7%99%BD/" style="font-size: 0.88rem;">win10桌面图标变白<sup>1</sup></a><a href="/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/" style="font-size: 0.88rem;">个人博客迁移<sup>1</sup></a><a href="/tags/%E4%BA%91%E5%9B%BE%E5%BA%8A/" style="font-size: 0.88rem;">云图床<sup>1</sup></a><a href="/tags/%E5%8A%A0%E9%80%9Fgithub%E5%8D%9A%E5%AE%A2%E8%AE%BF%E9%97%AE/" style="font-size: 0.88rem;">加速github博客访问<sup>1</sup></a><a href="/tags/%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/" style="font-size: 0.88rem;">博客使用手册<sup>1</sup></a><a href="/tags/%E5%8D%9A%E5%AE%A2%E5%8A%A0%E9%80%9F%E5%9B%BE%E5%BA%8A/" style="font-size: 0.88rem;">博客加速图床<sup>1</sup></a><a href="/tags/%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/" style="font-size: 0.88rem;">图片压缩在线工具<sup>1</sup></a><a href="/tags/%E5%B0%8F%E7%8B%BC%E6%AF%AB%E8%BE%93%E5%85%A5%E6%B3%95/" style="font-size: 0.88rem;">小狼毫输入法<sup>1</sup></a><a href="/tags/%E6%8F%92%E4%BB%B6/" style="font-size: 0.88rem;">插件<sup>1</sup></a><a href="/tags/%E6%94%BF%E6%B2%BB/" style="font-size: 0.88rem;">政治<sup>14</sup></a><a href="/tags/%E8%A7%A3%E5%86%B3443%E7%AB%AF%E5%8F%A3%E8%A2%ABvmware%E5%8D%A0%E7%94%A8/" style="font-size: 0.88rem;">解决443端口被vmware占用<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%9F%BA%E7%A1%80/" style="font-size: 0.88rem;">计算机程序与基础<sup>1</sup></a><a href="/tags/%E8%B5%84%E6%BA%90%E6%90%9C%E7%B4%A2/" style="font-size: 0.88rem;">资源搜索<sup>1</sup></a><a href="/tags/%E9%AD%94%E6%B3%95/" style="font-size: 0.88rem;">魔法<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 星仔 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script async src="https://www.iconfont.cn/collections/detail?cid=44481"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>